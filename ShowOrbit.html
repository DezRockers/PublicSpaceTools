<!DOCTYPE html>
<html lang="en">

<head>
    <title>Using chart in HTML page</title>
    <meta charset="utf-8" />
    <!-- Automatically support high DPI devices -->
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <!-- Flexbox styling to have the chart and header fill the page.
        Chart will take as much space as possible. -->
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
        }

        .box {
            display: flex;
            flex-flow: column;
            height: 100%;
        }

        .box .row.header {
            flex: 0 1 auto;
        }

        .box .row.content {
            flex: 1 1 auto;
        }
    </style>
</head>

<body class="box">
    <h1 class="row header">LightningChart<sup>&#174;</sup> JS in HTML page</h1>

    <!-- Create div to render the chart into-->
    <div id="target" class="row content"></div>

    <!--IIFE assembly (lcjs.iife.js) is a standalone JS file, 
      which does not need any build tools, 
      such as NPM, to be installed-->
    <!--Script source must be defined in it's own script tag-->
    <script src="lightningchart/dist/lcjs.iife.js"></script>

    <!--Actual chart related script tag-->
    <script>
        // Replace the contents of this script tag if you want to test code from our examples:
        // https://www.arction.com/lightningchart-js-interactive-examples/

        // Extract required parts from LightningChartJS.
        const {
            lightningChart,
    		PointStyle3D,
    		ColorShadingStyles,
    		ColorRGBA,
    		SolidFill,
    		SolidLine,
    		AxisTickStrategies,
		    emptyLine,
    		emptyFill,
    		UIElementBuilders,
    		UIOrigins
        } = lcjs //Note: @arction/lcjs is not needed here, when using IIFE assembly

        // Create a 3D Chart.
        const chart = lightningChart().Chart3D({
            // Set the chart into a div with id, 'target'. 
            // Chart's size will automatically adjust to div's size. 
            container: 'target'
        })
            .setTitle('Orbit plot') // Set chart title
            
            chart.setCameraLocation({x:1,y:1,z:-1});
            
            // get each axis
            let axisX = chart.getDefaultAxisX();
            let axisY = chart.getDefaultAxisY();
            let axisZ = chart.getDefaultAxisZ();
            
		// note lightningchart is not right handed so we need to convert axes! Y->Z and Z->Y
            //axisX.setTitle("X-axis");
            //axisY.setTitle("Z-axis");
            //axisZ.setTitle("Y-axis");
            
            axisX.setTickStrategy(AxisTickStrategies.Empty).setStrokeStyle(emptyLine);
            axisY.setTickStrategy(AxisTickStrategies.Empty).setStrokeStyle(emptyLine);
            axisZ.setTickStrategy(AxisTickStrategies.Empty).setStrokeStyle(emptyLine);

        //const data = [
        //    { x: 7100, y: 0, z: 0 },
        //    { x: 7000, y: 1000, z: 1000 },
        //    { x: 6800, y: 2000, z: 2000 },
        //    { x: 6500, y: 2800, z: 2800 },
        //    { x: 6000, y: 3000, z: 3000 }
        //]
		
		// retrieve the position vectors back from localStorage by splitting on commas
		// note lightningchart is not right handed so we need to convert axes! Y->Z and Z->Y
       	var data = new Array();
       	var xValues = localStorage.getItem("xValues").split(',');
       	var yValues = localStorage.getItem("zValues").split(',');
       	var zValues = localStorage.getItem("yValues").split(',');
       	
       	// compute max values for axis scaling
       	var Max = 0.0;
        for (i = 0; i < xValues.length; i++)
        {
        	var point = {x:xValues[i], y:yValues[i], z:zValues[i]};
        	if (Math.abs(xValues[i]) > Max)
        	{
        		Max = Math.abs(xValues[i]);
        	}
        	if (Math.abs(yValues[i]) > Max)
        	{
        		Max = Math.abs(yValues[i]);
        	}
        	if (Math.abs(zValues[i]) > Max)
        	{
        		Max = Math.abs(zValues[i]);
        	}
        	data[i] = point;
		}
		// scale Max to give a margin
		Max = Max * 1.5;

        // Add a line series for the orbit
        const pointSeries = chart.addLineSeries()
            .setName('Orbit data')
            .add(data)
        	.setStrokeStyle(new SolidLine({
			     thickness: 2,
			     fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })	// set colour to redish
			 }))
        	
        const ellipsoidSeries = chart.addPointSeries()
	    // Specify ellipsoid center coordinate.
	    .setName('Earth')
	    .add({ x: 0, y: 0, z: 0 })
	    .setColorShadingStyle(new ColorShadingStyles.Phong())
	    .setPointStyle(new PointStyle3D.Triangulated({
	        // Specify ellipsoid dimensions.
	        // it looks like the size is the diameter
	        // so we need to double earth's radius
	        // including flattening at poles
	        size: { x: 6378*2, y: 6378*2, z: 6357*2 },
	        fillStyle: new SolidFill({ color: ColorRGBA(0, 0, 255) })	// set colour to bluish
	    }))

        // then scale the axes
        axisX.setInterval(-Max, Max, false, true);
        axisY.setInterval(-Max, Max, false, true);
        axisZ.setInterval(-Max, Max, false, true); 
        
        // draw our own axes
        const Xaxis = chart.addPointLineSeries()
            .setName('X-axis')
            .add({ x: 0, y: 0, z: 0 })
            .add({ x: Max, y: 0, z: 0 })
        	.setStrokeStyle(new SolidLine({
			     thickness: 2,
			     fillStyle: new SolidFill({ color: ColorRGBA(255, 255, 255) })	// set colour to white
			 }))
        	.setPointStyle( (pointStyle) => pointStyle
        		.setShape( 'sphere' )
        		.setFillStyle( new SolidFill({ color: ColorRGBA(255, 255, 255) }) )
        	)

		// note lightningchart is not right handed so we need to convert axes! Y->Z and Z->Y
		const Yaxis = chart.addPointLineSeries()
            .setName('Y-axis')
            .add({ x: 0, y: 0, z: 0 })
            .add({ x: 0, y: 0, z: Max })
        	.setStrokeStyle(new SolidLine({
			     thickness: 2,
			     fillStyle: new SolidFill({ color: ColorRGBA(0, 255, 0) })	// set colour to green
			 }))
        	.setPointStyle( (pointStyle) => pointStyle
        		.setShape( 'sphere' )
        		.setFillStyle( new SolidFill({ color: ColorRGBA(0, 255, 0) }) )
        	)

        const Zaxis = chart.addPointLineSeries()
            .setName('Z-axis')
            .add({ x: 0, y: 0, z: 0 })
            .add({ x: 0, y: Max, z: 0 })
        	.setStrokeStyle(new SolidLine({
			     thickness: 2,
			     fillStyle: new SolidFill({ color: ColorRGBA(255, 255, 0) })	// set colour to yellow
			 }))
        	.setPointStyle( (pointStyle) => pointStyle
        		.setShape( 'sphere' )
        		.setFillStyle( new SolidFill({ color: ColorRGBA(255, 255, 0) }) )
        	)

		// draw the equator
		// remembering to swap Y and Z coordinates!
		var equator = new Array();
		var Re = 6378;	// km
		var pi = 3.1415926535897932384626433832795;
		for ( i = 0; i < 360; i++)
		{
			var X = Re * Math.cos(i*pi/180);
			var Y = Re * Math.sin(i*pi/180);
			var point = {x:X, y:0, z:Y};
			equator[i] = point;
		}
        const equatorSeries = chart.addLineSeries()
            .setName('Equator')
            .add(equator)
        	.setStrokeStyle(new SolidLine({
			     thickness: 2,
			     fillStyle: new SolidFill({ color: ColorRGBA(0, 0, 150) })	// set colour to dark bluish
			 }))
			 
		// draw orbit projection in the plane of the equator
		// remembering to swap Y and Z coordinates!
		var equatorialOrbit = new Array();
		var a = Number(localStorage.getItem("semiMajorAxis"));	// km
		var pi = 3.1415926535897932384626433832795;
		for ( i = 0; i < 360; i++)
		{
			var X = a * Math.cos(i*pi/180);
			var Y = a * Math.sin(i*pi/180);
			var point = {x:X, y:0, z:Y};
			equatorialOrbit[i] = point;
		}
        const equatorialOrbitSeries = chart.addLineSeries()
            .setName('Equatorial Orbit Projection')
            .add(equatorialOrbit)
        	.setStrokeStyle(new SolidLine({
			     thickness: 2,
			     fillStyle: new SolidFill({ color: ColorRGBA(50, 0, 0) })	// set colour to dark redish
			 }))
			 
		// line to the ascending node
		var ascendingNode = Number(localStorage.getItem("ascendingNode"));	// degrees
		X = a * Math.cos(ascendingNode*pi/180);
		Y = a * Math.sin(ascendingNode*pi/180);
        const lineToAcsendingNode = chart.addLineSeries()
            .setName('Line to Ascending Node')
            .add({ x: 0, y: 0, z: 0 })
            .add({ x: X, y: 0, z: Y })
        	.setStrokeStyle(new SolidLine({
			     thickness: 2,
			     fillStyle: new SolidFill({ color: ColorRGBA(255, 127, 0) })	// set colour to orange
			 }))
			 
		// Add LegendBox to chart.
		const legend = chart.addLegendBox()
	    // Dispose example UI elements automatically if they take too much space. This is to avoid bad UI on mobile / etc. devices.
    	.setAutoDispose({
        	type: 'max-width',
        	maxWidth: 0.30,
    	})
	    .add(chart)
    </script>
</body>

</html>