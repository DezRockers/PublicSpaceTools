
import { Eventer, Token, Listener } from "@arction/eventer";
import { Record } from 'immutable';/**
 * Chart abstraction layer that implements Chart title and padding.
 * @hidden Internal class
 */
export declare abstract class Chart extends Panel implements ChartAPI {
    protected readonly _ui: Layer2D;
    /**
     * @param   layerSupplier           LayerSupplier. Must NOT be cached, because it contains reference to actual Engine instance.
     * @param   scaleFactory            Scale factory.
     * @param   _bg                     Rendering layer for background
     * @param   removeChart 	        Injectable panel/chart remove method
     * @param   _ui                     Rendering layer for Charts own UI-elements.
     *                                  This layer should NOT be used for elements created by users.
     * @param   resizeEventInterface    Injectable event interface for resizing Panel (used for dashboard)
     * @param   theme                   Theme used to style elements in the Chart.
     * @hidden
     */
    constructor(_lcjsOptions: InternalLightningChartOptions, layerSupplier: LayerSupplier, scaleFactory: ScaleFactory, _bg: Layer2D, _ui: Layer2D, removeChart: (chart: Panel) => void, resizeEventInterface?: DashboardResizeEventInterface, theme?: Theme);
    /**
     * Get minimum size of Chart.
     * Depending on the type of class this value might be automatically computed to fit different elements.
     * @return  Vec2 minimum size or undefined if unimplemented
     * @hidden
     */
    abstract getMinimumSize(): Point | undefined;
    /**
     * Disable/Enable all animations of the Chart.
     * @param animationsEnabled Boolean value to enable or disable animations.
     * @return                  Chart itself for fluent interface.
     */
    abstract setAnimationsEnabled<T>(animationsEnabled: boolean | undefined): ThisType<T>;
    /**
     * Disable all animations for all charts in the dashboard.
     *
     * After calling this function, animations (Zooming, scaling) for all Charts will be disabled.
     * Animations must be recreated manually for each chart afterwards.
     * @return      Dashboard itself for fluent interface.
     * @deprecated  Deprecated in v3.1.0. Will be removed in v4.0.0. Use [[setAnimationsEnabled]] instead.
     */
    abstract disableAnimations(): this;
    /**
     * Set text of Chart title.
     * @param   title  Chart title as a string.
     * @returns        Object itself for fluent interface.
     */
    setTitle(title: string): this;
    /**
     * Get text of Chart title.
     * @returns         Chart title as a string.
     */
    getTitle(): string;
    /**
     * Set fill style of Chart Title.
     *
     * Example usage:
     *```javascript
     * // Create a new style
     * Chart.setTitleFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Change transparency
     * Chart.setTitleFillStyle((solidFill) => solidFill.setA(80))
     * // Set hidden
     * Chart.setTitleFillStyle(emptyFill)
     * ```
     *
     * @param   value   Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns         Chart itself
     */
    setTitleFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of Chart Title.
     * @returns FillStyle object
     */
    getTitleFillStyle(): FillStyle;
    /**
     * Set font of Chart Title.
     *
     * Example usage:
     *```javascript
     * // Create a new FontSettings
     * Chart.setTitleFont(new FontSettings({ size: 24, style: 'italic' }))
     * // Change existing settings
     * Chart.setTitleFont((fontSettings) => fontSettings.setWeight('bold'))
     * ```
     *
     * @param   value   Either a FontSettings object or a function, which will be used to create a new FontSettings based on current value.
     * @returns         Chart itself
     */
    setTitleFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
    /**
     * Get font of Chart title.
     * @return  FontSettings object
     */
    getTitleFont(): FontSettings;
    /**
     * Set rotation of Chart title.
     * @param value Rotation in degrees
     * @returns Object itself
     */
    setTitleRotation(value: number): this;
    /**
     * Get rotation of Chart title.
     * @returns Rotation in degrees
     */
    getTitleRotation(): number;
    /**
     * Specifies padding before chart title.
     *
     * This does not have an effect if title is hidden (empty FillStyle).
     *
     * ```typescript
     *  // Example usage,
     *  // Add empty space at top of chart, before title.
     *  ChartXY.setTitleMarginTop(32)
     * ```
     *
     * @param  marginPixels Gap between the top of chart and its title in pixels.
     * @returns             Chart itself for fluent interface
     */
    setTitleMarginTop(marginPixels: pixel): this;
    /**
     * @returns Padding before Chart title
     */
    getTitleMarginTop(): number;
    /**
     * Specifies padding after chart title.
     *
     * This does not have an effect if title is hidden (empty FillStyle).
     *
     * ```typescript
     *  // Example usage,
     *  // Add empty space between title and series.
     *  ChartXY.setTitleMarginBottom(32)
     * ```
     * @param  marginPixels Gap after the chart title in pixels.
     * @returns             Chart itself for fluent interface
     */
    setTitleMarginBottom(marginPixels: pixel): this;
    /**
     * @returns Padding after Chart title
     */
    getTitleMarginBottom(): number;
    /**
     * Set padding around Chart in pixels.
     *
     * ```typescript
     *  // Example 1, specify complete padding (four sides).
     *  ChartXY.setPadding({ left: 16, right: 16, top: 32, bottom: 8 })
     * ```
     *
     * ```typescript
     *  // Example 2, specify only single padding.
     *  ChartXY.setPadding({ right: 64 })
     * ```
     *
     * @param   padding     Number with pixel margins for all sides or datastructure with individual pixel paddings
     *                      for each side. Any side can be omitted, only passed values will be overridden.
     * @return              Object itself
     */
    setPadding(padding: Partial<Margin> | number): this;
    /**
     * Get padding around Chart in pixels.
     * @return  Padding datastructure
     */
    getPadding(): Margin;
    /**
     * **Permanently** dispose the component.
     *
     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
     * **to the component and its children** in application code.
     * ```javascript
     * let chart = ...ChartXY()
     * let axisX = chart.getDefaultAxisX()
     * // Dispose Chart, and remove all references so that they can be garbage-collected.
     * chart.dispose()
     * chart = undefined
     * axisX = undefined
     * ```
     * @return  Object itself for fluent interface
     */
    dispose(): this;
}
/**
 * Interface that defines end user API for a 'Chart'.
 * @hidden  This interface is hidden because we don't want to bloat Typedoc.
 *          The actual API will still be visible via the actual implementation.
 */
export interface ChartAPI {
    /**
     * Set text displayed by charts built-in title component.
     *
     * ```typescript
     *  // Example, set title.
     *  ChartXY.setTitle('Realtime traffic visualization')
     * ```
     *
     * **NOTE: To hide title, AND remove padding around it, ** use `setTitleFillStyle(emptyFill)`
     *
     * @param   title  Chart title as a string.
     * @returns        Object itself for fluent interface.
     */
    setTitle(title: string): this;
    /**
     * Get text of Chart title.
     * @returns         Chart title as a string.
     */
    getTitle(): string;
    /**
     * Set fill style of Chart Title.
     *
     * Example usage:
     *```javascript
     * // Create a new style
     * setTitleFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Change transparency
     * setTitleFillStyle((solidFill) => solidFill.setA(80))
     * // Set hidden
     * setTitleFillStyle(emptyFill)
     * ```
     * @param   value   Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns         Chart itself
     */
    setTitleFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of Chart Title.
     * @returns FillStyle object
     */
    getTitleFillStyle(): FillStyle;
    /**
     * Set font of Chart Title.
     *
     * Example usage:
     *```javascript
     * // Create a new FontSettings
     * setTitleFont(new FontSettings({ size: 24, style: 'italic' }))
     * // Change existing settings
     * setTitleFont((fontSettings) => fontSettings.setWeight('bold'))
     * ```
     *
     * @param   value   Either a FontSettings object or a function, which will be used to create a new FontSettings based on current value.
     * @returns         Chart itself
     */
    setTitleFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
    /**
     * Get font of Chart title.
     * @return  FontSettings object
     */
    getTitleFont(): FontSettings;
    /**
     * Specifies padding before chart title.
     *
     * This does not have an effect if title is hidden (empty FillStyle).
     * @param  marginPixels Gap between the top of chart and its title in pixels.
     * @returns             Chart itself for fluent interface
     */
    setTitleMarginTop(marginPixels: pixel): this;
    /**
     * @returns Padding before Chart title
     */
    getTitleMarginTop(): number;
    /**
     * Specifies padding after chart title.
     *
     * This does not have an effect if title is hidden (empty FillStyle).
     *
     * ```typescript
     *  // Example usage,
     *  // Add empty space between title and series.
     *  ChartXY.setTitleMarginBottom(32)
     * ```
     * @param  marginPixels Gap after the chart title in pixels.
     * @returns             Chart itself for fluent interface
     */
    setTitleMarginBottom(marginPixels: pixel): this;
    /**
     * @returns Padding after Chart title
     */
    getTitleMarginBottom(): number;
    /**
     * Set padding around Chart in pixels.
     *
     * ```typescript
     *  // Example 1, specify complete padding (four sides).
     *  ChartXY.setPadding({ left: 16, right: 16, top: 32, bottom: 8 })
     * ```
     *
     * ```typescript
     *  // Example 2, specify only single padding.
     *  ChartXY.setPadding({ right: 64 })
     * ```
     * @param   padding     Number with pixel margins for all sides or datastructure with individual pixel paddings
     *                      for each side. Any side can be omitted, only passed values will be overridden.
     * @return              Object itself for fluent interface
     */
    setPadding(padding: Partial<Margin> | number): this;
    /**
     * Get padding around Chart in pixels.
     * @return              Padding datastructure
     */
    getPadding(): Margin;
    /**
     * Set [[FillStyle]] of chart background.
     *
     * ```typescript
     *  // Example usage,
     *  ChartXY.setBackgroundFillStyle(new SolidFill({ color: ColorRGBA( 80, 0, 0 ) }))
     * ```
     *
     * **Related API:**
     * - Use [[SolidFill]] to describe a solid fill color.
     * - Use [[ColorRGBA]] to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
     *
     * @param   value       `FillStyle` or function which mutates the active `FillStyle`.
     * @return              Object itself
     */
    setBackgroundFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fillstyle of chart background.
     * @return              FillStyle
     */
    getBackgroundFillStyle(): FillStyle;
    /**
     * Set [[LineStyle]] of chart background border stroke.
     *
     * ```typescript
     *  // Example usage,
     *  ChartXY.setBackgroundStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorRGBA( 0, 255, 0 ) })
     *  }))
     * ```
     *
     * **Related API:**
     * - Use [[SolidLine]] to describe a solid line style.
     * - Use [[SolidFill]] to describe a solid fill color.
     * - Use [[ColorRGBA]] to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
     *
     * @param   value       `LineStyle` or function which mutates the active `LineStyle`.
     * @return              Object itself
     */
    setBackgroundStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stroke style of chart background.
     * @return              LineStyle
     */
    getBackgroundStrokeStyle(): LineStyle;
}
/**
 * Enum for selecting behaviour of user-interaction-triggered highlighting of *Series*.
 *
 * This is currently only usable on *FigureSeries*:
 * - BoxSeries
 * - RectangleSeries
 * - SegmentSeries
 * - ...
 */
export declare enum HighlightModes {
    /**
     * Highlighting is not affected by user-interactions.
     */
    noHighlighting = 0,
    /**
     * When any part of a *Series* is interacted with, the whole *Series* is highlighted.
     */
    onHover = 1,
    /**
     * When a part of a *Series* is interacted with, that part will be highlighted.
     */
    onHoverIndividual = 2
}
/**
 * Abstract base class for "Chart components".
 * Chart component is defined as a mouse-interactable component of a Chart.
 * ChartComponent is a public class, so users can have access to it.
 * @hidden Internal class
 */
export declare abstract class ChartComponent<VisualType extends ChartVisual = ChartVisual> implements Interactable, Attachable, Highlightable {
    /**
     * Subscribe to highlight object event. This is called whenever an object is highlighted.
     * @param   handler         Function that is called when event is triggered.
     * @param   isHighlighted   The Highlight state.
     * @return                  Token that can be used to unsubscribe from the event.
     */
    onHighlight(handler: (isHighlighted: boolean) => void): Token;
    /**
     * Unsubscribe from Highlight object event. This is called whenever an object is highlighted
     * @param   token       Token that was received when subscribing to the event.
     * @return              True if the unsubscription was successful.
     */
    offHighlight(token: Token): boolean;
    /**
     * Sets the name of the Component
     * updating attached LegendBox entries
     * @param   name    Name of the Component
     * @return          Object itself
     */
    setName(name: string): this;
    /**
     * Get the name of the Component.
     * @returns     The name of the Component.
     */
    getName(): string;
    /**
     * @returns  TODO: True for enabled and false for disabled
     */
    isDisposed(): boolean;
    /**
     * Tell the owning chart to remove this component.
     * @return  Object itself.
     */
    dispose(): this;
    /**
     * Tell the owning chart to restore this component.
     * @return  Object itself.
     */
    restore(): this;
    /**
     * Enable or disable forced highlighting of component
     * @param highLight True for enabled and false for disabled
     * @returns         component itself for fluent interface
     */
    setHighlighted(highLight: boolean): this;
    /**
     * @returns the state of highlighted flag
     */
    getHighlighted(): boolean;
    /**
     * Set component mouse interactions enabled or disabled.
     *
     * Disabling mouse interactions means that the objects below this component can be interacted _through_ it.
     *
     * Possible side-effects from disabling mouse interactions:
     *
     * - **Mouse events are not triggered.** For example, [[onMouseMove]].
     * - **Mouse driven highlighting will not work**.
     *
     * @param state Specifies state of mouse interactions
     * @return      Object itself for fluent interface
     */
    setMouseInteractions(state: boolean): this;
    /**
     * Get mouse interactions enabled or disabled.
     * Disabled mouse-interactions will naturally prevent mouse-driven highlighting from ever happening.
     * @return Mouse interactions state
     */
    getMouseInteractions(): boolean;
    /**
     * Get boolean flag for whether object is currently under mouse or not
     * @return  Boolean for is object under mouse currently
     */
    getIsUnderMouse(): boolean;
    /**
     * Set highlight on mouse hover enabled or disabled.
     *
     * Mouse interactions have to be enabled on the component for this to function as expected.
     * See [[setMouseInteractions]] for more information.
     *
     * @param state True if highlighting on mouse hover, false if no highlight on mouse hover
     * @return      Object itself for fluent interface.
     */
    setHighlightOnHover(state: boolean): this;
    /**
     * Get boolean flag for whether object should highlight on mouse hover
     * @return Boolean for if object should highlight on mouse hover or not.
     */
    getHighlightOnHover(): boolean;
    /**
     * On LegendBox entry mouse enter event listener
     */
    private onEntryMouseEnter;
    /**
     * On LegendBox entry mouse leave event listener
     */
    private onEntryMouseLeave;
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Series itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick?: boolean): this;
    /**
     * Add event listener to Enter Event
     * @param   clbk    Event listener for Mouse Enter Event
     * @return          Token of the event listener
     */
    onMouseEnter: (clbk: MouseEventHandler<this>) => Token;
    /**
     * Add event listener to Mouse Leave Event
     * @param   clbk    Event listener for Mouse Leave Event
     * @return          Token of the event listener
     */
    onMouseLeave: (clbk: AbruptMouseEventHandler<this>) => Token;
    /**
     * Add event listener to Mouse Click Event
     * @param   clbk    Event listener for Mouse Click Event
     * @return          Token of the event listener
     */
    onMouseClick: (clbk: MouseEventHandler<this>) => Token;
    /**
     * Add event listener to Mouse Double Click Event
     * @param   clbk    Event listener for Mouse Double Click Event
     * @return          Token of the event listener
     */
    onMouseDoubleClick: (clbk: MouseEventHandler<this>) => Token;
    /**
     * Add event listener to Mouse Down Event
     * @param   clbk    Event listener for Mouse Down Event
     * @return          Token of the event listener
     */
    onMouseDown: (clbk: MouseEventHandler<this>) => Token;
    /**
     * Add event listener to Mouse Up Event
     * @param   clbk    Event listener for Mouse Up Event
     * @return          Token of the event listener
     */
    onMouseUp: (clbk: MouseEventHandler<this>) => Token;
    /**
     * Add event listener to Mouse Move Event
     * @param   clbk    Event listener for Mouse Move Event
     * @return          Token of the event listener
     */
    onMouseMove: (clbk: MouseEventHandler<this>) => Token;
    /**
     * Subscribe to Mouse Drag Start event
     */
    onMouseDragStart(clbk: MouseDragStartEventHandler<this>): Token;
    /**
     * Subscribe to Mouse Drag event
     */
    onMouseDrag(clbk: MouseDragEventHandler<this>): Token;
    /**
     * Subscribe to Mouse Drag Stop event
     */
    onMouseDragStop(clbk: MouseDragStopEventHandler<this>): Token;
    /**
     * Subscribe to Mouse Wheel event
     * @param   clbk        Event handler function
     * @returns             Token of subscription
     */
    onMouseWheel(clbk: MouseWheelEventHandler<this>): Token;
    /**
     * Subscribe to Touch Start event
     * @param   clbk        Event handler function
     * @returns             Token of subscription
     */
    onTouchStart(clbk: TouchEventHandler<this>): Token;
    /**
     * Subscribe to Touch Move event
     * @param   clbk        Event handler function
     * @returns             Token of subscription
     */
    onTouchMove(clbk: TouchEventHandler<this>): Token;
    /**
     * Subscribe to Touch End event
     * @param   clbk        Event handler function
     * @returns             Token of subscription
     */
    onTouchEnd(clbk: TouchEventHandler<this>): Token;
    /**
     * Remove event listener from Mouse Enter Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseEnter: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Leave Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseLeave: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Click Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseClick: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Double Click Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseDoubleClick: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Down Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseDown: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Up Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseUp: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Move Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseMove: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Drag Start Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseDragStart: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Drag Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseDrag: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Drag Stop Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseDragStop: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Wheel Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseWheel: (token: Token) => boolean;
    /**
     * Remove event listener from Touch Start Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offTouchStart(token: Token): boolean;
    /**
     * Remove event listener from Touch Move Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offTouchMove(token: Token): boolean;
    /**
     * Remove event listener from Touch End Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offTouchEnd(token: Token): boolean;
}
/**
 * Interface for ChartVisual.
 * ChartVisuals are a building block which links rendering Engine to a ChartComponent.
 *
 * Examples: An Engine Shape or an UI-element.
 * @hidden
 */
export interface ChartVisual extends Disposable {
    /**
     * Set mouse interactions enabled or disabled
     * @param state Specifies state of mouse interactions
     * @return      Object itself for fluent interface
     */
    setMouseInteractions(state: boolean): this;
}
/**
 * @hidden
 */
export interface ChartWithScrollingAnimations {
    /**
     * Set if mouse and cursor interactions should be disabled during scrolling animations for the chart's series.
     * @param   state   True if mouse and cursor interactions should be disabled during scrolling animations, false if not.
     * @return          Chart itself for fluent interface.
     */
    setMouseInteractionsWhileScrolling(state: boolean): this;
    /**
     * Get if mouse and cursor interactions are disabled during scrolling animations for the chart's series.
     * @return True if interactions with series are disabled, false if not.
     */
    getMouseInteractionsWhileScrolling(): boolean;
}
/**
 * @hidden
 */
export interface ChartWithZoomingAnimations {
    /**
     * Set if mouse and cursor interactions should be disabled during zooming animations for the chart's series.
     * @param   state   True if mouse and cursor interactions should be disabled during zooming animations, false if not.
     * @return          Chart itself for fluent interface.
     */
    setMouseInteractionsWhileZooming(state: boolean): this;
    /**
     * Get if mouse and cursor interactions are disabled during zooming animations for the chart's series.
     * @return True if interactions with series are disabled, false if not.
     */
    getMouseInteractionsWhileZooming(): boolean;
}
/**
 * Type requirement for Charts that own Axes.
 * @hidden
 */
export interface ChartWithAxis<AxisType extends GenericAxis<any, any, any, any, any, any, any>> extends ChartWithSeries {
    /**
     * Iterate over each Axis of Chart.
     * @param   clbk    Callback function for each Axis.
     */
    forEachAxis(clbk: (axis: AxisType) => void): void;
}
/**
 * Collection of preset options for behavior of *chart AutoCursor*.
 *
 * Use with `setAutoCursorMode` method.
 *
 * ```typescript
 *  // Example, disable AutoCursor
 *  ChartXY.setAutoCursorMode(AutoCursorModes.disabled)
 * ```
 */
export declare enum AutoCursorModes {
    /**
     * *AutoCursor* should be disabled.
     */
    disabled = 0,
    /**
     * *AutoCursor* will be active whenever users mouse is inside the *Chart*.
     *
     * It will snap to point at the closest data-point of a *Series* inside the *Chart*.
     */
    snapToClosest = 1,
    /**
     * *AutoCursor* will only be active when users mouse is directly pointing at a *Series* inside the *Chart*.
     */
    onHover = 2
}
/**
 * Class abstraction layer for Charts that have cursor and series background.
 * @hidden Internal class
 */
export declare abstract class ChartWithCursor<SeriesType extends Series2D = Series2D, CursorPointMarkerType extends PointMarker = PointMarker, CursorResultTableBackgroundType extends UIBackground = UIBackground, AutoCursorType extends AutoCursor<CursorPointMarkerType, CursorResultTableBackgroundType> = AutoCursor<CursorPointMarkerType, CursorResultTableBackgroundType>> extends ChartWithSeries<SeriesType> implements ChartWithStylableSeriesBackground {
    /**
     * Style chart `AutoCursor` using a callback function.
     *
     * ```typescript
     *  // Example syntax
     *  ChartXY.setAutoCursor((autoCursor) => autoCursor
     *      // `autoCursor` is of type AutoCursorXY, use its API for styling the cursor.
     *      .setGridStrokeXStyle(new SolidLine({
     *          thickness: 1,
     *          fillStyle: new SolidFill({ color: ColorRGBA( 255, 0, 0 ) })
     *      }))
     *  )
     * ```
     *
     * See [[AutoCursorXY]] for all available methods for configuring the `AutoCursor`.
     *
     * **Example usage:**
     *
     * ```typescript
     *  // Example 1, disable Y Axis tick marker & grid line.
     *  ChartXY.setAutoCursor((autoCursor) => autoCursor
     *      .disposeTickMarkerY()
     *      .setGridStrokeYStyle(emptyLine),
     *  )
     * ```
     *
     * ```typescript
     *  // Example 2, style AutoCursor ResultTable.
     *  ChartXY.setAutoCursor((autoCursor) => autoCursor
     *      .setResultTable((resultTable) => resultTable
     *          .setOrigin(UIOrigins.LeftTop)
     *          .setTextFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
     *          .setTextFont((font) => font
     *              .setSize(12)
     *              .setFamily('sans-serif')
     *          )
     *          .setBackground((background) => background
     *              .setFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 0) }))
     *          )
     *      )
     *  )
     * ```
     *
     * ```typescript
     *  // Example 3, style AutoCursor TickMarker X.
     *  ChartXY.setAutoCursor((autoCursor) => autoCursor
     *      .setTickMarkerX((tickMarker: UIPointableTextBox) => tickMarker
     *          .setTextFont((font) => font.setWeight('bold'))
     *          .setTextFillStyle(new SolidFill({ color: ColorRGBA(0, 255, 0) }))
     *          .setBackground((background) => background.setFillStyle(emptyFill).setStrokeStyle(emptyLine)),
     *      )
     *  )
     * ```
     *
     * @param   mutator         Callback function that receives reference to the charts `AutoCursor`.
     * @return                  Object itself for fluent interface.
     */
    setAutoCursor(mutator: Mutator<AutoCursorType>): this;
    /**
     * Get reference to charts `AutoCursor`.
     *
     * See [[AutoCursorXY]] for all available methods for configuring the `AutoCursor`.
     *
     * @returns     `AutoCursor`.
     */
    getAutoCursor(): AutoCursorType;
    /**
     * Set chart `AutoCursor` behavior, by selecting a preset option from [[AutoCursorModes]].
     *
     * Possible values:
     * - `AutoCursorModes.snapToClosest` (default) | *AutoCursor* snaps to closest data point from mouse location.
     * - `AutoCursorModes.onHover` | *AutoCursor* is only shown when it is directly over a *series*.
     * - `AutoCursorModes.disabled` | *AutoCursor* is disabled
     *
     * ```typescript
     *  // Example, disable AutoCursor
     *  ChartXY.setAutoCursorMode(AutoCursorModes.disabled)
     * ```
     *
     * **Related information:**
     *
     * On *series* level, *AutoCursor* behavior can be configured individually for each *series*, and there are also more *series* specific options available.
     * Here is `LineSeries` for example:
     *
     * - [[LineSeries.setCursorEnabled]] | configure whether cursor should pick on the series or not.
     * - [[LineSeries.setCursorResultTableFormatter]] | configure formatting of *result table* contents, when this series is pointed.
     * - [[LineSeries.setCursorInterpolationEnabled]] | configure whether cursor should interpolate the displayed data point between the two closest data points, or snap to the nearest *real* data point.
     * - [[LineSeries.setCursorSolveBasis]] | configure basis of finding nearest data point for the series (`'nearest-x'`, `'nearest'`, etc.).
     *
     * @param   mode        Selection of *AutoCursor* behavior.
     * @return              Object itself for fluent interface.
     */
    setAutoCursorMode(mode: AutoCursorModes): this;
    /**
     * Get `AutoCursor` behavior, from a collection of preset options ([[AutoCursorModes]]).
     * @return              Active selection of *AutoCursor* behavior.
     */
    getAutoCursorMode(): AutoCursorModes;
    /**
     * Set [[FillStyle]] of *series background* (area behind *series*).
     *
     * ```typescript
     *  // Example usage,
     *  ChartXY.setSeriesBackgroundFillStyle(new SolidFill({ color: ColorRGBA( 60, 0, 0 ) }))
     * ```
     *
     * **Related API:**
     * - Use [[SolidFill]] to describe a solid fill color.
     * - Use [[ColorRGBA]] to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
     *
     * **Transparent chart backgrounds:**
     *
     * LightningChart JS charts can be configured to be fully or partially transparent.
     *
     * ```ts
     *  // Example, partially transparent chart
     *
     *  // Engine background exists under all LCJS components. In case of Dashboard, there is only 1 shared engine background.
     *  chart.engine.setBackgroundFillStyle(emptyFill)
     *  // Chart background covers every 1 chart. In case of Dashboard, every chart has its own chart background.
     *  chart.setBackgroundFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 100) }))
     *  // Some charts also have a separate series background.
     *  chart.setSeriesBackgroundFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 100) }))
     * ```
     *
     * @param   value       `FillStyle` or function which mutates the active `FillStyle`.
     * @return              Object itself
     */
    setSeriesBackgroundFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get FillStyle of Series background area (area behind series).
     * @return              FillStyle
     */
    getSeriesBackgroundFillStyle(): FillStyle;
    /**
     * Set [[LineStyle]] of series background border stroke.
     *
     * ```typescript
     *  // Example usage,
     *  ChartXY.setSeriesBackgroundStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorRGBA( 0, 255, 0 ) })
     *  }))
     * ```
     *
     * **Related API:**
     * - Use [[SolidLine]] to describe a solid line style.
     * - Use [[SolidFill]] to describe a solid fill color.
     * - Use [[ColorRGBA]] to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
     *
     * @param   value       `LineStyle` or function which mutates the active `LineStyle`.
     * @return              Object itself
     */
    setSeriesBackgroundStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get Stroke style of Series background area (area behind series).
     * @return              LineStyle
     */
    getSeriesBackgroundStrokeStyle(): LineStyle;
    /**
     * Solves the nearest data-point from series inside Chart of a given coordinate on screen
     * @param   location    Location on screen or omit for cur mouse location
     * @return              Undefined or data-structure for positioning of markers (and cursors)
     */
    solveNearest(location?: Point | undefined): undefined | CursorPoint;
    /**
     * Subscribe to mouse-enter event on Series Background
     */
    onSeriesBackgroundMouseEnter: (handler: MouseEventHandler<this>) => Token;
    /**
     * Subscribe to mouse-leave event on Series Background
     */
    onSeriesBackgroundMouseLeave: (handler: MouseEventHandler<this>) => Token;
    /**
     * Subscribe to mouse-move event on Series Background
     */
    onSeriesBackgroundMouseMove: (handler: MouseEventHandler<this>) => Token;
    /**
     * Subscribe to mouse-down event on Series Background
     */
    onSeriesBackgroundMouseDown: (handler: MouseEventHandler<this>) => Token;
    /**
     * Subscribe to mouse-up event on Series Background
     */
    onSeriesBackgroundMouseUp: (handler: MouseEventHandler<this>) => Token;
    /**
     * Subscribe to mouse-click event on Series Background
     */
    onSeriesBackgroundMouseClick: (handler: MouseEventHandler<this>) => Token;
    /**
     * Subscribe to mouse-doubleClick event on Series Background
     */
    onSeriesBackgroundMouseDoubleClick: (handler: MouseEventHandler<this>) => Token;
    /**
     * Subscribe to mouse-drag start event on Series Background
     */
    onSeriesBackgroundMouseDragStart: (handler: MouseDragStartEventHandler<this>) => Token;
    /**
     * Subscribe to mouse-drag event on Series Background
     */
    onSeriesBackgroundMouseDrag: (handler: MouseDragEventHandler<this>) => Token;
    /**
     * Subscribe to mouse-drag stop event on Series Background
     */
    onSeriesBackgroundMouseDragStop: (handler: MouseDragStopEventHandler<this>) => Token;
    /**
     * Subscribe to mouse-wheel event on Series Background
     */
    onSeriesBackgroundMouseWheel: (handler: MouseWheelEventHandler<this>) => Token;
    /**
     * Subscribe to touch start event on Series Background
     */
    onSeriesBackgroundTouchStart: (handler: TouchEventHandler<this>) => Token;
    /**
     * Subscribe to touch move event on Series Background
     */
    onSeriesBackgroundTouchMove: (handler: TouchEventHandler<this>) => Token;
    /**
     * Subscribe to touch end event on Series Background
     */
    onSeriesBackgroundTouchEnd: (handler: TouchEventHandler<this>) => Token;
    /**
     * Remove event listener from mouse-enter event on Series Background
     */
    offSeriesBackgroundMouseEnter: (token: Token) => boolean;
    /**
     * Remove event listener from mouse-leave event on Series Background
     */
    offSeriesBackgroundMouseLeave: (token: Token) => boolean;
    /**
     * Remove event listener from mouse-move event on Series Background
     */
    offSeriesBackgroundMouseMove: (token: Token) => boolean;
    /**
     * Remove event listener from mouse-down event on Series Background
     */
    offSeriesBackgroundMouseDown: (token: Token) => boolean;
    /**
     * Remove event listener from mouse-up event on Series Background
     */
    offSeriesBackgroundMouseUp: (token: Token) => boolean;
    /**
     * Remove event listener from mouse-click event on Series Background
     */
    offSeriesBackgroundMouseClick: (token: Token) => boolean;
    /**
     * Remove event listener from mouse-doubleClick event on Series Background
     */
    offSeriesBackgroundMouseDoubleClick: (token: Token) => boolean;
    /**
     * Remove event listener from mouse-drag start event on Series Background
     */
    offSeriesBackgroundMouseDragStart: (token: Token) => boolean;
    /**
     * Remove event listener from mouse-drag event on Series Background
     */
    offSeriesBackgroundMouseDrag: (token: Token) => boolean;
    /**
     * Remove event listener from mouse-drag stop event on Series Background
     */
    offSeriesBackgroundMouseDragStop: (token: Token) => boolean;
    /**
     * Remove event listener from mouse-wheel event on Series Background
     */
    offSeriesBackgroundMouseWheel: (token: Token) => boolean;
    /**
     * Remove event listener from touch start event on Series Background
     */
    offSeriesBackgroundTouchStart: (token: Token) => boolean;
    /**
     * Remove event listener from touch move event on Series Background
     */
    offSeriesBackgroundTouchMove: (token: Token) => boolean;
    /**
     * Remove event listener from touch end event on Series Background
     */
    offSeriesBackgroundTouchEnd: (token: Token) => boolean;
    /**
     * **Permanently** dispose the component.
     *
     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
     * **to the component and its children** in application code.
     * ```javascript
     * let chart = ...ChartXY()
     * let axisX = chart.getDefaultAxisX()
     * // Dispose Chart, and remove all references so that they can be garbage-collected.
     * chart.dispose()
     * chart = undefined
     * axisX = undefined
     * ```
     * @return  Object itself for fluent interface
     */
    dispose(): this;
}
/**
 * Class abstraction layer for Charts that have Series.
 *
 * NOTE: Sub classes are responsible for calling series_.beforePlot and series._afterPlot !!
 * @hidden Internal class
 */
export declare abstract class ChartWithSeries<SeriesType extends Series = Series> extends Chart {
    /**
     * Set the state for all Series in the Chart to highlight on mouse hover.
     * @param   state   True if all Series should be highlighted on mouse hover, false if not.
     * @return          Object itself for fluent interface.
     */
    setSeriesHighlightOnHover(state: boolean): this;
}
/**
 * File contains interface of a "Control".
 *
 * Meaning a stand-alone Charting component, which owns a rendering Engine.
 * Eq. Panel, Dashboard, ...
 */
/**
 * Abstract super class for a Control.
 * Meaning a stand-alone Charting component, which owns a rendering Engine.
 * Eq. Panel, Dashboard, ...
 * @hidden Internal class
 */
export interface Control {
    /**
     * Public, safe interface of rendering engine.
     */
    readonly engine: PublicEngine;
    /**
     * Add a stand-alone *UIElement* using a *builder*.
     *
     * **Example usage:**
     *
     * 1) TextBox with default positioning coordinate system.
     *
     * ```typescript
     *  addUIElement( UIElementBuilders.TextBox )
     *      // Position = [0, 100] as percentages.
     *      .setPosition({ x: 50, y: 50 })
     * ```
     *
     * 2) Position in pixel coordinate system.
     *
     * ```typescript
     *  addUIElement( UIElementBuilders.TextBox, chart.pixelScale )
     *      // Position = pixels.
     *      .setPosition({ x: 300, y: 100 })
     * ```
     *
     * 3) Position on Axes.
     *
     * ```typescript
     *  addUIElement( UIElementBuilders.TextBox, { x: chartXY.getDefaultAxisX(), y: chartXY.getDefaultAxisY() } )
     *      // Position = Axis values.
     *      .setPosition({ x: 5, y: 5 })
     * ```
     *
     * @typeparam   UIElementType   Type of *UIElement* that is specified by 'builder'-*parameter*.
     *
     * @param       builder *UIElementBuilder*. If omitted, *TextBoxBuilder* will be selected. Use [[UIElementBuilders]] for selection.
     * @param       scale   Optional parameter for altering the coordinate system used for positioning the UIElement. Defaults to whole component in percentages [0, 100].
     * @returns             Object that fulfills *interfaces*:  *UIElementType* (typeparam) and *UIElement*
     */
    addUIElement<UIElementType extends UIPart = UITextBox>(uiElementBuilder?: UIElementBuilder<UIElementType>, scale?: UserScaleDefinition): UIElementType & UIElement;
    /**
     * Add a *legendbox*.
     *
     * *Legendbox* is a type of *UI element*, that floats inside the chart/component it is created inside. It can be freely moved around
     * with user interactions, as well as positioned in application code.
     *
     * The purpose of *legendbox* is to describe the *series* and other visual components of the *chart*, by displaying their names and colors.
     * Hovering over a *series'* *legendbox entry* will highlight that *series*, and clicking on the *entry* will toggle that *series'* visibility.
     *
     * **Legendbox alignment:**
     *
     * Alignment of legendbox can be selected by supplying one of the available [[LegendBoxBuilders]] to `addLegendBox`:
     *
     * ```typescript
     *  // Default (vertical) LegendBox.
     *  const legendBox = ChartXY.addLegendBox()
     *
     *  // Horizontal LegendBox.
     *  const horizontalLegendBox = ChartXY.addLegendBox(LegendBoxBuilders.HorizontalLegendBox)
     * ```
     *
     * **Custom Legendbox positioning:**
     *
     * By default LegendBoxes are placed on the right side, or bottom of the *chart* (depending on *alignment*).
     *
     * A custom location can be configured with [[UIElement]] API:
     * - [[UIElement.setPosition]]
     * - [[UIElement.setOrigin]]
     * - [[UIElement.setMargin]]
     *
     * *Position coordinate system* is specified when creating *legendbox*.
     *
     * 1) LegendBox with default positioning coordinate system.
     *
     * ```typescript
     *  addLegendBox( LegendBoxBuilders.VerticalLegendBox )
     *      // Position = [0, 100] as percentages.
     *      .setPosition({ x: 50, y: 50 })
     * ```
     *
     * 2) Position in pixel coordinate system.
     *
     * ```typescript
     *  addLegendBox( LegendBoxBuilders.VerticalLegendBox, chart.pixelScale )
     *      // Position = pixels.
     *      .setPosition({ x: 300, y: 100 })
     * ```
     *
     * 3) Position on Axes.
     *
     * ```typescript
     *  addLegendBox( LegendBoxBuilders.VerticalLegendBox, { x: chartXY.getDefaultAxisX(), y: chartXY.getDefaultAxisY() } )
     *      // Position = Axis values.
     *      .setPosition({ x: 5, y: 5 })
     * ```
     *
     * @param       builder *LegendBoxBuilder*. If omitted, *VerticalLegendBox* will be selected. Use [[LegendBoxBuilders]] for selection.
     * @param       scale   Optional parameter for altering the coordinate system used for positioning the LegendBox. Defaults to whole Chart in percentages [0, 100].
     * @returns             Object with two interfaces: LegendBox and UIElement.
     */
    addLegendBox(builder?: UILegendBoxBuilder, scale?: UserScaleDefinition): LegendBox & UIElement;
    /**
     * Capture rendered state in an image file. Prompts the browser to download the created file.
     *
     * **NOTE: The download might be blocked by browser/plugins as harmful.**
     * To prevent this, only call the method in events tied to user-interactions.
     * From mouse-event handlers, for example.
     *
     * Has two optional parameters which directly reference JavaScript API HTMLCanvasElement.toDataURL.
     * For supported image formats, compression quality, Etc. refer to:
     *
     * https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL
     *
     * Example usage:
     *```javascript
     * // Download 'screenshot.png'
     * saveToFile('screenshot')
     * // Attempt download 'maybeNotSupported.bmp'
     * saveToFile('maybeNotSupported', 'image/bmp')
     * // Attempt download jpeg.file with specified compression quality
     * saveToFile('fileName', 'image/jpeg', 0.50)
     * ```
     *
     * @sideEffect              **If 'type' is not supported by browser, an Error will be thrown.**
     *
     * @param   fileName        Name of prompted download file as string. **File extension shouldn't be included**
     *                          as it is automatically detected from 'type'-argument.
     * @param   type            A DOMString indicating the image format. The default format type is image/png.
     * @param   encoderOptions  A Number between 0 and 1 indicating the image quality to use for image formats
     *                          that use lossy compression such as image/jpeg and image/webp. If this argument is anything else,
     *                          the default value for image quality is used. The default value is 0.92.
     */
    saveToFile(fileName: string, type?: string, encoderOptions?: number): this;
    /**
     * **Permanently** dispose the component.
     *
     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
     * **to the component and its children** in application code.
     * ```javascript
     * let chart = ...ChartXY()
     * let axisX = chart.getDefaultAxisX()
     * // Dispose Chart, and remove all references so that they can be garbage-collected.
     * chart.dispose()
     * chart = undefined
     * axisX = undefined
     * ```
     * @return  Object itself for fluent interface
     */
    dispose(): this;
    /**
     * Returns the Theme currently being used.
     * @returns An object containing the Theme.
     */
    getTheme(): Theme;
}
/**
 * Capture rendered state in an image file. Prompts the browser to download the created file.
 *
 * **NOTE: The download might be blocked by browser/plugins as harmful.**
 * To prevent this, only call the method in events tied to user-interactions.
 * From mouse-event handlers, for example.
 *
 * Has two optional parameters which directly reference JavaScript API HTMLCanvasElement.toDataURL.
 * For supported image formats, compression quality, Etc. refer to:
 *
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL
 *
 * Example usage:
 *```javascript
 * // Download 'screenshot.png'
 * saveToFile('screenshot')
 * // Attempt download 'maybeNotSupported.bmp'
 * saveToFile('maybeNotSupported', 'image/bmp')
 * // Attempt download jpeg.file with specified compression quality
 * saveToFile('fileName', 'image/jpeg', 0.50)
 * ```
 *
 * @sideEffect              **If 'type' is not supported by browser, an Error will be thrown.**
 *
 * @param   fileName        Name of prompted download file as string. **File extension shouldn't be included**
 *                          as it is automatically detected from 'type'-argument.
 * @param   type            A DOMString indicating the image format. The default format type is image/png.
 * @param   encoderOptions  A Number between 0 and 1 indicating the image quality to use for image formats
 *                          that use lossy compression such as image/jpeg and image/webp. If this argument is anything else,
 *                          the default value for image quality is used. The default value is 0.92.
 */
export declare const saveToFile: (engine: PublicEngine, fileName: string, type?: string, encoderOptions?: number | undefined) => void;
/**
 * Type union for supported ways for users to define a Scale for positioning UI elements and Legend Boxes.
 */
export declare type UserScaleDefinition = ScaleXY | Vec2<Axis | LinearScaleXY>;
/**
 * Interface for type requirements of a component that can be put inside a Dashboard.
 * @hidden
 */
export interface DashboardPanel {
    /**
     * Get minimum size of Panel.
     * Depending on the type of class this value might be automatically computed to fit different elements.
     * @return  Point minimum size or undefined if unimplemented
     */
    getMinimumSize(): Point | undefined;
}
/**
 * Interface for readonly configuration of [Dashboard](../classes/dashboard.html).
 *
 * **Mandatory properties:**
 *
 * - [numberOfColumns]([[DashboardOptions.numberOfColumns]]): Number of *dashboard cells* along horizontal plane.
 * - [numberOfRows]([[DashboardOptions.numberOfRows]]): Number of *dashboard cells* along vertical plane.
 *
 * ```typescript
 *  // Example, Create a 3x3 dashboard.
 *  const dashboard = LightningChart.Dashboard({
 *      // Number of cells in X direction.
 *      numberOfColumns: 3,
 *      // Number of cells in Y direction.
 *      numberOfRows: 3,
 *  })
 * ```
 *
 * To learn about the effects of *columns* / *rows* configuration, please read more here [Dashboard](../classes/dashboard.html).
 *
 *
 * **Optional extra configuration:**
 *
 * - [[DashboardOptions.theme]]: Specify dashboard color *theme*.
 * - [[DashboardOptions.disableAnimations]]: Convenience flag to disable all animations from dashboard.
 *
 * ```typescript
 *  // Example 1, create dashboard with specified color theme.
 *  const dashboard = LightningChart.Dashboard({
 *      // Number of cells in X direction.
 *      numberOfColumns: 3,
 *      // Number of cells in Y direction.
 *      numberOfRows: 3,
 *      // Select color theme.
 *      theme: Themes.light,
 *  })
 * ```
 */
export interface DashboardOptions extends CommonChartOptions {
    /**
     * Number of *dashboard cells* along horizontal plane.
     *
     * To learn about the effects of *columns* / *rows* configuration, please read more here [Dashboard](../classes/dashboard.html).
     */
    readonly numberOfColumns: number;
    /**
     * Number of *dashboard cells* along vertical plane.
     *
     * To learn about the effects of *columns* / *rows* configuration, please read more here [Dashboard](../classes/dashboard.html).
     */
    readonly numberOfRows: number;
}
/**
 * Interface for minimum set of parameters required for adding charts / panels to a *dashboard cell*.
 *
 *  Example usage:
 *```javascript
 * // 1x1 component at top left cell
 * { columnIndex: 0, rowIndex: 0, columnSpan: 1, rowSpan: 1 }
 * // 4x1 component at top row
 * { columnIndex: 0, rowIndex: 0, columnSpan: 4, rowSpan: 1 }
 * ```
 */
export interface DashboardCellOptions {
    /**
     * Column index on dashboard (X location, 0 = left)
     */
    columnIndex: number;
    /**
     * Row index on dashboard (Y location, 0 = top)
     */
    rowIndex: number;
    /**
     * Column span (X width), default = 1
     */
    columnSpan?: number;
    /**
     * Row span (Y height), default = 1
     */
    rowSpan?: number;
    /**
     * Theme used to style all elements inside the component.
     * See [[Themes]] for pre-made options.
     */
    theme?: Theme;
    /**
     * Optional flag that can be used to disable all animations by default.
     */
    disableAnimations?: boolean;
}
/**
 * Interface that can be used to define [[ChartOptions3D]] configurations, when inside a [[Dashboard]],
 * that can't be changed after creation.
 */
export interface Chart3DDashboardOptions extends DashboardCellOptions, ChartOptions3D {
}
/**
 * Interface that can be used to define [[ChartXY]] configurations, when inside a [[Dashboard]],
 * that can't be changed after creation. For example:
 *
 * - Specifying TickStrategies for default X or Y Axes'. This is mostly used for creating DateTime Axes.
 *
 * - Supplying a custom Builder for the AutoCursor of Chart. This can be used to modify the AutoCursor on a level,
 * which can't be done during runtime. For example, changing the shape of ResultTable Background, Etc.
 *
 *
 *  Example usage:
 *```javascript
 * // Default
 * undefined
 * // Specified AutoCursor ResultTable Background
 * { chartXYOptions: { autoCursorBuilder: AutoCursorBuilders.XY.setResultTableBackground(UIBackgrounds.Circle) } }
 * ```
 */
export interface ChartOptions<CursorPointMarkerType extends PointMarker, CursorResultTableBackgroundType extends UIBackground> extends DashboardCellOptions, ChartXYOptions<CursorPointMarkerType, CursorResultTableBackgroundType> {
}
/**
 * Interface that can be used to define [[SpiderChart]] configurations, when inside a  [[Dashboard]],
 * that can't be changed after creation.
 *
 *  Example usage:
 *```javascript
 * // Specified AutoCursor ResultTable Background
 * { spiderChartOptions: { autoCursorBuilder: AutoCursorBuilders.Spider.setResultTableBackground(UIBackgrounds.Circle) } }
 * ```
 */
export interface SpiderOptions<CursorPointMarkerType extends PointMarker, CursorResultTableBackgroundType extends UIBackground> extends DashboardCellOptions, SpiderChartOptions<CursorPointMarkerType, CursorResultTableBackgroundType> {
}
/**
 * Interface that can be used to define [[PolarChart]] configurations, when inside a  [[Dashboard]],
 * that can't be changed after creation.
 *
 *  Example usage:
 *```javascript
 * // Specified AutoCursor ResultTable Background
 * { polarChartOptions: { autoCursorBuilder: AutoCursorBuilders.Polar.setResultTableBackground(UIBackgrounds.Circle) } }
 * ```
 */
export interface PolarOptions<CursorPointMarkerType extends PointMarker, CursorResultTableBackgroundType extends UIBackground> extends DashboardCellOptions, PolarChartOptions<CursorPointMarkerType, CursorResultTableBackgroundType> {
}
/**
 * Interface that can be used to define [[PieChart]]configurations, when inside a [[Dashboard]], that can't be changed after creation.
 *
 *  Example usage:
 *```javascript
 * // Pie Chart with default type
 * undefined
 * // Pie Chart* with specified type
 * { pieChartOptions: { type: PieChartTypes.PieChartWithLabelsOnSides } }
 * ```
 */
export interface PieOptions<PieChartType extends PieChartTypes> extends DashboardCellOptions, PieChartOptions<PieChartType> {
}
/**
 * Interface that can be used to define [[FunnelChart]] configurations, when inside a [[Dashboard]], that can't be changed after creation.
 *
 *  Example usage:
 *```javascript
 * // Funnel Chart with default type
 * undefined
 * // Funnel Chart with specified type
 * { funnelOptions: { type: FunnelChartTypes.LabelsOnSides } }
 * ```
 */
export interface FunnelOptions<FunnelChartType extends FunnelChartTypes> extends DashboardCellOptions, FunnelChartOptions<FunnelChartType> {
}
/**
 * Interface that can be used to define [[PyramidChart]] configurations, when inside a [[Dashboard]], that can't be changed after creation.
 *
 * Example usage:
 * ```javascript
 * // Pyramid Chart with default type
 * undefined
 * // Pyramid Chart with specified type
 * { pyramidOptions: { type: PyramidChartTypes.LabelsInsideSlices } }
 * ```
 */
export interface PyramidOptions<PyramidChartType extends PyramidChartTypes> extends DashboardCellOptions, PyramidChartOptions<PyramidChartType> {
}
/**
 * Interface that can be used to define [[GaugeChart]] configurations, when inside a [[Dashboard]], that can't be changed after creation.
 *
 *  Example usage:
 *```javascript
 * // Gauge Chart* with default type
 * undefined
 * // Gauge Chart* with specified type
 * { gaugeOptions: { **type:** *GaugeChartTypes*.Solid } }
 * ```
 */
export interface GaugeOptions<GaugeChartType extends GaugeChartTypes> extends DashboardCellOptions, GaugeChartOptions<GaugeChartType> {
}
/**
 * Interface that can be used to define [[ZoomBandChart]] configurations, when inside a [[Dashboard]], that can't be changed after creation.
 */
export interface ZoomBandChartOptions extends DashboardCellOptions {
    /**
     * *Axis* that the created `ZoomBandChart` is attached to.
     *
     * If multiple Axes are supplied, `ZoomBandChart` will automatically ensure that every axis will always have same interval.
     *
     * This behaviour is same as using [[synchronizeAxisIntervals]].
     */
    axis: Axis | Array<Axis>;
    /**
     * Flag to set the Band above or under the series in `ZoomBandChart`
     * Default value: `true`
     */
    bandAboveSeries?: boolean;
}
/**
 * Interface that can be used to define [[MapChart]] configurations, when inside a [[Dashboard]],
 * that can't be changed after creation.
 *
 * **Example usage:**
 *
 * - Specify minimum amount of required configurations ([[DashboardBasicOptions]]).
 *
 * ``` ts
 *  const mapChart = lightningChart().Dashboard({
 *      rowIndex: 0,
 *      columnIndex: 0,
 *      rowSpan: 1,
 *      columnSpan: 1
 *  })
 * ```
 *
 * - Specify *MapType*.
 *
 * ``` ts
 *  const mapChart = lightningChart().Dashboard({
 *      rowIndex: 0,
 *      columnIndex: 0,
 *      rowSpan: 1,
 *      columnSpan: 1,
 *      type: MapTypes.USA
 *  })
 * ```
 */
export interface MapChartDashboardOptions<SelectedMapType extends MapType, CursorPointMarkerType extends PointMarker, CursorResultTableBackgroundType extends UIBackground> extends DashboardCellOptions, MapChartOptions<SelectedMapType, CursorPointMarkerType, CursorResultTableBackgroundType> {
}
/**
 * *Dashboard* is a component for flexible positioning of multiple *Chart*s efficiently.
 * It is created with [[LightningChart.Dashboard]] method.
 *
 * Upon its creation an amount of *columns* and *rows* is specified. *Charts* and other components can
 * then be placed in cells with given *column* and *row*-locations and sizes
 * (using methods of *Dashboard*. For example: [[Dashboard.createChartXY]].
 *
 * The *Dashboard* will distribute the available space for *columns* and *rows*, which users can resize
 * with mouse and touch interactions or programmatically.
 */
export declare class Dashboard implements Control, Validatable {
    protected readonly _lcjsOptions: InternalLightningChartOptions;
    protected readonly _dashboardOptions: DashboardOptions;
    private readonly _disposeEngine;
    /**
     * Public, safe interface for Dashboards rendering engine.
     */
    readonly engine: PublicEngine;
    /**
     * Scale that represents dashboard area in percents (0-100).
     */
    readonly uiScale: LinearScaleXY;
    /**
     * @param   _lcjsOptions        LightningChart options
     * @param   _dashboardOptions    Settings union used to define dashboard.
     * @param   engine              Injectable engine
     * @param   _disposeEngine      Handler used to dispose the engine when Dashboard.dispose() is called.
     * @param   logoFactory         Logo factory.
     * @hidden
     */
    constructor(_lcjsOptions: InternalLightningChartOptions, _dashboardOptions: DashboardOptions, engine: Engine, _disposeEngine: () => void, logoFactory?: LogoFactory);
    /**
     * Set the minimum and maximum boundaries for dashBoard horizontal size.
     * @param boundary  Single value for static engine size, or a tuple for size range [min, max] in pixels.
     */
    setWidth(boundary: number | [number | undefined, number | undefined] | undefined): this;
    /**
     * Set the minimum and maximum boundaries for dashBoard vertical size.
     * @param boundary  Single value applied to both minimum and maximum size, or a tuple for [min, max] size in pixels.
     */
    setHeight(boundary: number | [number | undefined, number | undefined] | undefined): this;
    /**
     * Get the minimum and maximum horizontal boundaries used for the Dashboard.
     * @return Horizontal boundaries as a tuple [minSize, maxSize]
     */
    getWidth(): [number | undefined, number | undefined] | undefined;
    /**
     * Get the minimum and maximum vertical boundaries used for the Dashboard.
     * @return Vertical boundaries as a tuple [minSize, maxSize]
     */
    getHeight(): [number | undefined, number | undefined] | undefined;
    /**
     * Set fillStyle of dashboard background.
     * @param   fillStyle   FillStyle or mutator to modify existing one
     * @return              Object itself
     */
    setBackgroundFillStyle(fillStyle: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fillStyle of dashboard
     * @return              FillStyle
     */
    getBackgroundFillStyle(): FillStyle;
    /**
     * Set stroke style of dashboard background.
     * @param   value       LineStyle
     * @return              Object itself
     */
    setBackgroundStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stroke style of dashboard background.
     * @return              LineStyle
     */
    getBackgroundStrokeStyle(): LineStyle;
    /**
     * Get theme used for the dashboard.
     * @return  Theme
     */
    getTheme(): Theme;
    /**
     * Set style of Dashboard splitters.
     *
     * Example usage:
     *```javascript
     * // Specified LineStyle
     * Dashboard.setSplitterStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * Dashboard.setSplitterStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden
     * Dashboard.setSplitterStyle(emptyLine)
     * ```
     * @param   value   Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
     * @returns         Chart itself
     */
    setSplitterStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of Dashboard splitters.
     * @return  LineStyle object
     */
    getSplitterStyle(): LineStyle;
    /**
     * Set style of Dashboard splitters when highlighted.
     *
     * Example usage:
     *```javascript
     * // Specified LineStyle
     * Dashboard.setSplitterStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * Dashboard.setSplitterStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden
     * Dashboard.setSplitterStyle(emptyLine)
     * ```
     * @param   value   Either a LineStyle object or a function, which will be used to modify current value or
     *                  undefined for automatic value based on normal style.
     * @returns         Chart itself
     */
    setSplitterStyleHighlight(value: LineStyle | ImmutableMutator<LineStyle> | undefined): this;
    /**
     * Get style of Dashboard splitters when highlighted.
     * @return  LineStyle object
     */
    getSplitterStyleHighlight(): LineStyle;
    /**
     * Set width of a column in relation to other columns. By default all column widths are `1`.
     *
     * By changing one columns width to `2`, it would make that column allocate twice as much width as others.
     *
     *  ```ts
     *  // Example, Dashboard with 3 columns with widths (20%, 20%, 60%) of dashboard width
     *  dashboard.setColumnWidth( 0, 1 )
     *  dashboard.setColumnWidth( 1, 1 )
     *  dashboard.setColumnWidth( 2, 3 )
     *  ```
     * @param index             Index of the column (starts from 0)
     * @param relativeWidth     Relative width of the column, can be any number.
     */
    setColumnWidth(index: number, relativeWidth: number): this;
    /**
     * Get width of a column in relation to other columns. By default all column widths are `1`.
     *
     * Example usage:
     *  ```ts
     *  dashboard.getColumnWidth( 0 )
     *  ```
     * @param index             Index of the column (starts from 0)
     * @return                  Relative width of the column.
     */
    getColumnWidth(index: number): number;
    /**
     * Set height of a row in relation to other rows. By default all row heights are `1`.
     *
     * By changing one rows height to `2`, it would make that row allocate twice as much height as others.
     *
     *  ```ts
     *  // Dashboard with 3 rows with heights (20%, 20%, 60%) of dashboard height
     *  dashboard.setRowHeight( 0, 1 )
     *  dashboard.setRowHeight( 1, 1 )
     *  dashboard.setRowHeight( 2, 3 )
     *  ```
     * @param index             Index of the row (starts from 0)
     * @param relativeHeight    Relative height of the row
     */
    setRowHeight(index: number, relativeHeight: number): this;
    /**
     * Get height of a row in relation to other rows. By default all row heights are `1`.
     *
     * Example usage:
     *```javascript
     * dashboard.getRowHeight( 0 )
     * ```
     * @param index             Index of the row (starts from 0)
     */
    getRowHeight(index: number): number;
    /**
     * Disable/Enable all animations of the Chart.
     * @param animationsEnabled Boolean value to enable or disable animations.
     * @return                  Chart itself for fluent interface.
     */
    setAnimationsEnabled(animationsEnabled: boolean | undefined): this;
    /**
     * Get animations disable/enable state.
     * @returns Animations default state.
     */
    getAnimationsEnabled(): boolean;
    /**
     * Disable all animations for all charts in the dashboard.
     *
     * After calling this function, animations (Zooming, scaling) for all Charts will be disabled.
     * Animations must be recreated manually for each chart afterwards.
     * @return      Dashboard itself for fluent interface.
     * @deprecated  Deprecated in v3.1.0. Will be removed in v4.0.0. Use [[setAnimationsEnabled]] instead.
     */
    disableAnimations(): this;
    /**
     * Use mapping function on all charts inside dashboard.
     * Dashboard filters any other types of cells out.
     * @param   clbk Map function for Chart
     */
    mapCharts<T>(clbk: (chart: Chart) => T): T[];
    /**
     * Use forEach function on charts inside dashboard.
     * Dashboard filters any other types of cells out.
     * @param   clbk forEach function for Chart
     */
    forEachChart(clbk: (chart: Chart) => void): void;
    /**
     * **Permanently** dispose the component.
     *
     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
     * **to the component and its children** in application code.
     * ```javascript
     * let chart = ...ChartXY()
     * let axisX = chart.getDefaultAxisX()
     * // Dispose Chart, and remove all references so that they can be garbage-collected.
     * chart.dispose()
     * chart = undefined
     * axisX = undefined
     * ```
     * @return  Object itself for fluent interface
     */
    dispose(): this;
    /**
     * Subscribe `onDispose` event.
     * This event is triggered whenever the Control (Dashboards and all chart types) is disposed.
     *
     * ```typescript
     *  // Example usage
     *
     * Dashboard.onDispose(() => {
     *   console.log('Dashboard was disposed')
     * })
     *
     * Dashboard.dispose()
     * ```
     *
     * @param   handler         Handler function for event
     * @return                  Token of subscription
     */
    onDispose: (handler: () => unknown) => Token;
    /**
     * Remove event listener from dispose event.
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offDispose: (token: Token) => boolean;
    /**
     * Capture rendered state in an image file. Prompts the browser to download the created file.
     *
     * **NOTE: The download might be blocked by browser/plugins as harmful.**
     * To prevent this, only call the method in events tied to user-interactions.
     * From mouse-event handlers, for example.
     *
     * Has two optional parameters which directly reference JavaScript API HTMLCanvasElement.toDataURL.
     * For supported image formats, compression quality, Etc. refer to:
     *
     * https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL
     *
     * Example usage:
     *```javascript
     * // Download 'screenshot.png'
     * Dashboard.saveToFile('screenshot')
     * // Attempt download 'maybeNotSupported.bmp'
     * Dashboard.saveToFile('maybeNotSupported', 'image/bmp')
     * // Attempt download jpeg.file with specified compression quality
     * Dashboard.saveToFile('fileName', 'image/jpeg', 0.50)
     * ```
     * @sideEffect              **If 'type' is not supported by browser, an Error will be thrown.**
     *
     * @param   fileName        Name of prompted download file as string. **File extension shouldn't be included**
     *                          as it is automatically detected from 'type'-argument.
     * @param   type            A DOMString indicating the image format. The default format type is image/png.
     * @param   encoderOptions  A Number between 0 and 1 indicating the image quality to use for image formats
     *                          that use lossy compression such as image/jpeg and image/webp. If this argument is anything else,
     *                          the default value for image quality is used. The default value is 0.92.
     */
    saveToFile(fileName: string, type?: string, encoderOptions?: number): this;
    /**
     * Add a stand-alone *UIElement* using a *builder*.
     *
     * **Example usage:**
     *
     * 1) TextBox with default positioning coordinate system.
     *
     * ```typescript
     *  addUIElement( UIElementBuilders.TextBox )
     *      // Position = [0, 100] as percentages.
     *      .setPosition({ x: 50, y: 50 })
     * ```
     *
     * 2) Position in pixel coordinate system.
     *
     * ```typescript
     *  addUIElement( UIElementBuilders.TextBox, chart.pixelScale )
     *      // Position = pixels.
     *      .setPosition({ x: 300, y: 100 })
     * ```
     *
     * 3) Position on Axes.
     *
     * ```typescript
     *  addUIElement( UIElementBuilders.TextBox, { x: chartXY.getDefaultAxisX(), y: chartXY.getDefaultAxisY() } )
     *      // Position = Axis values.
     *      .setPosition({ x: 5, y: 5 })
     * ```
     *
     * @typeparam   UIElementType   Type of *UIElement* that is specified by 'builder'-*parameter*.
     *
     * @param       builder *UIElementBuilder*. If omitted, *TextBoxBuilder* will be selected. Use [[UIElementBuilders]] for selection.
     * @param       scale   Optional parameter for altering the coordinate system used for positioning the UIElement. Defaults to whole Dashboard in percentages [0, 100].
     * @returns             Object that fulfills *interfaces*:  *UIElementType* (typeparam) and *UIElement*
     */
    addUIElement<UiElementType extends UIPart = UITextBox>(uiElementBuilder?: UIElementBuilder<UiElementType>, scale?: UserScaleDefinition): UiElementType & UIElement;
    /**
     * Add a *legendbox*.
     *
     * *Legendbox* is a type of *UI element*, that floats inside the chart/component it is created inside. It can be freely moved around
     * with user interactions, as well as positioned in application code.
     *
     * The purpose of *legendbox* is to describe the *series* and other visual components of the *chart*, by displaying their names and colors.
     * Hovering over a *series'* *legendbox entry* will highlight that *series*, and clicking on the *entry* will toggle that *series'* visibility.
     *
     * **Legendbox alignment:**
     *
     * Alignment of legendbox can be selected by supplying one of the available [[LegendBoxBuilders]] to `addLegendBox`:
     *
     * ```typescript
     *  // Default (vertical) LegendBox.
     *  const legendBox = ChartXY.addLegendBox()
     *
     *  // Horizontal LegendBox.
     *  const horizontalLegendBox = ChartXY.addLegendBox(LegendBoxBuilders.HorizontalLegendBox)
     * ```
     *
     * **Custom Legendbox positioning:**
     *
     * By default LegendBoxes are placed on the right side, or bottom of the *chart* (depending on *alignment*).
     *
     * A custom location can be configured with [[UIElement]] API:
     * - [[UIElement.setPosition]]
     * - [[UIElement.setOrigin]]
     * - [[UIElement.setMargin]]
     *
     * *Position coordinate system* is specified when creating *legendbox*.
     *
     * 1) LegendBox with default positioning coordinate system.
     *
     * ```typescript
     *  addLegendBox( LegendBoxBuilders.VerticalLegendBox )
     *      // Position = [0, 100] as percentages.
     *      .setPosition({ x: 50, y: 50 })
     * ```
     *
     * 2) Position in pixel coordinate system.
     *
     * ```typescript
     *  addLegendBox( LegendBoxBuilders.VerticalLegendBox, chart.pixelScale )
     *      // Position = pixels.
     *      .setPosition({ x: 300, y: 100 })
     * ```
     *
     * 3) Position on Axes.
     *
     * ```typescript
     *  addLegendBox( LegendBoxBuilders.VerticalLegendBox, { x: chartXY.getDefaultAxisX(), y: chartXY.getDefaultAxisY() } )
     *      // Position = Axis values.
     *      .setPosition({ x: 5, y: 5 })
     * ```
     *
     * Inside Dashboard, a [[UILegendBoxPanel]] can also be used for simplified creation of *legendboxes* for several charts.
     *
     * @param       builder *LegendBoxBuilder*. If omitted, *VerticalLegendBox* will be selected. Use [[LegendBoxBuilders]] for selection.
     * @param       scale   Optional parameter for altering the coordinate system used for positioning the LegendBox. Defaults to whole Chart in percentages [0, 100].
     * @returns             Object with two interfaces: LegendBox and UIElement.
     */
    addLegendBox(builder?: UILegendBoxBuilder, scale?: UserScaleDefinition): LegendBox & UIElement;
    /**
     * Add new ChartXY to dashboard at specified location and span.
     *
     * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
     * @param    options   Options object for creating a chartXY.
     * @return             ChartXY.
     */
    createChartXY: <CursorPointMarkerType extends PointMarker, CursorResultTableBackgroundType extends UIBackground>(options: ChartOptions<CursorPointMarkerType, CursorResultTableBackgroundType>) => ChartXY<CursorPointMarkerType, CursorResultTableBackgroundType>;
    /**
     * Add new SpiderChart to dashboard at specified location and span.
     *
     * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
     * @param    options   Options object for creating a Spider chart.
     * @return             SpiderChart.
     */
    createSpiderChart: <CursorPointMarkerType extends PointMarker, CursorResultTableBackgroundType extends UIBackground>(options: SpiderOptions<CursorPointMarkerType, CursorResultTableBackgroundType>) => SpiderChart<CursorPointMarkerType, CursorResultTableBackgroundType>;
    /**
     * Add new PolarChart to dashboard at specified location and span.
     *
     * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
     * @param    options   Options object for creating a PolarChart chart.
     * @return             PolarChart.
     */
    createPolarChart: <CursorPointMarkerType extends PointMarker, CursorResultTableBackgroundType extends UIBackground>(options: PolarOptions<CursorPointMarkerType, CursorResultTableBackgroundType>) => PolarChart<CursorPointMarkerType, CursorResultTableBackgroundType>;
    /**
     * Add new PieChart to dashboard at specified location and span.
     *
     * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
     * @param    options   Options object for creating a PieChart.
     * @return             PieChart.
     */
    createPieChart: <PieChartType extends PieChartTypes = typeof PieChartWithLabelsOnSides>(options: PieOptions<PieChartType>) => InstanceType<PieChartType>;
    /**
     * Add new FunnelChart to dashboard at specified location and span.
     *
     * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
     * @param    options   Options object for creating a FunnelChart.
     * @return             FunnelChart.
     */
    createFunnelChart: <FunnelChartType extends FunnelChartTypes = typeof FunnelChartWithLabelsOnSides>(options: FunnelOptions<FunnelChartType>) => InstanceType<FunnelChartType>;
    /**
     * Add new PyramidChart to dashboard at specified location and span.
     *
     * Throws an error if either column/row index is less than 0 or index + span is more than Dashboard's numberOfColumns/Rows.
     * @param   options     Options object for creating a PyramidChart.
     * @returns             PyramidChart
     */
    createPyramidChart: <PyramidChartType extends PyramidChartTypes = typeof PyramidChartWithLabelsOnSides>(options: PyramidOptions<PyramidChartType>) => InstanceType<PyramidChartType>;
    /**
     * Create a container for UI objects on dashboard with specified location and span.
     *
     * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
     * @param    options   Options object for creating a UIPanel.
     * @return             Panel.
     */
    createUIPanel: (options: DashboardCellOptions) => UIPanel;
    /**
     * Create a new *legend box panel*, a convenience component for placing *legend box items*
     * from multiple different *charts* into a single *row layout*, to dashboard at specified location and span.
     *
     *
     * Refer to [[UILegendBoxPanel]] for more information, like *example usage*.
     *
     * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
     * @param    options   Options object for creating a *legend box panel*.
     * @return             UILegendBoxPanel.
     */
    createLegendBoxPanel: (options: DashboardCellOptions) => UILegendBoxPanel;
    /**
     * Add new GaugeChart to dashboard at specified location and span.
     *
     * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
     * @param    options   Options object for creating a GaugeChart.
     * @return             GaugeChart.
     */
    createGaugeChart: <GaugeChartType extends GaugeChartTypes = typeof SolidGauge>(options?: GaugeOptions<GaugeChartType>) => InstanceType<GaugeChartType>;
    /**
     * Add new ZoomBandChart to dashboard at specified location and span.
     *
     * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
     * @param    options   Options object for creating a ZoomBandChart.
     * @return             ZoomBandChart.
     */
    createZoomBandChart: (options: ZoomBandChartOptions) => ZoomBandChart;
    /**
     * Factory for `MapChart`. This chart visualizes a Map of the selected part of the world. Defaults to the entire world.
     * It has built-in *cursor* functionality and supports dynamic region coloring.
     *
     * To learn more about its features, refer to [MapChart](../classes/mapchart.html).
     *
     * **Dashboard cell configuration:**
     *
     * When inside a `Dashboard`, the chart location relative to the `Dashboard` **must be supplied when it is created**.
     *
     * ```typescript
     *  // Example, dashboard cell configuration.
     *  const chart = Dashboard.createMapChart({
     *      // X location, 0 = left.
     *      columnIndex: 0,
     *      // Y location, 0 = top.
     *      rowIndex: 0,
     *      // Amount of X cells allocated for this chart.
     *      columnSpan: 1,
     *      // Amount of Y cells allocated for this chart.
     *      rowSpan: 1,
     *  })
     * ```
     *
     * **Readonly configuration:**
     *
     * Some properties of `MapChart` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example, specify map type.
     *  const chart = LightningChart.Map({
     *      type: MapTypes.Europe
     *  })
     * ```
     *
     * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to [[EngineOptions]].
     *
     * For `MapChart` specific properties, refer to [[MapChartOptions]].
     *
     * @param   options     Object with readonly configuration arguments for `MapChart`.
     * @return              Created chart.
     */
    createMapChart: <SelectedMapType extends MapType, CursorPointMarkerType extends PointMarker, CursorResultTableBackgroundType extends UIBackground>(options: MapChartDashboardOptions<SelectedMapType, CursorPointMarkerType, CursorResultTableBackgroundType>) => MapChart<SelectedMapType, CursorPointMarkerType, CursorResultTableBackgroundType>;
    /**
     * Add new Chart3D to dashboard at specified location and span.
     *
     * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
     * @param    options   Options object for creating a Chart3D.
     * @return             Chart3D.
     */
    createChart3D: (options: Chart3DDashboardOptions) => Chart3D;
}
/**
 * Interface for Chart with stylable series background (area behind series).
 * @hidden Public API, but interface is not included in API doc because the API can be referenced from Charts that implement it (goal = minimal API).
 */
export interface ChartWithStylableSeriesBackground {
    /**
     * Set [[FillStyle]] of *series background* (area behind *series*).
     *
     * ```typescript
     *  // Example usage,
     *  ChartXY.setSeriesBackgroundFillStyle(new SolidFill({ color: ColorRGBA( 60, 0, 0 ) }))
     * ```
     *
     * **Related API:**
     * - Use [[SolidFill]] to describe a solid fill color.
     * - Use [[ColorRGBA]] to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
     *
     * @param   value       `FillStyle` or function which mutates the active `FillStyle`.
     * @return              Object itself
     */
    setSeriesBackgroundFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get FillStyle of Series background area (area behind series).
     * @return              FillStyle
     */
    getSeriesBackgroundFillStyle(): FillStyle;
    /**
     * Set [[LineStyle]] of series background border stroke.
     *
     * ```typescript
     *  // Example usage,
     *  ChartXY.setSeriesBackgroundStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorRGBA( 0, 255, 0 ) })
     *  }))
     * ```
     *
     * **Related API:**
     * - Use [[SolidLine]] to describe a solid line style.
     * - Use [[SolidFill]] to describe a solid fill color.
     * - Use [[ColorRGBA]] to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
     *
     * @param   value       `LineStyle` or function which mutates the active `LineStyle`.
     * @return              Object itself
     */
    setSeriesBackgroundStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get Stroke style of Series background area (area behind series).
     * @return              LineStyle
     */
    getSeriesBackgroundStrokeStyle(): LineStyle;
}
/**
 * Component that can be added to a [[Dashboard]], with method [[Dashboard.createLegendBoxPanel]].
 *
 * It is a convenience component for placing *legend box items* from multiple different *charts* into a single *row layout*.
 *
 * **Example usage:**
 *
 * ```typescript
 *  // Add a UILegendBoxPanel to a Dashboard.
 *  const legendBoxPanel = dashboard.createLegendBoxPanel({
 *      columnIndex: 0,
 *      rowIndex: 0,
 *      columnSpan: 1,
 *      rowSpan: 1,
 *  })
 *
 *  // Add charts to shared Legend.
 *  legendBoxPanel
 *      .add(myChart1)
 *      .add(myChart2)
 *
 *  // Internally created LegendBoxes can be modified via callback.
 *  legendBoxPanel.setLegendBoxes((legendBox, chart) => {
 *      // Check reference to only apply style to LegendBox matching a specific chart.
 *      if (chart !== myChart1) return
 *      // Now, only the LegendBox matching 'myChart1' will be affected.
 *      legendBox
 *          .setTitle('Custom legend title')
 *          .setTitleFont((font) => font.setWeight('bold'))
 *  })
 * ```
 *
 * **Frequently used methods:**
 * - [[UILegendBoxPanel.add]]
 * - [[UILegendBoxPanel.setLegendBoxes]]
 *
 * **Related APIs**:
 * - [[LegendBox]]
 * - [[LegendBoxEntry]]
 *
 * For more application specific LegendBox requirements, it is recommended to:
 * - Use [[UIPanel]] and manage UI layouts and checkboxes on user application side.
 * - Craft the *user interface* outside LCJS, with *HTML* for example.
 */
export declare class UILegendBoxPanel extends UIPanel {
    /**
     * Attach a *Chart* or collection of *Charts* to the *legend box panel*.
     *
     * This appends a new *legend box* to the panel, which will contain *entries* for all the attachable components in the supplied *chart*.
     *
     * The supplied argument can be either a single *chart*, or a *dashboard*, in which case all
     * currently existing charts inside the dashboard will be attached.
     *
     * The created *legend boxes* can be styled afterwards using [[UILegendBoxPanel.setLegendBoxes]].
     *
     * **Example usage**:
     *
     *  ```typescript
     *  // Add charts to LegendBoxPanel.
     *  legendBoxPanel
     *      .add(myChart1)
     *      .add(myChart2)
     *
     *  // ... or add all charts inside a Dashboard with a single call.
     *  legendBoxPanel.add(dashboard)
     * ```
     *
     * @param value             Chart or Dashboard.
     * @param opts              Optional extra configuration arguments.
     * @return                  Object itself.
     */
    add(value: Chart | Dashboard, opts?: LegendBoxAddOptions): this;
    /**
     * Trigger a callback for each *legend box* inside the panel.
     * Each legend box is paired with a single *chart* that the user has attached to the *legend box panel*,
     * which can be used for applying modifications to any particular *legend boxes* only.
     *
     * **Example usage:**
     *
     * ```typescript
     *  // Style internally created LegendBoxes. NOTE: Must be called after the LegendBoxes are created, using LegendBoxPanel.add()
     *  LegendBoxPanel.setLegendBoxes((legendBox, chart) => {
     *      legendBox
     *          // Style LegendBox title.
     *          .setTitleFont((font) => font.setWeight('bold'))
     *          // Style LegendBox entries.
     *          .setEntries((entry) => entry
     *              .setTextFont((font) => font.setSize(12))
     *          )
     *  })
     *
     *  // Style can be applied to selected LegendBoxes only by checking reference to supplied chart.
     *  LegendBoxPanel.setLegendBoxes((legendBox, chart) => {
     *      // Only apply style to LegendBox matching one single chart.
     *      if (chart !== myChart1) return
     *
     *      // Style legendBox ...
     *  })
     *
     * ```
     *
     * @param   clbk    Function that is called for each existing *legend box*, and attached *chart*.
     * @return          Object itself for fluent interface.
     */
    setLegendBoxes(clbk: (legendBox: LegendBox, chart: Chart) => void): this;
}
/**
 * Cursor-based visual that can be plotted on a Chart.
 * Like Cursors its built of two parts:
 * PointMarker and ResultTable, first of which
 * shows the location of the Marker clearly and the second
 * to display information about the pointed DataPoint.
 * @hidden
 */
export interface Marker<PointMarkerType extends PointMarker, ResultTableBackgroundType extends UIBackground, CursorType extends Cursor<PointMarkerType, ResultTableBackgroundType>> extends Draggable {
    /**
     * Set visibility mode for PointMarker.
     * PointMarker is a visual that is displayed at the Cursors position.
     * @param   visibilityMode   Defines when part is visible
     * @return                  Object itself
     */
    setPointMarkerVisibility(visibilityMode: UIVisibilityModes): this;
    /**
     * Get visibility mode for PointMarker.
     * PointMarker is a visual that is displayed at the Cursors position.
     * @return                  VisibilityMode
     */
    getPointMarkerVisibility(): UIVisibilityModes;
    /**
     * Set visibility mode for ResultTable.
     * ResultTable is a visual that displays currently pointed data next to its location.
     * @param   visibilityMode   Defines when part is visible
     * @return                  Object itself
     */
    setResultTableVisibility(visibilityMode: UIVisibilityModes): this;
    /**
     * Get visibility mode for ResultTable.
     * ResultTable is a visual that displays currently pointed data next to its location.
     * @return                  VisibilityMode
     */
    getResultTableVisibility(): UIVisibilityModes;
    /**
     * Set mouse interactions enabled or disabled
     * @param state Specifies state of mouse interactions
     * @return      Object itself for fluent interface
     */
    setMouseInteractions(state: boolean): this;
    /**
     * @return Mouse interactions state
     */
    getMouseInteractions(): boolean;
    /**
     * Set auto-fit strategy of Cursor.
     * Affects logic of automatic fitting of Cursors ResultTable to the screen.
     * @param   autoFitStrategy     AutoFitStrategy factory or undefined to disable auto-fitting
     * @returns                     Object itself for fluent interface
     */
    setAutoFitStrategy(autoFitStrategy?: AutoFitStrategyFactory<ResultTableBackgroundType>): this;
    /**
     * Get is auto-fit enabled.
     * Affects logic of automatic fitting of Cursors ResultTable to the screen.
     * @returns                     Boolean flag whether auto-fit is enabled
     */
    getAutoFitStrategy(): boolean;
}
/**
 * Cursor-based visual that can be plotted on a Chart.
 * Like Cursors its built of two parts:
 * PointMarker and ResultTable, first of which
 * shows the location of the Marker clearly and the second
 * to display information about the pointed DataPoint.
 * @hidden Internal class
 */
export declare abstract class ChartMarker<PointMarkerType extends PointMarker = PointMarker, ResultTableBackgroundType extends UIBackground = UIBackground, CursorType extends InternalStaticCursor<PointMarkerType, ResultTableBackgroundType> = InternalStaticCursor<PointMarkerType, ResultTableBackgroundType>> implements Marker<PointMarkerType, ResultTableBackgroundType, CursorType>, Disposable {
    /**
     * Set the position of Annotation on its scale.
     * @param   position    Position on Annotations scale.
     */
    setPosition(position: Point): this;
    /**
     * Get current position of Annotation
     * @return              Position on Annotations scale
     */
    getPosition(): Point;
    /**
     * This event is called whenever the position of the Marker is changed
     * @param   handler         Function that is called when event is triggered.
     * @param   position        New position of Marker.
     * @return                  Token that can be used to unsubscribe from the event.
     */
    onPositionChange(handler: (marker: this, position: Point) => void): Token;
    /**
     * This event is called whenever the position of the Marker is changed
     * @param   token       Token that was received when the subscription was created.
     * @return              True if unsubscription was successful.
     */
    offPositionChange(token: Token): boolean;
    /**
     * Set visibility mode for PointMarker.
     * PointMarker is a visual that is displayed at the Cursors position.
     * @param   visibilityMode   Defines when part is visible
     * @return                  Object itself
     */
    setPointMarkerVisibility(visibilityMode: UIVisibilityModes): this;
    /**
     * Get visibility mode for PointMarker.
     * PointMarker is a visual that is displayed at the Cursors position.
     * @return                  VisibilityMode
     */
    getPointMarkerVisibility(): UIVisibilityModes;
    /**
     * Set visibility mode for ResultTable.
     * ResultTable is a visual that displays currently pointed data next to its location.
     * NOTE: ResultTable is only visible when it has displayable content, regardless of its VisibilityMode!
     * @param   visibilityMode   Defines when part is visible
     * @return                  Object itself
     */
    setResultTableVisibility(visibilityMode: UIVisibilityModes): this;
    /**
     * Get visibility mode for ResultTable.
     * ResultTable is a visual that displays currently pointed data next to its location.
     * @return                  VisibilityMode
     */
    getResultTableVisibility(): UIVisibilityModes;
    /**
     * Set mouse interactions enabled or disabled
     * @param state Specifies state of mouse interactions
     * @return      Object itself for fluent interface
     */
    setMouseInteractions(state: boolean): this;
    /**
     * @return Mouse interactions state
     */
    getMouseInteractions(): boolean;
    /**
     * Set auto-fit strategy of Cursor.
     * Affects logic of automatic fitting of Cursors ResultTable to the screen.
     * @param   autoFitStrategy     AutoFitStrategy factory or undefined to disable auto-fitting
     * @returns                     Object itself for fluent interface
     */
    setAutoFitStrategy(autoFitStrategy?: AutoFitStrategyFactory<ResultTableBackgroundType>): this;
    /**
     * Get is auto-fit enabled.
     * Affects logic of automatic fitting of Cursors ResultTable to the screen.
     * @returns                     Boolean flag whether auto-fit is enabled
     */
    getAutoFitStrategy(): boolean;
    /**
     * @returns True if object is attached or not attachable, false if it is not attached and attachable
     */
    isAttached(): boolean;
    /**
     * Points the Marker at a given CursorPoint.
     * Updating its position and displayed data.
     */
    pointAt(cursorPoint: CursorPoint): this;
    /**
     * Dispose this Marker from owner's collection.
     */
    dispose(): this;
    /**
     * Restore the marker to parent and the marker's cursor ( and its elements ).
     * @return Marker itself.
     */
    restore(): this;
    /**
     * @return True if Cursor has been disposed, false if not.
     */
    isDisposed(): boolean;
    /**
     * Mutator function for PointMarker.
     * PointMarker is a visual that is displayed at the Cursors position
     * @param   mutator     Mutator function for PointMarker
     * @return              Object itself for fluent interface
     */
    setPointMarker(mutator: Mutator<PointMarkerType>): this;
    /**
     * Get PointMarker object.
     * PointMarker is a visual that is displayed at the Cursors position
     * @returns             PointMarker object
     */
    getPointMarker(): PointMarkerType;
    /**
     * Mutator function for ResultTable.
     * ResultTable is a visual that displays currently pointed data next to its location
     * @param   mutator     Mutator function for ResultTable
     * @return              Object itself for fluent interface
     */
    setResultTable(mutator: Mutator<ResultTable<ResultTableBackgroundType>>): this;
    /**
     * Get ResultTable object.
     * ResultTable is a visual that displays currently pointed data next to its location
     * @returns             ResultTable object
     */
    getResultTable(): ResultTable<ResultTableBackgroundType>;
    /**
     * Set dragging mode of object. Defines how the object can be dragged by mouse.
     *
     * See [[UIDraggingModes]] collection for options.
     * @param       draggingMode    DraggingMode or undefined to disable dragging
     * @returns                     Object itself
     */
    setDraggingMode(draggingMode?: UIDraggingModes): this;
    /**
     * Get dragging mode of object.
     * Defines how the object can be dragged by mouse.
     * @returns                     Object itself
     */
    getDraggingMode(): UIDraggingModes;
}
/**
 * Simple ChartMarker implementation for 2D Charts.
 * Like Cursors its built of two parts:
 * PointMarker and ResultTable, first of which
 * shows the location of the Marker clearly and the second
 * to display information about the pointed DataPoint.
 * @hidden Internal class
 */
export declare class ChartMarker2D<PointMarkerType extends PointMarker, ResultTableBackgroundType extends UIBackground> extends ChartMarker<PointMarkerType, ResultTableBackgroundType, InternalStaticCursor<PointMarkerType, ResultTableBackgroundType>> {
    protected readonly _layer: Layer2D;
    protected _removeMarker: (marker: ChartMarker) => void;
    protected _restoreMarker: (marker: ChartMarker) => void;
    readonly _theme: Theme;
    /**
     * @param _layer        Rendering layer
     * @param scale         Rendering scale
     * @param CursorBuilder CursorBuilder that defines look of chartMarker
     * @hidden
     */
    constructor(_layer: Layer2D, renderingScale: LinearScaleXY, scale: ScaleXY, CursorBuilder: StaticCursor2DBuilder<PointMarkerType, ResultTableBackgroundType>, _removeMarker: (marker: ChartMarker) => void, _restoreMarker: (marker: ChartMarker) => void, _theme: Theme);
}
/**
 * Abstract base class for charts and UI panels
 * @hidden Internal class
 */
export declare abstract class Panel implements Control, DashboardPanel {
    /**
     * Public, safe interface for Panels rendering engine.
     */
    readonly engine: PublicEngine;
    /**
     * Scale for panel area in percentages (0-100).
     */
    uiScale: LinearScaleXY;
    /**
     * Scale for panel area in pixels.
     */
    pixelScale: LinearScaleXY;
    /**
     * Get minimum size of Panel.
     * Depending on the type of class this value might be automatically computed to fit different elements.
     * @return  Point minimum size or undefined if unimplemented
     */
    abstract getMinimumSize(): Point | undefined;
    /**
     * Returns the Theme currently being used.
     * @returns An object containing the Theme.
     */
    getTheme(): Theme;
    /**
     * Set [[FillStyle]] of chart background.
     *
     * ```typescript
     *  // Example usage,
     *  ChartXY.setBackgroundFillStyle(new SolidFill({ color: ColorRGBA( 80, 0, 0 ) }))
     * ```
     *
     * **Related API:**
     * - Use [[SolidFill]] to describe a solid fill color.
     * - Use [[ColorRGBA]] to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
     *
     * **Transparent chart backgrounds:**
     *
     * LightningChart JS charts can be configured to be fully or partially transparent.
     *
     * ```ts
     *  // Example, partially transparent chart
     *
     *  // Engine background exists under all LCJS components. In case of Dashboard, there is only 1 shared engine background.
     *  chart.engine.setBackgroundFillStyle(emptyFill)
     *  // Chart background covers every 1 chart. In case of Dashboard, every chart has its own chart background.
     *  chart.setBackgroundFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 100) }))
     *  // Some charts also have a separate series background.
     *  chart.setSeriesBackgroundFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 100) }))
     * ```
     *
     * @param   value       `FillStyle` or function which mutates the active `FillStyle`.
     * @return              Object itself
     */
    setBackgroundFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fillstyle of chart background.
     * @return              FillStyle
     */
    getBackgroundFillStyle(): FillStyle;
    /**
     * Set [[LineStyle]] of chart background border stroke.
     *
     * ```typescript
     *  // Example usage,
     *  ChartXY.setBackgroundStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorRGBA( 0, 255, 0 ) })
     *  }))
     * ```
     *
     * **Related API:**
     * - Use [[SolidLine]] to describe a solid line style.
     * - Use [[SolidFill]] to describe a solid fill color.
     * - Use [[ColorRGBA]] to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
     *
     * @param   value       `LineStyle` or function which mutates the active `LineStyle`.
     * @return              Object itself
     */
    setBackgroundStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stroke style of chart background.
     * @return              LineStyle
     */
    getBackgroundStrokeStyle(): LineStyle;
    /**
     * Add a stand-alone *UIElement* using a *builder*.
     *
     * **Example usage:**
     *
     * 1) TextBox with default positioning coordinate system.
     *
     * ```typescript
     *  addUIElement( UIElementBuilders.TextBox )
     *      // Position = [0, 100] as percentages.
     *      .setPosition({ x: 50, y: 50 })
     * ```
     *
     * 2) Position in pixel coordinate system.
     *
     * ```typescript
     *  addUIElement( UIElementBuilders.TextBox, chart.pixelScale )
     *      // Position = pixels.
     *      .setPosition({ x: 300, y: 100 })
     * ```
     *
     * 3) Position on Axes.
     *
     * ```typescript
     *  addUIElement( UIElementBuilders.TextBox, { x: chartXY.getDefaultAxisX(), y: chartXY.getDefaultAxisY() } )
     *      // Position = Axis values.
     *      .setPosition({ x: 5, y: 5 })
     * ```
     *
     * @typeparam   UIElementType   Type of *UIElement* that is specified by 'builder'-*parameter*.
     *
     * @param       builder *UIElementBuilder*. If omitted, *TextBoxBuilder* will be selected. Use [[UIElementBuilders]] for selection.
     * @param       scale   Optional parameter for altering the coordinate system used for positioning the UIElement. Defaults to whole Chart in percentages [0, 100].
     * @returns             Object that fulfills *interfaces*:  *UIElementType* (typeparam) and *UIElement*
     */
    addUIElement<UIElementType extends UIPart = UITextBox>(builder?: UIElementBuilder<UIElementType>, scale?: UserScaleDefinition): UIElementType & UIElement;
    /**
     * Add a *legendbox*.
     *
     * *Legendbox* is a type of *UI element*, that floats inside the chart/component it is created inside. It can be freely moved around
     * with user interactions, as well as positioned in application code.
     *
     * The purpose of *legendbox* is to describe the *series* and other visual components of the *chart*, by displaying their names and colors.
     * Hovering over a *series'* *legendbox entry* will highlight that *series*, and clicking on the *entry* will toggle that *series'* visibility.
     *
     * **Legendbox alignment:**
     *
     * Alignment of legendbox can be selected by supplying one of the available [[LegendBoxBuilders]] to `addLegendBox`:
     *
     * ```typescript
     *  // Default (vertical) LegendBox.
     *  const legendBox = ChartXY.addLegendBox()
     *
     *  // Horizontal LegendBox.
     *  const horizontalLegendBox = ChartXY.addLegendBox(LegendBoxBuilders.HorizontalLegendBox)
     * ```
     *
     * **Custom Legendbox positioning:**
     *
     * By default LegendBoxes are placed on the right side, or bottom of the *chart* (depending on *alignment*).
     *
     * A custom location can be configured with [[UIElement]] API:
     * - [[UIElement.setPosition]]
     * - [[UIElement.setOrigin]]
     * - [[UIElement.setMargin]]
     *
     * *Position coordinate system* is specified when creating *legendbox*.
     *
     * 1) LegendBox with default positioning coordinate system.
     *
     * ```typescript
     *  addLegendBox( LegendBoxBuilders.VerticalLegendBox )
     *      // Position = [0, 100] as percentages.
     *      .setPosition({ x: 50, y: 50 })
     * ```
     *
     * 2) Position in pixel coordinate system.
     *
     * ```typescript
     *  addLegendBox( LegendBoxBuilders.VerticalLegendBox, chart.pixelScale )
     *      // Position = pixels.
     *      .setPosition({ x: 300, y: 100 })
     * ```
     *
     * 3) Position on Axes.
     *
     * ```typescript
     *  addLegendBox( LegendBoxBuilders.VerticalLegendBox, { x: chartXY.getDefaultAxisX(), y: chartXY.getDefaultAxisY() } )
     *      // Position = Axis values.
     *      .setPosition({ x: 5, y: 5 })
     * ```
     *
     * @param       builder *LegendBoxBuilder*. If omitted, *VerticalLegendBox* will be selected. Use [[LegendBoxBuilders]] for selection.
     * @param       scale   Optional parameter for altering the coordinate system used for positioning the LegendBox. Defaults to whole Chart in percentages [0, 100].
     * @returns             Object with two interfaces: LegendBox and UIElement.
     */
    addLegendBox(builder?: UILegendBoxBuilder, scale?: UserScaleDefinition): LegendBox & UIElement;
    /**
     * **Permanently** dispose the component.
     *
     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
     * **to the component and its children** in application code.
     * ```javascript
     * let chart = ...ChartXY()
     * let axisX = chart.getDefaultAxisX()
     * // Dispose Chart, and remove all references so that they can be garbage-collected.
     * chart.dispose()
     * chart = undefined
     * axisX = undefined
     * ```
     * @return  Object itself for fluent interface
     */
    dispose(): this;
    /**
     * Capture rendered state in an image file. Prompts the browser to download the created file.
     *
     * **NOTE: The download might be blocked by browser/plugins as harmful.**
     * To prevent this, only call the method in events tied to user-interactions.
     * From mouse-event handlers, for example.
     *
     * Has two optional parameters which directly reference JavaScript API HTMLCanvasElement.toDataURL.
     * For supported image formats, compression quality, Etc. refer to:
     *
     * https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL
     *
     * Example usage:
     *```javascript
     * // Download 'screenshot.png'
     * Panel.saveToFile('screenshot')
     * // Attempt download 'maybeNotSupported.bmp'
     * Panel.saveToFile('maybeNotSupported', 'image/bmp')
     * // Attempt download jpeg.file with specified compression quality
     * Panel.saveToFile('fileName', 'image/jpeg', 0.50)
     * ```
     * @sideEffect              **If 'type' is not supported by browser, an Error will be thrown.**
     *
     * @param   fileName        Name of prompted download file as string. **File extension shouldn't be included**
     *                          as it is automatically detected from 'type'-argument.
     * @param   type            A DOMString indicating the image format. The default format type is image/png.
     * @param   encoderOptions  A Number between 0 and 1 indicating the image quality to use for image formats
     *                          that use lossy compression such as image/jpeg and image/webp. If this argument is anything else,
     *                          the default value for image quality is used. The default value is 0.92.
     */
    saveToFile(fileName: string, type?: string, encoderOptions?: number): this;
    /**
     * Subscribe to mouse-enter event on Chart background
     */
    onBackgroundMouseEnter(handler: MouseEventHandler<this>): Token;
    /**
     * Remove subscription from mouse-enter event on Chart background
     * @param token Event listener
     * @returns True if the listener is successfully removed and false if it is not found
     */
    offBackgroundMouseEnter(token: Token): boolean;
    /**
     * Subscribe to mouse-move event on Chart background
     */
    onBackgroundMouseMove(handler: MouseEventHandler<this>): Token;
    /**
     * Remove subscription from mouse-move event on Chart background
     * @param token Event listener
     * @returns True if the listener is successfully removed and false if it is not found
     */
    offBackgroundMouseMove(token: Token): boolean;
    /**
     * Subscribe to mouse-leave event on Chart background
     */
    onBackgroundMouseLeave(handler: MouseEventHandler<this>): Token;
    /**
     * Remove subscription from mouse-leave event on Chart background
     * @param token Event listener
     * @returns True if the listener is successfully removed and false if it is not found
     */
    offBackgroundMouseLeave(token: Token): boolean;
    /**
     * Subscribe to mouse-down event on Chart background
     */
    onBackgroundMouseDown(handler: MouseEventHandler<this>): Token;
    /**
     * Remove subscription from mouse-down event on Chart background
     * @param token Event listener
     * @returns True if the listener is successfully removed and false if it is not found
     */
    offBackgroundMouseDown(token: Token): boolean;
    /**
     * Subscribe to mouse-up event on Chart background
     */
    onBackgroundMouseUp(handler: MouseEventHandler<this>): Token;
    /**
     * Remove subscription from mouse-up event on Chart background
     * @param token Event listener
     * @returns True if the listener is successfully removed and false if it is not found
     */
    offBackgroundMouseUp(token: Token): boolean;
    /**
     * Subscribe to mouse-click event on Chart background
     */
    onBackgroundMouseClick(handler: MouseEventHandler<this>): Token;
    /**
     * Remove subscription from mouse-click event on Chart background
     * @param token Event listener
     * @returns True if the listener is successfully removed and false if it is not found
     */
    offBackgroundMouseClick(token: Token): boolean;
    /**
     * Subscribe to mouse-doubleClick event on Chart background
     */
    onBackgroundMouseDoubleClick(handler: MouseEventHandler<this>): Token;
    /**
     * Remove subscription from mouse-doubleClick event on Chart background
     * @param token Event listener
     * @returns True if the listener is successfully removed and false if it is not found
     */
    offBackgroundMouseDoubleClick(token: Token): boolean;
    /**
     * Subscribe to mouse-drag start event on Chart background
     */
    onBackgroundMouseDragStart(handler: MouseDragStartEventHandler<this>): Token;
    /**
     * Remove subscription from mouse-dragStart event on Chart background
     * @param token Event listener
     * @returns True if the listener is successfully removed and false if it is not found
     */
    offBackgroundMouseDragStart(token: Token): boolean;
    /**
     * Subscribe to mouse-drag event on Chart background
     */
    onBackgroundMouseDrag(handler: MouseDragEventHandler<this>): Token;
    /**
     * Remove subscription from mouse-drag event on Chart background
     * @param token Event listener
     * @returns True if the listener is successfully removed and false if it is not found
     */
    offBackgroundMouseDrag(token: Token): boolean;
    /**
     * Subscribe to mouse-drag stop event on Chart background
     */
    onBackgroundMouseDragStop(handler: MouseDragStopEventHandler<this>): Token;
    /**
     * Remove subscription from mouse-dragStop event on Chart background
     * @param token Event listener
     * @returns True if the listener is successfully removed and false if it is not found
     */
    offBackgroundMouseDragStop(token: Token): boolean;
    /**
     * Subscribe to mouse-wheel event on Chart background
     */
    onBackgroundMouseWheel(handler: MouseWheelEventHandler<this>): Token;
    /**
     * Remove subscription from mouse-wheel event on Chart background
     * @param token Event listener
     * @returns True if the listener is successfully removed and false if it is not found
     */
    offBackgroundMouseWheel(token: Token): boolean;
    /**
     * Subscribe to touch-start event on Chart background
     */
    onBackgroundTouchStart(handler: TouchEventHandler<this>): Token;
    /**
     * Remove subscription from touch-start event on Chart background
     * @param token Event listener
     * @returns True if the listener is successfully removed and false if it is not found
     */
    offBackgroundMouseTouchStart(token: Token): boolean;
    /**
     * Subscribe to touch-move event on Chart background
     */
    onBackgroundTouchMove(handler: TouchEventHandler<this>): Token;
    /**
     * Remove subscription from touch-move event on Chart background
     * @param token Event listener
     * @returns True if the listener is successfully removed and false if it is not found
     */
    offBackgroundTouchMove(token: Token): boolean;
    /**
     * Subscribe to touch-end event on Chart background
     */
    onBackgroundTouchEnd(handler: TouchEventHandler<this>): Token;
    /**
     * Remove subscription from touch-end event on Panel background
     * @param token Event listener
     * @returns True if the listener is successfully removed and false if it is not found
     */
    offBackgroundTouchEnd(token: Token): boolean;
    /**
     * Subscribe to `resize` event.
     * This event is triggered whenever the area of *chart* changes (due to document or dashboard resizing).
     *
     * ```typescript
     *  // Example usage,
     *  ChartXY.onResize((chart, width, height, engineWidth, engineHeight) => {
     *      console.log('Chart resized', 'width', width, 'height', height, 'engineWidth', engineWidth, 'engineHeight', engineHeight)
     *  })
     * ```
     *
     * @param   handler         Handler function for event
     * @param   obj             Panel itself
     * @param   width           Width of panel in pixels
     * @param   height          Height of panel in pixels
     * @param   engineWidth     Width of panels rendering engine in pixels
     * @param   engineHeight    Height of panels rendering engine in pixels
     * @return                  Token of subscription
     */
    onResize: (handler: (obj: this, width: pixel, height: pixel, engineWidth: pixel, engineHeight: pixel) => void) => Token;
    /**
     * Remove event listener from resize event.
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offResize: (token: Token) => boolean;
    /**
     * Subscribe `onDispose` event.
     * This event is triggered whenever the Control (Dashboards and all chart types) is disposed.
     *
     * ```typescript
     *  // Example usage
     *
     * Chart.onDispose(() => {
     *   console.log('chert was disposed')
     * })
     *
     * Chart.dispose()
     * ```
     *
     * @param   handler         Handler function for event
     * @return                  Token of subscription
     */
    onDispose: (handler: () => unknown) => Token;
    /**
     * Remove event listener from dispose event.
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offDispose: (token: Token) => boolean;
}
/**
 * Type of Dashboard resize-event interface. This interface is injected into Panels created by Dashboard.
 * The Panel should use it to subscribe to Dashboard-resize events.
 * @hidden
 */
export declare type DashboardResizeEventInterface = AbstractEventInterface;
/**
 * Class for a panel that can have UI elements added into it.
 */
export declare class UIPanel extends Panel {
    /**
     * @param   layerSupplier           Layer supplier
     * @param   scaleFactory            ScaleXY factory.
     * @param   removeChart 	        Injectable panel/chart remove method
     * @param   logoFactory             Logo factory.
     * @param   resizeEventInterface    Injectable event interface for resizing Panel (used for dashboard)
     * @param   logoLayer               Layer to use for logo, if the chart was created on a dashboard.
     * @hidden
     */
    constructor(_lcjsOptions: InternalLightningChartOptions, layerSupplier: LayerSupplier, scaleFactory: ScaleFactory, removeChart: (panel: Panel) => void, logoFactory?: LogoFactory, resizeEventInterface?: DashboardResizeEventInterface, theme?: Theme);
    /**
     * **Permanently** dispose the component.
     *
     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
     * **to the component and its children** in application code.
     * ```javascript
     * let chart = ...ChartXY()
     * let axisX = chart.getDefaultAxisX()
     * // Dispose Chart, and remove all references so that they can be garbage-collected.
     * chart.dispose()
     * chart = undefined
     * axisX = undefined
     * ```
     * @return  Object itself for fluent interface
     */
    dispose(): this;
    /**
     * Set minimum size of UIPanel in pixels.
     * This will affect its resizability by dragging dashboard splitters.
     * @param   minimumSize Minimum size as Point pixels
     */
    setMinimumSize(minimumSize: Point): this;
    /**
     * Get minimum size of UIPanel in pixels as set by user.
     * @return  Point minimum size in pixels or undefined
     */
    getMinimumSize(): Point | undefined;
}
/**
 * Internal interface for any type of Series (2D, 3D, ...).
 *
 * Intended for sharing Axis logic which interfaces with all kinds of Axes.
 */
export interface Series extends ChartComponent {
    /**
     * Set whether series is taken into account with automatic scrolling and fitting of attached axes.
     *
     * By default, this is true for all series.
     *
     * By setting this to `false`, any series can be removed from axis scrolling/fitting.
     *
     * ```ts
     *  // Example syntax, remove series from automatic scrolling / fitting.
     *  LineSeries.setAutoScrollingEnabled(false)
     * ```
     * @param   enabled     `true` default, axes will take series into account in scrolling and fitting operations.
     *                      `false`, axes will ignore series boundaries.
     * @return              Object itself for fluent interface.
     */
    setAutoScrollingEnabled(enabled: boolean): this;
    /**
     * Get whether series is taken into account with automatic scrolling and fitting of attached axes.
     *
     * By default, this is true for all series.
     *
     * @return               `true` default, axes will take series into account in scrolling and fitting operations.
     *                      `false`, axes will ignore series boundaries.
     */
    getAutoScrollingEnabled(): boolean;
}
/**
 * Base class for a major group of ChartComponents - Series.
 * Adds Cursor / solveNearest logic.
 * Base class for all Series. Series are chart components which support cursors, basically.
 * @hidden Internal class
 */
export declare abstract class Series2D<VisualType extends ChartVisual = ChartVisual, CursorPointInterface extends CursorPoint<Series2D> = any> extends ChartComponent<VisualType> implements Series {
    /**
     * Scale of the Series.
     * Necessary for translation of data points
     */
    abstract readonly scale: ScaleXY;
    /**
     * Set whether series is taken into account with automatic scrolling and fitting of attached axes.
     *
     * By default, this is true for all series.
     *
     * By setting this to `false`, any series can be removed from axis scrolling/fitting.
     *
     * ```ts
     *  // Example syntax, remove series from automatic scrolling / fitting.
     *  LineSeries.setAutoScrollingEnabled(false)
     * ```
     * @param   enabled     `true` default, axes will take series into account in scrolling and fitting operations.
     *                      `false`, axes will ignore series boundaries.
     * @return              Object itself for fluent interface.
     */
    setAutoScrollingEnabled(enabled: boolean): this;
    /**
     * Get whether series is taken into account with automatic scrolling and fitting of attached axes.
     *
     * By default, this is true for all series.
     *
     * @return               `true` default, axes will take series into account in scrolling and fitting operations.
     *                      `false`, axes will ignore series boundaries.
     */
    getAutoScrollingEnabled(): boolean;
    /**
     * Abstract method that solves the nearest datapoint to a given coordinate on screen.
     * @param   location    Location on screen
     * @return              Undefined or data-structure for positioning of cursors
     */
    abstract solveNearestFromScreen(location: Point): undefined | CursorPointInterface;
    /**
     * Abstract method that solves the nearest datapoint to a given coordinate on a screen from a specific segment.
     * @param   location    Location on screen
     * @param   segment     Segment to solve from
     * @return              Undefined or data-structure for positioning of cursors
     */
    abstract solveNearestFromSegment(location: Point, segment: ChartVisual): undefined | CursorPointInterface;
    /**
     * Configure whether *cursors* should pick on this particular *series* or not.
     *
     * ```typescript
     *  // Example, prevent chart auto cursor from snapping to a series.
     *  LineSeries.setCursorEnabled(false)
     * ```
     *
     * **Related API:**
     *
     * - [[setCursorResultTableFormatter]] | configure formatting of *result table* contents, when this series is pointed.
     * - [[setCursorSolveBasis]] | configure basis of finding nearest data point for the series (`'nearest-x'`, `'nearest'`, etc.).
     * This method is not available for all *series* types (more support will be added in near future).
     * - [[setCursorInterpolationEnabled]] | configure whether cursor should interpolate the displayed data point between the two closest data points, or snap to the nearest *real* data point.
     * This method is not available for all *series* types.
     * - [[ChartXY.setAutoCursorMode]] | configure behavior when auto cursor is visible.
     */
    setCursorEnabled(state: boolean): this;
    /**
     * @returns Whether Cursor is enabled or not
     */
    getCursorEnabled(): boolean;
    /**
     * Add event listener to Series Hover Event.
     * Hover event is a custom mouse-event designed for Series that is the main link between Cursors and Series.
     * @param   clbk            Callback function that is called whenever mouse enters / moves or leaves the Series
     *
     * @param   series          Series itself
     * @param   cursorPoint     Interface for positioning Cursors on Series or undefined if mouse left Series.
     * @return                  Token of the event listener
     */
    onHover: (clbk: (series: this, cursorPoint: CursorPointInterface | undefined) => void) => Token;
    /**
     * Remove event listener from Series Hover Event.
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offHover: (token: Token) => boolean;
}
/**
 * Function for handling of interframe modification
 * @param   values  Values calculated by Ease function
 */
export declare type AnimationFrameCallback = (values: Array<number>) => void;
/**
 * Ease Animation function
 * @param   delta   Delta time from start of animation
 * @hidden
 */
export declare type Ease = (delta: number) => number;
/**
 * Interface for [[AnimationEasing]].
 *
 * See  [[AnimationEasings]] for a collection of default options.
 * @param   start       Starting value of the animation
 * @param   end         End value of the animation
 * @param   duration    Animation Duration in milliseconds
 */
export declare type AnimationEasing = (start: number, end: number, duration: number) => Ease;
/**
 * [[AnimationEasing]] collection to use with [[Animator]].
 */
export declare const AnimationEasings: {
    linear: (start: number, end: number, duration: number) => Ease;
    easeIn: (start: number, end: number, duration: number) => Ease;
    easeOut: (start: number, end: number, duration: number) => Ease;
    ease: (start: number, end: number, duration: number) => Ease;
    /**
     * Scroll easing factory for logarithmic axes.
     */
    logarithmic: (base: number) => AnimationEasing;
};
/**
 * Class for animation handling
 * @property    delta           Delta time from start of animation
 * @property    eases           Array of Eases animation functions
 * @property    nextAnimations  Queue of future animations
 * @property    action          Function for handling of interframe modification
 * @property    duration        Animation duration in milliseconds
 * @property    easing          Ease animation function factory
 */
export declare class Animation {
    private readonly _values;
    readonly action: AnimationFrameCallback;
    readonly duration: number;
    readonly easing: AnimationEasing;
    private readonly _animations;
    delta: number;
    eases: Array<Ease>;
    /**
     * @param   _values      Array of start and end animation values
     * @param   action      Function for handling of interframe modification
     * @param   duration    Animation Duration in milliseconds
     * @param   easing      Ease Animation function factory. See [[AnimationEasings]] for a collection of options.
     */
    constructor(_values: Array<[number, number]>, action: AnimationFrameCallback, duration: number, easing: AnimationEasing, _animations: Array<Animation>);
    /**
     * Starts an animation
     * @return Object itself for fluent interface
     */
    start(): this;
    /**
     * Add animations which has to be executed subsequently
     * @param   animations  Subsequent Animation or Array of them
     * @return           Object itself for fluent interface
     */
    addNextAnimations(animations: Animation | Array<Animation>): this;
    /**
     * Add and create animation which has to be executed subsequently
     * @param   values      Array of start and end animation values
     * @param   action      Function for handling of interframe modification
     * @return              new Animation
     */
    NextAnimation(values: Array<[number, number]>, action: AnimationFrameCallback, duration?: number): Animation;
    /**
     * Subscribe on current animation end event
     * @param action Event listener
     * @return       Token of the event listener
     */
    onAnimationEnd(action: (nextAnimation?: Animation) => void, token?: Token): Token;
    /**
     * Subscribe on every subsequent animations end event
     * @param action Event listener
     * @return       Token of the event listener
     */
    onEveryAnimationEnd(action: (nextAnimation?: Animation) => void, token?: Token): Token;
    /**
     * Subscribe on all subsequent animations end event
     * @param action Event listener
     * @return       Token of the event listener
     */
    onAllAnimationEnd(action: VoidFunction, token?: Token): Token;
    /**
     * Remove all listeners from Animation End Event
     * @return  Object itself for fluent interface
     */
    allOffAnimationEnd(): this;
    /**
     * Remove all listeners from Every Animation End Event
     * @return  Object itself for fluent interface
     */
    allOffEveryAnimationEnd(): this;
    /**
     * Remove all listeners from All Animation End Event
     * @return  Object itself for fluent interface
     */
    allOffAllAnimationEnd(): this;
    /**
     * Remove a listener from Animation End Event
     * @param   token   Token of the listener
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offAnimationEnd(token: Token): boolean;
    /**
     * Remove a listener from Every Animation End Event
     * @param   token   Token of the listener
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offEveryAnimationEnd(token: Token): boolean;
    /**
     * Remove a listener from All Animation End Event
     * @param   token   Token of the listener
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offAllAnimationEnd(token: Token): boolean;
    /**
     * Finish current animation and start the next one on the sequence
     * @param   emitEvents   Flag that tells whether the function should emit any events
     * @return  Future animations or undefined
     */
    finish(emitEvents?: boolean): Animation | undefined;
    /**
     * Finish all animations
     * @param   emitEvents   Flag that tells whether the function should emit any events
     */
    finishAll(emitEvents?: boolean): void;
    /**
     * Get is animation over and there are no queued animations
     */
    isOver: () => boolean;
    /**
     * Get final value of queued animations
     * @returns Final values of the animations
     */
    getFinalValues(): number[];
    /**
     * Get time until all queued animations will finish
     */
    getTimeUntilFinish(): number;
}
/**
 * Type of Animation Factory
 * @param   values          Array of start and end animation values
 * @param   action          Function for handling of interframe modification
 * @param   customDuration  Override default duration of animation
 */
export declare type AnimationFactory = (values: Array<[number, number]>, action: AnimationFrameCallback, customDuration?: number) => Animation;
/**
 * Animator factory.
 *
 * **Unpolished API, usage can be copied from Examples set but it is not further encouraged**.
 * @param afterUpdate   After all animation update callback
 * @param fps           Desirable frame rate for all animations (Limited to around 60fps by browser)
 */
export declare const Animator: (afterUpdate: () => void, fps?: number) => (duration?: number | undefined, easing?: AnimationEasing | undefined) => AnimationFactory;
/**
 * Interface for enabling powerful application specific optimizations if input data follows a *specific pattern*.
 *
 * It is strongly recommended to utilize data patterns whenever possible.
 * The resulting performance can be 10 or even 100 times better when compared to not using data patterns.
 *
 * **When using this flag, it is the users responsibility to ensure that the supplied data abides by the promised pattern**.
 * Invalid input data can result in rendering artifacts or data not being rendered.
 *
 * **Example usage:**
 *
 * ```typescript
 *  // Example 1, Line Chart with timestamp X values that come directly from a sensor and have some randomness.
 *  // => 'ProgressiveX' can be used
 *  ChartXY.addLineSeries({
 *      dataPattern: {
 *          // pattern: 'ProgressiveX' => Each consecutive data point has increased X coordinate.
 *          pattern: 'ProgressiveX',
 *          // regularProgressiveStep: false => The X step between each consecutive data point is not regular.
 *          regularProgressiveStep: false
 *      }
 *  })
 * ```
 *
 * ```typescript
 *  // Example 2, Line Chart with timestamp X values that always progress by exactly 1 minute (60000 ms).
 *  // => 'ProgressiveX' + regularProgressiveStep can be used
 *  ChartXY.addLineSeries({
 *      dataPattern: {
 *          // pattern: 'ProgressiveX' => Each consecutive data point has increased X coordinate.
 *          pattern: 'ProgressiveX',
 *          // regularProgressiveStep: true => The X step between each consecutive data point is regular (for example, always `1.0`).
 *          regularProgressiveStep: true
 *      }
 *  })
 * ```
 */
export interface DataPattern {
    /**
     * Data pattern selection from a collection of preset options.
     *
     * `'ProgressiveX'` = every data points X value is **higher** than the previous ones X value.
     *
     * `'ProgressiveY'` = every data points Y value is **higher** than the previous ones Y value.
     *
     * `'RegressiveX'` = every data points X value is **lower** than the previous ones X value.
     *
     * `'RegressiveY'` = every data points X value is **lower** than the previous ones Y value.
     */
    pattern: 'ProgressiveX' | 'ProgressiveY' | 'RegressiveX' | 'RegressiveY';
    /**
     * Optional flag that can be used to indicate that the input data points will always progress by a static amount.
     * This is used in conjuction with a Progressive or Regressive `pattern`.
     *
     * For example, if `pattern: 'ProgressiveX'`, and the step between two consecutive data points is always `X = 1`, then this can be set to `regularProgressiveStep: true`.
     *
     * Enabling the `regularProgressiveStep` option when eligible can lead to increased performance,
     * but it is not a very significant difference.
     *
     * When enabled, invalid input data can result in rendering artifacts or data not being rendered.
     * If you see rendering errors, try setting this to `false`, or make sure that your data is indeed "regular progressive":
     *
     * - For `pattern: 'ProgressiveX' or 'RegressiveX'`, ensure that X step between each data point is always the same.
     * - For `pattern: 'ProgressiveY' or 'RegressiveY'`, ensure that Y step between each data point is always the same.
     */
    regularProgressiveStep?: boolean;
    /**
     * Optional flag that can be used to disable automatic grouping of progressive data that is packed **very** tightly together.
     *
     * Even if data grouping is enabled, data will be automatically displayed according to the active zoom level so that the data looks accurate at all times.
     *
     * Set to `true` or omit for maximum performance.
     */
    allowDataGrouping?: boolean;
}
/**
 * Flag that indicates a certain type of application in the context of a single SHAPE.
 * Used for enabling application specific valuable optimizations.
 * Some of them are supplied by users, while some are selected internally.
 *
 * @hidden
 */
export declare type InternalApplicationFlag = 'ApplicationType' | 'DataPattern';
/**
 * Type map for arguments that can be are with each ApplicationFlag.
 *
 * @hidden
 */
export declare type InternalApplicationFlagArgs = {
    ApplicationType: {
        /**
         * Type of application shape is used for (as in for rendering user series, or some small UI shape, or user managed UI shape).
         */
        type: 'UserSeries' | 'InternalUI';
    };
    DataPattern: {
        /**
         * Distinct data pattern identification.
         */
        pattern: 'ProgressiveX' | 'ProgressiveY' | 'RegressiveX' | 'RegressiveY';
        /**
         * Used in conjuction with 'Progressive' patterns, if true then the STEP between data points values on the progressive plane can be assumed to
         * always be the same.
         */
        regularProgressiveStep?: boolean;
        /**
         * Optional flag that can be used to disable automatic grouping of progressive data that is packed **very** tightly together.
         *
         * Even if data grouping is enabled, data will be automatically displayed according to the active zoom level so that the data looks accurate at all times.
         */
        allowDataGrouping?: boolean;
    };
};
/**
 * @hidden
 */
export declare type InternalApplicationFlagPlusArgs<Flag extends InternalApplicationFlag = InternalApplicationFlag> = {
    type: Flag;
    args: InternalApplicationFlagArgs[Flag];
};
/**
 * Interface that can be used to configure rendering Engine of LCJS *charts* and *dashboards*.
 *
 * **Commonly used properties:**
 *
 * - [container]([[FitEngineToDiv.container]]): Specify DOM container for chart.
 *
 * **Example usage:**
 *
 * ```typescript
 *  // Example 1, create chart without specifying DOM container. LCJS will automatically append a <div> in the document.
 *  // Recommended for testing, mainly.
 *  const chart = LightningChart.ChartXY({})
 * ```
 *
 * ```typescript
 *  // Example 2, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
 *  const chart = LightningChart.ChartXY({
 *      // Argument can be either *element id* or actual reference to the HTML element.
 *      container: 'my-chart-div'
 *  })
 * ```
 */
export declare type EngineOptions = EngineSettings & (FitEngineToDiv | DimensionalEngineSize);
/**
 * Interface specifies settings for Engine.
 */
export interface EngineSettings {
    /**
     * Max FPS (frames-per-second).
     * Setting this will postpone rendering events that would otherwise happen, if it would result in FPS higher than the value.
     *
     * NOTE: This property can't be used to accurately specify actual FPS as it is dictated by the browser. The purpose for 'maxFps' is
     * to limit unnecessary rendering loads where they are not needed.
     */
    readonly maxFps?: number;
    /**
     * Set preference for anti-aliasing.
     *
     * If set to true or undefined and browser supports anti-aliasing then the chart will be anti-aliased. If set to false or browser
     * doesn't support anti-aliasing then the chart will not be anti-aliased.
     */
    readonly antialias?: boolean;
    /**
     * Set preference for high quality line anti-aliasing.
     *
     * If set to true or undefined and browser supports OES_standard_derivatives or WebGL2 then the non-primitive lines (thickness !== -1) will be anti-aliased. If set to false or browser
     * doesn't support the OES_standard_derivatives extension or WebGl2 then the lines will not be anti-aliased with high quality but the line might me anti-aliased with default hardware anti-aliasing.
     *
     * Setting [[EngineSettings.antialias]] to `false` will also disable line anti-aliasing.
     */
    readonly lineAntiAlias?: boolean;
    /**
     * Set device pixel ratio.
     *
     * This ratio is used to support high DPI devices. This should be set to true when the meta tag "viewport"
     * has been set to "width=device-width" and you want to let the chart automatically determine the device pixel ratio to use.
     * ```html
     * <meta name="viewport" content="width=device-width, initial-scale=1.0">
     * ```
     *
     * Set this to a specific number if you want to use a specific device pixel ratio.
     *
     * By default, device pixel ratio of **1** will be used.
     *
     * If this option is not specified the ratio will be automatically decided based on the existence of the viewport meta tag
     * and the content of the tag if found.
     */
    readonly devicePixelRatio?: boolean | number;
    /**
     * *Color theme* for the component.
     *
     * A collection of default implementations can be accessed by [[Themes]].
     *
     * ```typescript
     *  // Example, specify color theme of chart.
     *  const chart = LightningChart.ChartXY({
     *      theme: Themes.light
     *  })
     * ```
     */
    readonly theme?: Theme;
    /**
     * Pass instructions regarding WebGL (rendering engine framework).
     */
    readonly webgl?: {
        /**
         * Force specific WebGL version to be used.
         *
         * LightningChart JS supports WebGL versions 2 and 1.
         * WebGL 2 is used when available (better performance).
         *
         * If a specific version is selected, then it is always used, or if it is not available then the chart will crash.
         * This can be useful for debugging a specific WebGL version.
         */
        version?: 'webgl1' | 'webgl2';
    };
}
/**
 * Interface specifies that Engine should not think about its own size and simply fit itself into
 * an existing element on the document, which should be created by user.
 */
export interface FitEngineToDiv {
    /**
     * The DOM Element or its ID that will contain the chart.
     * If there is no such element found, the chart will not work.
     *
     * If nothing was provided, LCJS will automatically append a new DIV element on the document for the chart.
     *
     * **Resizing chart**:
     *
     * When the chart is inside a container managed by user, manual trigger of chart resize is required:
     *
     * ```js
     *  // Example syntax, trigger chart resize on user event.
     *  myResizeEventCallback(() => {
     *      // Trigger chart resize manually.
     *      chart.engine.layout()
     *  })
     * ```
     *
     * For more information, see [[PublicEngine]].
     */
    readonly container?: HTMLDivElement | string;
}
/**
 * Check if element is of the FitEngineToDiv interface.
 * @param element Element to check
 * @hidden
 */
export declare const _isFitEngineToDiv: (element?: (EngineSettings & FitEngineToDiv) | (EngineSettings & DimensionalEngineSize) | undefined) => element is FitEngineToDiv;
/**
 * Interface specifies individual sizes for each dimension - width and height.
 */
export interface DimensionalEngineSize {
    /**
     * Specifies width of engine.
     */
    readonly width?: EngineDimension;
    /**
     * Specifies height of engine.
     */
    readonly height?: EngineDimension;
}
/**
 * Type of dimension for engine; can be a tuple of boundaries, a single static dimension or undefined for container size.
 * When using a tuple to specify boundaries [min, max], actual size for engine will be the size of its container clamped to the specified
 * pixel boundaries. Any of the values inside the tuple can be undefined.
 * Using a single number will set a static size for engine dimension, meaning no resizing of engine will take effect.
 */
export declare type EngineDimension = [number | undefined, number | undefined] | undefined | number;
/**
 * Object that represents a range of values.
 */
export interface FormattingRange {
    /**
     * Get first value on range.
     *
     * This can be higher than the *end* value, for example, in the case of a *inverted Axis*.
     * @return  Number
     */
    getInnerStart(): number;
    /**
     * Get final value on range.
     *
     * This can be smaller than the *start* value, for example, in the case of a *inverted Axis*.
     * @return  Number
     */
    getInnerEnd(): number;
}
/**
 * Type definition for a *pure* *formatting function*.
 *
 * The formatter is supplied a numeric value, and it formats it into a *string*, that can be displayed
 * on an *Axis tick*, for example.
 * @param   value           Numeric value.
 * @param   range           Object that represents the possible range for *value*.
 *                          For example, the start-end range of an *Axis*.
 * @return                  Value formated as string
 */
export declare type FormattingFunction = (value: number, range: FormattingRange, locale?: string) => string;
/**
 * Enum-like object for implementations of default Formatting functions.
 */
export declare const FormattingFunctions: {
    /**
     * Formats a number.
     * @param   value           Value on range to format
     * @param   range           FormatingRange
     * @return                  Value formated as string
     */
    Numeric: (value: number, range: FormattingRange) => string;
    /**
     * Formats a number by range-dependant rounding and usage of units.
     * @param   value           Value on range to format
     * @param   range           FormatingRange
     * @return                  Value formated as string with units
     */
    NumericUnits: (value: number, range: FormattingRange) => string;
};
/**
 * Datastructure with generic X and Y properties.
 */
export interface Vec2<T> {
    readonly x: T;
    readonly y: T;
}
/**
 * Type definition of a generic 3-dimensional Vector datastructure.
 */
export interface Vec3<T> {
    readonly x: T;
    readonly y: T;
    readonly z: T;
}
/**
 * Interface for a immutable data-structure which represents a data point in XY charts.
 */
export interface Point {
    /**
     * Location in X-dimension.
     */
    readonly x: number;
    /**
     * Location in Y-dimension.
     */
    readonly y: number;
}
/**
 * Interface for a mutable data-structure which represents a 2-dimensional location.
 */
export interface MPoint {
    /**
     * Location in X-dimension.
     */
    x: number;
    /**
     * Location in Y-dimension.
     */
    y: number;
}
/**
 * Interface for immutable data-structure which contains a color property.
 *
 * Can be used for individual data point coloring when styled with [[IndividualPointFill]].
 *
 * For some series types, individual data point coloring might have to be explicitly enabled when the series is created.
 * Refer to series documentation for more detailed information.
 */
export interface ColorValue {
    /**
     * Data point color.
     *
     * Can be used for individual data point coloring when styled with [[IndividualPointFill]].
     *
     * For some series types, individual data point coloring might have to be explicitly enabled when the series is created.
     * Refer to series documentation for more detailed information.
     */
    readonly color?: Color;
}
/**
 * Interface for a data point that contains an associated numeric data value.
 *
 * Can be used for dynamic per data point coloring when associated with a Color lookup table [[LUT]].
 *
 * For some series types, dynamic data point coloring might have to be explicitly enabled when the series is created.
 * Refer to series documentation for more detailed information.
 */
export interface DataValue {
    /**
     * Numeric value associated with the data point.
     *
     * Can be used for dynamic per data point coloring when associated with a Color lookup table [[LUT]].
     *
     * For some series types, dynamic data point coloring might have to be explicitly enabled when the series is created.
     * Refer to series documentation for more detailed information.
     */
    readonly value?: number;
}
/**
 * Interface for a data point that contains an associated size property.
 *
 * Can be used for individual configuration of data points size.
 *
 * For some series types, individually sized data points might have to be explicitly enabled when the series is created.
 * Refer to series documentation for more detailed information.
 */
export interface SizeValue {
    /**
     * Numeric size associated with the data point.
     *
     * Can be used for individual configuration of data points size.
     *
     * For some series types, individually sized data points might have to be explicitly enabled when the series is created.
     * Refer to series documentation for more detailed information.
     */
    readonly size?: number;
}
/**
 * Interface for a data point that contains an associated rotation property.
 *
 * Can be used for individual configuration of data points rotation.
 *
 * For some series types, individually rotated data points might have to be explicitly enabled when the series is created.
 * Refer to series documentation for more detailed information.
 */
export interface RotationValue {
    /**
     * Data point rotation as radians.
     *
     * ```typescript
     *  // A degree rotation can be easily translated to radians with the below formula.
     *  rotation: rotationDeg * Math.PI / 180
     * ```
     *
     * Can be used for individual configuration of data points rotation.
     *
     * For some series types, individually rotated data points might have to be explicitly enabled when the series is created.
     * Refer to series documentation for more detailed information.
     */
    readonly rotation?: number;
}
/**
 * Interface for mutable data-structure which contains a color.
 */
export interface MColorValue {
    /**
     * Color for the fill.
     */
    color: Color;
}
/**
 * Interface for immutable data-structure which represents a 2-dimensional location and an associated Color.
 *
 * This can be used for Point-based series for coloring each point individually, when combined with usage of IndividualPointFill-style.
 */
export interface ColorPoint extends Point, ColorValue {
}
export interface SizePoint extends Point {
    size: number;
}
export interface RotationPoint extends Point {
    /**
     * Point rotation as radians.
     */
    rotation: number;
}
/**
 * Interface for a mutable data-structure which represents a 2-dimensional location and an associated Color.
 *
 * This can be used for Point-based series for coloring each point individually, when combined with usage of IndividualPointFill-style.
 */
export interface MColorPoint extends MPoint, MColorValue {
}
/**
 * Interface for a data-structure which represents a 2-dimensional location, but with one of the planes
 * having two values instead of just one to create an area in the given location.
 *
 * Used to supply points to AreaRangeSeries.
 */
export interface AreaPoint {
    /**
     * Position of Point.
     */
    readonly position: number;
    /**
     * High value of Point in the given position.
     */
    readonly high: number;
    /**
     * Low value of Point in the given position.
     */
    readonly low: number;
}
/**
 * Interface for a data-structure which represents a 3-dimensional location.
 *
 * **Required properties:**
 *
 * - [[Coord3D.x]] | coordinate along X Axis.
 * - [[Coord3D.y]] | coordinate along Y Axis.
 * - [[Coord3D.z]] | coordinate along Z Axis.
 */
export interface Coord3D {
    /**
     * Location in X-dimension.
     */
    readonly x: number;
    /**
     * Location in Y-dimension.
     */
    readonly y: number;
    /**
     * Location in Z-dimension.
     */
    readonly z: number;
}
/**
 * This type is only used internally at the moment.
 *
 * It is XY point with optional `value`, `size`, etc.. properties.
 *
 * Notable that in 3D this would be `Point3D` (user type), but not sure which is the way to go.
 *
 * @hidden
 */
export declare type DataPointXY = Point & ColorValue & SizeValue & RotationValue & DataValue;
/**
 * Interface for a data-structure which represents a 3-dimensional location.
 *
 * **Required properties:**
 *
 * - [[Point3D.x]] | coordinate along X Axis.
 * - [[Point3D.y]] | coordinate along Y Axis.
 * - [[Point3D.z]] | coordinate along Z Axis.
 *
 * **Optional properties:**
 *
 * - [[Point3D.color]] | data point color.
 * - [[Point3D.size]] | data point size.
 * - [[Point3D.value]] | data point value for dynamic coloring.
 *
 * ```ts
 *  // Example syntax,
 *  PointSeries3D.add([
 *      {
 *          x: 0,
 *          y: 0,
 *          z: 0,
 *          // `color` can be used for individual point coloring.
 *          color: ColorRGBA(255, 0, 0),
 *          // `size` can be used for individual point sizing.
 *          size: 5.0,
 *          // `value` can be used for dynamic point coloring.
 *          value: 160.0,
 *      }
 *  ])
 * ```
 */
export interface Point3D {
    /**
     * Location in X-dimension.
     */
    readonly x: number;
    /**
     * Location in Y-dimension.
     */
    readonly y: number;
    /**
     * Location in Z-dimension.
     */
    readonly z: number;
    /**
     * Optional Color associated with the data point.
     *
     * Can be used for individual data point coloring when styled with [[IndividualPointFill]].
     *
     * For some series types, individual data point coloring might have to be explicitly enabled when the series is created.
     * Refer to series documentation for more detailed information.
     */
    readonly color?: Color;
    /**
     * Optional Size associated with the data point.
     *
     * Can be used for individual configuration of data points size.
     *
     * For some series types, individually sized data points might have to be explicitly enabled when the series is created.
     * Refer to series documentation for more detailed information.
     */
    readonly size?: number;
    /**
     * Optional Value associated with the data point.
     *
     * Can be used for dynamic per data point coloring when associated with a Color lookup table [[LUT]].
     *
     * For some series types, dynamic data point coloring might have to be explicitly enabled when the series is created.
     * Refer to series documentation for more detailed information.
     */
    readonly value?: number;
    /**
     * Optional Size on X Axis associated with the data point.
     *
     * Can be used for individual configuration of data points size along Axis dimensions.
     *
     * For some series types, individually sized data points might have to be explicitly enabled when the series is created.
     * Refer to series documentation for more detailed information.
     */
    readonly sizeAxisX?: number;
    /**
     * Optional Size on Y Axis associated with the data point.
     *
     * Can be used for individual configuration of data points size along Axis dimensions.
     *
     * For some series types, individually sized data points might have to be explicitly enabled when the series is created.
     * Refer to series documentation for more detailed information.
     */
    readonly sizeAxisY?: number;
    /**
     * Optional Size on Z Axis associated with the data point.
     *
     * Can be used for individual configuration of data points size along Axis dimensions.
     *
     * For some series types, individually sized data points might have to be explicitly enabled when the series is created.
     * Refer to series documentation for more detailed information.
     */
    readonly sizeAxisZ?: number;
}
/**
 * Interface for a immutable data-structure which defines a location along the XZ plane, without any Y information.
 */
export interface PointXZ {
    /**
     * Location in X-dimension.
     */
    readonly x: number;
    /**
     * Location in Z-dimension.
     */
    readonly z: number;
}
/**
 * Interface for immutable data-structure which represents an intensity value in the situation.
 * @hidden
 */
export interface IntensityValue {
    /**
     * Intensity value in the situation.
     */
    readonly intensity: number;
}
/**
 * Interface for mutable data-structure which represents an intensity value in the situation.
 */
export interface MIntensityValue {
    /**
     * Intensity value in the situation.
     */
    intensity: number;
}
/**
 * Interface for mutable data-structure which represents a 2-dimensional location and an associated Intensity value.
 *
 * This can be used for Point-based series for coloring each point individually, when combined with usage of IndividualPointFill-style.
 */
export interface MIntensityPoint extends MPoint, MIntensityValue {
}
/**
 * Interface for mutable data-structure which represents a 2-dimensional location and an associated Color and Intensity value.
 * This structure is used for IntensityMesh series for modification of the Mesh topology, coloring, and paletting.
 * A cell can be colored either:
 * - with a provided color for coloring each cell individually, when combined with usage of IndividualPointFill-style.
 * - with a color fetched from value range palette based on *intensity* value, when combined with usage of PalettedFill-style.
 */
export interface MIntensityColorPoint extends MColorPoint, MIntensityValue {
}
/**
 * Interface for mutable data-structure which represents a Color and Intensity value in the situation.
 * This structure is used for IntensityGrid series for coloring and paletting only.
 * A cell can be colored either:
 * - with a provided color for coloring each cell individually, when combined with usage of IndividualPointFill-style.
 * - with a color fetched from value range palette based on *intensity* value, when combined with usage of PalettedFill-style.
 */
export interface MIntensityColorValue extends MColorValue, MIntensityValue {
}
/**
 * @property columns    Horizontal resolution of the Heatmap.
 * @property rows       Vertical resolution of the Heatmap.
 * @property start      Starting point position of the Heatmap.
 * @property end        End point position of the Heatmap.
 * @property pixelated  Data definition per cell / per vertex of the Heatmap.
 */
export interface IntensityOptions {
    /**
     * Horizontal resolution of the Heatmap.
     */
    columns: number;
    /**
     * Vertical resolution of the Heatmap.
     */
    rows: number;
    /**
     * Starting point position of the Heatmap.
     */
    start: Point;
    /**
     * End point position of the Heatmap.
     */
    end: Point;
    /**
     * Data definition per cell / per vertex of the Heatmap.
     *
     * | Value                     | Desired result                        |
     * | :------------------------ | :------------------------------------ |
     * | *pixelate:* ***true***    | Intensity / Color applies per cell    |
     * | *pixelate:* ***false***   | Intensity / Color applies per vertex  |
     */
    pixelate: boolean;
}
/**
 * Interface describes the range interval between two numeric values.
 */
export interface NumericInterval {
    /**
     * Start interval.
     */
    start: number;
    /**
     * End interval.
     */
    end: number;
}
/**
 * Interface describes the range interval.
 * Contains information about the staring index and how many elements in the group.
 */
export interface NumericGroup {
    /**
     * Start interval.
     */
    start: number;
    /**
     * Amount of items.
     */
    count: number;
}
/**
 * Interface for storing the information about grid resolution range
 * e.g. start and end for columns and rows.
 */
export interface GridRangeOptions {
    /**
     * Column range. Start column number ... End column number.
     */
    column: NumericInterval;
    /**
     * Row range. Start row number ... End row number.
     */
    row: NumericInterval;
}
/**
 *
 * @hidden
 */
export interface IntensityUpdateEventMap<Geometry> {
    color: Matrix<Color>;
    value: Matrix<number>;
    geometry: Matrix<Geometry>;
    y: Matrix<number>;
}
/**
 * Generic multi-dimensional array of specified type.
 */
export declare type Matrix<T> = Array<Array<T>>;
export declare type UpdateColorCallback = (row: number, column: number, current?: IntensityValue & Partial<ColorValue>) => Color | undefined;
export declare type UpdateValueCallback = (row: number, column: number, current?: IntensityValue) => number | undefined;
export declare type UpdateYCallback = (row: number, column: number, current?: number) => number;
export declare type UpdateGeometryCallback<T> = (row: number, column: number, current: T) => T | undefined;
/**
 * Interface for a data-structure which represents a measurement of four sides.
 * Has number properties for:
 * - left
 * - top
 * - right
 * - bottom
 *
 * This data-structure is mainly used for specifying Chart paddings and UIElement paddings/margins.
 *
 * Duplicate of Padding.
 */
export interface Margin {
    /**
     * Left value.
     */
    readonly left: number;
    /**
     * Top value.
     */
    readonly top: number;
    /**
     * Right value.
     */
    readonly right: number;
    /**
     * Bottom value.
     */
    readonly bottom: number;
}
/**
 * Interface for a data-structure which represents a measurement of four sides.
 * Has number properties for:
 * - left
 * - top
 * - right
 * - bottom
 *
 * This data-structure is mainly used for specifying Chart paddings and UIElement paddings/margins.
 *
 * Duplicate of Margin.
 */
export declare type Padding = Margin;
/**
 * Interface that just specifies the ability to remove shapes.
 * @hidden
 */
export interface Removable {
    /**
     * Remove the component from rendering.
     *
     * If the Component supports it, this can be reverted with **restore()** method.
     * @return  Object itself for fluent interface.
     */
    dispose(): this;
    /**
     * @return  True if the component is currently disposed, and thus not being rendered. If the Component supports it, this can be reverted with **restore()** method.
     */
    isDisposed(): boolean;
}
/**
 * Interface that just specifies the ability to remove and restore shapes.
 * @hidden
 */
export interface Disposable extends Removable {
    /**
     * After the Components **dispose()** method has been called, removing it from rendering, *restore()* can be used to return it back.
     * @return  Object itself for fluent interface.
     */
    restore(): this;
}
/**
 * Decoration for normal number. Indicates that the value should be interpreted as amount of pixels.
 * @hidden
 */
export declare type pixel = number;
/**
 * Type of a mutator function for abstract object.
 * Function provides functionality for modifying an object.
 * @param   object  Object to mutate
 */
export declare type Mutator<T> = (object: T) => void;
/**
 * Type of a mutator function for abstract, immutable object.
 * Function provides functionality for creating a new object based on an existing one.
 * @param   object  Reference object
 * @return          New object
 */
export declare type ImmutableMutator<T, B = T> = (object: T) => B;
/**
 * Enum for selecting shape of points for Point-based *Series*.
 * Supported by:
 * - [[PointSeries]]
 * - [[PointLineSeries]]
 * - [[SpiderSeries]]
 *
 * This must be specified when the *Series* is created, and can't be changed afterwards.
 */
export declare enum PointShape {
    /**
     * Square shape.
     */
    Square = 0,
    /**
     * Circle shape.
     */
    Circle = 1,
    /**
     * Triangle shape.
     */
    Triangle = 2
}
/**
 * Readonly configuration parameters that apply to all components.
 * @hidden
 */
export interface CommonChartOptions {
    /**
     * *Color theme* for the component.
     *
     * A collection of default implementations can be accessed by [[Themes]].
     *
     * ```typescript
     *  // Example, specify color theme of chart.
     *  const chart = LightningChart.ChartXY({
     *      theme: Themes.light
     *  })
     * ```
     */
    theme?: Theme;
    /**
     * Convenience flag that can be used to disable all animations in a component.
     */
    disableAnimations?: boolean;
}
/**
 * Type definition for different configurations of 3D culling.
 *
 * Culling means skipping drawing of specific geometry parts, based on its orientation.
 *
 * `'disabled'` -> full geometry is drawn.
 *
 * `'cull-back'` -> the behind of geometry is **not** drawn.
 *
 * `'cull-front'` -> the front of geometry is **not** drawn.
 */
export declare type CullMode3D = 'disabled' | 'cull-back' | 'cull-front';
/**
 * Description of intensity interpolation mode for Intensity Heatmap and Surface series.
 *
 * Use with `setIntensityInterpolation` methods.
 *
 * `'disabled'`: Interpolation disabled; draw data exactly as it is.
 *
 * `'bilinear'`: Each PIXEL is colored based on an Bi-linearly interpolated intensity value based on the 4 closest real intensity values.
 */
export declare type IntensityInterpolationMode = 'disabled' | 'bilinear';
/**
 * Type union of all JavaScript typed arrays.
 *
 * Read more [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays)
 */
export declare type TypedArray = Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array;
/**
 * Type of an abstract Palette function.
 * NOTE: It is common for applications dealing with Palettes to assume that they are continuous,
 * meaning that when supplied an overflowing index, it will return loop back to start.
 * @param   index   Index of item to pick from Palette
 * @return          Generated item
 */
export declare type Palette<T> = (index: number) => T;
/**
 * Type of an abstract Palette factory.
 * @param   length  Length of Palette
 * @return          Palette of specified length
 */
export declare type PaletteFactory<T> = (length: number, color?: Color) => Palette<T>;
/**
 * Collection of default *Color* *PaletteFactories*.
 *
 * Items are mostly functions that take a single argument, *length*, and return a *Color* [[Palette]] of that given length.
 *
 * *Color* *Palettes* are functions that give a *Color* based on a given *index*.
 */
export declare const ColorPalettes: {
    warm: PaletteFactory<Color>;
    cold: PaletteFactory<Color>;
    fullSpectrum: PaletteFactory<Color>;
    reverseSpectrum: PaletteFactory<Color>;
    flatUI: PaletteFactory<Color>;
    arction: PaletteFactory<Color>;
    arctionWarm: PaletteFactory<Color>;
    sunset: PaletteFactory<Color>;
    dynamic: PaletteFactory<Color>;
    magenta: PaletteFactory<Color>;
    greyscale: PaletteFactory<Color>;
    frozen: PaletteFactory<Color>;
    retro: PaletteFactory<Color>;
    crayons: PaletteFactory<Color>;
    custom: PaletteFactory<Color>;
    sector: (start: number, end: number, saturation?: number, vibrance?: number) => PaletteFactory<Color>;
    auroraBorealis: PaletteFactory<Color>;
    blueSciFi: PaletteFactory<Color>;
    light: PaletteFactory<Color>;
    monochrome: PaletteFactory<Color>;
    night: PaletteFactory<Color>;
    sunset2: PaletteFactory<Color>;
};
/**
 * Type union of possible options for describing a 3D _color shading style_.
 *
 * Interacting with color shading styles is designed to be carried out via [[ColorShadingStyles]].
 */
export declare type ColorShadingStyle = SimpleShadingStyle | PhongShadingStyle;
/**
 * Simple color shading style.
 *
 * Colors each pixel exactly according to its material color.
 *
 * Colors are **not** affected by camera angle, lighting, etc.
 *
 * ```js
 *  // Example syntax, select simple color shading style.
 *  pointSeries3D.setColorShadingStyle(new ColorShadingStyles.Simple())
 * ```
 *
 * Color shading style is specified with [[Series3D.setColorShadingStyle]] method.
 *
 * _Simple color shading_ is really fast, which can be a crucial difference especially on low end devices, like laptops and mobile phones.
 */
export declare class SimpleShadingStyle {
    readonly type = "simple";
}
/**
 * Interface for configuration properties of [[PhongShadingStyle]].
 *
 * ```js
 *  // Example syntax, use Phong shading with specific configuration.
 *  pointSeries3D.setColorShadingStyle(new ColorShadingStyles.Phong({
 *      // Add specular reflection for "highlight" effect.
 *      specularReflection: 0.5,
 *      specularColor: ColorRGBA(255, 255, 255),
 *  }))
 * ```
 */
export interface PhongShadingStyleOptions {
    /**
     * Controls how much ambient light affects the color.
     *
     * Value ranges from 0 to 1, where higher values correspond to reflecting more.
     *
     * The impact of ambient color on a surface is also affected by [[ambientColor]] property.
     *
     * The default value is `1.0`.
     */
    ambientReflection: number;
    /**
     * Controls specular reflection strength.
     *
     * Describes how much the material reflects specular light.
     *
     * The impact of specular color on a surface is also affected by [[shininess]] and [[specularColor]] properties.
     *
     * Value ranges from 0 to 1, where higher values correspond to reflecting more.
     *
     * The default value is `0.1`.
     */
    specularReflection: number;
    /**
     * Controls how strongly the diffuse color is. Diffuse color is the color defined by user.
     *
     * Value ranges from 0 to 1, where higher values correspond to reflecting more.
     *
     * The default value is `1.0`.
     */
    diffuseReflection: number;
    /**
     * Ambient light color.
     *
     * Describes light that is present at all points of the surface, kind of like a _background light_.
     *
     * The impact of ambient color on a surface is also affected by [[ambientReflection]] property.
     *
     * The default setting is black.
     *
     * ```js
     *  // Example, white ambient light.
     *  ambientColor: ColorRGBA(255, 255, 255)
     * ```
     */
    ambientColor: Color;
    /**
     * Specular highlight color.
     *
     * Describes light that is reflected from a shiny surface.
     * Can be used to get a "shine" effect on surfaces.
     *
     * The impact of specular color on a surface is also affected by [[specularReflection]] and [[shininess]] properties.
     *
     * The default setting is white.
     *
     * ```js
     *  // Example, red specular light.
     *  specularColor: ColorRGBA(255, 0, 0)
     * ```
     */
    specularColor: Color;
    /**
     * Specular highlight shininess.
     *
     * Describes how _shiny_ the material surface is.
     *
     * The impact of specular color on a surface is also affected by [[specularReflection]] and [[specularColor]] properties.
     *
     * Value ranges from 1 to 64, where higher values correspond to being _exponentially_ **less** shiny.
     *
     * The default value is `32`.
     */
    shininess: number;
}
/**
 * _Phong_ color shading style.
 *
 * Phong shading supports ambient and specular lighting, greatly increasing depth perception
 * capabilities.
 *
 * With Phong shading enabled, the color of each pixel is affected by angle to camera, as well as the various available
 * Phong shading properties, like light colors and reflection values.
 *
 * ```js
 *  // Example syntax, use default Phong shading.
 *  pointSeries3D.setColorShadingStyle(new ColorShadingStyles.Phong())
 * ```
 *
 * ```js
 *  // Example syntax, use Phong shading with specific configuration.
 *  pointSeries3D.setColorShadingStyle(new ColorShadingStyles.Phong({
 *      // Add specular reflection for "highlight" effect.
 *      specularReflection: 0.5,
 *      specularColor: ColorRGBA(255, 255, 255),
 *  }))
 * ```
 *
 * Color shading style is specified with [[Series3D.setColorShadingStyle]] method.
 */
export declare class PhongShadingStyle implements PhongShadingStyleOptions {
    readonly type = "phong";
    /**
     * Controls how much ambient light affects the color.
     *
     * Value ranges from 0 to 1, where higher values correspond to reflecting more.
     *
     * The impact of ambient color on a surface is also affected by [[ambientColor]] property.
     *
     * The default value is `1.0`.
     */
    readonly ambientReflection: number;
    /**
     * Controls specular reflection strength.
     *
     * Describes how much the material reflects specular light.
     *
     * The impact of specular color on a surface is also affected by [[shininess]] and [[specularColor]] properties.
     *
     * Value ranges from 0 to 1, where higher values correspond to reflecting more.
     *
     * The default value is `0.1`.
     */
    readonly specularReflection: number;
    /**
     * Controls how strongly the diffuse color is. Diffuse color is the color defined by user.
     *
     * Value ranges from 0 to 1, where higher values correspond to reflecting more.
     *
     * The default value is `1.0`.
     */
    readonly diffuseReflection: number;
    /**
     * Ambient light color.
     *
     * Describes light that is present at all points of the surface, kind of like a _background light_.
     *
     * The impact of ambient color on a surface is also affected by [[ambientReflection]] property.
     *
     * The default setting is black.
     *
     * ```js
     *  // Example, white ambient light.
     *  ambientColor: ColorRGBA(255, 255, 255)
     * ```
     */
    readonly ambientColor: Color;
    /**
     * Specular highlight color.
     *
     * Describes light that is reflected from a shiny surface.
     * Can be used to get a "shine" effect on surfaces.
     *
     * The impact of specular color on a surface is also affected by [[specularReflection]] and [[shininess]] properties.
     *
     * The default setting is white.
     *
     * ```js
     *  // Example, red specular light.
     *  specularColor: ColorRGBA(255, 0, 0)
     * ```
     */
    readonly specularColor: Color;
    /**
     * Specular highlight shininess.
     *
     * Describes how _shiny_ the material surface is.
     *
     * The impact of specular color on a surface is also affected by [[specularReflection]] and [[specularColor]] properties.
     *
     * Value ranges from 1 to 64, where higher values correspond to being _exponentially_ **less** shiny.
     *
     * The default value is `32`.
     */
    readonly shininess: number;
    constructor(options?: Partial<PhongShadingStyleOptions> | undefined);
}
/**
 * Object with different options for 3D series _color shading style_.
 *
 * Color shading style is specified with [[Series3D.setColorShadingStyle]] method.
 *
 * ```js
 *  // Example syntax, select simple color shading style.
 *  pointSeries3D.setColorShadingStyle(new ColorShadingStyles.Simple())
 * ```
 */
export declare const ColorShadingStyles: {
    /**
     * Simple color shading style.
     *
     * Colors each pixel exactly according to its material color.
     *
     * Colors are **not** affected by camera angle, lighting, etc.
     *
     * ```js
     *  // Example syntax, select simple color shading style.
     *  pointSeries3D.setColorShadingStyle(new ColorShadingStyles.Simple())
     * ```
     *
     * _Simple color shading_ is really fast, which can be a crucial difference especially on low end devices, like laptops and mobile phones.
     */
    Simple: typeof SimpleShadingStyle;
    /**
     * _Phong_ color shading style.
     *
     * Phong shading supports ambient and specular lighting, greatly increasing depth perception
     * capabilities.
     *
     * With Phong shading enabled, the color of each pixel is affected by angle to camera, as well as the various available
     * Phong shading properties, like light colors and reflection values.
     *
     * ```js
     *  // Example syntax, use default Phong shading.
     *  pointSeries3D.setColorShadingStyle(new ColorShadingStyles.Phong())
     * ```
     *
     * ```js
     *  // Example syntax, use Phong shading with specific configuration.
     *  pointSeries3D.setColorShadingStyle(new ColorShadingStyles.Phong({
     *      // Add specular reflection for "highlight" effect.
     *      specularReflection: 0.5,
     *      specularColor: ColorRGBA(255, 255, 255),
     *  }))
     * ```
     */
    Phong: typeof PhongShadingStyle;
};
/**
 * Function for translating a `XY` coordinate between different *coordinate systems*.
 *
 * A *coordinate system* can be selected by a *scale* property of *chart*, or by specifying a pair of `Axis`.
 *
 * ```ts
 *  // Example 1, translate from percentage location in chart, to pixel location in chart.
 *  const pixelLocation = translatePoint(
 *      // percentage location within chart, where [0,0] = bottom left, and [100,100] = top right.
 *      { x: 10, y: 10 },
 *      chart.uiScale,
 *      chart.pixelScale
 *  )
 * ```
 *
 * ```ts
 *  // Example 2, translate axis coordinate to pixel location in chart.
 *  const pixelLocation = translatePoint(
 *      // axis coordinate.
 *      { x: 116.9, y: 26.4 },
 *      {
 *          x: chart.getDefaultAxisX(),
 *          y: chart.getDefaultAxisY(),
 *      },
 *      chart.pixelScale
 *  )
 *
 *  // NOTE: Translation from chart pixel coordinates to *document* is done using `engineLocation2Client` method.
 *  const pixelLocationDocument = chart.engine.engineLocation2Client(pixelLocation.x, pixelLocation.y)
 *  // `pixelLocationDocument` can now be used for absolute positioning HTML elements, or other such things...
 *
 * ```
 *
 * **Available chart coordinate systems:**
 *
 * Every LCJS chart class has two available *coordinate systems*:
 *
 * 1. `uiScale` | Percentage based coordinate system, where [0,0] = bottom left, and [100,100] = top right.
 * 2. `pixelScale` | Pixel based coordinate system, where [0,0] = bottom left.
 *
 * With `ChartXY`, *axes* can be also used (see example usage above).
 *
 * @param   value           `XY` coordinate.
 * @param   originScale     Source *coordinate system*.
 * @param   targetScale     Target *coordinate system*.
 * @return                  Coordinate that corresponds `value` on target *coordinate system*.
 */
export declare const translatePoint: <DataPoint extends Point>(value: DataPoint, originScale: ScaleXY | Vec2<Axis | ScaleXY>, targetScale: ScaleXY | Vec2<Axis | ScaleXY>) => DataPoint;
/**
 * @hidden
 */
export declare type CoordinateSystemDefinition3D = {
    id: 'world';
    chart: Chart3D;
} | {
    id: 'axes';
    chart: Chart3D;
};
/**
 * Function that translates a coordinate between different 3D coordinate systems.
 *
 * ```js
 *  // Example, translate coordinate from Chart3D Axes to World Space.
 *  const coordWorld = translatePoint3D(
 *      // Coordinate on Axes.
 *      { x: 10, y: 5, z: 25 },
 *      // Source coordinate system.
 *      chart3D.axes,
 *      // Target coordinate system.
 *      chart3D.world
 *  )
 * ```
 *
 * @param   coordinate                  Coordinate to translate.
 * @param   originCoordinateSystem      Coordinate system of `coordinate`.
 * @param   targetCoordinateSystem      Target coordinate system.
 * @return                              `coordinate` translated to `targetCoordinateSystem`.
 */
export declare const translatePoint3D: <DataPoint extends Coord3D>(coordinate: DataPoint, originCoordinateSystem: CoordinateSystemDefinition3D, targetCoordinateSystem: CoordinateSystemDefinition3D) => DataPoint;
/**
 * Factory for creating a SolidFill palette.
 * @param  colorPalettes   Collection of default colors from PaletteFactory
 * @param  amount          Amount of colors in the palette
 * @return                 A new SolidFill palette
 */
export declare const SolidFillPalette: (colorPalettes: PaletteFactory<Color>, amount: number, color?: Color | undefined) => Palette<FillStyle>;
/**
 * Factory for creating a RadialGradientFill palette.
 * @param  colorPalettes   Collection of default colors from PaletteFactory
 * @param  amount          Amount of colors in the palette
 * @return                 A new RadialGradientFill palette
 */
export declare const RadialGradientFillPalette: (colorPalettes: PaletteFactory<Color>, amount: number, color?: Color | undefined) => Palette<FillStyle>;
/**
 * Factory for creating a LinearGradientFill palette.
 * @param    colorPalettes   Collection of default colors from PaletteFactory
 * @param    amount          Amount of colors in the palette
 * @param    angle           Angle for the Linear Gradient. Set to 90 degrees by default.
 * @return                   A new LinearGradientFill palette
 */
export declare const LinearGradientFillPalette: (colorPalettes: PaletteFactory<Color>, amount: number, angle?: number | undefined, color?: Color | undefined) => Palette<FillStyle>;
/**
 * Convenience function for synchronizing the intervals of `n` amount of ´Axis´.
 *
 * ```ts
 *  // Example, usage syntax.
 *  synchronizeAxisIntervals(
 *      chart1.getDefaultAxisX(),
 *      // Any number of Axis can be passed one after another.
 *      chart2.getDefaultAxisX()
 *  )
 * ```
 *
 * `synchronizeAxisIntervals` uses [[Axis.onScaleChange]] and [[Axis.setInterval]] methods internally for its logic.
 *
 * The return value can be used for removing the synchronization logic at any time.
 *
 * @param   axes    List of Axis to synchronize. These can be Axis from [[ChartXY]], [[Chart3D]] or [[PolarChart]].
 * @return          Handle for removing created side effects.
 */
export declare const synchronizeAxisIntervals: (...axes: (Axis | Axis3D | PolarAxisAmplitude)[]) => SynchronizeAxisIntervalsHandle;
/**
 * Handle returned by [[synchronizeAxisIntervals]] for removing created side effects.
 *
 * ```ts
 *  // Example usage.
 *  // Synchronize Axis intervals.
 *  const handle = synchronizeAxisIntervals(axis1, axis2)
 *
 *  // When you want to remove the synchronization logic, call handle.remove.
 *  handle.remove()
 * ```
 */
export declare type SynchronizeAxisIntervalsHandle = {
    /**
     * Remove side effects created by [[synchronizeAxisIntervals]],
     * removing the synchronization logic.
     *
     * ```ts
     *  // Example syntax,
     *  SynchronizeAxisIntervalsHandle.remove()
     * ```
     */
    remove: () => void;
};
/**
 * Collection of math utilities for numeric Vec3s.
 */
export declare const vec3Utils: {
    /**
     * Add a single value to all values of a 3-dimensional Vector.
     * @param v     3-dimensional Vector to add to.
     * @param value Value to add to all 3-dimensional Vector's values.
     * @return      Result as a new 3-dimensional Vector as 3D Point.
     */
    add(v: Point3D, value: number): Point3D;
    /**
     * Add two or more 3-dimensional Vectors together.
     * @param   v1  First 3-dimensional Vector to add to.
     * @param   v2  One or multiple 3-dimensional Vectors to add.
     * @return      New 3-dimensional Vector as 3D Point.
     */
    addVec(v1: Point3D, ...v2: Point3D[]): Point3D;
    /**
     * Subtract a single value from all values of a 3-dimensional Vector.
     * @param v     3-dimensional Vector to subtract from.
     * @param value Value to subtract from all 3-dimensional Vector's values.
     * @return      Result as a new 3-dimensional Vector as 3D Point.
     */
    subtract(v: Point3D, value: number): Point3D;
    /**
     * Subtract one or more 3-dimensional Vector from another.
     * @param   v1  3-dimensional Vector to subtract from.
     * @param   v2  One or multiple 3-dimensional Vectors to subtract.
     * @return      Result as a new 3-dimensional Vector as 3D Point.
     */
    subtractVec(v1: Point3D, ...v2: Point3D[]): Point3D;
    /**
     * Multiply values of a 3-dimensional Vector by a single value.
     * @param   v           3-dimensional Vector to multiply.
     * @param   multiplier  Number to multiply the 3-dimensional Vectors values with.
     * @return              Result as a new 3-dimensional Vector as 3D Point.
     */
    multiply(v: Point3D, multiplier: number): Point3D;
    /**
     * Divide values of a 3-dimensional Vector by a single value.
     * @param v         3-dimensional Vector to divide.
     * @param divisor   Number to divide the 3-dimensional Vectors values with.
     * @return          Result as a new 3-dimensional Vector as 3D Point.
     */
    divide(v: Point3D, divisor: number): Point3D;
    /**
     * Multiply one 3-dimensional Vector with one or more 3-dimensional Vectors
     * in the order they were provided.
     * @param   v1  3-dimensional Vector.
     * @param   v2  One or multiple 3-dimensional Vectors to multiply with.
     * @return      Result as a new 3-dimensional Vector as 3D Point.
     */
    multiplyVec(v1: Point3D, ...v2: Point3D[]): Point3D;
    /**
     * Divide one 3-dimensional Vector with one or more 3-dimensional Vectors
     * in the order they were provided.
     * @param   v1  3-dimensional Vector to divide.
     * @param   v2  One or multiple 3-dimensional Vector to divide with.
     * @returns     Result as a new 3-dimensional Vector as 3D Point.
     */
    divideVec(v1: Point3D, ...v2: Point3D[]): Point3D;
    /**
     * Get the length of a 3-dimensional Vector.
     * @param   v   3-dimensional Vector.
     * @return      Length of a 3-dimensional Vector.
     */
    length(v: Point3D): number;
    /**
     * Get the normal of a 3-dimensional Vector.
     * @param   v   3-dimensional Vector.
     * @return      Normal as a 3-dimensional Vector.
     */
    normalize(v: Point3D): Point3D;
    /**
     * Get the dot product of two 3-dimensional Vectors.
     * @param v1 3-dimensional Vector.
     * @param v2 3-dimensional Vector.
     */
    dot(v1: Point3D, v2: Point3D): number;
    /**
     * Get the cross product of two 3-dimensional Vectors.
     * @param v1 Vector to compare towards
     * @param v2 Vector to compare with
     */
    cross(v1: Point3D, v2: Point3D): Point3D;
    /**
     * @returns     Radian angle between v1 and v2.
     */
    angle(v1: Point3D, v2: Point3D): number;
    /**
     * Rotate vector around another arbitrary axis, by amount 'theta' in radians.
     * @param   v       Vector to rotate
     * @param   axis    Vector of arbitrary rotation axis
     * @param   theta   Rotation amount in radians
     */
    rotateAroundAxis(v: Point3D, axis: Point3D, theta: number): Point3D;
    /**
     * Linear interpolation between two vectors and an arbitrary amount as %.
     * amount = 0 -> returns a
     * amount = 1 -> returns b
     * @param a         Vector a for interpolation
     * @param b         Vector b for interpolation
     * @param amount    Interpolation amount
     */
    lerp(a: Point3D, b: Point3D, amount: number): Point3D;
    /**
     * Check two vectors are equal.
     * @param a Vector a
     * @param b Vector b
     */
    equals(a: Point3D, b: Point3D): boolean;
    /**
     * Get vector as absolute.
     * @param v Vector to get absolute value of
     * @returns `{ x: Math.abs( v.x ), y: Math.abs( v.y ), z: Math.abs( v.z ) }`
     */
    abs(v: Point3D): Point3D;
    /**
     * Sign of Vector.
     * @param v     Vector.
     * @returns     `{ x: Math.sign( v.x ), y: Math.sign( v.y ), z: Math.sign( v.z ) }`
     */
    sign(v: Point3D): Point3D;
};
/**
 * Function for initializing the LightningChart library.
 *
 * Returns the main interface of LCJS, which is used to create all top level components - *charts* and *dashboards*.
 *
 * ```typescript
 *  const lcjs = lightningChart({
 *      // Either supply license number, or omit for automatic community license.
 *      // license: 'my-license-number'
 *  })
 *
 *  // Create charts...
 *  const chart = lcjs.ChartXY()
 * ```
 *
 * - More information of available chart types and options: [[LightningChart]]
 * - More information of top level *LCJS* configuration (licensing, etc.): [[LightningChartOptions]]
 *
 *
 * @param   arg1    Object containing any properties supported by [[LightningChartOptions]] interface. Most 
 *                  *string* license can be supplied to support old syntax, but **this will be deprecated eventually**, consider using `{ license: 'my-license' }` syntax instead.
 * @param   arg2    Additional information for license verification. Only required by Application Deployment license.
 *                  Consider using `{ licenseInformation: ... }` arg1 syntax instead.
 * @return          A *LightningChart* object for creating *Charts* and components.
 */
export declare const lightningChart: (arg1?: string | LightningChartOptions | undefined, arg2?: AppDeploymentLicenseInformation | undefined) => LightningChart;
/**
 * File contains interfaces of charting component factories.
 */
/**
 * Main interface of LCJS, which is used to create all top level components - *charts* and *dashboards*.
 * Reference to `LightningChart` is received with the [[lightningChart]] export, which is also used to supply possible license information, and other top-level configuration:
 *
 * ```typescript
 *  const lcjs = lightningChart({
 *      // Either supply license number, or omit for automatic community license.
 *      // license: 'my-license-number'
 *  })
 *
 *  // Create charts...
 *  const chart = lcjs.ChartXY()
 * ```
 *
 * To get started, browse through the available properties, for example:
 *
 * - [[LightningChart.ChartXY]].
 * - [[LightningChart.Chart3D]].
 * - [[LightningChart.Dashboard]].
 *
 */
export interface LightningChart {
    /**
     * Factory for `Dashboard`.
     * Dashboard allows placement of multiple *charts* inside a *grid layout*. Usage of *dashboard* is recommended when applicable,
     * due to increased performance (shared rendering context for all *charts*).
     *
     * To learn more about *dashboard* features, refer to [Dashboard](../classes/dashboard.html).
     *
     * **Dashboard configuration:**
     *
     * When a *dashboard* is created, the user must specify an amount of *columns* and *rows* for the grid layout.
     * These dimensions can't be changed afterwards, whereas the distribution of width/height between the *columns* and *rows*, can be adjusted at any time.
     *
     * ```typescript
     *  // Example, Create a 3x3 dashboard.
     *  const dashboard = LightningChart.Dashboard({
     *      // Number of cells along horizontal plane.
     *      numberOfColumns: 3,
     *      // Number of cells along vertical plane.
     *      numberOfRows: 3,
     *  })
     * ```
     *
     * To learn about the effects of *columns* / *rows* configuration, please read more here [Dashboard](../classes/dashboard.html).
     *
     * **Optional extra configuration:**
     *
     * Some extra, optional properties of `Dashboard` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in the same object parameter that is used for supplying `numberOfColumns`, and `numberOfRows`.
     *
     * ```typescript
     *  // Example, create 3x3 dashboard inside DOM element managed by user. The element must be added to the document, before creating the dashboard.
     *  const chart = LightningChart.Dashboard({
     *      // Number of cells along horizontal plane.
     *      numberOfColumns: 3,
     *      // Number of cells along vertical plane.
     *      numberOfRows: 3,
     *      // Argument can be either *element id* or actual reference to the HTML element.
     *      container: 'my-chart-div'
     *  })
     * ```
     *
     * For general *dashboard* properties, like specifying DOM container, rendering engine configuration, refer to [[EngineOptions]].
     *
     * For `Dashboard` specific properties, refer to [[DashboardOptions]].
     *
     * **Dashboard examples:**
     *
     * You can find an interactive gallery of different `Dashboard` use cases on our web site [`lightningchart.com`](https://www.arction.com/lightningchart-js-interactive-examples/search.html?t=dashboard)
     *
     * @param   options     Optional object with readonly configuration arguments for `Dashboard`.
     * @return              Created dashboard.
     *
     */
    Dashboard: (options: EngineOptions & DashboardOptions) => Dashboard;
    /**
     * Factory for `ChartXY`. This chart visualizes data between two dimensions *X* and *Y*.
     * It has built-in *Axis* functionality, and supports a large set of *series* types.
     *
     * To learn more about its features, refer to [ChartXY](../classes/chartxy.html).
     *
     * **Readonly configuration:**
     *
     * Some properties of `ChartXY` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
     *  const chart = LightningChart.ChartXY({
     *      // Argument can be either *element id* or actual reference to the HTML element.
     *      container: 'my-chart-div'
     *  })
     * ```
     *
     * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to [[EngineOptions]].
     *
     * For `ChartXY` specific properties, refer to [[ChartXYOptions]].
     *
     * @param   options     Optional object with readonly configuration arguments for `ChartXY`.
     * @return              Created chart.
     */
    ChartXY: <CursorPointMarkerType extends PointMarker, CursorResultTableBackgroundType extends UIBackground>(options?: EngineOptions & ChartXYOptions<CursorPointMarkerType, CursorResultTableBackgroundType>) => ChartXY<CursorPointMarkerType, CursorResultTableBackgroundType>;
    /**
     * Factory for `SpiderChart`. This chart visualizes data distributed over several *axes*.
     * *Spider Axes* are layed out in a circle, without any set limit on the amount of axes.
     * It supports a collection of different *series* types.
     *
     * To learn more about its features, refer to [SpiderChart](../classes/spiderchart.html).
     *
     * **Readonly configuration:**
     *
     * Some properties of `SpiderChart` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
     *  const chart = LightningChart.SpiderChart({
     *      // Argument can be either *element id* or actual reference to the HTML element.
     *      container: 'my-chart-div'
     *  })
     * ```
     *
     * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to [[EngineOptions]].
     *
     * For `SpiderChart` specific properties, refer to [[SpiderChartOptions]].
     *
     * @param   options     Optional object with readonly configuration arguments for `SpiderChart`.
     * @return              Created chart.
     */
    Spider: <CursorPointMarkerType extends PointMarker, CursorResultTableBackgroundType extends UIBackground>(options?: EngineOptions & SpiderChartOptions<CursorPointMarkerType, CursorResultTableBackgroundType>) => SpiderChart<CursorPointMarkerType, CursorResultTableBackgroundType>;
    /**
     * Factory for `PolarChart`. This chart visualizes data in a *Polar coordinate system* ( **angle** + **amplitude** ).
     * It has built-in *Axis* functionality, and supports a collection of different *series* types.
     *
     * To learn more about its features, refer to [PolarChart](../classes/polarchart.html).
     *
     * **Readonly configuration:**
     *
     * Some properties of `PolarChart` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
     *  const chart = LightningChart.Polar({
     *      // Argument can be either *element id* or actual reference to the HTML element.
     *      container: 'my-chart-div'
     *  })
     * ```
     *
     * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to [[EngineOptions]].
     *
     * For `PolarChart` specific properties, refer to [[PolarChartOptions]].
     *
     * @param   options     Optional object with readonly configuration arguments for `PolarChart`.
     * @return              Created chart.
     */
    Polar: <CursorPointMarkerType extends PointMarker, CursorResultTableBackgroundType extends UIBackground>(options?: EngineOptions & PolarChartOptions<CursorPointMarkerType, CursorResultTableBackgroundType>) => PolarChart<CursorPointMarkerType, CursorResultTableBackgroundType>;
    /**
     * Factory for `PieChart`. This chart visualizes proportions and percentages between categories,
     * by dividing a circle into proportional segments.
     *
     * To learn more about its features, refer to [PieChart](../classes/piechart.html).
     *
     * **Readonly configuration:**
     *
     * Some properties of `PieChart` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
     *  const chart = LightningChart.Pie({
     *      // Argument can be either *element id* or actual reference to the HTML element.
     *      container: 'my-chart-div'
     *  })
     * ```
     *
     * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to [[EngineOptions]].
     *
     * For `PieChart` specific properties, refer to [[PieChartOptions]].
     *
     * **Return type:**
     *
     * `PieChart` return type depends on supplied readonly configuration! Specifically, [[PieChartOptions.type]].
     *
     * | Configuration `type` | Return chart type |
     * | :------------------- | :---------------- |
     * | `undefined` or omitted | [[PieChartWithLabelsOnSides]] |
     * | `PieChartTypes.LabelsOnSides` | [[PieChartWithLabelsOnSides]] |
     * | `PieChartTypes.LabelsInsideSlices` | [[PieChartWithLabelsInsideSlices]] |
     *
     * @param   options     Optional object with readonly configuration arguments for `PieChart`.
     * @return              Created chart.
     */
    Pie: <PieChartType extends PieChartTypes = typeof PieChartWithLabelsOnSides>(options?: EngineOptions & PieChartOptions<PieChartType>) => InstanceType<PieChartType>;
    /**
     * Factory for `GaugeChart`. Gauge charts indicate where your data point(s) falls over a particular range.
     * This chart type is often used in executive dashboard reports to show key business indicators.
     *
     * To learn more about its features, refer to [SolidGauge](../classes/solidgauge.html).
     *
     * **Readonly configuration:**
     *
     * Some properties of `GaugeChart` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
     *  const chart = LightningChart.Gauge({
     *      // Argument can be either *element id* or actual reference to the HTML element.
     *      container: 'my-chart-div'
     *  })
     * ```
     *
     * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to [[EngineOptions]].
     *
     * For `GaugeChart` specific properties, refer to [[GaugeChartOptions]].
     *
     * @param   options     Optional object with readonly configuration arguments for `GaugeChart`.
     * @return              Created chart.
     */
    Gauge: (options?: EngineOptions & GaugeChartOptions<typeof SolidGauge>) => SolidGauge;
    /**
     * Factory for `FunnelChart`. This chart visualizes proportions and percentages between categories.
     *
     * To learn more about its features, refer to [FunnelChart](../classes/funnelchart.html).
     *
     * **Readonly configuration:**
     *
     * Some properties of `FunnelChart` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
     *  const chart = LightningChart.Funnel({
     *      // Argument can be either *element id* or actual reference to the HTML element.
     *      container: 'my-chart-div'
     *  })
     * ```
     *
     * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to [[EngineOptions]].
     *
     * For `FunnelChart` specific properties, refer to [[FunnelChartOptions]].
     *
     * **Return type:**
     *
     * `FunnelChart` return type depends on supplied readonly configuration! Specifically, [[FunnelChartOptions.type]].
     *
     * | Configuration `type` | Return chart type |
     * | :------------------- | :---------------- |
     * | `undefined` or omitted | [[FunnelChartWithLabelsOnSides]] |
     * | `FunnelChartTypes.LabelsOnSides` | [[FunnelChartWithLabelsOnSides]] |
     * | `FunnelChartTypes.LabelsInsideSlices` | [[FunnelChartWithLabelsInsideSlices]] |
     *
     * @param   options     Optional object with readonly configuration arguments for `FunnelChart`.
     * @return              Created chart.
     */
    Funnel: <FunnelChartType extends FunnelChartTypes = typeof FunnelChartWithLabelsOnSides>(options?: EngineOptions & FunnelChartOptions<FunnelChartType>) => InstanceType<FunnelChartType>;
    /**
     * Factory for `PyramidChart`. This chart visualizes proportions and percentages between categories.
     *
     * To learn more about its features, refer to [PyramidChart](../classes/pyramidchart.html).
     *
     * **Readonly configuration:**
     *
     * Some properties of `PyramidChart` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
     *  const chart = LightningChart.Pyramid({
     *      // Argument can be either *element id* or actual reference to the HTML element.
     *      container: 'my-chart-div'
     *  })
     * ```
     *
     * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to [[EngineOptions]].
     *
     * For `PyramidChart` specific properties, refer to [[PyramidChartOptions]].
     *
     * **Return type:**
     *
     * `PyramidChart` return type depends on supplied readonly configuration! Specifically, [[PyramidChartOptions.type]].
     *
     * | Configuration `type` | Return chart type |
     * | :------------------- | :---------------- |
     * | `undefined` or omitted | [[PyramidChartWithLabelsOnSides]] |
     * | `PyramidChartTypes.LabelsOnSides` | [[PyramidChartWithLabelsOnSides]] |
     * | `PyramidChartTypes.LabelsInsideSlices` | [[PyramidChartWithLabelsInsideSlices]] |
     *
     * @param   options     Optional object with readonly configuration arguments for `PyramidChart`.
     * @return              Created chart.
     */
    Pyramid: <PyramidChartType extends PyramidChartTypes = typeof PyramidChartWithLabelsOnSides>(options?: EngineOptions & PyramidChartOptions<PyramidChartType>) => InstanceType<PyramidChartType>;
    /**
     * Factory for `UIPanel`. This component can only be used to anchor *UI elements* outside of any particular *chart*.
     *
     * To learn more about its features, refer to [UIPanel](../classes/uipanel.html).
     *
     * **Readonly configuration:**
     *
     * Some properties of `UIPanel` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example, create panel inside DOM element managed by user. The element must be added to the document, before creating the chart.
     *  const panel = LightningChart.UIPanel({
     *      // Argument can be either *element id* or actual reference to the HTML element.
     *      container: 'my-panel-div'
     *  })
     * ```
     *
     * For full list of available properties, refer to [[EngineOptions]].
     *
     * @param   options     Optional object with readonly configuration arguments for `UIPanel`.
     * @return              Created UI panel.
     */
    UIPanel: (options?: EngineOptions) => UIPanel;
    /**
     * Factory for `MapChart`. This chart visualizes a Map of the selected part of the world. Defaults to the entire world.
     * It has built-in *cursor* functionality and supports dynamic region coloring.
     *
     * To learn more about its features, refer to [MapChart](../classes/mapchart.html).
     *
     * **Readonly configuration:**
     *
     * Some properties of `MapChart` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example, specify map type.
     *  const chart = LightningChart.Map({
     *      type: MapTypes.Europe
     *  })
     * ```
     *
     * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to [[EngineOptions]].
     *
     * For `MapChart` specific properties, refer to [[MapChartOptions]].
     *
     * **Required resources:**
     *
     * `MapChart` requires external file resources in order to work.
     * These resources are distributed along with the LightningChart JS package (`node_modules/@arction/lcjs/dist/resources`).
     *
     * In order to use `MapChart` the map resources need to be hosted on a file server.
     * When `MapChart` is created, a GET request will be issued to URL: `<resourcesBaseUrl>/maps/<mapDataFile>`.
     *
     * The file server location can be specified by supplying a `resourcesBaseUrl`
     * (see [[LightningChartOptions.resourcesBaseUrl]]).
     *
     * The following table documents which resource files are required based on used *Map type*:
     *
     * | Map type                   | Map data file                             |
     * | :------------------------- | :---------------------------------------- |
     * | `MapTypes.World`           | `'countries_world.json'`                  |
     * | `MapTypes.Europe`          | `'countries_europe.json'`                 |
     * | `MapTypes.NorthAmerica`    | `'countries_northAmerica.json'`           |
     * | `MapTypes.SouthAmerica`    | `'countries_southAmerica.json'`           |
     * | `MapTypes.Africa`          | `'countries_africa.json'`                 |
     * | `MapTypes.Asia`            | `'countries_asia.json'`                   |
     * | `MapTypes.USA`             | `'states_usa.json'`                       |
     * | `MapTypes.Canada`          | `'territoriesProvinces_canada.json'`      |
     * | `MapTypes.Australia`       | `'territories_australia.json'`            |
     *
     * @param   options     Optional object with readonly configuration arguments for `MapChart`.
     * @return              Created chart.
     */
    Map: <SelectedMapType extends MapType, CursorPointMarkerType extends PointMarker, CursorResultTableBackgroundType extends UIBackground>(options?: EngineOptions & MapChartOptions<SelectedMapType, CursorPointMarkerType, CursorResultTableBackgroundType>) => MapChart<SelectedMapType, CursorPointMarkerType, CursorResultTableBackgroundType>;
    /**
     * Factory for Chart3D.
     * This Chart visualizes data in a 3-dimensional scene, with camera and light source(s).
     * Currently supports only Point Series, but more series types will be added later on.
     * Factory for `Chart3D`. This chart visualizes data in three dimensions.
     * It has built-in *Axis* and *camera* functionality, and supports a collection of different *series* types.
     *
     * To learn more about its features, refer to [Chart3D](../classes/chart3d.html).
     *
     * **Readonly configuration:**
     *
     * Some properties of `Chart3D` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
     *  const chart = LightningChart.Chart3D({
     *      // Argument can be either *element id* or actual reference to the HTML element.
     *      container: 'my-chart-div'
     *  })
     * ```
     *
     * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to [[EngineOptions]].
     *
     * For `Chart3D` specific properties, refer to [[ChartOptions3D]].
     *
     * @param   options     Optional object with readonly configuration arguments for `Chart3D`.
     * @return              Created chart.
     */
    Chart3D: (options?: EngineOptions & ChartOptions3D) => Chart3D;
}
/**
 * Interface for configuring LightningChart JS initialization, before any charts or series are created.
 *
 * Supplied when `lightningChart` function is called:
 *
 * ```typescript
 *  const lcjs = lightningChart({
 *      // Either supply license number, or omit for automatic community license.
 *      // license: 'my-license-number'
 *  })
 *
 *  // Create charts...
 *  const chart = lcjs.ChartXY()
 * ```
 */
export interface LightningChartOptions {
    /**
     * Optional development or deployment license. If omitted, a community license will be used.
     */
    license?: string;
    /**
     * Additional information for license verification. Only required by Application Deployment license.
     */
    licenseInformation?: AppDeploymentLicenseInformation;
    /**
     * Optionally supplieable data structure for overriding mouse buttons that trigger user interactions.
     *
     * See [[OverrideInteractionMouseButtons]] for full list of supported overrides.
     *
     * Example usage:
     *
     * - Swap ChartXY panning and zoom/fit mouse buttons.
     *
     * ```typescript
     *  const lcjs = lightningChart({
     *      // LightningChartOptions
     *      overrideInteractionMouseButtons: {
     *          chartXYPanMouseButton: 0, // LMB
     *          chartXYRectangleZoomFitMouseButton: 2, // RMB
     *      }
     *  })
     *
     *  // Create charts...
     *  const chart = lcjs.ChartXY()
     * ```
     */
    overrideInteractionMouseButtons?: OverrideInteractionMouseButtons;
    /**
     * Specify URL path to file server that hosts LightningChart JS resources.
     *
     * LightningChart JS is distributed along with some resource files, which are required for select features only:
     * - [[MapChart]] (`resources/maps/`)
     * - [[OnScreenMenu]] (`resources/osm/`)
     *
     * When any of these features are used, the user has to ensure that the necessary resources are hosted on a file server where LightningChart JS can fetch them.
     *
     * _Example local file server with `http-server` from `node_modules`:_
     *
     * ```
     *  npm i --global http-server
     *  cd node_modules/@arction/lcjs/dist/resources
     *  http-server --cors
     * ```
     *
     * ```js
     *  const lcjs = lightningChart({
     *      resourcesBaseUrl: 'http://127.0.0.1:8081', // <--- or whichever port http-server assigned.
     *  })
     * ```
     *
     * **Node Js:**
     *
     * When using LightningChart JS in Node JS environment with [lcjs-headless](https://github.com/Arction/lcjs-headless) you will need to provide a path to the resource files.
     * This path needs to be provided with syntax `fs:<path>`. For example:
     *
     * ```js
     *  const lcjs = lightningChart({
     *      resourcesBaseUrl: `fs:${path.resolve(__dirname, 'node_modules', '@arction', 'lcjs', 'dist', 'resources')}`
     *  })
     * ```
     *
     * **Troubleshooting:**
     *
     * If LightningChart JS can't fetch any required resource, it will result in an error.
     * Here is a list of common resource issues:
     *
     * **1. Resources are not hosted.**
     *
     * In LightningChart JS template projects, the hosting of resources is built-in.
     * However, in users own projects, it is the users responsibility to setup a file server for LightningChart JS resources if they are required.
     *
     * **2. Resources server URL is wrong.**
     *
     * Please make sure that the configured `resourcesBaseUrl` points to URL landing inside `resources` folder.
     *
     * `resourcesBaseUrl` should not end with a `'/'`.
     * For example, `'http://127.0.0.1:8081'` is a valid value. `'http://127.0.0.1:8081/'` might result in an error.
     *
     * **3. Request is CORS blocked.**
     *
     * A common issue especially when first starting development / testing.
     * For example, when hosting `resources` folder with `http-server` *npm module*, the extra `cors` flag must be supplied.
     *
     * ```bash
     *  cd node_modules/@arction/lcjs/dist/resources
     *  http-server --cors
     * ```
     */
    resourcesBaseUrl?: string;
    /**
     * Optional configuration for instructing desired reaction to warnings that can have small side-effects, like decreasing performance or which might indicate issues in application code.
     *
     * By default these warnings are enabled, which might result in some output to browser console, stdout or such channels.
     *
     * By setting `warnings` to `false`, this kind of warnings can be disabled.
     *
     * ```js
     *  // Example syntax, disable low-level warnings.
     *  const chart = lightningChart({
     *      warnings: false
     *  }).ChartXY()
     * ```
     */
    warnings?: boolean;
}
/**
 * Internal type matching `LightningChartOptions`, but no property can be omitted to reduce bugs.
 *
 * Also, license information is dropped for safety.
 * @hidden
 */
export interface InternalLightningChartOptions {
    overrideInteractionMouseButtons: OverrideInteractionMouseButtons | undefined;
    resourcesBaseUrl: string;
    warnings: boolean;
}
/**
 * Application deployment license information.
 */
export interface AppDeploymentLicenseInformation {
    /**
     * Company name
     */
    company: string;
    /**
     * Application title
     */
    appTitle: string;
    [key: string]: string;
}
/**
 * Factory for creation of Engine.
 * Handles application of different engine restrictions based on whether suite is for development or production
 * @param   engineOptions  Settings union for Engine.
 * @return                  Engine object.
 */
export declare type EngineFactory = (lcjsOptions: LightningChartOptions | undefined, engineOptions?: EngineOptions) => Engine;
/**
 * Type of LayerSupplier factory.
 * @param   componentIndex  Index of component to create layer supplier for
 * @return                  LayerSupplier object
 * @hidden
 */
export declare type LayerSupplierFactory = (componentIndex: number) => LayerSupplier;
/**
 * Interface for object that is used for supplying rendering layers for charting components.
 * @hidden
 */
export interface LayerSupplier {
}
export {};
/**
 * Interface which can be used to interact with a created Logo.
 */
export interface LogoHandle {
}
/**
 * Logo factory. Takes scale used by a chart to properly render the logo for that chart.
 * @return  LogoHandle interface for interacting with created Logo.
 */
export declare type LogoFactory = (scale: LinearScaleXY) => LogoHandle;
/**
 * Interface for end user API of the LCJS engine.
 * It provides some useful capabilities over the area enclosed by a single LCJS context (which can be just a single chart, or a Dashboard with several charts).
 *
 * **Commonly used properties:**
 *
 * - [layout]([[PublicEngine.layout]]): Trigger resizing of charts.
 * - [captureFrame]([[PublicEngine.captureFrame]]): Take a screenshot of charts.
 * - [scale]([[PublicEngine.scale]]): Coordinate system that encloses entire LCJS context in pixels starting from bottom left.
 * - [clientLocation2Engine]([[PublicEngine.clientLocation2Engine]]): Translate web page coordinate to LCJS engine coordinate.
 * - [engineLocation2Client]([[PublicEngine.engineLocation2Client]]): Translate LCJS engine coordinate to web page coordinate.
 */
export interface PublicEngine {
    /**
     * HTML Div element that contains the rendering Engine.
     */
    container: HTMLDivElement;
    /**
     * Coordinate system that encloses entire LCJS context in pixels starting from bottom left.
     *
     * Referenced usually by `chart.engine.scale`.
     *
     * The _engine scale_ is used as an intermediary step when translating locations from the web page into LCJS coordinates, or vice versa.
     *
     * See [[clientLocation2Engine]] for translating web page coordinate to `engine.scale` and
     * [[engineLocation2Client]] for translating `engine.scale` coordinate to web page.
     *
     * To further translate a location on `engine.scale` to another coordinate system, like _axis_, use [[translatePoint]] function.
     *
     * This feature is extremely powerful since it allows combining of LCJS and HTML/CSS or any web UI framework.
     */
    scale: LinearScaleXY;
    /**
     * Set Mouse style.
     * @param   presetName  Name of a Mouse preset in js.
     * @param   existingKey Key for existing request to refresh
     * @return              Key that can be used to restore Mouse style
     */
    setMouseStyle: (presetName: string, existingKey?: number) => number;
    /**
     * Restore Mouse style.
     * @param   key     Key generated using 'setMouseStyle'
     */
    restoreMouseStyle: (key?: number) => void;
    /**
     * Translates a coordinate on the web page (for example, `MouseEvent.clientX`, `MouseEvent.clientY`) that originates from browser top-left,
     * to [[PublicEngine.scale]].
     *
     * ```js
     *  // Example usage, listen to chartXY background mouse move and console the location on default axis.
     *  chart.onSeriesBackgroundMouseMove((_, event) => {
     *      // Translate mouse location to LCJS coordinate system for solving data points from series, and translating to Axes.
     *      const mouseLocationEngine = chart.engine.clientLocation2Engine(
     *          event.clientX,
     *          event.clientY
     *      );
     *
     *      // Translate LCJS coordinate to default chart axes.
     *      const mouseLocationAxis = translatePoint(mouseLocationEngine, chart.engine.scale, { x: chart.getDefaultAxisX(), y: chart.getDefaultAxisY() })
     *      console.log('axis', mouseLocationAxis)
     *  })
     * ```
     *
     * To further translate a location on `engine.scale` to another coordinate system, like _axis_, use [[translatePoint]] function.
     *
     * This feature is extremely powerful since it allows combining of LCJS and HTML/CSS or any web UI framework.
     *
     * @param   x   Location of X in browser
     * @param   y   Location of Y in browser
     * @return      Respective coordinate on `engine.scale`
     */
    clientLocation2Engine(x: number, y: number): Point;
    /**
     * Translates a coordinate on `engine.scale` that originates from LCJS bottom-left to respective location on the web page currently.
     *
     * This coordinate can, for example, be used with absolute CSS positioning:
     *
     * ```
     *  // Example usage, absolute position a HTML element on a coordinate along two LCJS Axes.
     *  const element = document.createElement('span')
     *  chart.engine.container.append(element)
     *  element.style.position = 'absolute'
     *  element.style.display = 'block'
     *  element.innerHTML = 'hello'
     *  element.style.color = 'red'
     *
     *  const repositionElement = () => {
     *      // Position HTML element with CSS by translating LCJS Axis location to web page.
     *      const locationAxis = { x: chart.getDefaultAxisX().getInterval().start, y: chart.getDefaultAxisY().getInterval().end }
     *      const locationEngine = translatePoint(locationAxis, { x: chart.getDefaultAxisX(), y: chart.getDefaultAxisY() }, chart.engine.scale)
     *      const locationDocument = chart.engine.engineLocation2Client(locationEngine.x, locationEngine.y)
     *      element.style.left = `${locationDocument.x}px`
     *      element.style.top = `${locationDocument.y}px`
     *  }
     *
     *  // NOTE: Axis -> Document translation is invalid if one of many things changes:
     *  // 1. Axis interval, style or ticks change.
     *  // 2. Web page is scrolled, zoomed or resized.
     *  // 3. Dashboard splitter is resized.
     *  // In this example, the element is repositioned continuously, which might not always be for the best.
     *  setInterval(repositionElement)
     * ```
     *
     * This feature is extremely powerful since it allows combining of LCJS and HTML/CSS or any web UI framework.
     *
     * @param   x   Location of X in engine
     * @param   y   Location of Y in engine
     */
    engineLocation2Client(x: number, y: number): Point;
    /**
     * Capture state of rendering Engines canvas. Returns the captured image as a Blob-object.
     *
     * Has two optional parameters which directly reference JavaScript API HTMLCanvasElement.toDataURL:
     *
     * https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL
     *
     * @param   type            A DOMString indicating the image format. The default format type is image/png.
     * @param   encoderOptions  A Number between 0 and 1 indicating the image quality to use for image formats
     *                          that use lossy compression such as image/jpeg and image/webp. If this argument is anything else,
     *                          the default value for image quality is used. The default value is 0.92. Other arguments are ignored.
     * @return                  JavaScript Blob whose 'type' depends on what was passed to 'type' parameter of this method.
     *                          Defaults to image/png
     */
    captureFrame(type?: string, encoderOptions?: number): Blob;
    /**
     * Render a frame of specific size to a ArrayBuffer.
     *
     * Mainly for Node JS usage. In browser the chart itself will not be resized correctly.
     * @param width Horizontal resolution
     * @param height Vertical resolution
     * @param noFlip Leave the image upside down
     */
    renderFrame(width: number, height: number, noFlip?: boolean): Uint8Array;
    /**
     * Calculate the layout again. This should be called when the container of chart is resized.
     *
     * ```js
     *  // Example syntax, trigger chart resize on user event.
     *  myResizeEventCallback(() => {
     *      // Trigger chart resize manually.
     *      chart.engine.layout()
     *  })
     * ```
     */
    layout(): void;
    /**
     * Set Fill Style of engine background.
     *
     * Every LCJS component has an Engine background under it. In case of Dashboard, there is only 1 shared engine background.
     *
     * **Transparent chart backgrounds:**
     *
     * LightningChart JS charts can be configured to be fully or partially transparent.
     *
     * ```ts
     *  // Example, partially transparent chart
     *
     *  // Engine background exists under all LCJS components. In case of Dashboard, there is only 1 shared engine background.
     *  chart.engine.setBackgroundFillStyle(emptyFill)
     *  // Chart background covers every 1 chart. In case of Dashboard, every chart has its own chart background.
     *  chart.setBackgroundFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 100) }))
     *  // Some charts also have a separate series background.
     *  chart.setSeriesBackgroundFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 100) }))
     * ```
     *
     * @param   fillStyle   FillStyle or mutator to modify existing one.
     * @return              Object itself
     */
    setBackgroundFillStyle(fillStyle: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get Fill Style of engine background.
     * @return              FillStyle
     */
    getBackgroundFillStyle(): FillStyle;
    /**
     * Set Stroke Style of engine background.
     * @param   value       LineStyle
     * @return              Object itself
     */
    setBackgroundStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get Stroke Style of engine background.
     * @return              LineStyle
     */
    getBackgroundStrokeStyle(): LineStyle;
}
/**
 * Interface for overriding mouse buttons that trigger user interactions.
 *
 * Can be supplied along [[LightningChartOptions]] before creating any chart or series, when initiating the `lightningChart` function:
 *
 * ```typescript
 *  const lcjs = lightningChart({
 *      overrideInteractionMouseButtons: {
 *          chartXYPanMouseButton: 0, // LMB
 *          chartXYRectangleZoomFitMouseButton: 2, // RMB
 *      }
 *  })
 *
 *  // Create charts...
 *  const chart = lcjs.ChartXY()
 * ```
 */
export interface OverrideInteractionMouseButtons {
    /**
     * Override mouse button that activates *rectangle zoom / fit* actions when dragging over ChartXY series background.
     *
     * By default *Left Mouse Button* (`0`).
     *
     * - Left Mouse Button = `0`
     * - Middle Mouse Button = `1`
     * - Right Mouse Button = `2`
     */
    chartXYRectangleZoomFitMouseButton?: number;
    /**
     * Override mouse button that activates *panning* action when dragging over ChartXY series background.
     *
     * By default *Right Mouse Button* (`2`).
     *
     * - Left Mouse Button = `0`
     * - Middle Mouse Button = `1`
     * - Right Mouse Button = `2`
     */
    chartXYPanMouseButton?: number;
    /**
     * Override mouse button that activates *zooming* action when dragging over ChartXY Axis.
     *
     * By default *Left Mouse Button* (`0`).
     *
     * - Left Mouse Button = `0`
     * - Middle Mouse Button = `1`
     * - Right Mouse Button = `2`
     */
    axisXYZoomMouseButton?: number;
    /**
     * Override mouse button that activates *panning* action when dragging over ChartXY Axis.
     *
     * By default *Right Mouse Button* (`2`).
     *
     * - Left Mouse Button = `0`
     * - Middle Mouse Button = `1`
     * - Right Mouse Button = `2`
     */
    axisXYPanMouseButton?: number;
}

export declare abstract class Element {
    protected readonly _engine: Engine;
    
    constructor(_engine: Engine);
}

export declare enum MouseClickEventType {
    click = 0,
    dbclick = 1,
    mouseDown = 2,
    mouseUp = 3,
    contextmenu = 4,
    wheel = 5
}

export declare enum TouchEventType {
    touchStart = 0,
    touchMove = 1,
    touchEnd = 2
}

export declare enum HTMLContainerType {
    osm = 0
}

export interface HTMLContainer {
    dispose: () => void;
}

export declare type HTMLContainerMap = Map<string, HTMLContainer>;

export declare type HTMLContainerTypeMap = Map<HTMLContainerType, HTMLContainerMap>;

export declare abstract class Engine implements Validatable {
    
    constructor(lcjsOptionsInput?: LightningChartOptions, options?: EngineOptions);
    
    private handleOsmPointerEvent;
    
    setBackgroundFillStyle(fillStyle: FillStyle | ImmutableMutator<FillStyle>): this;
    
    getBackgroundFillStyle(): FillStyle;
    
    setBackgroundStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    
    getBackgroundStrokeStyle(): LineStyle;
}

export declare abstract class Entity extends Element implements Disposable, ApplicationFlagOwner {
    readonly _engine: Engine;
    protected readonly _remove: RemoveHandler<Entity>;
    protected readonly _restore: RestoreHandler<Entity>;
    protected readonly _applicationFlags: InternalApplicationFlagPlusArgs[];
    
    constructor(_engine: Engine, _remove: RemoveHandler<Entity>, _restore: RestoreHandler<Entity>, _applicationFlags: InternalApplicationFlagPlusArgs[]);
    
    dispose(): this;
    
    restore(): this;
    
    isDisposed(): boolean;
    
    setMouseInteractions(isMouseInteractionEnabled: boolean): this;
    
    getMouseInteractions(): boolean;
    
    getIsUnderMouse(): boolean;
    
    getIsGrabbed(): boolean;
    
    setIsUnderMouse(state: boolean): this;
    
    setMouseMoveEventHandler(callback: MouseEventHandler<this>): this;
    
    setMouseEnterEventHandler(callback: MouseEventHandler<this>): this;
    
    setMouseLeaveEventHandler(callback: AbruptMouseEventHandler<this>): this;
    
    setMouseClickEventHandler(callback: MouseEventHandler<this>): this;
    
    setMouseDoubleClickEventHandler(callback: MouseEventHandler<this>): this;
    
    setMouseDownEventHandler(callback: MouseEventHandler<this>): this;
    
    setMouseUpEventHandler(callback: MouseEventHandler<this>): this;
    
    setMouseWheelEventHandler(callback: MouseWheelEventHandler<this>): this;
    
    setMouseContextMenuEventHandler(callback: MouseEventHandler<this>): this;
    
    setMouseDragEventHandler(callback: MouseDragEventHandler<this>): this;
    
    setMouseDragStartEventHandler(callback: MouseDragStartEventHandler<this>): this;
    
    setMouseDragStopEventHandler(callback: MouseDragStopEventHandler<this>): this;
    
    setTouchStartEventHandler(callback: TouchEventHandler<this>): this;
    
    setTouchMoveEventHandler(callback: TouchEventHandler<this>): this;
    
    setTouchEndEventHandler(callback: TouchEventHandler<this>): this;
}

export declare abstract class Entity2D extends Entity {
}

export declare abstract class Entity3D extends Entity {
    readonly _layer: Layer3D;
    
    constructor(_layer: Layer3D, _remove: RemoveHandler<Entity>, _restore: RestoreHandler<Entity>, applicationFlags: InternalApplicationFlagPlusArgs[]);
}

export interface MousePickingFlags3D {
    
    overrideFollowing?: boolean;
    
    skipMousePicking?: boolean;
}

export declare abstract class Layer<E extends Entity = Entity> extends Element {
    readonly _engine: Engine;
    private readonly _zIndex;
    
    constructor(_engine: Engine, _zIndex: number);
}

export declare abstract class Layer2D extends Layer<Entity2D> {
}

export declare abstract class Layer3D extends Layer<Entity3D> {
    readonly _scale: Vec3<UnitScale>;
    
    constructor(_engine: Engine, _zIndex: number, _scale: Vec3<UnitScale>);
    
    setCameraLocation(cameraLocation: Point3D): this;
    
    getCameraLocation(): Point3D;
    
    setCameraDirection(cameraDirection: Point3D): this;
    
    getCameraDirection(): Point3D;
    
    setLightLocation(lightLocation: Point3D): this;
    
    getLightLocation(): Point3D | undefined;
}

export {};

export declare const ShaderFeatureUtils: {
    
    pickVertexLocationTranslation: (scale: LinearScaleXY | RadialScale | MixedScaleXY | Vec3<UnitScale>) => AxisWorldTranslationDefinition;
};

export interface DataSet<VerticesList> {
}

export interface ConnectableSegment<VerticesList> extends DataSet<VerticesList> {
}

export interface Region {
}

export declare abstract class Shape<ScaleType extends ScaleXY = ScaleXY> extends Entity2D {
    readonly _engine: Engine;
    protected readonly _scale: ScaleType;
    
    constructor(_engine: Engine, _scale: ScaleType, _remove: RemoveHandler<Entity>, _restore: RestoreHandler<Entity>, applicationFlags: InternalApplicationFlagPlusArgs[]);
}

export declare abstract class FilledShape<ScaleType extends ScaleXY = ScaleXY> extends Shape<ScaleType> {
    readonly _engine: Engine;
    
    constructor(_engine: Engine, scale: ScaleType, _remove: RemoveHandler<Entity>, _restore: RestoreHandler<Entity>, applicationFlags: InternalApplicationFlagPlusArgs[]);
}

export declare abstract class StyledShape<ScaleType extends ScaleXY = ScaleXY> extends FilledShape<ScaleType> {
    readonly _engine: Engine;
    
    constructor(_engine: Engine, scale: ScaleType, _remove: RemoveHandler<Entity>, _restore: RestoreHandler<Entity>, applicationFlags: InternalApplicationFlagPlusArgs[]);
}


export declare abstract class SizableShape<ScaleType extends ScaleXY = ScaleXY> extends FilledShape<ScaleType> {
    readonly size: Val<number>;
    
    constructor(engine: Engine, scale: ScaleType, _remove: RemoveHandler<Entity>, _restore: RestoreHandler<Entity>, applicationFlags: InternalApplicationFlagPlusArgs[], size?: Val<number>);
}

export declare abstract class Text extends FilledShape<LinearScaleXY | RadialScale | MixedScaleXY> {
    readonly font: any;
    
    constructor(engine: Engine, scale: LinearScaleXY | RadialScale | MixedScaleXY, _remove: RemoveHandler<Entity>, _restore: RestoreHandler<Entity>, applicationFlags: InternalApplicationFlagPlusArgs[], font?: any);
}

export declare abstract class PointSet extends SizableShape<LinearScaleXY | RadialScale | MixedScaleXY> implements Region, DataSet<Point[] | ColorPoint[]> {
    
    constructor(engine: Engine, scale: LinearScaleXY | RadialScale | MixedScaleXY, _remove: RemoveHandler<Entity>, _restore: RestoreHandler<Entity>, applicationFlags: InternalApplicationFlagPlusArgs[], size?: number);
}

export declare abstract class Rect extends StyledShape<LinearScaleXY | RadialScale | MixedScaleXY> {
    
    constructor(engine: Engine, scale: LinearScaleXY | RadialScale | MixedScaleXY, _remove: RemoveHandler<Entity>, _restore: RestoreHandler<Entity>, applicationFlags: InternalApplicationFlagPlusArgs[]);
}

export declare abstract class Polygon extends StyledShape<LinearScaleXY | RadialScale> implements Region {
}

export declare abstract class ConvexPolygon extends Polygon {
}

export declare abstract class SimplePolygon extends Polygon {
}

export declare abstract class ComplexPolygon extends Polygon {
}

export declare abstract class Junction extends FilledShape<LinearScaleXY | RadialScale | MixedScaleXY> implements Region, ConnectableSegment<[Point[], Point[]]> {
    
    constructor(engine: Engine, scale: LinearScaleXY | RadialScale | MixedScaleXY, _remove: RemoveHandler<Entity>, _restore: RestoreHandler<Entity>, applicationFlags: InternalApplicationFlagPlusArgs[]);
}

export declare abstract class Arc extends StyledShape<LinearScaleXY | RadialScale> {
    
    constructor(engine: Engine, scale: LinearScaleXY | RadialScale, _remove: RemoveHandler<Entity>, _restore: RestoreHandler<Entity>, applicationFlags: InternalApplicationFlagPlusArgs[]);
}

export declare enum PolygonType {
    Complex = 0,
    Simple = 1,
    Convex = 2
}

export declare abstract class LineLike<ScaleType extends ScaleXY = ScaleXY> extends Shape<ScaleType> {
    readonly engine: Engine;
    
    constructor(engine: Engine, scale: ScaleType, _remove: RemoveHandler<Entity>, _restore: RestoreHandler<Entity>, applicationFlags: InternalApplicationFlagPlusArgs[]);
}

export declare abstract class Line extends LineLike<LinearScaleXY | RadialScale | MixedScaleXY> {
    
    constructor(engine: Engine, scale: LinearScaleXY | RadialScale | MixedScaleXY, _remove: RemoveHandler<Entity>, _restore: RestoreHandler<Entity>, applicationFlags: InternalApplicationFlagPlusArgs[]);
}

export declare abstract class LineCollection extends LineLike<LinearScaleXY | RadialScale | MixedScaleXY> {
    
    constructor(engine: Engine, scale: LinearScaleXY | RadialScale | MixedScaleXY, _remove: RemoveHandler<Entity>, _restore: RestoreHandler<Entity>, applicationFlags: InternalApplicationFlagPlusArgs[]);
}
export interface LineSetOptions {
    
    individualLookupValuesEnabled?: boolean;
}

export declare abstract class LineSet<ScaleType extends ScaleXY = ScaleXY> extends LineLike<ScaleType> implements Region, ConnectableSegment<Point[]> {
    
    constructor(engine: Engine, scale: ScaleType, _remove: RemoveHandler<Entity>, _restore: RestoreHandler<Entity>, applicationFlags: InternalApplicationFlagPlusArgs[]);
    
    abstract getPointsBounds(): Interval<Point>;
}

export declare abstract class Intensity extends FilledShape<LinearScaleXY | RadialScale> implements Region, IntensityState<Point> {
    readonly engine: Engine;
    
    constructor(engine: Engine, scale: LinearScaleXY | RadialScale, _remove: RemoveHandler<Entity>, _restore: RestoreHandler<Entity>, applicationFlags: InternalApplicationFlagPlusArgs[]);
}

export interface IntensityState<T> {
}

export interface Region3D extends Region {
}

export declare abstract class Shape3D extends Entity3D {
    
    constructor(_layer: Layer3D, _remove: RemoveHandler<Shape3D>, _restore: RestoreHandler<Shape3D>, applicationFlags: InternalApplicationFlagPlusArgs[]);
}

export declare type PointSetStyle3D = TriangulatedPoints3D | PixelatedPoints3D;

export interface PointSet3DOptions {
    
    individualPointColorEnabled: boolean;
    
    individualPointSizeEnabled: boolean;
    
    individualLookupValuesEnabled: boolean;
    
    individualPointSizeAxisEnabled: boolean;
}

export interface PointSet3D extends Shape3D, Region3D, DataSet<Point3D[]> {
}

export declare type JointStyle3D = TriangulatedPoints3D | EmptyPoints3D;

export interface LineSet3D extends Shape3D, Region3D, DataSet<Point3D[]> {
}

export interface Surface3D extends Shape3D, Region3D {
}

export interface BoxSet3D extends Shape3D, Region3D {
}

export interface LineCollection3D extends Shape3D {
}

export interface ColumnPackager {
    
    type: 'horizontalProgressive' | 'horizontalRegressive' | 'verticalProgressive' | 'verticalRegressive' | 'disabled';
    
    packager: (vertices: Point[], pixelSize: Point, thickness: number) => Point[];
}

export declare class Validator {
}

export declare class ValConstructor<T> extends Validator {
    private _value;
    
    constructor(_value: T, isInvalid: boolean);
}

export interface HighlightableType {
    
    getDefaultHighlightStyle(): this;
}

export declare class HighlightableValue<T extends HighlightableType> {
    
    constructor(initNormal: T, initHighlighted?: T);
}

export declare class PanelError extends Error {
    constructor(m: string, owner?: any);
}

export declare class AxisError extends Error {
    constructor(m: string, owner?: any);
}

export declare class EngineError extends Error {
    constructor(m: string, owner?: any, riseAlert?: boolean);
}

export declare class ShaderError extends EngineError {
    constructor(m: string);
}

export declare class UnImplementedError extends Error {
    constructor(name: string);
}
export {};

export interface RadialGradientGLInfo {
    
    bounds: [number, number, number, number];
    
    distance: [number, number];
    
    center: [number, number];
    
    aspectRatio: number;
}

export interface LinearGradientGLInfo {
    
    bounds: [number, number, number, number];
    
    startPoint: [number, number];
    
    endPoint: [number, number];
}

export interface MVec2<T> {
    x: T;
    y: T;
}

export interface MVec3<T> {
    x: T;
    y: T;
    z: T;
}

export interface Interval<T> {
    readonly min: T;
    readonly max: T;
}

export interface MInterval<T> {
    min: T;
    max: T;
}

export interface Area {
    x: number;
    y: number;
    width: number;
    height: number;
}

export declare type Val<T> = ValConstructor<T>;

export interface MMargin {
    left: number;
    top: number;
    right: number;
    bottom: number;
}

export interface Ray<T> {
    
    origin: T;
    
    direction: T;
}

export interface Validatable {
}

export interface AbstractEventInterface<T extends any[] = any[]> {
    
    on: (listener: (args: T) => void) => Token;
    
    off: (token: Token) => boolean;
}

export declare const abstractEventInterface: <T extends any[] = any[]>(eventer: Eventer, topic: string) => AbstractEventInterface<T>;

export interface ExtendedPointerEvent extends PointerEvent {
    
    interactions: Point[];
    
    forceTouchEnd: boolean;
}

export interface ApplicationFlagOwner {
}

export interface PointValuePair {
    point: Point;
    value: number | undefined;
}
export {};

export declare type Matrix3 = number[];

export declare const m3: {
    translation(tx: number, ty: number): Matrix3;
    rotation(angleInRadians: number): Matrix3;
    scaling(sx: number, sy: number): Matrix3;
    translate(m: Matrix3, tx: number, ty: number): Matrix3;
    rotate(m: Matrix3, angleInRadians: number): Matrix3;
    scale(m: Matrix3, sx: number, sy: number): Matrix3;
    multiply(a: Matrix3, b: Matrix3): Matrix3;
    
    projection(width: number, height: number, invertY: 1 | -1): Matrix3;
};

export declare type Matrix4 = number[];

export declare const m4: {
    translation(tx: number, ty: number, tz: number): Matrix4;
    xRotation(angleInRadians: number): Matrix4;
    yRotation(angleInRadians: number): Matrix4;
    zRotation(angleInRadians: number): Matrix4;
    scaling(sx: number, sy: number, sz: number): Matrix4;
    translate(m: Matrix4, tx: number, ty: number, tz: number): Matrix4;
    xRotate(m: Matrix4, angleInRadians: number): Matrix4;
    yRotate(m: Matrix4, angleInRadians: number): Matrix4;
    zRotate(m: Matrix4, angleInRadians: number): Matrix4;
    scale(m: Matrix4, sx: number, sy: number, sz: number): Matrix4;
    multiply(a: Matrix4, b: Matrix4): Matrix4;
    inverse(m: Matrix4): Matrix4;
    
    projectionPerspective(fovDeg: number, aspectRatio: number, near: number, far: number): Matrix4;
    
    projectionOrthographic(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
};

export declare class ObservableValue<T> {
    private _value;
    
    constructor(_value: T);
}

export declare enum SolveNearestBasis {
    
    Nearest = 0,
    
    NearestX = 1,
    
    NearestY = 2
}
declare type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;

export declare type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

export declare type NonReadonly<T> = {
    -readonly [P in keyof T]: T[P];
};
export {};

export declare type RemoveHandler<T> = (obj: T) => void;

export declare type RestoreHandler<T> = (obj: T) => void;
export declare type BoundaryCorner<T> = (boundary: Interval<Vec2<T>>) => T;

export declare type RemoveReadonly<T> = {
    -readonly [P in keyof T]: T[P];
};
/**
 * File contains internal default style factories for all of library.
 * These are also intended to be public so user can easily replicate them and perhaps mutate them somehow in the future.
 */
/**
 * Collection of some useful cursor styles.
 *
 * Uses HTML DOM Style cursor property, so supported values are specified by browser.
 *
 * https://www.w3schools.com/jsref/prop_style_cursor.asp
 *
 * Use with [[UIElement.setMouseStyle]]
 */
export declare enum MouseStyles {
    Move = "move",
    ResizeColumn = "col-resize",
    ResizeRow = "row-resize",
    Horizontal = "ew-resize",
    Vertical = "ns-resize",
    NorthWest = "nw-resize",
    NorthEast = "ne-resize",
    Copy = "copy",
    CrossHair = "crosshair",
    Default = "default",
    Help = "help",
    Restricted = "not-allowed",
    None = "none",
    Point = "pointer",
    Text = "text",
    Wait = "wait",
    ZoomIn = "zoom-in",
    ZoomOut = "zoom-out"
}
/**
 * Collection of fast-access *arguments* for [[UIElement.setOrigin]]
 */
export declare const UIOrigins: {
    LeftBottom: Point;
    CenterBottom: Point;
    RightBottom: Point;
    LeftCenter: Point;
    Center: Point;
    RightCenter: Point;
    LeftTop: Point;
    CenterTop: Point;
    RightTop: Point;
};
/**
 * A [[SolidFill]] singleton for a completely transparent fill.
 * Can be useful in at least following cases:
 *
 * 1) User wants to hide something but still have it interactable by mouse/touch
 *
 * 2) User wants to hide something that does not support [[emptyFill]]
 *
 * Otherwise, [[emptyFill]] should be preferred for better performance.
 */
export declare const transparentFill: SolidFill;
/**
 * A [[SolidLine]] singleton for a completely transparent line.
 * Can be useful in at least following cases:
 *
 * 1) User wants to hide something but still have it interactable by mouse/touch
 *
 * 2) User wants to hide something that does not support [[emptyFill]]
 *
 * Otherwise, [[emptyLine]] should be preferred for better performance.
 */
export declare const transparentLine: SolidLine<SolidFill>;
/**
 * Base unit height for all controls. This value is multiplied by the
 * rows specified in the [[OnScreenMenuDimensions]] interface to get the final
 * control dimensions.
 */
export declare const onScreenMenuControlBaseHeight: number;
/**
 * Base unit width for all controls. This value is multiplied by the
 * columns specified in the [[OnScreenMenuDimensions]] interface to get the final
 * control dimensions.
 */
export declare const onScreenMenuControlBaseWidth: number;
/**
 * Default opacity value for all On-Screen Menu controls.
 */
export declare const onScreenMenuControlOpacity: string;
/**
 * url for sprite image
 */
export declare const onScreenMenuSpriteURL: string;
/**
 * Default button Shape for all On-Screen menu buttons.
 */
export declare const onScreenMenuDefaultButtonShape: OnScreenMenuButtonShape;
/**
 * Default background color for the On-screen menu div element.
 */
export declare const defaultOsmBackgroundColor = "#363636";
/**
 * Enum for various types of pre-defined positions that On-Screen Menu button can take.
 */
export declare enum OSMPosition {
    TopRight = 0,
    TopLeft = 1,
    BottomLeft = 2,
    BottomRight = 3
}
/** @internal */
export interface OnScreenMenuIconSet {
    ZoomIn: string | SpriteImagePosition;
    ZoomInX: string | SpriteImagePosition;
    ZoomInY: string | SpriteImagePosition;
    ZoomOut: string | SpriteImagePosition;
    ZoomOutX: string | SpriteImagePosition;
    ZoomOutY: string | SpriteImagePosition;
    ZoomToFit: string | SpriteImagePosition;
    EnableAnimation: string | SpriteImagePosition;
    DisableAnimation: string | SpriteImagePosition;
    CollapseMenu: string | SpriteImagePosition;
    ShowMenu: string | SpriteImagePosition;
}
/**
 *
 * A collection of default *library color theme* implementations.
 *
 * Color theme of components must be specified when it is created, and can't be changed afterwards (without destroying and recreating the component):
 *
 * ```js
 *  // Example syntax, create ChartXY with specific color theme.
 *  const chart = lightningChart().ChartXY({
 *      theme: Themes.darkTurquoise,
 *  })
 * ```
 *
 * LCJS default theme is [[darkGold]].
 */
export interface Themes {
    /**
     * A predominantly dark theme.
     *
     * For a more polished and impressive looking dark theme, see [[darkGold]].
     *
     * @deprecated  Will be removed in v.4.0. For a suitable long term supported option, see [[darkGold]].
     */
    dark: Theme;
    /**
     * Theme with light backgrounds.
     *
     * For a more polished and impressive looking dark theme, see [[lightNew]].
     */
    light: Theme;
    /**
     * Dark theme with gradients
     *
     * @deprecated  Will be removed in v.4.0. For a suitable long term supported option, see [[darkGold]].
     */
    darkGradient: Theme;
    /**
     * Light theme with gradients
     *
     * @deprecated  Will be removed in v.4.0. For a suitable long term supported option, see [[lightNew]].
     */
    lightGradient: Theme;
    /**
     * Aurora Borealis theme
     *
     * For a more polished and impressive looking dark theme, see [[auroraBorealisNew]].
     */
    auroraBorealis: Theme;
    /**
     * Sunset Theme
     *
     * @deprecated  Will be removed in v.4.0. For a suitable long term supported option, see [[darkRed]].
     */
    sunset: Theme;
    /**
     * Blue SciFi Theme
     *
     * For a more polished and impressive looking dark theme, see [[blueSciFiNew]].
     */
    blueSciFi: Theme;
    /**
     * Monochrome Theme
     *
     * @deprecated  Will be removed in v.4.0. For a suitable long term supported option, see [[darkGold]].
     */
    monochrome: Theme;
    /**
     * Cool lavender theme
     *
     * @deprecated  Will be removed in v.4.0. For a suitable long term supported option, see [[darkMagenta]].
     */
    lavender: Theme;
    /**
     * Cool lavender theme with gradients
     *
     * @deprecated  Will be removed in v.4.0. For a suitable long term supported option, see [[darkMagenta]].
     */
    lavenderGradient: Theme;
    /**
     * Relaxing and earth-like theme
     *
     * @deprecated  Will be removed in v.4.0. For a suitable long term supported option, see [[rockyMountains]].
     */
    classic: Theme;
    /**
     * Colorful dark theme
     *
     * @deprecated  Will be removed in v.4.0. For a suitable long term supported option, see [[darkGold]].
     */
    night: Theme;
    /**
     * Dark theme with pink
     *
     * @deprecated  Will be removed in v.4.0. For a suitable long term supported option, see [[darkRed]].
     */
    raspberry: Theme;
    /**
     * Dark gradient theme with pink
     *
     * @deprecated  Will be removed in v.4.0. For a suitable long term supported option, see [[darkRed]].
     */
    lipstick: Theme;
    /**
     * Green theme
     *
     * @deprecated  Will be removed in v.4.0. For a suitable long term supported option, see [[darkLime]].
     */
    green: Theme;
    /**
     * Light green theme
     *
     * @deprecated  Will be removed in v.4.0. For a suitable long term supported option, see [[lightNature]].
     */
    lightGreen: Theme;
    /**
     * Red theme
     *
     * @deprecated  Will be removed in v.4.0. For a suitable long term supported option, see [[darkRed]].
     */
    red: Theme;
    /**
     * Light red theme
     *
     * @deprecated  Will be removed in v.4.0. For a suitable long term supported option, see [[lightNew]].
     */
    lightRed: Theme;
    /**
     * Purple theme
     *
     * @deprecated  Will be removed in v.4.0. For a suitable long term supported option, see [[darkMagenta]].
     */
    purple: Theme;
    /**
     * Light purple theme
     *
     * @deprecated  Will be removed in v.4.0. For a suitable long term supported option, see [[lightNew]].
     */
    lightPurple: Theme;
    /**
     * Rainbow theme
     *
     * @deprecated  Will be removed in v.4.0. For a suitable long term supported option, see [[cyberSpace]].
     */
    rainbow: Theme;
    /**
     * Default dark color Theme with chart colors starting from golden yellow and shifting towards soft red colors.
     *
     * **DarkGold Theme is the current default LightningChart JS color theme**.
     *
     * For more similar variants of dark color themes, see:
     * - [[darkGreen]]
     * - [[darkLime]]
     * - [[darkMagenta]]
     * - [[darkRed]]
     * - [[darkTurquoise]]
     */
    darkGold: Theme;
    /**
     * Default dark color Theme with chart colors starting from bright green.
     *
     * For more similar variants of dark color themes, see:
     * - [[darkGold]]
     * - [[darkLime]]
     * - [[darkMagenta]]
     * - [[darkRed]]
     * - [[darkTurquoise]]
     */
    darkGreen: Theme;
    /**
     * Default dark color Theme with chart colors starting from bright lime.
     *
     * For more similar variants of dark color themes, see:
     * - [[darkGold]]
     * - [[darkGreen]]
     * - [[darkMagenta]]
     * - [[darkRed]]
     * - [[darkTurquoise]]
     */
    darkLime: Theme;
    /**
     * Default dark color Theme with chart colors starting from bright magenta.
     *
     * For more similar variants of dark color themes, see:
     * - [[darkGold]]
     * - [[darkGreen]]
     * - [[darkLime]]
     * - [[darkRed]]
     * - [[darkTurquoise]]
     */
    darkMagenta: Theme;
    /**
     * Default dark color Theme with chart colors starting from bright red.
     *
     * For more similar variants of dark color themes, see:
     * - [[darkGold]]
     * - [[darkGreen]]
     * - [[darkLime]]
     * - [[darkMagenta]]
     * - [[darkTurquoise]]
     */
    darkRed: Theme;
    /**
     * Default dark color Theme with chart colors starting from bright turquoise.
     *
     * For more similar variants of dark color themes, see:
     * - [[darkGold]]
     * - [[darkGreen]]
     * - [[darkLime]]
     * - [[darkMagenta]]
     * - [[darkRed]]
     */
    darkTurquoise: Theme;
    /**
     * Default **dark** color Theme with natural green and brown shaded colors.
     */
    darkNature: Theme;
    /**
     * Vibrant default color Theme with light blue data colors above darker blue backgrounds with impactful highlight gradients.
     *
     * NOTE: In v.4.0, this will be renamed to `blueSciFi` and the old `blueSciFi` theme will be permanently removed.
     */
    blueSciFiNew: Theme;
    /**
     * Default **light** color Theme with blue and red data colors.
     *
     * NOTE: In v.4.0, this will be renamed to `light` and the old `light` theme will be permanently removed.
     */
    lightNew: Theme;
    /**
     * Beautiful default **light** color Theme with chilling blue shaded backgrounds, white gradients and flat data colors with high contrast.
     */
    glacier: Theme;
    /**
     * Default **light** color Theme with natural green and brown shaded colors.
     */
    lightNature: Theme;
    /**
     * Wild default color Theme with bright blue background with an impactful red gradient at the top of chart.
     * Data colors shift through a vibrant color palette, starting from red. Each chart is highlighted with a bright white spot of highlight.
     *
     * DuskInLapland Theme is not designed for production level charts, but more for impactful highlights during application proof of concept development and LightningChart marketing.
     */
    duskInLapland: Theme;
    /**
     * Wild default color Theme with bright colors and beautiful gradient backgrounds imitating the Finnish natural phenomenon known as _aurora borealis_.
     *
     * AuroraBorealis Theme is not designed for production level charts, but more for impactful highlights during application proof of concept development and LightningChart marketing.
     *
     * NOTE: In v.4.0, this will be renamed to `auroraBorealis` and the old `auroraBorealis` theme will be permanently removed.
     */
    auroraBorealisNew: Theme;
    /**
     * Wild default color Theme with bright colors and extravagant gradient backgrounds with shades of cyan and magenta.
     *
     * CyberSpace Theme is not designed for production level charts, but more for impactful highlights during application proof of concept development and LightningChart marketing.
     */
    cyberSpace: Theme;
}
/**
 *
 * A collection of default *library color theme* implementations.
 *
 * Color theme of components must be specified when it is created, and can't be changed afterwards (without destroying and recreating the component):
 *
 * ```js
 *  // Example syntax, create ChartXY with specific color theme.
 *  const chart = lightningChart().ChartXY({
 *      theme: Themes.darkTurquoise,
 *  })
 * ```
 *
 * LCJS default theme is [[darkGold]].
 *
 * See [[Themes]] for more information for all different themes.
 */
export declare const Themes: Themes;
/**
 * PUBLIC !
 * File contains interfaces and enums used in UI system.
 */
/**
 * Enum that is used to specify a relative area inside an UI element.
 *
 * Probably not needed in user applications.
 */
export declare enum UISpace {
    /**
     * Smallest area, equal to the UiElements respective visual content
     */
    Content = 0,
    /**
     * Content + Padding, area that should be contained within Backgrounds border
     */
    PaddedContent = 1,
    /**
     * Content + Padding + Background padding
     */
    PaddedBackground = 2,
    /**
     * Content + Padding + Background padding + Margin
     */
    Everything = 3
}
/**
 * Enum for selecting visibility of parts of *Marker*s. Each part can be configured individually:
 *
 * Example usage:
 * ```javascript
 * // Hide part
 * SeriesMarkerXY.setTickMarkerYVisibility( UIVisibilityModes.never )
 * // Show part when pointed
 * ChartMarkerXY.setResultTableVisibility( UIVisibilityModes.whenHovered )
 * ```
 */
export declare enum UIVisibilityModes {
    /**
     * Part is never visible
     */
    never = 0,
    /**
     * Part is always visible
     */
    always = 1,
    /**
     * Part is visible when Marker is hovered with mouse and not being dragged
     */
    whenHovered = 2,
    /**
     * Part is visible when Marker is being dragged with mouse
     */
    whenDragged = 3,
    /**
     * Part is visible when Marker is not being dragged with mouse
     */
    whenNotDragged = 4,
    /**
     * Part is visible when Marker is hovered with mouse or dragged
     */
    whenHoveredOrDragged = 5
}
/**
 * Enum for selecting behavior of dragging interactions of *UIElements*. Dragging can be done by both mouse and touch.
 *
 * Use with [[UIElement.setDraggingMode]]
 */
export declare enum UIDraggingModes {
    /**
     * *UIElement* is not draggable.
     */
    notDraggable = 0,
    /**
     * *UIElement* is draggable.
     */
    draggable = 1,
    /**
     * *UIElement* is only draggable on horizontal plane.
     */
    onlyHorizontal = 2,
    /**
     * *UIElement* is only draggable on vertical plane.
     */
    onlyVertical = 3
}
/**
 * Interface for object that can be dragged by mouse.
 * @hidden
 */
export interface Draggable {
    /**
     * Set dragging mode of object. Defines how the object can be dragged by mouse.
     *
     * See [[UIDraggingModes]] collection for options.
     * @param       draggingMode    DraggingMode or undefined to disable dragging
     * @returns                     Object itself
     */
    setDraggingMode(draggingMode?: UIDraggingModes): this;
    /**
     * Get dragging mode of object.
     * Defines how the object can be dragged by mouse.
     * @returns                     Object itself
     */
    getDraggingMode(): UIDraggingModes;
}
/**
 * Enum for specifying a direction. Used for styling *Pointable* *UIElements*.
 */
export declare enum UIDirections {
    Up = 0,
    Right = 1,
    Down = 2,
    Left = 3
}
/**
 * Interface for UI elements used for CustomTick Markers.
 *
 * A Pointable has two components: a label and a pointer.
 */
export interface Pointable {
    /**
     * NOTE: Internal method, usage is not encouraged.
     * @hidden
     */
    setDirection(direction: UIDirections): this;
    /**
     * NOTE: Internal method, usage is not encouraged.
     * @hidden
     */
    getDirection(): UIDirections;
    /**
     * NOTE: Usage is not encouraged, please use [[CustomTick.setTickLength]]
     * @hidden
     */
    setPointerLength(length: pixel): this;
    /**
     * NOTE: Usage is not encouraged, please use [[CustomTick.getTickLength]]
     * @hidden
     */
    getPointerLength(): pixel;
    /**
     * NOTE: Usage is not encouraged, please use [[CustomTick.setTickLabelPadding]]
     * @hidden
     */
    setTickLabelPadding(margin: pixel): this;
    /**
     * NOTE: Usage is not encouraged, please use [[CustomTick.getTickLabelPadding]]
     * @hidden
     */
    getTickLabelPadding(): pixel;
}
/**
 * Interface for object that can be rendered as part of UI.
 * @hidden
 */
export interface Plotable {
}
/**
 * Event handler for mouse move
 * @param   obj             Object
 * @param   event           Browser MouseEvent that triggered the event
 */
export declare type MouseEventHandler<T> = (obj: T, event: MouseEvent) => void;
/**
 * Event handler for mouse event that is 'abrupt'.
 * Meaning that the event can be triggered as a side-effect of something totally unrelated, without an actual mouse-event.
 * ( Designed for making sure that mouse-leave is handled when hovered entity is disposed )
 * @param   obj             Object
 * @param   event           Browser MouseEvent that triggered the event of undefined if event is abrupt
 */
export declare type AbruptMouseEventHandler<T> = (obj: T, event?: MouseEvent) => void;
/**
 * Event handler for mouse drag start
 * @param   obj             Object
 * @param   event           Browser MouseEvent that triggered the event
 * @param   button          Button that is being held down
 */
export declare type MouseDragStartEventHandler<T> = (obj: T, event: MouseEvent, button: number) => void;
/**
 * Event handler for mouse drag
 * @param   obj             Object
 * @param   event           Browser MouseEvent that triggered the event
 * @param   button          Button that is being held down
 * @param   startLocation   Start location of mouse
 * @param   delta           Dragged delta
 */
export declare type MouseDragEventHandler<T> = (obj: T, event: MouseEvent, button: number, startLocation: Point, delta: Point) => void;
/**
 * Event handler for mouse drag
 * @param   obj             Object
 * @param   event           Browser MouseEvent that triggered the event
 * @param   button          Button that is being held down
 * @param   startLocation   Start location of mouse
 */
export declare type MouseDragStopEventHandler<T> = (obj: T, event: MouseEvent, button: number, startLocation: Point) => void;
/**
 * Event handler for mouse wheel
 * @param   obj             Object
 * @param   event           Browser WheelEvent that triggered the event
 */
export declare type MouseWheelEventHandler<T> = (obj: T, event: WheelEvent) => void;
/**
 * Event handler for pointer event (touch)
 * @param   obj             Object
 * @param   event           Browser PointerEvent that triggered the event
 */
export declare type TouchEventHandler<T> = (obj: T, event: ExtendedPointerEvent) => void;
/**
 * Interface for object that can have mouse-event-subscriptions.
 * @hidden
 */
export interface Interactable {
    /**
     * Set mouse interactions enabled or disabled
     * @param state Specifies state of mouse interactions
     * @return      Object itself for fluent interface
     */
    setMouseInteractions(state: boolean): this;
    /**
     * @return Mouse interactions state
     */
    getMouseInteractions(): boolean;
    /**
     * Subscribe on Mouse Enter event
     * @param   listener    Event handler function
     * @returns             Token of subscription
     */
    onMouseEnter(listener: MouseEventHandler<this>): Token;
    /**
     * Subscribe on Mouse Enter leave
     * @param   listener    Event handler function
     * @returns             Token of subscription
     */
    onMouseLeave(listener: AbruptMouseEventHandler<this>): Token;
    /**
     * Subscribe on Mouse Enter click
     * @param   listener    Event handler function
     * @returns             Token of subscription
     */
    onMouseClick(listener: MouseEventHandler<this>): Token;
    /**
     * Subscribe to Mouse Double Click event
     * @param   listener    Event handler function
     * @returns             Token of subscription
     */
    onMouseDoubleClick(listener: MouseEventHandler<this>): Token;
    /**
     * Subscribe to Mouse Down event
     * @param   listener    Event handler function
     * @returns             Token of subscription
     */
    onMouseDown(listener: MouseEventHandler<this>): Token;
    /**
     * Subscribe to Mouse Up event
     * @param   listener    Event handler function
     * @returns             Token of subscription
     */
    onMouseUp(listener: MouseEventHandler<this>): Token;
    /**
     * Subscribe to Mouse Move event
     * @param   listener    Event handler function
     * @returns             Token of subscription
     */
    onMouseMove(listener: MouseEventHandler<this>): Token;
    /**
     * Subscribe to Mouse Drag Start event
     * @param   listener    Event handler function
     * @returns             Token of subscription
     */
    onMouseDragStart(listener: MouseDragStartEventHandler<this>): Token;
    /**
     * Subscribe to Mouse Drag event
     * @param   listener    Event handler function
     * @returns             Token of subscription
     */
    onMouseDrag(listener: MouseDragEventHandler<this>): Token;
    /**
     * Subscribe to Mouse Drag Stop event
     * @param   listener    Event handler function
     * @returns             Token of subscription
     */
    onMouseDragStop(listener: MouseDragStopEventHandler<this>): Token;
    /**
     * Subscribe to Mouse Wheel event
     * @param   listener    Event handler function
     * @returns             Token of subscription
     */
    onMouseWheel(listener: MouseWheelEventHandler<this>): Token;
    /**
     * Subscribe to Touch Start event
     * @param   listener    Event handler function
     * @returns             Token of subscription
     */
    onTouchStart(listener: TouchEventHandler<this>): Token;
    /**
     * Subscribe to Touch Move event
     * @param   listener    Event handler function
     * @returns             Token of subscription
     */
    onTouchMove(listener: TouchEventHandler<this>): Token;
    /**
     * Subscribe to Touch End event
     * @param   listener    Event handler function
     * @returns             Token of subscription
     */
    onTouchEnd(listener: TouchEventHandler<this>): Token;
    /**
     * Remove event listener from Mouse Enter Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseEnter(token: Token): boolean;
    /**
     * Remove event listener from Mouse Leave Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseLeave(token: Token): boolean;
    /**
     * Remove event listener from Mouse Click Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseClick(token: Token): boolean;
    /**
     * Remove event listener from Mouse Double Click Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseDoubleClick(token: Token): boolean;
    /**
     * Remove event listener from Mouse Down Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseDown(token: Token): boolean;
    /**
     * Remove event listener from Mouse Up Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseUp(token: Token): boolean;
    /**
     * Remove event listener from Mouse Move Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseMove(token: Token): boolean;
    /**
     * Remove event listener from Mouse Drag start Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseDragStart(token: Token): boolean;
    /**
     * Remove event listener from Mouse Drag Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseDrag(token: Token): boolean;
    /**
     * Remove event listener from Mouse Drag stop Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseDragStop(token: Token): boolean;
    /**
     * Remove event listener from Mouse Wheel Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseWheel(token: Token): boolean;
    /**
     * Remove event listener from Touch Start Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offTouchStart(token: Token): boolean;
    /**
     * Remove event listener from Touch Move Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offTouchMove(token: Token): boolean;
    /**
     * Remove event listener from Touch End Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offTouchEnd(token: Token): boolean;
}
/**
 * Interface for object that can be switched on/off and that can have respective event-subscriptions
 * @hidden
 */
export interface Switchable {
    /**
     * Set state of switchable object.
     *
     * **NOTE: If *Switchable*.getLocked() == true, this method will not do anything.!**
     * @param isOn  State as boolean flag
     * @returns     Object itself for fluent interface
     */
    setOn(isOn: boolean): this;
    /**
     * @return State as boolean flag
     */
    getOn(): boolean;
    /**
     * Set whether *Switchable* is locked or not. When locked, *Switchable*.setOn() is disabled.
     * @param isLocked state
     * @returns State as boolean flag
     */
    setLocked(isLocked: boolean): this;
    /**
     * @returns State of isLocked boolean flag
     */
    getLocked(): boolean;
    /**
     * Subscribe to Switch event
     * @return      Token of subscription
     */
    onSwitch(listener: (obj: this, state: boolean) => void): Token;
    /**
     * Remove event listener from Switch event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offSwitch(token: Token): boolean;
}
/**
 * Interface for an object that can be highlighted.
 * @hidden
 */
export interface Highlightable {
    /**
     * Set highlighted state of the Object
     * @param isHighlighted Highlight state of the object
     * @returns             Object itself for fluent interface
     */
    setHighlighted(isHighlighted: boolean): this;
    /**
     * @return True for highlighted state of object and false for basic
     */
    getHighlighted(isHighlighted: boolean): boolean;
    /**
     * Subscribe to highlight object event. This is called whenever an object is highlighted.
     * @param   handler         Function that is called when event is triggered.
     * @param   isHighlighted   The Highlight state.
     * @return                  Token that can be used to unsubscribe from the event.
     */
    onHighlight(handler: (isHighlighted: boolean) => void): Token;
    /**
     * Unsubscribe from Highlight object event. This is called whenever an object is highlighted
     * @param   token       Token that was received when subscribing to the event.
     * @return              True if the unsubscription was successful.
     */
    offHighlight(token: Token): boolean;
}
/**
 * Indicates object which can have margin.
 * Margin is empty space around element content (including background if any)
 * @hidden
 */
export interface Marginable {
    /**
     * Set margin around object in pixels.
     * @param   margin      Number with pixel margins for all sides or datastructure with individual pixel margins
     *                      for each side. Any side can be omitted, only passed values will be overridden.
     * @return              Object itself
     */
    setMargin(margin: Partial<MMargin> | number): this;
    /**
     * Get margin around object in pixels.
     * @return  Margin datastructure
     */
    getMargin(): Margin;
}
/**
 * Interface that provides styling methods for some component.
 * @hidden
 */
export interface StylableComponent {
    /**
     * Set fill style
     * @param value Fill style object or function which modifies it
     * @return      Object itself for fluent interface
     */
    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * @return Current fill style
     */
    getFillStyle(): FillStyle;
    /**
     * Set fill style object when highlighted
     * @param value Fill style object or mutator to modify existing one or undefined for auto assignment
     * @return      Object itself for fluent interface
     */
    setFillStyleHighlight(value: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * @return Current fill style object when highlighted or undefined for auto assignment
     */
    getFillStyleHighlight(): FillStyle | undefined;
}
/**
 * Interface that provides styling methods for some text component.
 * @hidden
 */
export interface StylableTextComponent extends StylableComponent {
    /**
     * Set font of text.
     * @param   value   FontSettings or mutator function for existing settings
     * @return          Object itself
     */
    setFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
    /**
     * Get font of text.
     * @return          FontSettings
     */
    getFont(): FontSettings;
    /**
     * Set rotation of text.
     * @param value Rotation in degrees
     * @returns Object itself
     */
    setTextRotation(value: number): this;
    /**
     * Get rotation of text.
     * @returns Rotation in degrees
     */
    getTextRotation(): number;
}
/**
 * Interface for an object that has stylable background.
 * @hidden
 */
export interface StylableBackground<BackgroundType extends UIBackground = UIBackground> extends Highlightable {
    /**
     * Method for mutating Background of object.
     *
     * Type of Background is generic, see [[UIBackground]] for minimum interface.
     * @param   mutator Mutator function for Background
     * @return          Object itself for fluent interface
     */
    setBackground(mutator: Mutator<BackgroundType>): this;
    /**
     * Get elements Background object
     *
     * Type of Background is generic, see [[UIBackground]] for minimum interface.
     * @returns     Background object
     */
    getBackground(): BackgroundType;
    /**
     * Set padding around object in pixels.
     * Padding is empty space between the UiElements content and Background
     * @param   padding     Number with pixel margins for all sides or datastructure with individual pixel paddings
     *                      for each side. Any side can be omitted, only passed values will be overridden.
     * @return              Object itself
     */
    setPadding(padding: Partial<Margin> | number): this;
    /**
     * Get padding around object in pixels.
     * Padding is empty space between the UiElements content and Background
     * @return  Margin datastructure
     */
    getPadding(): Margin;
}
/**
 * @hidden
 */
export interface GettableText {
    /**
     * Get the text of the entire shape.
     * @returns             The entire text string.
     */
    getText(): string;
}
/**
 * @hidden
 */
export interface SettableText {
    /**
     * Set the text of the entire shape.
     * @param   text    Text string.
     */
    setText(text: string): this;
}
/**
 * Styling API for "Text" component.
 * @hidden
 */
export interface StyleTextAPI {
    /**
     * Set text fill style object
     * @param value Fill style object or function which modifies it
     * @return      Object itself for fluent interface
     */
    setTextFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * @return Current text fill style object
     */
    getTextFillStyle(): FillStyle;
    /**
     * Set font of Label.
     * @param   value   FontSettings or mutator function for existing settings
     * @return          Object itself
     */
    setTextFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
    /**
     * Get font of Label.
     * @return          FontSettings
     */
    getTextFont(): FontSettings;
    /**
     * Set rotation of Label.
     * @param value Rotation in degrees
     * @returns Object itself
     */
    setTextRotation(rotation: number): this;
    /**
     * Get rotation of Label.
     * @returns Rotation in degrees
     */
    getTextRotation(): number;
}
/**
 * Interface for object that has stylable and settable text.
 * @hidden
 */
export declare type CustomizableText = StyleTextAPI & GettableText & SettableText;
/**
 * Interface for object that has configurations for style of button.
 * @hidden
 */
export interface StylableButton {
    /**
     * Set fill style of Button when state is OFF
     * @param   value   Fill style object or function which modifies it
     * @return          Object itself for fluent interface
     */
    setButtonOffFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of Button when state is OFF
     * @return  Fill style object
     */
    getButtonOffFillStyle(): FillStyle;
    /**
     * Set highlighted fill style of Button when state is OFF
     * @param value     FillStyle for highlighted object or function which modifies it or undefined for auto assignment
     */
    setButtonOffFillStyleHighlight(value: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * Get highlighted fill style of Button when state is OFF
     * @return  Fill style object or undefined for auto assignment
     */
    getButtonOffFillStyleHighlight(): FillStyle | undefined;
    /**
     * Set style of Button when state is OFF
     * @param   lineStyle       Style object or function which modifies it
     * @return                  Object itself for fluent interface
     */
    setButtonOffStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of Button when state is OFF
     * @return  Line style object
     */
    getButtonOffStrokeStyle(): LineStyle;
    /**
     * Set size of Button when state is OFF
     * @param   size    Point or pixel for squared button size
     * @return          Object itself
     */
    setButtonOffSize(size: Point | pixel): this;
    /**
     * Get size of Button when state is OFF
     * @return          Size of button as Point
     */
    getButtonOffSize(): Point;
    /**
     * Set fill style of Button when state is ON
     * @param   value   Fill style object or function which modifies it
     * @return          Object itself for fluent interface
     */
    setButtonOnFillStyle(value: FillStyle | Mutator<FillStyle>): this;
    /**
     * Get fill style of Button when state is ON
     * @return  Fill style object
     */
    getButtonOnFillStyle(): FillStyle;
    /**
     * Set highlighted fill style of Button when state is ON
     * @param style     FillStyle for highlighted object or function which modifies it or undefined for auto assignment
     */
    setButtonOnFillStyleHighlight(style: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * Get highlighted fill style of Button when state is ON
     * @return  Fill style object or undefined for auto assignment
     */
    getButtonOnFillStyleHighlight(): FillStyle | undefined;
    /**
     * Set style of Button when state is ON
     * @param   lineStyle       Line style object or function which modifies it
     * @return                  Object itself for fluent interface
     */
    setButtonOnStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of Button when state is ON
     * @return  Line style object
     */
    getButtonOnStrokeStyle(): LineStyle;
    /**
     * Set size of Button when state is ON
     * @param   size    Point or pixel for squared button size
     * @return          Object itself
     */
    setButtonOnSize(size: Point | pixel): this;
    /**
     * Get size of Button when state is ON
     * @return          Size of button as Point
     */
    getButtonOnSize(): Point;
}
/**
 * Interface for describing *auto dispose mode* of an UI element.
 *
 * Can be used to set a condition, where the UI element is automatically *disposed*, removing it from view.
 * Use with [[UIElement.setAutoDisposeMode]].
 *
 * ```ts
 *  // Example, remove UI element when it is larger than 20% of viewport.
 *  UIElement.setAutoDisposeMode({
 *      type: 'max-width',
 *      maxWidth: 0.20,
 *  })
 * ```
 */
export declare type AutoDisposeMode = undefined | {
    type: 'max-width';
    maxWidth: number;
} | {
    type: 'max-height';
    maxHeight: number;
};
/**
 * Three-dimensional Axis, that resides inside Chart3D.
 * Can be either X, Y or Z. There is always exactly one Axis3D object for each dimension in a Chart3D.
 *
 * *Axes* have automatic scrolling logic to fit attached *Series*.
 * This can be modified with *Axis*.**setScrollStrategy()**
 *
 * *Axes* are associated with a title, which can be enabled with *Axis*.**setTitle()**
 */
export declare class Axis3D extends GenericAxis<UnitScale, Chart3D, Series3D, AxisStrategy3D, Tick3D, Tick3DPlottingVariables, TickSpecificPlottingVariables> {
    /**
     * Set style of Axis line stroke.
     *
     * ```ts
     *  // Example syntax, specify LineStyle
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorHEX('#F00') })
     *  }))
     * ```
     *
     * ```ts
     *  // Example syntax, change thickness only
     *  Axis.setStrokeStyle((stroke) => new SolidLine({ ...stroke, thickness: 5 }))
     * ```
     *
     * **Supported fill styles:**
     *
     * [[SolidFill]]:
     *
     * Solid fill color.
     *
     * ```ts
     *  // Example, solid colored line.
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
     *  }))
     * ```
     *
     * To learn more about available *Color* factories, see [[ColorRGBA]]
     *
     * [[PalettedFill]]:
     *
     * Color line stroke dynamically based on `x`, `y` or `z` coordinate.
     *
     * ```ts
     *  // Example, dynamic color by Y coordinates
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new PalettedFill({
     *          lookUpProperty: 'y',
     *          lut: new LUT({
     *              interpolate: true,
     *              steps: [
     *                  { value: 0, color: ColorRGBA(255, 0, 0) },
     *                  { value: 10, color: ColorRGBA(0, 255, 0) },
     *              ]
     *          })
     *      })
     *  }))
     * ```
     *
     * To learn more about Color lookup tables, see [[LUT]].
     *
     * [[LinearGradientFill]]:
     *
     * Color line stroke with a linear configurable gradient palette.
     *
     * ```ts
     *  // Example, linear gradient line color
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new LinearGradientFill()
     *  }))
     * ```
     *
     * To learn more about linear gradient configurations, see [[LinearGradientFill]].
     *
     * [[RadialGradientFill]]:
     *
     * Color line stroke with a radial configurable gradient palette.
     *
     * ```ts
     *  // Example, radial gradient line color
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new RadialGradientFill()
     *  }))
     * ```
     *
     * To learn more about radial gradient configurations, see [[RadialGradientFill]].
     *
     * @param   value   Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
     * @returns         Object itself for fluent interface.
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * @return          Style of Axis line.
     */
    getStrokeStyle(): LineStyle;
    /**
     * Specifies scroll animation.
     * Scroll animations can cause slow-downs with 3D charts with large amounts of data shown in the 3D chart.
     * @param   enabled     Boolean flag for whether scrolling should be animated or not.
     */
    setAnimationScroll(enabled: boolean | undefined): this;
    /**
     * Enable / disable all interactions of Axis.
     * @param   enabled Interactions enabled or not.
     * @return          Object itself for fluent interface.
     */
    setMouseInteractions(enabled: boolean): this;
    /**
     * Debugging methods.
     */
    private isX;
    /**
     * Debugging method.
     */
    private isY;
    /**
     * Debugging method.
     */
    private isZ;
}
/**
 * Implementation specific values necessary for tick plotting.
 * @hidden
 */
interface Tick3DPlottingVariables extends AbstractTickPlottingVariables {
    /**
     *
     */
    wuSize: Point3D;
    /**
     *
     */
    start: Point3D;
    /**
     *
     */
    end: Point3D;
    /**
     *
     */
    tickDirection3D: Point3D;
    /**
     *
     */
    tickDirection2D: Point;
    /**
     *
     */
    gridlinePositionA: Point3D;
    /**
     *
     */
    gridlinePositionB: Point3D;
    /**
     *
     */
    gridlinePositionC: Point3D;
}
/**
 * Variables calculated for each tick when plotting.
 *
 * Label : tick line + grid line positioning is split into two distinct phases for rendering optimizations,
 * these values are calculated when positioning the label and carried over to the line positioning phase.
 * @hidden
 */
interface TickSpecificPlottingVariables {
    posTickEnd3D: Point3D;
    posTickStart3D: Point3D;
    tickPositionRelative: number;
}
/**
 * Implementation of 3D Axis Tick.
 *
 * Tick doesn't contain any positioning logic, that is done in Axis !
 * @hidden
 */
export declare class Tick3D extends AbstractAxisTick {
    protected readonly _gridlineLayer: Layer3D;
    /**
     * @param   tickLevel       AxisTickLevel tick belongs to.
     * @param   value           Position of Tick on Axis.
     * @param   _removeFromAxis Remove handler for Tick.
     * @param   _restoreToAxis  Restore handler for Tick.
     * @param   _labelLayer     Layer for rendering Tick Label.
     * @param   _labelScale     Scale for rendering Tick label.
     * @param   _gridlineLayer  Rendering layer for 3D gridline.
     * @param   label           Optionally injectable Tick Label shape.
     *                          Injection can be useful to reuse Tick shapes for performance.
     */
    constructor(tickLevel: AxisTickLevel, value: number, _removeFromAxis: RemoveHandler<AbstractAxisTick>, _restoreToAxis: RestoreHandler<AbstractAxisTick>, _labelLayer: Layer2D, _labelScale: LinearScaleXY | MixedScaleXY, _gridlineLayer: Layer3D, label?: Text);
}
export {};
/**
 * Interface for a strategy which represents the logic that is different between X, Y and Z Axes.
 */
export interface AxisStrategy3D extends AbstractAxisStrategy<Series3D> {
}
/**
 * Chart for visualizing data in a 3-dimensional scene, with camera and light source(s).
 *
 * Camera can be moved around with user interactions (mouse & touch). It is always oriented to face the center of the scene.
 *
 * Light source is always located at the location of the Camera, and directed towards the center of *Axes*.
 *
 * Data can be added to the *Chart* via various *Series* types, each with their own method of visualization:
 *
 * ```javascript
 *  const pointLineSeries3D = chart3D.addPointLineSeries()
 *      .add( [
 *          { x: 0, y: 0, z: 0 },
 *          { x: 1, y: 0, z: 0 },
 *          { x: 2, y: 1, z: 0 }
 *      ] )
 * ```
 */
export declare class Chart3D extends ChartWithSeries<Series3D> implements ChartWithScrollingAnimations, ChartWithAxis<Axis3D>, ChartWithStylableSeriesBackground {
    /**
     * 3D Coordinate system selector to use with [[translatePoint3D]] function, which lets users translate coordinates between different 3D coordinate systems.
     *
     * ```js
     *  // Example, translate coordinate from Chart3D Axes to World Space.
     *  const coordWorld = translatePoint3D(
     *      // Coordinate on Axes.
     *      { x: 10, y: 5, z: 25 },
     *      // Source coordinate system.
     *      chart3D.axes,
     *      // Target coordinate system.
     *      chart3D.world
     *  )
     * ```
     *
     * The `axes` selector describes the coordinate system of 3D charts Axes (X, Y, Z).
     *
     * **About 3D coordinate systems:**
     *
     * `Chart3D` camera location is configured in World Space, which is currently the primary reason for interacting with different 3D coordinate systems.
     *
     * For example, depth sorting of transparent objects by rendering data based on their distance to the camera.
     *
     * Depth sorting is required for blending stacked transparent objects.
     */
    readonly axes: CoordinateSystemDefinition3D;
    /**
     * 3D Coordinate system selector to use with [[translatePoint3D]] function, which lets users translate coordinates between different 3D coordinate systems.
     *
     * ```js
     *  // Example, translate coordinate from Chart3D Axes to World Space.
     *  const coordWorld = translatePoint3D(
     *      // Coordinate on Axes.
     *      { x: 10, y: 5, z: 25 },
     *      // Source coordinate system.
     *      chart3D.axes,
     *      // Target coordinate system.
     *      chart3D.world
     *  )
     * ```
     *
     * The `world` selector describes 3D World Space.
     *
     * _3D world space_ is used for camera positioning, is centered at [0, 0, 0] and values generally range between += 5.
     *
     * **About 3D coordinate systems:**
     *
     * `Chart3D` camera location is configured in World Space, which is currently the primary reason for interacting with different 3D coordinate systems.
     *
     * For example, depth sorting of transparent objects by rendering data based on their distance to the camera.
     *
     * Depth sorting is required for blending stacked transparent objects.
     */
    readonly world: CoordinateSystemDefinition3D;
    /**
     * Method for adding a new `PointSeries3D` to the chart.
     * This series type for visualizing a collection of `{ x, y, z }` coordinates by different markers.
     *
     * `PointSeries3D` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
     *
     * - A static data set in millions data points range is rendered in hundreds of milliseconds (~200ms). Afterwards chart can be rotated and zoomed with 60 FPS.
     * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
     *
     * To learn more about its features and usage, refer to [[PointSeries3D]].
     *
     * **Readonly configuration:**
     *
     * Some properties of `PointSeries3D` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example,
     *  const pointCloudSeries3D = Chart3D.addPointSeries({
     *      // Specify point series type as point cloud.
     *      type: PointSeriesTypes3D.Pixelated
     *  })
     * ```
     *
     * To learn about available properties, refer to [[PointSeriesOptions3D]].
     *
     * @param   options         Optional object with readonly configuration arguments for `PointSeries3D`.
     * @return                  New series.
     */
    addPointSeries<T extends PointSeriesTypes3D = typeof PointSeries3D>(options?: PointSeriesOptions3D<T>): InstanceType<T>;
    /**
     * Method for adding a new `LineSeries3D` to the chart.
     * This Series type for visualizing a collection of `{ x, y, z }` coordinates by a continuous line stroke.
     *
     * `LineSeries3D` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
     *
     * - A static data set in millions data points range is rendered in hundreds of milliseconds (~200ms). Afterwards chart can be rotated and zoomed with 60 FPS.
     * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
     *
     * To learn more about its features and usage, refer to [[LineSeries3D]].
     *
     * @return                  New series.
     */
    addLineSeries(): LineSeries3D;
    /**
     * Method for adding a new `PointLineSeries3D` to the chart.
     * This Series type for visualizing a collection of `{ x, y, z }` coordinates by a continuous line stroke and markers.
     *
     * `PointLineSeries3D` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
     *
     * - A static data set in millions data points range is rendered in hundreds of milliseconds (~200ms). Afterwards chart can be rotated and zoomed with 60 FPS.
     * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
     *
     * To learn more about its features and usage, refer to [[PointLineSeries3D]].
     *
     * @return                  New series.
     */
    addPointLineSeries(): PointLineSeries3D;
    /**
     * Create Series for visualization of data by surfaces.
     *
     * Example usage:
     *
     * - **By default, creates *SurfaceGridSeries3D***
     * ```ts
     *  const gridSurface3D = Chart3D.addSurfaceSeries()
     * ```
     *
     * - **By specifying options object with *type*-property, the returned *Series*' class can be selected**
     * ```ts
     *  const meshSurface3D = Chart3D.addSurfaceSeries({
     *      type: SurfaceSeriesTypes3D.Mesh
     *  })
     * ```
     *
     * - **The easiest way to define Surface geometry is to invalidate it via a callback function**
     * ```ts
     * const resolution = 20
     * const grid = chart3D.addSurfaceSeries( {
     *     type: SurfaceSeriesTypes3D.Grid,
     *     rows: resolution,
     *     columns: resolution,
     *     start: { x: 0, z: 0 },
     *     end: { x: 100, z: 100 },
     *     pixelate: true
     * } )
     *     .invalidateYOnly( ( row, column, prev ) => {
     *         return Math.sin( row * 2 * Math.PI / resolution )
     *     } )
     *     .setFillStyle( new PalettedFill( {
     *          // Refer to "palette" examples for LUT creation.
     *          lut,
     *          lookUpProperty: 'y'
     *      } ) )
     * ```
     *
     * @param   options     Optional object for passing readonly parameters to configure the created *Series*.
     * @return  Created *Series*. If *options* were omitted or undefined, the *Series* type defaults to [[SurfaceGridSeries3D]], otherwise
     *          corresponds to class referenced by *options.type*.
     *
     * @deprecated          Old surface grid series implementation will be removed in v.4.0.0. Use [[addSurfaceGridSeries]] instead.
     *                      To keep using surface mesh series, use [[addSurfaceMeshSeries]].
     */
    addSurfaceSeries<T extends SurfaceSeriesTypes3D = typeof SurfaceGridSeries3D>(options: SurfaceSeriesOptions3D<T>): InstanceType<T>;
    /**
     * Add a Series for visualizing a *Surface Grid* with a static column and grid count. Has API for fast modification of cell Y and Intensity values.
     *
     * The grid is defined by imagining a plane along X and Z axis, split to < COLUMNS > (cells along X axis) and < ROWS > (cells along Z axis)
     *
     * The total amount of < CELLS > in a surface grid is calculated as `columns * rows`. Each < CELL > can be associated with DATA from an user data set.
     *
     * This series is optimized for *massive* amounts of data - here are some reference specs to give an idea:
     *
     * - A static data set in tens of millions range is rendered in a matter of seconds.
     * - A data set in tens of millions range can be updated in less than a second.
     * - Maximum data set size is entirely limited by available memory (RAM).
     *   Even billion (1 000 000 000) data points have been visualized on a personal computer.
     *   Interacting with massive surface charts (more than tens of millions data points) requires a powerful GPU !
     *
     * To learn more about its features and usage, refer to [[NewSurfaceGridSeries3D]].
     *
     *
     * **Readonly configuration:**
     *
     * Some properties of `NewSurfaceGridSeries3D` can only be configured when it is created. Some of these arguments are optional, while some are required.
     * They are all wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example,
     *  const surfaceGridSeries = Chart3D.addSurfaceGridSeries({
     *      columns: 100,
     *      rows: 200,
     *  })
     * ```
     *
     * To learn about these properties, refer to [[NewSurfaceGridSeries3DOptions]].
     *
     *
     * For *scrolling surface grid*, see [[addSurfaceScrollingGridSeries]].
     *
     * @param   options     Configuration parameters for Surface Grid Series.
     * @return              Surface Grid Series.
     */
    addSurfaceGridSeries(options: NewSurfaceGridSeries3DOptions): NewSurfaceGridSeries3D;
    /**
     * Add a Series for visualizing a *Surface Grid* with API for pushing data in a scrolling manner (append new data on top of existing data).
     *
     * The grid is defined by imagining a plane along X and Z axis, split to < COLUMNS > (cells along X axis) and < ROWS > (cells along Z axis)
     *
     * The total amount of < CELLS > in a surface grid is calculated as `columns * rows`. Each < CELL > can be associated with DATA from an user data set.
     *
     * This series is optimized for *massive* amounts of data - here are some reference specs to give an idea:
     *
     * - A data set of tens of millions data points is rendered in a matter of seconds.
     * - Maximum data set size is entirely limited by available memory (RAM).
     *   Even billion (1 000 000 000) data points have been visualized on a personal computer.
     *   Interacting with massive surface charts (more than tens of millions data points) requires a powerful GPU !
     * - Scrolling Surface Grid input stream rate is virtually unlimited - even 10 million incoming data points **per second** can easily be processed.
     *   Application limitations usually come from previously mentioned RAM and/or GPU bottlenecks.
     *
     * To learn more about its features and usage, refer to [[SurfaceScrollingGridSeries3D]].
     *
     *
     * **Readonly configuration:**
     *
     * Some properties of `SurfaceScrollingGridSeries3D` can only be configured when it is created. Some of these arguments are optional, while some are required.
     * They are all wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example,
     *  const surfaceScrollingGridSeries = Chart3D.addSurfaceScrollingGridSeries({
     *      columns: 100,
     *      rows: 200,
     *  })
     * ```
     *
     * To learn about these properties, refer to [[SurfaceScrollingGridSeries3DOptions]].
     *
     *
     * For *static surface grid*, see [[addSurfaceGridSeries]].
     *
     * @param   options     Configuration parameters for Surface Scrolling Grid Series.
     * @return              Surface Scrolling Grid Series.
     */
    addSurfaceScrollingGridSeries(options: SurfaceScrollingGridSeries3DOptions): SurfaceScrollingGridSeries3D;
    /**
     * Create Series for visualization of data by Surface Mesh.
     *
     * To learn more of capabilities and usage, see [[SurfaceMeshSeries3D]]
     *
     * @param   options     Optional object for passing readonly parameters to configure the created *Series*.
     * @return              SurfaceMeshSeries3D
     */
    addSurfaceMeshSeries(options: SurfaceOptions3D): SurfaceMeshSeries3D;
    /**
     * Create Series for visualization of large sets of individually configurable 3D *Boxes*.
     *
     * **Example usage:**
     *
     * ```ts
     *  // Construct a grid of vertical boxes.
     *  const data = [
     *      { x: 0, z: 0 },
     *      { x: 1, z: 0 },
     *      { x: 0, z: 1 },
     *      { x: 1, z: 1 }
     *  ]
     *      // Map coords into **BoxData**.
     *      .map( coords => {
     *      const height = Math.random() * 100
     *      return {
     *          xCenter: coords.x,
     *          yCenter: height / 2,
     *          zCenter: coords.z,
     *          xSize: 1,
     *          ySize: height,
     *          zSize: 1
     *      }
     *  })
     *  const chart = lightningChart().Chart3D()
     *  const boxSeries = chart.addBoxSeries()
     *      .invalidateData( data )
     * ```
     *
     * @return  BoxSeries3D.
     */
    addBoxSeries(): BoxSeries3D;
    /**
     * Get Axis X.
     * @return  Axis3D object.
     */
    getDefaultAxisX(): Axis3D;
    /**
     * Get Axis Y.
     * @return  Axis3D object.
     */
    getDefaultAxisY(): Axis3D;
    /**
     * Get Axis Z.
     * @return  Axis3D object.
     */
    getDefaultAxisZ(): Axis3D;
    /**
     * Convenience method to get a tuple of the Charts X, Y and Z axes.
     *
     * Equal to `[Chart3D.getDefaultAxisX(), Chart3D.getDefaultAxisY(), Chart3D.getDefaultAxisZ()]`
     *
     * Intended for conveniently applying same modifications to all axes.
     *
     * ```typescript
     * // Example, disable mouse interactions from all axes.
     * Chart3D.getDefaultAxes().forEach((axis) => axis.setMouseInteractions(false))
     * ```
     *
     * @returns     [Chart3D.getDefaultAxisX(), Chart3D.getDefaultAxisY(), Chart3D.getDefaultAxisZ()]
     */
    getDefaultAxes(): [Axis3D, Axis3D, Axis3D];
    /**
     * Set the location of camera in _World Space_, a coordinate system that is not tied to 3D Axes.
     *
     * The camera always faces (0, 0, 0) coordinate.
     *
     * The light source is always a set distance behind the camera.
     * @param   cameraLocation  Camera location in 3D space. Valid values are in the range **[1, 5]**.
     *                          Note, that placing the camera too close to the bounding box is restricted.
     */
    setCameraLocation(cameraLocation: Point3D): this;
    /**
     * Get the location of camera in _World Space_, a coordinate system that is not tied to 3D Axes.
     * @return                  Camera location in 3D space.
     */
    getCameraLocation(): Point3D;
    /**
     * Get the direction of camera in _World Space_, a coordinate system that is not tied to 3D Axes.
     *
     * The direction is set according to the location of the camera, so that it is facing (0, 0, 0).
     * @return                  Camera direction in 3D space. Always an unit vector.
     */
    getCameraDirection(): Point3D;
    /**
     * Set automatic camera fitting enabled. This is enabled as the default configuration.
     * Note that zooming in or out disables it automatically.
     * @param   enabled     Boolean.
     * @return              Object itself for fluent interface.
     */
    setCameraAutomaticFittingEnabled(enabled: boolean): Chart3D;
    /**
     * Get automatic camera fitting enabled. This is enabled as the default configuration.
     * Note that zooming in or out disables it automatically.
     * @return              Boolean.
     */
    getCameraAutomaticFittingEnabled(): boolean;
    /**
     * Subscribe to camera change event.
     *
     * This event is triggered whenever the location of `Chart3D` camera is changed.
     *
     * @handler     Callback function which is triggered on event. Receives two parameters: `chart`, and `cameraLocation`.
     * @return      Token which can be used with [[offCameraChange]] to unsubscribe the event handler.
     */
    onCameraChange(handler: (chart: Chart3D, cameraLocation: Point3D) => unknown): Token;
    /**
     * Unsubscribe from camera change event.
     *
     * This event is triggered whenever the location of `Chart3D` camera is changed.
     *
     * @param   token   Token which was received from [[onCameraChange]].
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offCameraChange(token: Token): boolean;
    /**
     * Set [[FillStyle]] of *series background* (area behind *series*).
     *
     * ```typescript
     *  // Example usage,
     *  Chart3D.setSeriesBackgroundFillStyle(new SolidFill({ color: ColorRGBA( 60, 0, 0 ) }))
     * ```
     *
     * **Related API:**
     * - Use [[SolidFill]] to describe a solid fill color.
     * - Use [[ColorRGBA]] to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
     *
     * @param   value       `FillStyle` or function which mutates the active `FillStyle`.
     * @return              Object itself
     */
    setSeriesBackgroundFillStyle(fillStyle: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get FillStyle of Series background area (area behind series).
     * @return              FillStyle
     */
    getSeriesBackgroundFillStyle(): FillStyle;
    /**
     * Set [[LineStyle]] of series background border stroke.
     *
     * ```typescript
     *  // Example usage,
     *  Chart3D.setSeriesBackgroundStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorRGBA( 0, 255, 0 ) })
     *  }))
     * ```
     *
     * **Related API:**
     * - Use [[SolidLine]] to describe a solid line style.
     * - Use [[SolidFill]] to describe a solid fill color.
     * - Use [[ColorRGBA]] to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
     *
     * @param   value       `LineStyle` or function which mutates the active `LineStyle`.
     * @return              Object itself
     */
    setSeriesBackgroundStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get Stroke style of Series background area (area behind series).
     * @return              LineStyle
     */
    getSeriesBackgroundStrokeStyle(): LineStyle;
    /**
     * Set style of 3D bounding box.
     *
     * The bounding box is a visual reference that all the data of the Chart is depicted inside of. The Axes of the
     * 3D chart are always positioned along the sides of the bounding box.
     *
     * Example usage:
     *
     * - **Specify explicit LineStyle object**
     * ```typescript
     *  Chart3D.setBoundingBoxStrokeStyle(new SolidLine({
     *      fillStyle: new SolidFill({ color: ColorHEX('#61ff61') }),
     *      thickness: 5
     *  }))
     * ```
     *
     * - **Modify default style**
     * ```typescript
     *  // Default value is SolidLine (note that a soft type cast is required for *TypeScript*).
     *  Chart3D.setBoundingBoxStrokeStyle(( line: SolidLine ) => line
     *      .setThickness( 10 )
     *  )
     * ```
     * @param   value   [[LineStyle]] object or function that modifies previous value.
     *                  Value defaults to [[SolidLine]].
     * @return          Object itself for fluent interface.
     */
    setBoundingBoxStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of 3D bounding box.
     *
     * The bounding box is a visual reference that all the data of the Chart is depicted inside of. The Axes of the
     * 3D chart are always positioned along the sides of the bounding box.
     *
     * @return  [[LineStyle]] object.
     */
    getBoundingBoxStrokeStyle(): LineStyle;
    /**
     * Set the dimensions of the Scenes bounding box.
     *
     * The bounding box is a visual reference that all the data of the Chart is depicted inside of. The Axes of the
     * 3D chart are always positioned along the sides of the bounding box.
     *
     * Example usage:
     * - **Symmetric bounding box**
     * ```javascript
     *  setBoundingBox( { x: 1.0, y: 1.0, z: 1.0 } )
     * ```
     * - **Bounding box whose Y dimension is 4 times that of the others**
     * ```javascript
     *  setBoundingBox( { x: 1.0, y: 4.0, z: 1.0 } )
     * ```
     *
     * @param   dimensions      Dimensions of bounding box. These values do not represent any "unit", only their relative
     *                          ratios are considered.
     * @return                  Object itself for fluent interface
     */
    setBoundingBox(dimensions: Point3D): this;
    /**
     * Get dimensions of Scenes "bounding box".
     * Bounding box defines the space allocated for the Charts 3D Axes.
     *
     * It is visualized with a wireframe, as well as 3D Axes on its sides.
     * @return              Dimensions of bounding box as World Units.
     */
    getBoundingBox(): Point3D;
    /**
     * **Permanently** dispose the component.
     *
     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
     * **to the component and its children** in application code.
     * ```javascript
     * let chart =  lightningChart().Chart3D()
     * let axisX = chart.getDefaultAxisX()
     * // Dispose Chart, and remove all references so that they can be garbage-collected.
     * chart.dispose()
     * chart = undefined
     * axisX = undefined
     * ```
     * @return  Object itself for fluent interface
     */
    dispose(): this;
    /**
     * Set all mouse-interaction flags at once.
     *
     * Affects rotation and zooming. Same as calling both [[setMouseInteractionZoom]] and [[setMouseInteractionRotate]].
     * @param   enabled     Are mouse-interactions enabled
     * @return              Object itself
     */
    setMouseInteractions(enabled: boolean): this;
    /**
     * Set is mouse-interaction enabled:
     * Zooming axes with mouse-wheel or by touch.
     * @param   enabled     Boolean flag
     * @return              Object itself
     */
    setMouseInteractionZoom(enabled: boolean): this;
    /**
     * Get is mouse-interaction enabled:
     * Zooming axes with mouse-wheel or by touch.
     * @return  Boolean flag
     */
    getMouseInteractionZoom(): boolean;
    /**
     * Set is mouse-interaction enabled:
     * Rotating axes with mouse-drag or by touch.
     * @param   enabled     Boolean flag
     * @return              Object itself
     */
    setMouseInteractionRotate(enabled: boolean): this;
    /**
     * Get is mouse-interaction enabled:
     * Rotating  axes with mouse-drag or by touch.
     * @return  Boolean flag
     */
    getMouseInteractionRotate(): boolean;
    /**
     * Set if mouse and cursor interactions should be disabled during scrolling animations for the chart's series.
     * @param   state   True if mouse and cursor interactions should be disabled during scrolling animations, false if not.
     * @return          Chart itself for fluent interface.
     */
    setMouseInteractionsWhileScrolling(state: boolean): this;
    /**
     * Get if mouse and cursor interactions are disabled during scrolling animations for the chart's series.
     * @return True if interactions with series are disabled, false if not.
     */
    getMouseInteractionsWhileScrolling(): boolean;
    /**
     * Operate on each axis of chart, x and y
     * @param   clbk    Callback function for axis
     */
    forEachAxis(clbk: (axis: Axis3D) => void): void;
    /**
     * Get minimum size of Chart.
     * Depending on the type of class this value might be automatically computed to fit different elements.
     * @return  Vec2 minimum size or undefined if unimplemented
     * @hidden
     */
    getMinimumSize(): Point | undefined;
    /**
     * Get reference to all series of `Chart3D`.
     * @return  List of 3D series.
     */
    getSeries(): Series3D[];
    /**
     * Disable/Enable all animations for the chart.
     *
     * Affects:
     * - Axis animations.
     * - Zoom animation.
     *
     * @param  animationsEnabled    Boolean value to enable/disable all animations
     * @return                      Chart itself for fluent interface.
     */
    setAnimationsEnabled(animationsEnabled: boolean | undefined): this;
    /**
     * Check if all animations of Chart3D are currently enabled or disabled.
     *
     * This concerns:
     * - Axis animations.
     * - Zoom animation.
     * @return                      `true` if all animations are enabled currently.
     */
    getAnimationsEnabled(): boolean;
    /**
     * Disable all animations for the chart.
     *
     * After calling this function, animations (Zooming, scaling) for all Axes will be disabled.
     * Animations must be recreated manually afterwards.
     * @return                      Chart itself for fluent interface.
     */
    disableAnimations(): this;
    /**
     * Set Chart3D zoom animation enabled.
     *
     * When enabled, zooming with mouse wheel or trackpad will include a short animation.
     *
     * This is enabled by default.
     *
     * ```typescript
     *  // Example syntax, disable zoom animation.
     *  chart3D.setAnimationZoom(false)
     * ```
     * @param   animationsEnabled   Boolean.
     * @return                      Chart itself for fluent interface.
     */
    setAnimationZoom(animationsEnabled: boolean | undefined): this;
    /**
     * Get Chart3D zoom animation enabled.
     *
     * When enabled, zooming with mouse wheel or trackpad will include a short animation.
     *
     * This is enabled by default.
     *
     * ```typescript
     *  // Example syntax, disable zoom animation.
     *  chart3D.setAnimationZoom(false)
     * ```
     * @return  Boolean.
     */
    getAnimationZoom(): boolean;
}
/**
 * Interface for readonly configuration of [Chart3D](../classes/chart3d.html).
 *
 * Some properties of `Chart3D` can only be configured when it is created. These arguments are all optional, and are wrapped in a single object parameter:
 *
 * ```typescript
 *  // Example, specify chart color theme.
 *  const chart = LightningChart.Chart3D({
 *      theme: Themes.light
 *  })
 * ```
 *
 * *Watch out!* The full set of available readonly configuration parameters depends on if the chart is *standalone*, or inside a *dashboard*:
 *
 * For *standalone* `Chart3D`, more parameters are documented in [[LightningChart.Chart3D]].
 *
 * For *dashboard* `Chart3D`, more parameters are documented in [[Dashboard.createChart3D]].
 *
 *
 * **Commonly used properties:**
 *
 * - [theme]([[ChartOptions3D.theme]]): Specify chart color *theme*.
 * - [disableAnimations]([[ChartOptions3D.disableAnimations]]): Convenience flag to disable all animations from chart.
 *
 * **Example usage:**
 *
 * ```typescript
 *  // Example 1, create chart with default configuration.
 *  const chart = LightningChart.Chart3D({})
 * ```
 *
 * ```typescript
 *  // Example 2, create chart with specified color theme.
 *  const chart = LightningChart.Chart3D({
 *      theme: Themes.light,
 *  })
 * ```
 */
export interface ChartOptions3D extends CommonChartOptions {
}
/**
 * Interface that can be used to specify readonly parameters when creating a [[PointLineSeries3D]].
 */
export interface PointLineSeriesOptions3D {
}
/**
 * Interface that can be used to specify readonly parameters when creating a new *Surface Series 3D*.
 */
export interface SurfaceSeriesOptions3D<T extends SurfaceSeriesTypes3D> extends SurfaceOptions3D {
    /**
     * Defines the type of *Surface Series 3D*.
     *
     * See [[SurfaceSeriesTypes3D]] for a collection of options.
     */
    type?: T;
}
/**
 * Type union of LineStyle types supported by LineSeries3D.
 */
export declare type LineSeriesStyle3D = SolidLine<SolidFill | PalettedFill>;
/**
 * Internal super class for LineSeries3D and PointLineSeries3D.
 *
 * Sub-classes only differ on joint styling logic.
 * @hidden
 */
export declare abstract class LineAndPointSeries3D extends Series3D<LineSet3D> implements XYZDataInput, AttachableWithLUT {
    /**
     * Set stroke style of Series.
     *
     * ```ts
     *  // Example syntax, specify LineStyle
     *  LineSeries3D.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorHEX('#F00') })
     *  }))
     * ```
     *
     * ```ts
     *  // Example syntax, change active LineStyle
     *  LineSeries3D.setStrokeStyle((stroke) => stroke.setThickness(5))
     * ```
     *
     * Use `-1` thickness to enable primitive line rendering.
     * Primitive line rendering can have slightly better rendering performance than line with `1` thickness but the quality of line is not as good.
     * ```typescript
     *  LineSeries3D.setStrokeStyle((solidLine) => solidLine.setThickness(-1))
     * ```
     *
     * - **Supported fill styles:**
     *
     * [[SolidFill]]:
     *
     * Solid color for entire line series.
     *
     * ```ts
     *  // Example, solid colored line.
     *  LineSeries3D.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
     *  }))
     * ```
     *
     * To learn more about available *Color* factories, see [[ColorRGBA]]
     *
     * [[PalettedFill]]:
     *
     * Color line stroke dynamically based on `x`, `y` or `z` coordinate.
     *
     * ```ts
     *  // Example, dynamic color by Y coordinates
     *  LineSeries3D.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new PalettedFill({
     *          lookUpProperty: 'y',
     *          lut: new LUT({
     *              interpolate: true,
     *              steps: [
     *                  { value: 0, color: ColorRGBA(255, 0, 0) },
     *                  { value: 100, color: ColorRGBA(0, 255, 0) },
     *              ]
     *          })
     *      })
     *  }))
     * ```
     *
     * To learn more about Color lookup tables, see [[LUT]].
     *
     * - **Primitive 3D line rendering**
     *
     * `LineSeries3D` has a special feature for drawing *primitive* line sets.
     *
     * When enabled, this will draw all line segments as exactly 1 pixel thick on the monitor (regardless of distance from camera).
     *
     * As a benefit, this is considerably lighter on the GPU, which is especially good with mobile and laptop devices with weak GPUs.
     *
     * *Primitive* drawing is enabled by setting stroke thickness to `-1`:
     *
     * ```ts
     *  // Enable primitive 3D line drawing.
     *  LineSeries3D.setStrokeStyle((stroke) => stroke.setThickness(-1))
     * ```
     *
     * - **Other information**
     *
     * In 3D, line thickness is not configured exactly as pixels (since the size of pixel is not affected by distance from camera).
     *
     * However, for usage convenience, you can consider line thickness in 3D as pixels just the same as 2D,
     * even if the resulting visualization will have some differences.
     *
     * @param   value   Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
     * @returns         Object itself for fluent interface.
     */
    setStrokeStyle(value: LineSeriesStyle3D | ImmutableMutator<LineSeriesStyle3D>): this;
    /**
     * Get normal line style (not highlighted).
     * @return  LineSeriesStyle3D
     */
    getStrokeStyle(): LineSeriesStyle3D;
    /**
     * Set line style of Series when it is highlighted.
     *
     * Example usage:
     *
     * - **Construct new SolidLine object**
     * ```javascript
     *  lineSeries3D.setStrokeStyle( new SolidLine({
     *      thickness: 5,
     *      fillStyle: new SolidFill({ color: ColorHEX('#FFF') })
     *  }) )
     * ```
     * - **Change thickness of existing SolidLine configuration**
     * ```javascript
     *  lineSeries.setStrokeStyle( (solidLine) => solidLine
     *      .setThickness( 5 )
     *  )
     * ```
     * - **Assign highlight style automatically based on normal style**
     * ```javascript
     *  lineSeries.setStrokeStyleHighlight( undefined )
     * ```
     * @param   value   A LineSeries object, a function which modifies the current style or
     *                  **undefined** for automatic value based on normal style.
     * @returns         Object itself for fluent interface.
     */
    setStrokeStyleHighlight(value: LineSeriesStyle3D | ImmutableMutator<LineSeriesStyle3D> | undefined): this;
    /**
     * Get highlight style of line.
     * @return  LineSeriesStyle3D
     */
    getStrokeStyleHighlight(): LineSeriesStyle3D;
    /**
     * Set line style of Series.
     *
     * Example usage:
     *
     * - **Construct new SolidLine object**
     * ```javascript
     *  lineSeries3D.setStrokeStyle( new SolidLine({
     *      thickness: 5,
     *      fillStyle: new SolidFill({ color: ColorHEX('#FFF') })
     *  }) )
     * ```
     * - **Change thickness of existing SolidLine configuration**
     * ```javascript
     *  lineSeries.setStrokeStyle( (solidLine) => solidLine
     *      .setThickness( 5 )
     *  )
     * ```
     * @param   value   A LineSeries object, or a function which modifies the current style.
     * @return          Object itself for fluent interface
     * @deprecated      Will be removed in v.4.0. Use [[setStrokeStyle]] instead.
     */
    setLineStyle(value: LineSeriesStyle3D | ImmutableMutator<LineSeriesStyle3D>): this;
    /**
     * Get normal line style (not highlighted).
     * @return  LineSeriesStyle3D
     * @deprecated      Will be removed in v.4.0. Use [[getStrokeStyle]] instead.
     */
    getLineStyle(): LineSeriesStyle3D;
    /**
     * Set line style of Series when it is highlighted.
     *
     * Example usage:
     *
     * - **Construct new SolidLine object**
     * ```javascript
     *  lineSeries3D.setStrokeStyle( new SolidLine({
     *      thickness: 5,
     *      fillStyle: new SolidFill({ color: ColorHEX('#FFF') })
     *  }) )
     * ```
     * - **Change thickness of existing SolidLine configuration**
     * ```javascript
     *  lineSeries.setStrokeStyle( (solidLine) => solidLine
     *      .setThickness( 5 )
     *  )
     * ```
     * - **Assign highlight style automatically based on normal style**
     * ```javascript
     *  lineSeries.setStrokeStyleHighlight( undefined )
     * ```
     * @param   value   A LineSeries object, a function which modifies the current style or
     *                  **undefined** for automatic value based on normal style.
     * @returns         Object itself for fluent interface.
     * @deprecated      Will be removed in v.4.0. Use [[setStrokeStyleHighlight]] instead.
     */
    setLineStyleHighlight(value: LineSeriesStyle3D | ImmutableMutator<LineSeriesStyle3D> | undefined): this;
    /**
     * Get highlight style of line.
     * @return  LineSeriesStyle3D
     * @deprecated      Will be removed in v.4.0. Use [[setStrokeStyleHighlight]] instead.
     */
    getLineStyleHighlight(): LineSeriesStyle3D;
    /**
     * Add point or array of points to the series.
     * @param    data    Point3D or array of points
     * @returns          Object itself for fluent interface
     */
    add(data: Point3D | Point3D[]): this;
    /**
     * Clear all previously pushed data points from the *series*.
     *
     * ```ts
     *  // Example usage
     *  LineSeries.clear()
     * ```
     *
     * @return      Object itself for fluent interface.
     */
    clear(): this;
    /**
     * Get amount of points that series currently has.
     * @return  Number of points
     */
    getPointAmount(): number;
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Object itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick?: boolean): this;
}
/**
 * Series type for visualizing a collection of `{ x, y, z }` coordinates by a continuous line stroke.
 *
 * `LineSeries3D` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
 *
 * - A static data set in millions data points range is rendered in hundreds of milliseconds (~200ms). Afterwards chart can be rotated and zoomed with 60 FPS.
 * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
 *
 * **Creating LineSeries3D:**
 *
 * `LineSeries3D` are created with [[Chart3D.addLineSeries]] method.
 *
 * ```typescript
 *  // Example syntax, create line series 3D
 *  const lineSeries3D = Chart3D.addLineSeries()
 * ```
 *
 * **Frequently used methods:**
 *
 * - Append data points to series | [[add]]
 * - Remove all data points from series | [[clear]]
 * - Configure style of line stroke | [[setStrokeStyle]]
 * - Remove series temporarily, or permanently | [[dispose]]
 * - Restore series after `dispose` | [[restore]]
 *
 * **Color shading style**.
 *
 * By default, `LineSeries3D` uses _Phong_ shading style.
 *
 * This can be changed with `LineSeries3D.setColorShadingStyle(new ColorShadingStyles.Simple())`
 *
 * **Related information:**
 *
 * To combine line stroke with markers over each data coordinate, [[PointLineSeries3D]] can be used.
 */
export declare class LineSeries3D extends LineAndPointSeries3D {
    /**
     * Set stroke style of Series.
     *
     * ```ts
     *  // Example syntax, specify LineStyle
     *  LineSeries3D.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorHEX('#F00') })
     *  }))
     * ```
     *
     * ```ts
     *  // Example syntax, change active LineStyle
     *  LineSeries3D.setStrokeStyle((stroke) => stroke.setThickness(5))
     * ```
     *
     * Use `-1` thickness to enable primitive line rendering.
     * Primitive line rendering can have slightly better rendering performance than line with `1` thickness but the quality of line is not as good.
     * ```typescript
     *  LineSeries3D.setStrokeStyle((solidLine) => solidLine.setThickness(-1))
     * ```
     *
     * - **Supported fill styles:**
     *
     * [[SolidFill]]:
     *
     * Solid color for entire line series.
     *
     * ```ts
     *  // Example, solid colored line.
     *  LineSeries3D.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
     *  }))
     * ```
     *
     * To learn more about available *Color* factories, see [[ColorRGBA]]
     *
     * [[PalettedFill]]:
     *
     * Color line stroke dynamically based on `x`, `y` or `z` coordinate.
     *
     * ```ts
     *  // Example, dynamic color by Y coordinates
     *  LineSeries3D.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new PalettedFill({
     *          lookUpProperty: 'y',
     *          lut: new LUT({
     *              interpolate: true,
     *              steps: [
     *                  { value: 0, color: ColorRGBA(255, 0, 0) },
     *                  { value: 100, color: ColorRGBA(0, 255, 0) },
     *              ]
     *          })
     *      })
     *  }))
     * ```
     *
     * To learn more about Color lookup tables, see [[LUT]].
     *
     * - **Primitive 3D line rendering**
     *
     * `LineSeries3D` has a special feature for drawing *primitive* line sets.
     *
     * When enabled, this will draw all line segments as exactly 1 pixel thick on the monitor (regardless of distance from camera).
     *
     * As a benefit, this is considerably lighter on the GPU, which is especially good with mobile and laptop devices with weak GPUs.
     *
     * *Primitive* drawing is enabled by setting stroke thickness to `-1`:
     *
     * ```ts
     *  // Enable primitive 3D line drawing.
     *  LineSeries3D.setStrokeStyle((stroke) => stroke.setThickness(-1))
     * ```
     *
     * - **Other information**
     *
     * In 3D, line thickness is not configured exactly as pixels (since the size of pixel is not affected by distance from camera).
     *
     * However, for usage convenience, you can consider line thickness in 3D as pixels just the same as 2D,
     * even if the resulting visualization will have some differences.
     *
     * @param   value   Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
     * @returns         Object itself for fluent interface.
     */
    setStrokeStyle(value: LineSeriesStyle3D | ImmutableMutator<LineSeriesStyle3D>): this;
    /**
     * Set line style of Series when it is highlighted.
     *
     * Example usage:
     *
     * - **Construct new SolidLine object**
     * ```javascript
     *  lineSeries3D.setStrokeStyle( new SolidLine({
     *      thickness: 5,
     *      fillStyle: new SolidFill({ color: ColorHEX('#FFF') })
     *  }) )
     * ```
     * - **Change thickness of existing SolidLine configuration**
     * ```javascript
     *  lineSeries.setStrokeStyle( (solidLine) => solidLine
     *      .setThickness( 5 )
     *  )
     * ```
     * - **Assign highlight style automatically based on normal style**
     * ```javascript
     *  lineSeries.setStrokeStyleHighlight( undefined )
     * ```
     * @param   value   A LineSeries object, a function which modifies the current style or
     *                  **undefined** for automatic value based on normal style.
     * @returns         Object itself for fluent interface.
     */
    setStrokeStyleHighlight(value: LineSeriesStyle3D | ImmutableMutator<LineSeriesStyle3D> | undefined): this;
}
/**
 * Series type for visualizing a collection of `{ x, y, z }` coordinates by a continuous line stroke and markers.
 *
 * `PointLineSeries3D` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
 *
 * - A static data set in millions data points range is rendered in hundreds of milliseconds (~200ms). Afterwards chart can be rotated and zoomed with 60 FPS.
 * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
 *
 * **Creating PointLineSeries3D:**
 *
 * `PointLineSeries3D` are created with [[Chart3D.addPointLineSeries]] method.
 *
 * ```typescript
 *  // Example syntax, create point line series 3D
 *  const pointLineSeries3D = Chart3D.addPointLineSeries()
 * ```
 *
 * **Frequently used methods:**
 *
 * - Append data points to series | [[add]]
 * - Remove all data points from series | [[clear]]
 * - Configure style of line stroke | [[setStrokeStyle]]
 * - Configure style of markers | [[setPointStyle]]
 * - Remove series temporarily, or permanently | [[dispose]]
 * - Restore series after `dispose` | [[restore]]
 *
 * **Color shading style**.
 *
 * By default, `PointLineSeries3D` uses _Phong_ shading style.
 *
 * This can be changed with `PointLineSeries3D.setColorShadingStyle(new ColorShadingStyles.Simple())`
 *
 * **Related information:**
 *
 * For series with only line stroke, see [[LineSeries3D]].
 *
 * For series with only markers, see [[PointSeries3D]].
 */
export declare class PointLineSeries3D extends LineAndPointSeries3D {
    /**
     * Set point style of Series.
     *
     * Example usage:
     *
     * - **New TriangulatedPoints3D object**
     * ```ts
     *  pointLineSeries3D.setPointStyle( new PointStyle3D.Triangulated({
     *      size: 10,
     *      shape: 'sphere',
     *      fillStyle: new SolidFill({ color: ColorHEX('#FFF') })
     *  }) )
     * ```
     * - **Change point size**
     * ```ts
     *  pointLineSeries3D.setPointStyle( (pointStyle) => pointStyle
     *      .setSize( 10 )
     *  )
     * ```
     * - **Change point shape**
     * ```ts
     *  pointLineSeries3D.setPointStyle( (pointStyle) => pointStyle
     *      .setShape( 'cube' )
     *  )
     * ```
     *
     * **NOTE:** Currently `PointLineSeries3D` only supports Solid filled points.
     * Alternatively, `PointSeries3D` can be used for various dynamic and powerful coloring features. See [[PointSeries3D.setPointStyle]] for examples and more information.
     *
     * @param   value   A TriangulatedPoints3D object, or a function which modifies the current style.
     * @return          Object itself for fluent interface
     */
    setPointStyle(value: TriangulatedPoints3D | ImmutableMutator<TriangulatedPoints3D>): this;
    /**
     * Get normal points style.
     * @return  TriangulatedPoints3D
     */
    getPointStyle(): TriangulatedPoints3D;
    /**
     * Set point style of Series when it is highlighted.
     *
     * Example usage:
     *
     * - **New TriangulatedPoints3D object**
     * ```ts
     *  pointLineSeries3D.setPointStyleHighlight( new PointStyle3D.Triangulated({
     *      size: 10,
     *      fillStyle: new SolidFill({ color: ColorHEX('#FFF') })
     *  }) )
     * ```
     * - **Change point size**
     * ```ts
     *  pointLineSeries3D.setPointStyleHighlight( (pointStyle) => pointStyle
     *      .setSize( 10 )
     *  )
     * ```
     * - **Change point shape**
     * ```ts
     *  pointLineSeries3D.setPointStyle( (pointStyle) => pointStyle
     *      .setShape( 'cube' )
     *  )
     * ```
     * - **Assign highlight style automatically based on normal style**
     * ```ts
     *  pointLineSeries3D.setPointStyleHighlight( undefined )
     * ```
     * @param   value   A TriangulatedPoints3D object, or a function which modifies the current style or
     *                  **undefined** for automatic value based on normal style.
     * @returns         Object itself for fluent interface.
     */
    setPointStyleHighlight(value: TriangulatedPoints3D | ImmutableMutator<TriangulatedPoints3D> | undefined): this;
    /**
     * Get highlight style of points.
     * @return  TriangulatedPoints3D
     */
    getPointStyleHighlight(): TriangulatedPoints3D;
    /**
     * Set stroke style of Series.
     *
     * ```ts
     *  // Example syntax, specify LineStyle
     *  LineSeries3D.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorHEX('#F00') })
     *  }))
     * ```
     *
     * ```ts
     *  // Example syntax, change active LineStyle
     *  LineSeries3D.setStrokeStyle((stroke) => stroke.setThickness(5))
     * ```
     *
     * Use `-1` thickness to enable primitive line rendering.
     * Primitive line rendering can have slightly better rendering performance than line with `1` thickness but the quality of line is not as good.
     * ```typescript
     *  LineSeries3D.setStrokeStyle((solidLine) => solidLine.setThickness(-1))
     * ```
     *
     * - **Supported fill styles:**
     *
     * [[SolidFill]]:
     *
     * Solid color for entire line series.
     *
     * ```ts
     *  // Example, solid colored line.
     *  LineSeries3D.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
     *  }))
     * ```
     *
     * To learn more about available *Color* factories, see [[ColorRGBA]]
     *
     * [[PalettedFill]]:
     *
     * Color line stroke dynamically based on `x`, `y` or `z` coordinate.
     *
     * ```ts
     *  // Example, dynamic color by Y coordinates
     *  LineSeries3D.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new PalettedFill({
     *          lookUpProperty: 'y',
     *          lut: new LUT({
     *              interpolate: true,
     *              steps: [
     *                  { value: 0, color: ColorRGBA(255, 0, 0) },
     *                  { value: 100, color: ColorRGBA(0, 255, 0) },
     *              ]
     *          })
     *      })
     *  }))
     * ```
     *
     * To learn more about Color lookup tables, see [[LUT]].
     *
     * - **Primitive 3D line rendering**
     *
     * `LineSeries3D` has a special feature for drawing *primitive* line sets.
     *
     * When enabled, this will draw all line segments as exactly 1 pixel thick on the monitor (regardless of distance from camera).
     *
     * As a benefit, this is considerably lighter on the GPU, which is especially good with mobile and laptop devices with weak GPUs.
     *
     * *Primitive* drawing is enabled by setting stroke thickness to `-1`:
     *
     * ```ts
     *  // Enable primitive 3D line drawing.
     *  LineSeries3D.setStrokeStyle((stroke) => stroke.setThickness(-1))
     * ```
     *
     * - **Other information**
     *
     * In 3D, line thickness is not configured exactly as pixels (since the size of pixel is not affected by distance from camera).
     *
     * However, for usage convenience, you can consider line thickness in 3D as pixels just the same as 2D,
     * even if the resulting visualization will have some differences.
     *
     * @param   value   Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
     * @returns         Object itself for fluent interface.
     */
    setStrokeStyle(value: LineSeriesStyle3D | ImmutableMutator<LineSeriesStyle3D>): this;
    /**
     * Set line style of Series when it is highlighted.
     *
     * Example usage:
     *
     * - **Construct new SolidLine object**
     * ```javascript
     *  pointLineSeries3D.setStrokeStyle( new SolidLine({
     *      thickness: 5,
     *      fillStyle: new SolidFill({ color: ColorHEX('#FFF') })
     *  }) )
     * ```
     * - **Change thickness of existing SolidLine configuration**
     * ```javascript
     *  pointLineSeries3D.setStrokeStyle( (solidLine) => solidLine
     *      .setThickness( 5 )
     *  )
     * ```
     * - **Assign highlight style automatically based on normal style**
     * ```javascript
     *  pointLineSeries3D.setStrokeStyleHighlight( undefined )
     * ```
     * @param   value   A LineSeriesStyle3D object, a function which modifies the current style or
     *                  **undefined** for automatic value based on normal style.
     * @returns         Object itself for fluent interface.
     */
    setStrokeStyleHighlight(value: LineSeriesStyle3D | ImmutableMutator<LineSeriesStyle3D> | undefined): this;
    /**
     * Set line style of Series.
     *
     * Example usage:
     *
     * - **Construct new SolidLine object**
     * ```javascript
     *  lineSeries3D.setStrokeStyle( new SolidLine({
     *      thickness: 5,
     *      fillStyle: new SolidFill({ color: ColorHEX('#FFF') })
     *  }) )
     * ```
     * - **Change thickness of existing SolidLine configuration**
     * ```javascript
     *  lineSeries.setStrokeStyle( (solidLine) => solidLine
     *      .setThickness( 5 )
     *  )
     * ```
     * @param   value   A LineSeriesStyle3D object, or a function which modifies the current style.
     * @return          Object itself for fluent interface
     * @deprecated      Will be removed in v.4.0. Use [[setStrokeStyle]] instead.
     */
    setLineStyle(value: LineSeriesStyle3D | ImmutableMutator<LineSeriesStyle3D>): this;
}
/**
 * Abstract base class for Point Series 3D implementations.
 *
 * Implements full series logic except for Point Style API and segment length.
 * @hidden
 */
declare abstract class AbstractPointSeries3D<Style extends TriangulatedPoints3D | PixelatedPoints3D> extends Series3D<PointSet3D> implements XYZDataInput {
    /**
     * @param _chart            Chart to which the component belongs
     * @param _removeFromChart  Handler to remove component from chart's collection it belongs to.
     * @param _restoreFromChart Handler to restore component from chart's collection it belongs to.
     * @param _layer3D          3D Rendering layer.
     * @param _options          Options.
     * @hidden
     */
    constructor(_chart: Chart3D, _removeFromChart: RemoveHandler<ChartComponent>, _restoreFromChart: RestoreHandler<ChartComponent>, _layer3D: Layer3D, _theme: Theme, _options: PointSeriesOptions3D | undefined);
    /**
     * Append a single `XYZ` coordinate or list of coordinates into the *series*.
     *
     * ```ts
     *  // Example, add single data point.
     *  pointSeries.add({ x: 0, y: 0, z: 0 })
     *
     *  // Example, add list of data points.
     *  pointSeries.add([
     *      { x: 0, y: 100, z: 50 },
     *      { x: 10, y: 50, z: 150 },
     *      { x: 20, y: 75, z: 100 },
     *  ])
     * ```
     *
     * Performance-wise, it is more efficient to call `add` just 1 time with an Array of points, instead of calling `add` several times with 1 point at a time.
     *
     * Data points can also be grouped with extra optional properties:
     * - `size` | Point size.
     * - `color` | Point color.
     * - `value` | Point value for dynamic coloring.
     *
     * [[setPointStyle]] method documentation contains detailed information about each of these features and how to use them.
     *
     * @param    points  Single XYZ coordinate or list of coordinates.
     * @returns          Object itself for fluent interface.
     */
    add(data: Point3D | Point3D[]): this;
    /**
     * Clear all previously pushed data points from the *series*.
     *
     * ```ts
     *  // Example usage
     *  pointSeries.clear()
     * ```
     *
     * @return      Object itself for fluent interface.
     */
    clear(): this;
    /**
     * Get amount of points that series currently has.
     * @return  Number of points
     */
    getPointAmount(): number;
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Object itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick?: boolean): this;
}
/**
 * Series type for visualizing a collection of `{ x, y, z }` coordinates by different markers
 *
 * `PointSeries3D` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
 *
 * - A static data set in millions data points range is rendered in hundreds of milliseconds (~200ms). Afterwards chart can be rotated and zoomed with 60 FPS.
 * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
 *
 * **Creating PointSeries3D:**
 *
 * `PointSeries3D` are created with [[Chart3D.addPointSeries]] method.
 *
 * Some properties of `PointSeries3D` can only be configured when it is created. These arguments are all optional,
 * and are wrapped in a single object parameter:
 *
 * ```typescript
 *  // Example,
 *  const pointSeries3D = Chart3D.addPointSeries({
 *      // Enable individual data points size.
 *      individualPointSizeEnabled: true
 *  })
 * ```
 *
 * To learn about available properties, refer to [[PointSeriesOptions3D]].
 *
 * **Frequently used methods:**
 *
 * - Append data points to series | [[add]]
 * - Remove all data points from series | [[clear]]
 * - Configure style of points | [[setPointStyle]]
 * - Remove series temporarily, or permanently | [[dispose]]
 * - Restore series after `dispose` | [[restore]]
 *
 * **Color shading style**.
 *
 * By default, `PointSeries3D` uses _Phong_ shading style.
 *
 * This can be changed with `PointSeries3D.setColorShadingStyle(new ColorShadingStyles.Simple())`
 *
 * **Related information:**
 *
 * There is another series type for visualizing large sets of 3D coordinates with markers: [[PointCloudSeries3D]]
 *
 * `PointCloudSeries3D` works otherwise same, except that it has simplified render process (all markers are 2D geometry),
 * which is faster and can be really powerful in visualizing large low-detail data sets!
 */
export declare class PointSeries3D extends AbstractPointSeries3D<TriangulatedPoints3D> implements AttachableWithLUT {
    /**
     * @param _chart            Chart to which the component belongs
     * @param _removeFromChart  Handler to remove component from chart's collection it belongs to.
     * @param _restoreFromChart Handler to restore component from chart's collection it belongs to.
     * @param _layer3D          3D Rendering layer.
     * @param _options          Options.
     * @param theme             Theme.
     * @hidden
     */
    constructor(_chart: Chart3D, _removeFromChart: RemoveHandler<ChartComponent>, _restoreFromChart: RestoreHandler<ChartComponent>, _layer3D: Layer3D, theme: Theme, _options: PointSeriesOptions3D | undefined);
    /**
     * Set point style of Series.
     *
     * **Example syntax:**
     *
     * ```ts
     *  // Example syntax, Specify new style
     *  pointSeries3D.setPointStyle( new PointStyle3D.Triangulated({
     *      size: 10,
     *      shape: 'sphere',
     *      fillStyle: new SolidFill({ color: ColorHEX('#FFF') })
     *  }) )
     * ```
     *
     * ```ts
     *  // Example syntax, Change point color
     *  pointSeries3D.setPointStyle( (pointStyle) => pointStyle
     *      .setFillStyle( new SolidFill({ color: ColorHEX('#FFF') }) )
     *  )
     * ```
     *
     * ```ts
     *  // Example syntax, Change point size
     *  pointSeries3D.setPointStyle( (pointStyle) => pointStyle
     *      .setSize( 10 )
     *  )
     * ```
     *
     * ```ts
     *  // Example syntax, Change point shape
     *  pointSeries3D.setPointStyle( (pointStyle) => pointStyle
     *      .setShape( 'cube' )
     *  )
     * ```
     *
     * **Point coloring:**
     *
     * Color of points is configured by the `fillStyle` property of active point style.
     *
     * Here is a list of all supported _fill styles_ with feature descriptions and example syntax:
     *
     * [[SolidFill]]:
     *
     * Solid color for all points in series.
     *
     * ```js
     *  // Example syntax, solid points color.
     *  pointSeries3D.setPointStyle(new PointStyle3D.Triangulated({
     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) }),
     *      size: 10,
     *      shape: 'sphere'
     *  }))
     * ```
     *
     * [[PalettedFill]]:
     *
     * Look-up dynamic per-point color based on a _look up property_ (number) and a color look up table ([[LUT]]).
     *
     * ```js
     *  // Example syntax, dynamic points color.
     *  pointSeries3D.setPointStyle(new PointStyle3D.Triangulated({
     *      fillStyle: new PalettedFill({
     *          // lookUpProperty defines basis of selecting look up value (number).
     *          lookUpProperty: 'value',
     *          // lut defines table for mapping look up value (number) to a color.
     *          lut: new LUT({
     *              interpolate: true,
     *              steps: [
     *                  { value: 0, color: ColorRGBA(0, 0, 0) },
     *                  { value: 1, color: ColorRGBA(255, 0, 0) }
     *              ]
     *          })
     *      }),
     *      size: 10,
     *      shape: 'sphere'
     *  }))
     * ```
     *
     * `PointSeries3D` supports several different look-up modes:
     *
     * `lookUpProperty: 'value'`:
     *
     * **IMPORTANT:** In order to use `value` property on data points, the feature has to be explicitly activated **when the series is created**:
     *
     * ```js
     *  // Example syntax, enable individual data point values.
     *  const pointSeries3D = chart3D.addPointSeries({
     *      individualLookupValuesEnabled: true
     *  })
     * ```
     *
     * `value` property is then added for every data point along side `x`, `y` and `z`:
     *
     * ```js
     *  // Example syntax, individual data point values.
     *  pointSeries3D.add([
     *      { x: 0, y: 0, z: 0, value: 0 },
     *      { x: 1, y: 0, z: 2, value: 1 },
     *  ])
     * ```
     *
     * Look-up value is read from data point `value` property.
     *
     * `lookUpProperty: 'x'`:
     *
     * Look-up value is set to data point `x` coordinate on Axis.
     *
     * `lookUpProperty: 'y'`:
     *
     * Look-up value is set to data point `y` coordinate on Axis.
     *
     * `lookUpProperty: 'z'`:
     *
     * Look-up value is set to data point `z` coordinate on Axis.
     *
     * [[IndividualPointFill]]:
     *
     * Supply individual color for each data point.
     *
     * **IMPORTANT:** In order to use `IndividualPointFill`, the feature has to be explicitly activated **when the series is created**:
     *
     * ```js
     *  // Example syntax, enable individual data point colors.
     *  const pointSeries3D = chart3D.addPointSeries({
     *      individualPointColorEnabled: true
     *  })
     * ```
     *
     * `color` property is then added for every data point along side `x`, `y` and `z`:
     *
     * ```js
     *  // Example syntax, individual data point colors.
     *  pointSeries3D.add([
     *      { x: 0, y: 0, z: 0, color: ColorRGBA(255, 0, 0) },
     *      { x: 1, y: 0, z: 2, color: ColorRGBA(0, 255, 0) },
     *  ])
     * ```
     *
     * **Point size:**
     *
     * Size of points is configured by the `size` property of active point style.
     *
     * If required, points can also be individually sized by adding a `size` property to data points.
     *
     * **IMPORTANT:** In order to use `size` property, the feature has to be explicitly activated **when the series is created**:
     *
     * ```js
     *  // Example syntax, enable individual data point size.
     *  const pointSeries3D = chart3D.addPointSeries({
     *      individualPointSizeEnabled: true
     *  })
     * ```
     *
     * `size` property is then added for every data point along side `x`, `y` and `z`:
     *
     * ```js
     *  // Example syntax, individual data point sizes.
     *  pointSeries3D.add([
     *      { x: 0, y: 0, z: 0, size: 5 },
     *      { x: 1, y: 0, z: 2, size: 10 },
     *  ])
     * ```
     *
     *
     * **Point size 3D:**
     *
     * As an alternative method to `size`, each 3D point can also be sized with individual sizes for each Axis (X, Y and Z).
     *
     * This is done by adding `sizeAxisX`, `sizeAxisY`, and `sizeAxisZ` properties to data points.
     *
     * **IMPORTANT:** In order to use these properties, the feature has to be explicitly activated **when the series is created**:
     *
     * ```js
     *  // Example syntax, enable individual data point 3D axis size.
     *  const pointSeries3D = chart3D.addPointSeries({
     *      individualPointSizeAxisEnabled: true
     *  })
     * ```
     *
     * `sizeAxisX`, `sizeAxisY` and `sizeAxisZ` properties are then added for every data point along side `x`, `y` and `z`:
     *
     * ```js
     *  // Example syntax, individual data point 3D axis sizes.
     *  pointSeries3D.add([
     *      { x: 0, y: 0, z: 0, sizeAxisX: 1, sizeAxisY: 10, sizeAxisZ: 5 },
     *      { x: 1, y: 0, z: 2, sizeAxisX: 1, sizeAxisY: 10, sizeAxisZ: 5 },
     *  ])
     * ```
     *
     *
     * **IMPORTANT:** in order for points to be sized based on `sizeAxisX`, `sizeAxisY` and `sizeAxisZ` properties, the active point style must also have a fallback point size definition **as axis dimensions**:
     *
     * ```js
     *  pointSeries3D.setPointStyle(new PointStyle3D.Triangulated({
     *      // IMPORTANT: fallback `size` must be defined with { x, y, z } syntax!
     *      size: { x: 1, y: 1, z: 1 },
     *      shape: 'sphere',
     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
     *  }))
     * ```
     *
     * @param   value   A TriangulatedPoints3D object, or a function which modifies the current style.
     * @return          Object itself for fluent interface
     */
    setPointStyle(value: TriangulatedPoints3D | ImmutableMutator<TriangulatedPoints3D>): this;
    /**
     * Get normal points style.
     * @return  TriangulatedPoints3D
     */
    getPointStyle(): TriangulatedPoints3D;
    /**
     * Set point style of Series when it is highlighted.
     *
     * Example syntax:
     *
     * - **New TriangulatedPoints3D object**
     * ```ts
     *  pointSeries3D.setPointStyleHighlight( new PointStyle3D.Triangulated({
     *      size: 10,
     *      fillStyle: new SolidFill({ color: ColorHEX('#FFF') })
     *  }) )
     * ```
     * - **Change point size**
     * ```ts
     *  pointSeries3D.setPointStyleHighlight( (pointStyle) => pointStyle
     *      .setSize( 10 )
     *  )
     * ```
     * - **Change point shape**
     * ```ts
     *  pointSeries3D.setPointStyle( (pointStyle) => pointStyle
     *      .setShape( 'cube' )
     *  )
     * ```
     * - **Assign highlight style automatically based on normal style**
     * ```ts
     *  pointSeries3D.setPointStyleHighlight( undefined )
     * ```
     *
     * Supports same capabilities as [[setPointStyle]] (has more detailed documentation).
     *
     * @param   value   A TriangulatedPoints3D object, or a function which modifies the current style or
     *                  **undefined** for automatic value based on normal style.
     * @returns         Object itself for fluent interface.
     */
    setPointStyleHighlight(value: TriangulatedPoints3D | ImmutableMutator<TriangulatedPoints3D> | undefined): this;
    /**
     * Get highlight style of points.
     * @return  TriangulatedPoints3D
     */
    getPointStyleHighlight(): TriangulatedPoints3D;
}
/**
 * Series type for visualizing a collection of `{ x, y, z }` coordinates by different **2D markers**.
 *
 * `PointCloudSeries3D` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
 *
 * - A static data set in millions data points range is rendered in hundreds of milliseconds (~200ms). Afterwards chart can be rotated and zoomed with 60 FPS.
 * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
 *
 * **Creating PointCloudSeries3D:**
 *
 * `PointCloudSeries3D` are created with [[Chart3D.addPointSeries]] method.
 *
 * Some properties of `PointCloudSeries3D` can only be configured when it is created. These arguments are all optional,
 * and are wrapped in a single object parameter:
 *
 * ```typescript
 *  // Example,
 *  const pointCloudSeries3D = Chart3D.addPointSeries({
 *      // Specify point series type as point cloud.
 *      type: PointSeriesTypes3D.Pixelated
 *  })
 * ```
 *
 * To learn about available properties, refer to [[PointSeriesOptions3D]].
 *
 * **Frequently used methods:**
 *
 * - Append data points to series | [[add]]
 * - Remove all data points from series | [[clear]]
 * - Configure style of points | [[setPointStyle]]
 * - Remove series temporarily, or permanently | [[dispose]]
 * - Restore series after `dispose` | [[restore]]
 *
 * **Related information:**
 *
 * There is another series type for visualizing large sets of 3D coordinates with markers: [[PointSeries3D]]
 *
 * `PointSeries3D` works otherwise same, except that it renders markers with 3D geometry, with a collection of different shape options,
 * like 3D boxes or spheres. For this reason, `PointCloudSeries3D` is significantly faster than `PointSeries3D`!
 *
 * The main difference between `PointSeries3D` and `PointCloudSeries3D` is that `PointCloudSeries3D` don't have *depth*,
 * so they have same size regardless of how far they are from the camera.
 */
export declare class PointCloudSeries3D extends AbstractPointSeries3D<PixelatedPoints3D> implements AttachableWithLUT {
    /**
     * @param _chart            Chart to which the component belongs
     * @param _removeFromChart  Handler to remove component from chart's collection it belongs to.
     * @param _restoreFromChart Handler to restore component from chart's collection it belongs to.
     * @param _layer3D          3D Rendering layer.
     * @param _options          Options.
     * @param theme             Theme.
     * @hidden
     */
    constructor(_chart: Chart3D, _removeFromChart: RemoveHandler<ChartComponent>, _restoreFromChart: RestoreHandler<ChartComponent>, _layer3D: Layer3D, theme: Theme, _options: PointSeriesOptions3D | undefined);
    /**
     * Set point style of Series.
     *
     * **Example syntax:**
     *
     * ```ts
     *  // Example syntax, Specify new style
     *  pointCloudSeries3D.setPointStyle( new PointStyle3D.Pixelated({
     *      size: 10,
     *      fillStyle: new SolidFill({ color: ColorHEX('#FFF') })
     *  }) )
     * ```
     *
     * ```ts
     *  // Example syntax, Change point color
     *  pointCloudSeries3D.setPointStyle( (pointStyle) => pointStyle
     *      .setFillStyle( new SolidFill({ color: ColorHEX('#FFF') }) )
     *  )
     * ```
     *
     * ```ts
     *  // Example syntax, Change point size
     *  pointCloudSeries3D.setPointStyle( (pointStyle) => pointStyle
     *      .setSize( 10 )
     *  )
     * ```
     *
     * **Point coloring:**
     *
     * Color of points is configured by the `fillStyle` property of active point style.
     *
     * Here is a list of all supported _fill styles_ with feature descriptions and example syntax:
     *
     * [[SolidFill]]:
     *
     * Solid color for all points in series.
     *
     * ```js
     *  // Example syntax, solid points color.
     *  pointCloudSeries3D.setPointStyle(new PointStyle3D.Pixelated({
     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) }),
     *      size: 10
     *  }))
     * ```
     *
     * [[PalettedFill]]:
     *
     * Look-up dynamic per-point color based on a _look up property_ (number) and a color look up table ([[LUT]]).
     *
     * ```js
     *  // Example syntax, dynamic points color.
     *  pointCloudSeries3D.setPointStyle(new PointStyle3D.Pixelated({
     *      fillStyle: new PalettedFill({
     *          // lookUpProperty defines basis of selecting look up value (number).
     *          lookUpProperty: 'value',
     *          // lut defines table for mapping look up value (number) to a color.
     *          lut: new LUT({
     *              interpolate: true,
     *              steps: [
     *                  { value: 0, color: ColorRGBA(0, 0, 0) },
     *                  { value: 1, color: ColorRGBA(255, 0, 0) }
     *              ]
     *          })
     *      }),
     *      size: 10
     *  }))
     * ```
     *
     * `pointCloudSeries3D` supports several different look-up modes:
     *
     * `lookUpProperty: 'value'`:
     *
     * **IMPORTANT:** In order to use `value` property on data points, the feature has to be explicitly activated **when the series is created**:
     *
     * ```js
     *  // Example syntax, enable individual data point values.
     *  const pointCloudSeries3D = chart3D.addPointSeries({
     *      type: PointSeriesTypes3D.Pixelated,
     *      individualLookupValuesEnabled: true
     *  })
     * ```
     *
     * `value` property is then added for every data point along side `x`, `y` and `z`:
     *
     * ```js
     *  // Example syntax, individual data point values.
     *  pointCloudSeries3D.add([
     *      { x: 0, y: 0, z: 0, value: 0 },
     *      { x: 1, y: 0, z: 2, value: 1 },
     *  ])
     * ```
     *
     * Look-up value is read from data point `value` property.
     *
     * `lookUpProperty: 'x'`:
     *
     * Look-up value is set to data point `x` coordinate on Axis.
     *
     * `lookUpProperty: 'y'`:
     *
     * Look-up value is set to data point `y` coordinate on Axis.
     *
     * `lookUpProperty: 'z'`:
     *
     * Look-up value is set to data point `z` coordinate on Axis.
     *
     * [[IndividualPointFill]]:
     *
     * Supply individual color for each data point.
     *
     * **IMPORTANT:** In order to use `IndividualPointFill`, the feature has to be explicitly activated **when the series is created**:
     *
     * ```js
     *  // Example syntax, enable individual data point colors.
     *  const pointCloudSeries3D = chart3D.addPointSeries({
     *      type: PointSeriesTypes3D.Pixelated,
     *      individualPointColorEnabled: true
     *  })
     * ```
     *
     * `color` property is then added for every data point along side `x`, `y` and `z`:
     *
     * ```js
     *  // Example syntax, individual data point colors.
     *  pointCloudSeries3D.add([
     *      { x: 0, y: 0, z: 0, color: ColorRGBA(255, 0, 0) },
     *      { x: 1, y: 0, z: 2, color: ColorRGBA(0, 255, 0) },
     *  ])
     * ```
     *
     * **Point size:**
     *
     * Size of points is configured by the `size` property of active point style.
     *
     * If required, points can also be individually sized by adding a `size` property to data points.
     *
     * **IMPORTANT:** In order to use `size` property, the feature has to be explicitly activated **when the series is created**:
     *
     * ```js
     *  // Example syntax, enable individual data point size.
     *  const pointCloudSeries3D = chart3D.addPointSeries({
     *      type: PointSeriesTypes3D.Pixelated,
     *      individualPointSizeEnabled: true
     *  })
     * ```
     *
     * `size` property is then added for every data point along side `x`, `y` and `z`:
     *
     * ```js
     *  // Example syntax, individual data point sizes.
     *  pointCloudSeries3D.add([
     *      { x: 0, y: 0, z: 0, size: 5 },
     *      { x: 1, y: 0, z: 2, size: 10 },
     *  ])
     * ```
     *
     * @param   value   A PixelatedPoints3D object, or a function which modifies the current style.
     * @return          Object itself for fluent interface
     */
    setPointStyle(value: PixelatedPoints3D | ImmutableMutator<PixelatedPoints3D>): this;
    /**
     * Get normal points style.
     * @return  PixelatedPoints3D
     */
    getPointStyle(): PixelatedPoints3D;
    /**
     * Set point style of Series when it is highlighted.
     *
     * Example usage:
     *
     * - **New PixelatedPoints3D object**
     * ```ts
     *  pointSeries3D.setPointStyleHighlight( new PointStyle3D.Pixelated({
     *      size: 10,
     *      fillStyle: new SolidFill({ color: ColorHEX('#FFF') })
     *  }) )
     * ```
     * - **Change point size**
     * ```ts
     *  pointSeries3D.setPointStyleHighlight( (pointStyle) => pointStyle
     *      .setSize( 10 )
     *  )
     * ```
     * - **Assign highlight style automatically based on normal style**
     * ```ts
     *  pointSeries3D.setPointStyleHighlight( undefined )
     * ```
     *
     * Supports same capabilities as [[setPointStyle]] (has more detailed documentation).
     *
     * @param   value   A PixelatedPoints3D object, or a function which modifies the current style or
     *                  **undefined** for automatic value based on normal style.
     * @returns         Object itself for fluent interface.
     */
    setPointStyleHighlight(value: PixelatedPoints3D | ImmutableMutator<PixelatedPoints3D> | undefined): this;
    /**
     * Get highlight style of points.
     * @return  PixelatedPoints3D
     */
    getPointStyleHighlight(): PixelatedPoints3D;
}
/**
 * Collection of *PointSeries3D* implementations.
 *
 * Used when creating an *PointSeries3D* with [[Chart3D.addPointSeries]].
 * Selected option tells what the returned *Series* type will be - *PointSeries3D* implementations are otherwise equal, but
 * their styling APIs expect different *Style* objects.
 *
 * - Select PointSeriesTypes3D.Triangulated for shaded geometries styled with [[PointStyle3D.Triangulated]].
 * - Select PointSeriesTypes3D.Pixelated for pixels styled with [[PointStyle3D.Pixelated]].
 */
export declare const PointSeriesTypes3D: {
    /**
     * Type of *Point Series 3D* that visualized points by shaded geometry styled using [[PointStyle3D.Triangulated]].
     */
    Triangulated: typeof PointSeries3D;
    /**
     * Type of *Point Series 3D* that visualized points by pixels styled using [[PointStyle3D.Pixelated]].
     */
    Pixelated: typeof PointCloudSeries3D;
};
/**
 * Available Point Series 3D types.
 *
 * Used internally for proper type casting. Should not be included in docs,
 * as it overrides the selection object just below, that has the same name.
 * @hidden
 */
export declare type PointSeriesTypes3D = typeof PointSeriesTypes3D[keyof typeof PointSeriesTypes3D];
/**
 * Interface that can be used to specify readonly parameters when creating a [[PointSeries3D]].
 *
 * `PointSeries3D` is created with [[Chart3D.addPointSeries]] method.
 */
export interface PointSeriesOptions3D<T extends PointSeriesTypes3D = PointSeriesTypes3D> {
    /**
     * Defines the type of *Point Series 3D*.
     *
     * See [[PointSeriesTypes3D]] for a collection of options.
     *
     * ```js
     *  // Example syntax,
     *  const pointSeries3D = chart3D.addPointSeries({
     *      type: PointSeriesTypes3D.Triangulated
     *  })
     * ```
     */
    type?: T;
    /**
     * Flag that can be used to enable data points `color` property on top of `x`, `y` and `z`.
     * By default this is disabled.
     *
     * This feature can be used to color data points individually by user supplied color.
     *
     * If required, this must be enabled **when the series is created**.
     *
     * ```js
     *  // Example, enable PointSeries3D data `color` property.
     *  const pointSeries3D = chart3D.addPointSeries({
     *      individualPointColorEnabled: true
     *  })
     *
     *  // 'color' property can now be included in data points.
     *  pointSeries3D.add([
     *      { x: 0, y: 0, z: 0, color: ColorRGBA(255, 0, 0) }
     *  ])
     * ```
     *
     * `individualPointColorEnabled` must be enabled in order to style `PointSeries3D` with [[IndividualPointFill]].
     * See [[PointSeries3D.setPointStyle]] for more detailed information.
     *
     * **Performance side-effects from enabling**:
     * - Increases CPU scripting time very slightly.
     * - Slightly increased GPU memory usage.
     */
    individualPointColorEnabled?: boolean;
    /**
     * Flag that can be used to enable data points `size` property on top of `x`, `y` and `z`.
     * By default this is disabled.
     *
     * This feature can be used to size data points individually by user supplied values.
     *
     * If required, this must be enabled **when the series is created**.
     *
     * ```js
     *  // Example, enable PointSeries3D data `size` property.
     *  const pointSeries3D = chart3D.addPointSeries({
     *      individualPointSizeEnabled: true
     *  })
     *
     *  // 'size' property can now be included in data points.
     *  pointSeries3D.add([
     *      { x: 0, y: 0, z: 0, size: 5 }
     *  ])
     *
     * **Performance side-effects from enabling**:
     * - With detailed point geometry (like 'sphere'), the geometry precision will be maximized, resulting in considerable increase in GPU processing time.
     */
    individualPointSizeEnabled?: boolean;
    /**
     * Flag that can be used to enable data points 'sizeAxisX', 'sizeAxisY' and 'sizeAxisZ' properties on top of `x`, `y` and `z`.
     * By default this is disabled.
     *
     * This feature can be used to size data points individually as 3D Axis dimensions.
     *
     * If required, this must be enabled **when the series is created**.
     *
     * ```js
     *  // Example, enable PointSeries3D data point individual axis size properties.
     *  const pointSeries3D = chart3D.addPointSeries({
     *      individualPointSizeAxisEnabled: true
     *  })
     *
     *  // 'sizeAxisX', 'sizeAxisY' and 'sizeAxisZ' properties can now be included in data points.
     *  pointSeries3D.add([
     *      { x: 0, y: 0, z: 0, sizeAxisX: 1, sizeAxisY: 10, sizeAxisZ: 5 }
     *  ])
     * ```
     *
     * **NOTE:** in order for points to be sized based on `sizeAxisX`, `sizeAxisY` and `sizeAxisZ` properties, the active point style must also have a fallback point size definition **as axis dimensions**:
     *
     * ```js
     *  pointSeries3D.setPointStyle(new PointStyle3D.Triangulated({
     *      // IMPORTANT: fallback `size` must be defined with { x, y, z } syntax!
     *      size: { x: 1, y: 1, z: 1 },
     *      shape: 'sphere',
     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
     *  }))
     * ```
     *
     * **Performance side-effects from enabling**:
     * - With detailed point geometry (like 'sphere'), the geometry precision will be maximized, resulting in considerable increase in GPU processing time.
     */
    individualPointSizeAxisEnabled?: boolean;
    /**
     * Flag that can be used to enable data points `value` property on top of `x`, `y` and `z`.
     * By default this is disabled.
     *
     * This feature can be used to color data points individually by dynamic color look up.
     *
     * If required, this must be enabled **when the series is created**.
     *
     * ```js
     *  // Example, enable PointSeries3D data `value` property.
     *  const pointSeries3D = chart3D.addPointSeries({
     *      individualLookupValuesEnabled: true
     *  })
     *
     *  // 'value' property can now be included in data points.
     *  pointSeries3D.add([
     *      { x: 0, y: 0, z: 0, value: 5 }
     *  ])
     * ```
     *
     * `individualLookupValuesEnabled` must be enabled in order to style `PointSeries3D` with [[PalettedFill]] of `lookUpProperty: 'value'`.
     * See [[PointSeries3D.setPointStyle]] for more detailed information.
     *
     * **Performance side-effects from enabling**:
     * - With detailed point geometry (like 'sphere'), the geometry precision will be maximized, resulting in considerable increase in GPU processing time.
     */
    individualLookupValuesEnabled?: boolean;
}
export {};
/**
 * Type requirement for Shapes which are used to render a Series3D.
 * @hidden
 */
export declare type Series3DVisual = ChartVisual & Region3D & Shape3D;
/**
 * Abstract base class for all _3D series types_.
 *
 * 3D series are created with methods of [[Chart3D]], for example [[Chart3D.addPointSeries]].
 *
 * List of 3D series types:
 *
 * - [[PointSeries3D]]
 * - [[LineSeries3D]]
 * - [[PointLineSeries3D]]
 * - [[BoxSeries3D]]
 * - [[SurfaceGridSeries3D]]
 * - [[SurfaceMeshSeries3D]]
 */
export declare abstract class Series3D<VisualType extends Series3DVisual = Series3DVisual> extends ChartComponent<VisualType> implements Series {
    /**
     * Set whether series is taken into account with automatic scrolling and fitting of attached axes.
     *
     * By default, this is true for all series.
     *
     * By setting this to `false`, any series can be removed from axis scrolling/fitting.
     *
     * ```ts
     *  // Example syntax, remove series from automatic scrolling / fitting.
     *  LineSeries.setAutoScrollingEnabled(false)
     * ```
     * @param   enabled     `true` default, axes will take series into account in scrolling and fitting operations.
     *                      `false`, axes will ignore series boundaries.
     * @return              Object itself for fluent interface.
     */
    setAutoScrollingEnabled(enabled: boolean): this;
    /**
     * Get whether series is taken into account with automatic scrolling and fitting of attached axes.
     *
     * By default, this is true for all series.
     *
     * @return               `true` default, axes will take series into account in scrolling and fitting operations.
     *                      `false`, axes will ignore series boundaries.
     */
    getAutoScrollingEnabled(): boolean;
    /**
     * Set Color Shading Style for series.
     *
     * Shading style changes the visual style of the rendering. See [[ColorShadingStyles]] for available shading styles.
     *
     * Use Simple color shading style:
     * ```js
     * series3D.setShadingStyle(new ColorShadingStyles.Simple())
     * ```
     *
     * Use Phong color shading style:
     * ```js
     * series3D.setShadingStyle(new ColorShadingStyles.Phong())
     * ```
     *
     * Configuring specular highlight for Phong shading style:
     * ```js
     * series3D.setShadingStyle(new ColorShadingStyles.Phong({
     *      specularReflection: 0.5,
     *      specularColor: ColorRGBA(255, 255, 255)
     * }))
     * ```
     *
     * @param shadingStyle  Color shading style to use for this series.
     * @returns             Object itself for fluent interface.
     */
    setColorShadingStyle(shadingStyle: ColorShadingStyle): this;
    /**
     * Get the currently used [[ColorShadingStyle]].
     * @returns The Color Shading Style for the series.
     */
    getColorShadingStyle(): ColorShadingStyle;
    /**
     * Set _3D depth test_ enabled for this series.
     *
     * By default this is enabled, meaning that any series that is rendered after this series and is behind this series will not be rendered.
     *
     * Can be disabled to alter 3D rendering behavior.
     *
     * ```js
     *  // Example syntax, disable depth test.
     *  pointSeries3D.setDepthTestEnabled(false)
     * ```
     *
     * @param enabled   Depth test enabled?
     * @return          Object itself for fluent interface.
     */
    setDepthTestEnabled(enabled: boolean): this;
    /**
     * Get _3D depth test_ enabled for this series.
     *
     * By default this is enabled, meaning that any series that is rendered after this series and is behind this series will not be rendered.
     *
     * Can be disabled to alter 3D rendering behavior.
     * @return          Depth test enabled?
     */
    getDepthTestEnabled(): boolean;
    /**
     * @return Max X value of the series
     */
    getXMax(): number | undefined;
    /**
     * @return Min X value of the series
     */
    getXMin(): number | undefined;
    /**
     * @return Max Y value of the series
     */
    getYMax(): number | undefined;
    /**
     * @return Min Y value of the series
     */
    getYMin(): number | undefined;
    /**
     * @return Max Z value of the series
     */
    getZMax(): number | undefined;
    /**
     * @return Min Z value of the series
     */
    getZMin(): number | undefined;
}
export interface XYZDataInput {
    /**
     * Append a single `XYZ` coordinate or list of coordinates into the *series*.
     *
     * ```ts
     *  // Example syntax
     *  LineSeries3D.add({ x: 0, y: 0, z: 0 })
     *
     *  LineSeries3D.add([
     *      { x: 0, y: 100, z: 50 },
     *      { x: 10, y: 50, z: 150 },
     *      { x: 20, y: 75, z: 100 },
     *  ])
     * ```
     *
     * @param    points  Single XYZ coordinate or list of coordinates.
     * @returns          Object itself for fluent interface.
     */
    add(data: Point3D | Point3D[]): this;
    /**
     * Clear all previously pushed data points from the *series*.
     *
     * ```ts
     *  // Example usage
     *  LineSeries.clear()
     * ```
     *
     * @return      Object itself for fluent interface.
     */
    clear(): this;
    /**
     * Get amount of points that series currently has.
     * @return  Number of points
     */
    getPointAmount(): number;
}
/**
 * Type requirement for Shapes which are used to render a BasicSeries3D.
 * @hidden
 */
export declare type BasicSeries3DVisual = Series3DVisual & DataSet<unknown>;
/**
 * Abstract base class for 3D series that are split into Segments, similarly as BasicSeries (2D).
 *
 * NOTE: The separation of segmented and not-segment Series types is not managed properly at the moment.
 * Existing problems are at least:
 * - Unclear class / method names ( BasicSeries could be made into something like SegmentedSeries ).
 * - Some "Segmented Series" do not extend from BasicSeries due to unresolved hierarchy problems
 *      * AreaSeries are all "Segmented Series".
 * - Currently "Segmented Series" expect data input in XY/XYZ format. However, these are two unrelated properties.
 *   Segmentation can be necessary for other types of data input, too (BoxSeries3D !).
 *      * It looks like BasicSeries can be further split into two: 'SegmentedSeries', and 'Series with XYZ data input'
 *      * What BoxSeries wants from BasicSeries3D: region logic + clear
 *
 * @hidden Internal class
 */
export declare abstract class BasicSeries3D<VisualType extends BasicSeries3DVisual = BasicSeries3DVisual> extends Series3D<VisualType> implements XYZDataInput {
    /**
     * Append a single `XYZ` coordinate or list of coordinates into the *series*.
     *
     * ```ts
     *  // Example syntax
     *  LineSeries3D.add({ x: 0, y: 0, z: 0 })
     *
     *  LineSeries3D.add([
     *      { x: 0, y: 100, z: 50 },
     *      { x: 10, y: 50, z: 150 },
     *      { x: 20, y: 75, z: 100 },
     *  ])
     * ```
     *
     * @param    points  Single XYZ coordinate or list of coordinates.
     * @returns          Object itself for fluent interface.
     */
    add(data: Point3D | Point3D[]): this;
    /**
     * Clear all previously pushed data points from the *series*.
     *
     * ```ts
     *  // Example usage
     *  LineSeries.clear()
     * ```
     *
     * @return      Object itself for fluent interface.
     */
    clear(): this;
    /**
     * Get amount of points that series currently has.
     * @return  Number of points
     */
    getPointAmount(): number;
    /**
     * @return Max X value of the series
     */
    getXMax(): number | undefined;
    /**
     * @return Min X value of the series
     */
    getXMin(): number | undefined;
    /**
     * @return Max Y value of the series
     */
    getYMax(): number | undefined;
    /**
     * @return Min Y value of the series
     */
    getYMin(): number | undefined;
    /**
     * @return Max Z value of the series
     */
    getZMax(): number | undefined;
    /**
     * @return Min Z value of the series
     */
    getZMin(): number | undefined;
}
/**
 * Series for visualizing a 3D Surface Grid inside [[Chart3D]].
 *
 * The grid is defined by imagining a plane along X and Z axis, split to < COLUMNS > (cells along X axis) and < ROWS > (cells along Z axis)
 *
 * The total amount of < CELLS > in a surface grid is calculated as `columns * rows`. Each < CELL > can be associated with DATA from an user data set.
 *
 * This series is optimized for *massive* amounts of data - here are some reference specs to give an idea:
 *
 * - A static data set in tens of millions range is rendered in a matter of seconds.
 * - A data set in tens of millions range can be updated in less than a second.
 * - Maximum data set size is entirely limited by available memory (RAM). Even billion (1 000 000 000) data points have been visualized on a personal computer.
 *
 * **Creating Surface Grid Series:**
 *
 * `NewSurfaceGridSeries3D` are created with [[Chart3D.addSurfaceGridSeries]] method.
 *
 * Some properties of `NewSurfaceGridSeries3D` can only be configured when it is created. Some of these arguments are optional, while some are required.
 * They are all wrapped in a single object parameter:
 *
 * ```typescript
 *  // Example,
 *  const surfaceGridSeries = Chart3D.addSurfaceGridSeries({
 *      columns: 100,
 *      rows: 200,
 *  })
 * ```
 *
 * To learn about these properties, refer to [[NewSurfaceGridSeries3DOptions]].
 *
 * **Frequently used methods:**
 *
 * - Specify cell height data | [[invalidateHeightMap]]
 * - Specify cell intensity data [[invalidateIntensityValues]]
 * - Configure fill style | [[setFillStyle]]
 * - Configure wireframe style | [[setWireframeStyle]]
 * - Configure intensity interpolation | [[setIntensityInterpolation]]
 * - Configure cull mode | [[setCullMode]]
 * - Remove series temporarily, or permanently | [[dispose]]
 * - Restore series after `dispose` | [[restore]]
 *
 * `NewSurfaceGridSeries3D` is suitable for visualizing a surface with unchanging locations along X and Z axes.
 *
 * For visualizing continuous sampling in 3D surface, refer to [[SurfaceScrollingGridSeries3D]].
 */
export declare class NewSurfaceGridSeries3D extends Series3D<SurfaceGridStatic> implements AttachableWithLUT {
    /**
     * Set fill style of Surface Grid.
     *
     * **Supported fill styles:**
     *
     * [[PalettedFill]]:
     *
     * Look-up dynamic per-CELL color based on a _look up property_ and a color look up table ([[LUT]]).
     *
     * `NewSurfaceGridSeries3D` supports several different look-up modes:
     *
     * `lookUpProperty: 'value'`:
     *
     * Color each CELL based on its INTENSITY value. Cell intensity values can be specified with [[invalidateIntensityValues]].
     *
     * ```ts
     *  // Example, enable dynamic coloring based on cell intensity data.
     *  surfaceGridSeries
     *      .setFillStyle(new PalettedFill({
     *          lookUpProperty: 'value',
     *          lut: new LUT({
     *              interpolate: true,
     *              steps: [
     *                  { value: 0, color: ColorRGBA(0, 0, 0) },
     *                  { value: 100, color: ColorRGBA(255, 0, 0) }
     *              ]
     *          })
     *      }))
     * ```
     *
     * `lookUpProperty: 'x' | 'y' | 'z'`:
     *
     * Color each CELL based on one of its axis coordinates.
     *
     * ```ts
     *  // Example, enable dynamic coloring based on cell Y coordinate.
     *  surfaceGridSeries
     *      .setFillStyle(new PalettedFill({
     *          lookUpProperty: 'y',
     *          lut: new LUT({
     *              interpolate: true,
     *              steps: [
     *                  { value: 0, color: ColorRGBA(0, 0, 0) },
     *                  { value: 100, color: ColorRGBA(255, 0, 0) }
     *              ]
     *          })
     *      }))
     * ```
     *
     * Intensity based dynamic coloring can further be configured with [[setIntensityInterpolation]] to enable or disable automatic interpolation of Intensity values.
     * This is enabled by default.
     *
     * [[SolidFill]]:
     *
     * Solid color for entire Surface Grid fill.
     *
     * ```ts
     *  // Example, solid surface grid fill.
     *  heatmapSeries.setFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
     * ```
     *
     * If only wireframe rendering is desired, using `emptyFill` is recommended for better performance.
     *
     * [[emptyFill]]:
     *
     * Disables Surface Grid fill.
     *
     * ```js
     *  // Example, hide heatmap fill and show wireframe.
     *  heatmapSeries
     *      .setFillStyle(emptyFill)
     *      .setWireframeStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
     * ```
     *
     * **Related functionality:**
     *
     * - Color shading style can affect the general coloring of 3D shapes | [[setColorShadingStyle]].
     *
     * @param value     FillStyle object or function which modifies current value.
     *                  Supported FillStyle types: [[SolidFill]], [[PalettedFill]], [[emptyFill]]
     * @return          Object itself.
     */
    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of series.
     * @return  FillStyle.
     */
    getFillStyle(): FillStyle;
    /**
     * Set wireframe style of Surface Grid.
     *
     * Wireframe consists of thin lines drawn around the borders of each surface CELL.
     * They are generally enabled to improve the perception of surface shape.
     *
     * Wireframe style is defined as [[LineStyle]].
     *
     * ```ts
     *  // Example 1, enable wireframe.
     *  heatmapSeries.setWireframeStyle(new SolidLine({
     *      thickness: 1,
     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
     *  }))
     * ```
     *
     * ```ts
     *  // Example 2, disable wireframe.
     *  heatmapSeries.setWireframeStyle(emptyLine)
     * ```
     *
     * At this time, only solid wireframe rendering is supported.
     * In future, this could be extended to coloring wireframe based on some dynamic properties (X, Y, Z, Intensity) similarly as surface fill.
     *
     * **Related functionality:**
     *
     * - Color shading style can affect the general coloring of 3D shapes | [[setColorShadingStyle]].
     *
     * @param value     LineStyle object or function which modifies current value.
     * @return          Object itself.
     */
    setWireframeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get surface grid wireframe style.
     * @return  LineStyle object.
     */
    getWireframeStyle(): LineStyle;
    /**
     * Set surface intensity interpolation mode.
     *
     * **This only affects surface grid with INTENSITY based dynamic coloring**, see [[setFillStyle]] for more information.
     *
     * This feature is enabled by default (`'bilinear'`).
     *
     * `'disabled'` or `undefined`: Interpolation disabled; draw data exactly as it is.
     *
     * `'bilinear'`: Each PIXEL is colored based on an Bi-linearly interpolated intensity value based on the 4 closest real intensity values.
     *
     * @param   interpolationMode   Surface intensity interpolation mode selection.
     * @return                      Object itself for fluent interface.
     */
    setIntensityInterpolation(interpolationMode: IntensityInterpolationMode | undefined): this;
    /**
     * Get surface intensity interpolation mode.
     */
    getIntensityInterpolation(): IntensityInterpolationMode;
    /**
     * Invalidate range of surface INTENSITY values starting from first column and row,
     * updating coloring if a Color look up table ([[LUT]]) has been attached to the series (see [[NewSurfaceGridSeries3D.setFillStyle]]).
     *
     * See the other overload of this method for invalidating a surface grid section which doesn't start from the first column and row.
     *
     * ```js
     *  // Example, 3x3 surface full invalidation.
     *  const surfaceGridSeries = Chart3D.addSurfaceGridSeries({
     *      dataOrder: 'columns',
     *      columns: 3,
     *      rows: 3
     *  })
     *
     *  surfaceGridSeries.invalidateIntensityValues([
     *      // Column 1 intensity values.
     *      [0, 0, 0],
     *      // Column 2 intensity values.
     *      [1, 1, 1],
     *      // Column 3 intensity values.
     *      [0, 2, 0],
     *  ])
     * ```
     *
     * Data interpretation basis is defined by [[NewSurfaceGridSeries3DOptions.dataOrder]] property from when the series was created.
     * Can be either list of *columns*, or list of *rows*.
     *
     * `invalidateIntensityValues` can trigger warnings when used controversially.
     * In production applications, these can be controlled with [[LightningChartOptions.warnings]].
     *
     * @param   value       Matrix (array of arrays) of intensity values.
     * @returns             Object itself for fluent interface.
     */
    invalidateIntensityValues(value: number[][]): this;
    /**
     * Invalidate a partial range of surface INTENSITY values, updating coloring if a Color look up table ([[LUT]]) has been attached to the series (see [[NewSurfaceGridSeries3D.setFillStyle]]).
     *
     * ```js
     *  // Example, 100x10 surface invalidate partial section of surface.
     *
     *  const surfaceGridSeries = Chart3D.addSurfaceGridSeries({
     *      dataOrder: 'columns',
     *      columns: 100,
     *      rows: 10
     *  })
     *
     *  surfaceGridSeries.invalidateIntensityValues({
     *      // Index of first invalidated column.
     *      iColumn: 50,
     *      // Index of first invalidated row.
     *      iRow: 2,
     *      // Intensity values matrix. It's dimensions imply the amount of invalidated columns & rows.
     *      values: [
     *          // 1st invalidated column intensity values.
     *          [1, 1, 1, 1, 1],
     *          // 2nd invalidated column intensity values.
     *          [2, 2, 2, 2, 2],
     *          // 3rd invalidated column intensity values.
     *          [1, 0, 0, 0, 1],
     *          // 4th invalidated column intensity values.
     *          [0, 1, 0, 1, 0],
     *          // 5th invalidated column intensity values.
     *          [0, 0, 1, 0, 0],
     *      ],
     *  })
     * ```
     *
     * `invalidateIntensityValues` can trigger warnings when used controversially.
     * In production applications, these can be controlled with [[LightningChartOptions.warnings]].
     *
     * @param   value       Partial invalidation information, where `values` is an intensity value matrix, `iColumn` the first affected column and `iRow` the first affected row.
     * @returns             Object itself for fluent interface.
     */
    invalidateIntensityValues(value: {
        iColumn: number;
        iRow: number;
        values: number[][];
    }): this;
    /**
     * Invalidate range of surface HEIGHT values starting from first column and row.
     * These values correspond to coordinates along the Y axis.
     *
     * See the other overload of this method for invalidating a surface grid section which doesn't start from the first column and row.
     *
     * ```js
     *  // Example, 3x3 surface full invalidation.
     *  const surfaceGridSeries = Chart3D.addSurfaceGridSeries({
     *      dataOrder: 'columns',
     *      columns: 3,
     *      rows: 3
     *  })
     *
     *  surfaceGridSeries.invalidateHeightMap([
     *      // Column 1 height (Y) values.
     *      [0, 0, 0],
     *      // Column 2 height (Y) values.
     *      [1, 1, 1],
     *      // Column 3 height (Y) values.
     *      [0, 2, 0],
     *  ])
     * ```
     *
     * Data interpretation basis is defined by [[NewSurfaceGridSeries3DOptions.dataOrder]] property from when the series was created.
     * Can be either list of *columns*, or list of *rows*.
     *
     * `invalidateHeightMap` can trigger warnings when used controversially.
     * In production applications, these can be controlled with [[LightningChartOptions.warnings]].
     *
     * @param   value       Matrix (array of arrays) of height values.
     * @returns             Object itself for fluent interface.
     */
    invalidateHeightMap(value: number[][]): this;
    /**
     * Invalidate a partial range of surface HEIGHT values.
     * These values correspond to coordinates along the Y axis.
     *
     * ```js
     *  // Example, 100x10 surface invalidate partial section of surface.
     *
     *  const surfaceGridSeries = Chart3D.addSurfaceGridSeries({
     *      dataOrder: 'columns',
     *      columns: 100,
     *      rows: 10
     *  })
     *
     *  surfaceGridSeries.invalidateHeightMap({
     *      // Index of first invalidated column.
     *      iColumn: 50,
     *      // Index of first invalidated row.
     *      iRow: 2,
     *      // Height (Y) values matrix. It's dimensions imply the amount of invalidated columns & rows.
     *      values: [
     *          // 1st invalidated column height (Y) values.
     *          [1, 1, 1, 1, 1],
     *          // 2nd invalidated column height (Y) values.
     *          [2, 2, 2, 2, 2],
     *          // 3rd invalidated column height (Y) values.
     *          [1, 0, 0, 0, 1],
     *          // 4th invalidated column height (Y) values.
     *          [0, 1, 0, 1, 0],
     *          // 5th invalidated column height (Y) values.
     *          [0, 0, 1, 0, 0],
     *      ],
     *  })
     * ```
     *
     * `invalidateIntensityValues` can trigger warnings when used controversially.
     * In production applications, these can be controlled with [[LightningChartOptions.warnings]].
     *
     * @param   value       Partial invalidation information, where `values` is an height (Y) value matrix, `iColumn` the first affected column and `iRow` the first affected row.
     * @returns             Object itself for fluent interface.
     */
    invalidateHeightMap(value: {
        iColumn: number;
        iRow: number;
        values: number[][];
    }): this;
    /**
     * Set culling of this Surface grid series.
     *
     * Culling means skipping drawing of specific geometry parts, based on its orientation.
     *
     * `'disabled'` -> full geometry is drawn.
     *
     * `'cull-back'` -> the behind of geometry is **not** drawn.
     *
     * `'cull-front'` -> the front of geometry is **not** drawn.
     *
     * Surface series default cull mode is `'disabled'` to show both sides of the surface.
     *
     * @param   mode        `CullMode3D` or `false` | `true` to disable/enable culling respectively.
     * @returns             Object itself for fluent interface.
     */
    setCullMode(mode: CullMode3D | boolean): this;
    /**
     * Get cull mode for this Surface grid series.
     *
     * Culling means skipping drawing of specific geometry parts, based on its orientation.
     *
     * `'disabled'` -> full geometry is drawn.
     *
     * `'cull-back'` -> the behind of geometry is **not** drawn.
     *
     * `'cull-front'` -> the front of geometry is **not** drawn.
     *
     * Surface series default cull mode is `'disabled'` to show both sides of the surface.
     * @return  Active cull mode.
     */
    getCullMode(): CullMode3D;
}
/**
 * Interface for readonly configuration of [[NewSurfaceGridSeries3D]].
 *
 * **Required properties:**
 * - [[NewSurfaceGridSeries3DOptions.columns]]: Amount of cells along X axis.
 * - [[NewSurfaceGridSeries3DOptions.rows]]: Amount of cells along Z axis.
 *
 * **Optional properties:**
 *
 * All or any of these can be omitted or set to `undefined`, in which case a default value is used.
 *
 * - [[NewSurfaceGridSeries3DOptions.dataOrder]]: Specifies interpretation order for Height and Intensity data.
 * - [[NewSurfaceGridSeries3DOptions.start]]: Specifies location of first cell on X and Z axes.
 * - [[NewSurfaceGridSeries3DOptions.step]]: Specifies step between cells on X and Z axes.
 * - [[NewSurfaceGridSeries3DOptions.end]]: Specifies location of last cell on X and Z axes.
 *
 * **Example usage:**
 *
 * ```typescript
 *  // Example 1, create surface grid series with minimum configuration.
 *  const surfaceGrid = Chart3D.addSurfaceGridSeries({
 *      columns: 100,
 *      rows: 50,
 *  })
 * ```
 *
 * See also [[Chart3D.addSurfaceScrollingGridSeries]].
 */
export interface NewSurfaceGridSeries3DOptions {
    /**
     * Amount of cells along X axis.
     *
     * **Required!**
     *
     * Surface grid data amount is specified as `columns * rows`.
     *
     * Larger data sets require more memory (RAM) to work. With nearly any setup, tens of millions data points can easily be reached and with good setups even
     * billion (1 000 000 000) data points have been properly visualized.
     */
    columns: number;
    /**
     * Amount of cells along Z axis.
     *
     * **Required!**
     *
     * Surface grid data amount is specified as `columns * rows`.
     *
     * Larger data sets require more memory (RAM) to work. With nearly any setup, tens of millions data points can easily be reached and with good setups even
     * billion (1 000 000 000) data points have been properly visualized.
     */
    rows: number;
    /**
     * Specifies interpretation order for Height and Intensity data when using [[NewSurfaceGridSeries3D.invalidateHeightMap]] or [[NewSurfaceGridSeries3D.invalidateIntensityValues]].
     *
     * `'columns'` -> Supply lists of "columns"
     *
     * ```typescript
     *  const intensityValues = [
     *      [
     *          0, // Intensity value column = 0, row = 0
     *          0, // Intensity value column = 0, row = 1
     *          0, // Intensity value column = 0, row = n
     *      ],
     *      [
     *          0, // Intensity value column = 1, row = 0
     *          0, // Intensity value column = 1, row = 1
     *          0, // Intensity value column = 1, row = n
     *      ],
     *  ]
     * ```
     *
     * `'rows'` -> Supply lists of "rows"
     *
     * ```typescript
     *  const intensityValues = [
     *      [
     *          0, // Intensity value row = 0, column = 0
     *          0, // Intensity value row = 0, column = 1
     *          0, // Intensity value row = 0, column = n
     *      ],
     *      [
     *          0, // Intensity value row = 1, column = 0
     *          0, // Intensity value row = 1, column = 1
     *          0, // Intensity value row = 1, column = n
     *      ],
     *  ]
     * ```
     *
     * Optional, defaults to `'columns'`.
     */
    dataOrder?: 'columns' | 'rows';
    /**
     * Specifies location of first cell on X and Z axes.
     *
     * Optional, defaults to `{ x: 0, z: 0 }`
     */
    start?: PointXZ;
    /**
     * Specifies step between cells on X and Z axes.
     *
     * Optional, defaults to `{ x: 1, y: 1 }`, unless [[NewSurfaceGridSeries3DOptions.end]] is specified.
     */
    step?: PointXZ;
    /**
     * Specifies location of last cell on X and Z axes.
     *
     * Optional.
     *
     * `end` has priority over [[NewSurfaceGridSeries3DOptions.step]].
     */
    end?: PointXZ;
}
/**
 * Series for visualizing a 3D Surface Grid inside [[Chart3D]], with API for pushing data in a scrolling manner (append new data on top of existing data).
 *
 * The grid is defined by imagining a plane along X and Z axis, split to < COLUMNS > (cells along X axis) and < ROWS > (cells along Z axis)
 *
 * The total amount of < CELLS > in a surface grid is calculated as `columns * rows`. Each < CELL > can be associated with DATA from an user data set.
 *
 * This series is optimized for *massive* amounts of data - here are some reference specs to give an idea:
 *
 * - A data set of tens of millions data points is rendered in a matter of seconds.
 * - Maximum data set size is entirely limited by available memory (RAM).
 *   Even billion (1 000 000 000) data points have been visualized on a personal computer.
 *   Interacting with massive surface charts (more than tens of millions data points) requires a powerful GPU !
 * - Scrolling Surface Grid input stream rate is virtually unlimited - even 10 million incoming data points **per second** can easily be processed.
 *   Application limitations usually come from previously mentioned RAM and/or GPU bottlenecks.
 *
 * **Creating Surface Scrolling Grid Series:**
 *
 * `SurfaceScrollingGridSeries3D` are created with [[Chart3D.addSurfaceScrollingGridSeries]] method.
 *
 * Some properties of `SurfaceScrollingGridSeries3D` can only be configured when it is created. Some of these arguments are optional, while some are required.
 * They are all wrapped in a single object parameter:
 *
 * ```typescript
 *  // Example,
 *  const surfaceScrollingGridSeries = Chart3D.addSurfaceScrollingGridSeries({
 *      columns: 100,
 *      rows: 200,
 *  })
 * ```
 *
 * To learn about these properties, refer to [[SurfaceScrollingGridSeries3DOptions]].
 *
 * **Frequently used methods:**
 *
 * - Append data | [[addValues]]
 * - Configure fill style | [[setFillStyle]]
 * - Configure wireframe style | [[setWireframeStyle]]
 * - Configure intensity interpolation | [[setIntensityInterpolation]]
 * - Configure cull mode | [[setCullMode]]
 * - Remove series temporarily, or permanently | [[dispose]]
 * - Restore series after `dispose` | [[restore]]
 *
 * `SurfaceScrollingGridSeries3D` is designed for visualizing real-time data sources, where either new columns or rows are pushed in periodically.
 *
 * For visualizing 3D surface grid with static columns and rows amount, refer to [[NewSurfaceGridSeries3D]].
 */
export declare class SurfaceScrollingGridSeries3D extends Series3D<SurfaceGridScrolling> implements AttachableWithLUT {
    /**
     * Set fill style of Surface Grid.
     *
     * **Supported fill styles:**
     *
     * [[PalettedFill]]:
     *
     * Look-up dynamic per-CELL color based on a _look up property_ and a color look up table ([[LUT]]).
     *
     * `SurfaceScrollingGridSeries3D` supports several different look-up modes:
     *
     * `lookUpProperty: 'value'`:
     *
     * Color each CELL based on its INTENSITY value. Cell intensity values can be specified with [[invalidateIntensityValues]].
     *
     * ```ts
     *  // Example, enable dynamic coloring based on cell intensity data.
     *  surfaceGridSeries
     *      .setFillStyle(new PalettedFill({
     *          lookUpProperty: 'value',
     *          lut: new LUT({
     *              interpolate: true,
     *              steps: [
     *                  { value: 0, color: ColorRGBA(0, 0, 0) },
     *                  { value: 100, color: ColorRGBA(255, 0, 0) }
     *              ]
     *          })
     *      }))
     * ```
     *
     * `lookUpProperty: 'x' | 'y' | 'z'`:
     *
     * Color each CELL based on one of its axis coordinates.
     *
     * ```ts
     *  // Example, enable dynamic coloring based on cell Y coordinate.
     *  surfaceGridSeries
     *      .setFillStyle(new PalettedFill({
     *          lookUpProperty: 'y',
     *          lut: new LUT({
     *              interpolate: true,
     *              steps: [
     *                  { value: 0, color: ColorRGBA(0, 0, 0) },
     *                  { value: 100, color: ColorRGBA(255, 0, 0) }
     *              ]
     *          })
     *      }))
     * ```
     *
     * Intensity based dynamic coloring can further be configured with [[setIntensityInterpolation]] to enable or disable automatic interpolation of Intensity values.
     * This is enabled by default.
     *
     * [[SolidFill]]:
     *
     * Solid color for entire Surface Grid fill.
     *
     * ```ts
     *  // Example, solid surface grid fill.
     *  heatmapSeries.setFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
     * ```
     *
     * If only wireframe rendering is desired, using `emptyFill` is recommended for better performance.
     *
     * [[emptyFill]]:
     *
     * Disables Surface Grid fill.
     *
     * ```js
     *  // Example, hide heatmap fill and show wireframe.
     *  heatmapSeries
     *      .setFillStyle(emptyFill)
     *      .setWireframeStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
     * ```
     *
     * **Related functionality:**
     *
     * - Color shading style can affect the general coloring of 3D shapes | [[setColorShadingStyle]].
     *
     * @param value     FillStyle object or function which modifies current value.
     *                  Supported FillStyle types: [[SolidFill]], [[PalettedFill]], [[emptyFill]]
     * @return          Object itself.
     */
    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of series.
     * @return  FillStyle.
     */
    getFillStyle(): FillStyle;
    /**
     * Set wireframe style of Surface Grid.
     *
     * Wireframe consists of thin lines drawn around the borders of each surface CELL.
     * They are generally enabled to improve the perception of surface shape.
     *
     * Wireframe style is defined as [[LineStyle]].
     *
     * ```ts
     *  // Example 1, enable wireframe.
     *  heatmapSeries.setWireframeStyle(new SolidLine({
     *      thickness: 1,
     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
     *  }))
     * ```
     *
     * ```ts
     *  // Example 2, disable wireframe.
     *  heatmapSeries.setWireframeStyle(emptyLine)
     * ```
     *
     * At this time, only solid wireframe rendering is supported.
     * In future, this could be extended to coloring wireframe based on some dynamic properties (X, Y, Z, Intensity) similarly as surface fill.
     *
     * **Related functionality:**
     *
     * - Color shading style can affect the general coloring of 3D shapes | [[setColorShadingStyle]].
     *
     * @param value     LineStyle object or function which modifies current value.
     * @return          Object itself.
     */
    setWireframeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get surface grid wireframe style.
     * @return  LineStyle object.
     */
    getWireframeStyle(): LineStyle;
    /**
     * Set surface intensity interpolation mode.
     *
     * **This only affects surface grid with INTENSITY based dynamic coloring**, see [[setFillStyle]] for more information.
     *
     * This feature is enabled by default (`'bilinear'`).
     *
     * `'disabled'` or `undefined`: Interpolation disabled; draw data exactly as it is.
     *
     * `'bilinear'`: Each PIXEL is colored based on an Bi-linearly interpolated intensity value based on the 4 closest real intensity values.
     *
     * @param   interpolationMode   Surface intensity interpolation mode selection.
     * @return                      Object itself for fluent interface.
     */
    setIntensityInterpolation(interpolationMode: IntensityInterpolationMode | undefined): this;
    /**
     * Get surface intensity interpolation mode.
     */
    getIntensityInterpolation(): IntensityInterpolationMode;
    /**
     * Clear all values added into the series.
     *
     * ```ts
     *  // Example syntax,
     *  surfaceScrollingGridSeries.clear()
     * ```
     *
     * This only affects Y and Intensity data. Other than any styles, etc. this will make the series behave as if it was just created.
     * @return      Object itself for fluent interface.
     */
    clear(): this;
    /**
     * Append values to the Surface Scrolling Grid Series.
     *
     * The series type can contain between 1 and 2 different data sets (Y values and Intensity values).
     * This same method is used for managing both types of data;
     *
     * When `addValues` is called, the parameter is wrapped in an object `{ }`, and one of (or both) `yValues` and `intensityValues` can be supplied.
     *
     * ```ts
     *  // Example syntax,
     *  surfaceScrollingGridSeries.addValues({
     *      yValues: ...
     *      intensityValues ...
     *  })
     * ```
     *
     * The type of `yValues` and `intensityValues` is a *number matrix*. At first level, it is a list of samples to add.
     *
     * ```ts
     *  yValues: [
     *      // Sample 1,
     *      // Sample 2
     *  ]
     * ```
     *
     * If both `yValues` and `intensityValues` are specified, then their length should be exactly same!
     *
     * Order of sample data is selected when the series is created;
     *
     * `scrollDimension: 'columns'` ->
     *
     * ```typescript
     *  yValues: [
     *      [
     *          0, // column = 0, row = 0
     *          0, // column = 0, row = 1
     *          0, // column = 0, row = n
     *      ],
     *      [
     *          0, // column = 1, row = 0
     *          0, // column = 1, row = 1
     *          0, // column = 1, row = n
     *      ],
     *  ]
     * ```
     *
     * `scrollDimension: 'rows'` ->
     *
     * ```typescript
     *  yValues: [
     *      [
     *          0, // row = 0, column = 0
     *          0, // row = 0, column = 1
     *          0, // row = 0, column = n
     *      ],
     *      [
     *          0, // row = 1, column = 0
     *          0, // row = 1, column = 1
     *          0, // row = 1, column = n
     *      ],
     *  ]
     * ```
     *
     * Example usage:
     *
     * ```typescript
     *  // Create X-scrolling surface series.
     *  const scrollingSurfaceSeries = Chart3D.addSurfaceScrollingGridSeries({
     *      scrollDimension: 'columns',
     *      rows: 5,
     *      columns: 50,
     *  })
     *
     *  // Push two Y columns into the series.
     *  scrollingSurfaceSeries.addValues({
     *      yValues: [
     *          [0, 0, 0, 0, 0],
     *          [0, 10, 0, 20, 0]
     *      ]
     *  })
     * ```
     *
     * `addValues` can trigger warnings when used controversially (for example, data overflow).
     * In production applications, these can be controlled with [[LightningChartOptions.warnings]].
     *
     * @param   arg     Object with `yValues` and/or `intensityValues` matrixes to append on top of previously added data.
     * @return          Object itself for fluent interface.
     */
    addValues(arg: {
        yValues?: number[][];
        intensityValues?: number[][];
    }): this;
    /**
     * Set culling of this Surface grid series.
     *
     * Culling means skipping drawing of specific geometry parts, based on its orientation.
     *
     * `'disabled'` -> full geometry is drawn.
     *
     * `'cull-back'` -> the behind of geometry is **not** drawn.
     *
     * `'cull-front'` -> the front of geometry is **not** drawn.
     *
     * Surface series default cull mode is `'disabled'` to show both sides of the surface.
     *
     * @param   mode        `CullMode3D` or `false` | `true` to disable/enable culling respectively.
     * @returns             Object itself for fluent interface.
     */
    setCullMode(mode: CullMode3D | boolean): this;
    /**
     * Get cull mode for this Surface grid series.
     *
     * Culling means skipping drawing of specific geometry parts, based on its orientation.
     *
     * `'disabled'` -> full geometry is drawn.
     *
     * `'cull-back'` -> the behind of geometry is **not** drawn.
     *
     * `'cull-front'` -> the front of geometry is **not** drawn.
     *
     * Surface series default cull mode is `'disabled'` to show both sides of the surface.
     * @return  Active cull mode.
     */
    getCullMode(): CullMode3D;
}
/**
 * Interface for readonly configuration of [[SurfaceScrollingGridSeries3D]].
 *
 * **Required properties:**
 * - [[SurfaceScrollingGridSeries3DOptions.columns]]: Amount of cells along X axis.
 * - [[SurfaceScrollingGridSeries3DOptions.rows]]: Amount of cells along Z axis.
 *
 * **Optional properties:**
 *
 * All or any of these can be omitted or set to `undefined`, in which case a default value is used.
 *
 * - [[SurfaceScrollingGridSeries3DOptions.scrollDimension]]: Specifies which dimension (columns or rows) is scrolling.
 * - [[SurfaceScrollingGridSeries3DOptions.start]]: Specifies location of first cell on X and Z axes.
 * - [[SurfaceScrollingGridSeries3DOptions.step]]: Specifies step between cells on X and Z axes.
 *
 * **Example usage:**
 *
 * ```typescript
 *  // Example 1, create surface grid series with minimum configuration.
 *  const surfaceGrid = Chart3D.addSurfaceScrollingGridSeries({
 *      columns: 100,
 *      rows: 50,
 *  })
 * ```
 *
 * See also [[Chart3D.addSurfaceGridSeries]].
 */
export interface SurfaceScrollingGridSeries3DOptions {
    /**
     * Amount of cells along X axis.
     *
     * **Required!**
     *
     * If [[SurfaceScrollingGridSeries3DOptions.scrollDimension]] is `'columns'`, then this will specify the amount of cells to keep before the oldest sample is shifted out.
     *
     * Surface grid data amount is specified as `columns * rows`.
     *
     * Larger data sets require more memory (RAM) to work. With nearly any setup, tens of millions data points can easily be reached and with good setups even
     * billion (1 000 000 000) data points have been properly visualized.
     */
    columns: number;
    /**
     * Amount of cells along Z axis.
     *
     * **Required!**
     *
     * If [[SurfaceScrollingGridSeries3DOptions.scrollDimension]] is `'rows'`, then this will specify the amount of cells to keep before the oldest sample is shifted out.
     *
     * Surface grid data amount is specified as `columns * rows`.
     *
     * Larger data sets require more memory (RAM) to work. With nearly any setup, tens of millions data points can easily be reached and with good setups even
     * billion (1 000 000 000) data points have been properly visualized.
     */
    rows: number;
    /**
     * Select scrolling dimension, as well as how to interpret grid matrix values supplied by user.
     *
     * If `columns` is selected, then there will be no limit on how many *columns* can be pushed to the series, but *rows* amount will be static.
     *
     * If `rows` is selected, then there will be no limit on how many *rows* can be pushed to the series, but *columns* amount will be static.
     *
     * Data order:
     *
     * `'columns'` -> Supply lists of "columns"
     *
     * ```typescript
     *  const intensityValues = [
     *      [
     *          0, // Intensity value column = 0, row = 0
     *          0, // Intensity value column = 0, row = 1
     *          0, // Intensity value column = 0, row = n
     *      ],
     *      [
     *          0, // Intensity value column = 1, row = 0
     *          0, // Intensity value column = 1, row = 1
     *          0, // Intensity value column = 1, row = n
     *      ],
     *  ]
     * ```
     *
     * `'rows'` -> Supply lists of "rows"
     *
     * ```typescript
     *  const intensityValues = [
     *      [
     *          0, // Intensity value row = 0, column = 0
     *          0, // Intensity value row = 0, column = 1
     *          0, // Intensity value row = 0, column = n
     *      ],
     *      [
     *          0, // Intensity value row = 1, column = 0
     *          0, // Intensity value row = 1, column = 1
     *          0, // Intensity value row = 1, column = n
     *      ],
     *  ]
     * ```
     *
     * Optional, defaults to `'columns'`.
     */
    scrollDimension?: 'columns' | 'rows';
    /**
     * Specifies location of first cell on X and Z axes.
     *
     * Optional, defaults to `{ x: 0, z: 0 }`
     */
    start?: PointXZ;
    /**
     * Specifies step between cells on X and Z axes.
     *
     * Optional, defaults to `{ x: 1, y: 1 }`.
     */
    step?: PointXZ;
}
/**
 * Abstract super class for Grid and Mesh Surface3D series.
 *
 * Implements the majority of Surface3D logic.
 * @hidden
 */
export declare abstract class SurfaceSeries3D extends Series3D<Surface3D> implements AttachableWithLUT {
    /**
     * Reset the existing intensity shape and apply new settings.
     * The following method removes all the existing data.
     * The shape would be reset to the default state:
     * - Old Geometry transformations do not valid. The Intensity is a uniform grid.
     * - Old IntensityValues and/or ColorValues do not valid and exist anymore.
     * @param options   Major mandotary properties of Intensity.
     * @returns   Series itself for fluent interface.
     */
    reset(options: SurfaceOptions3D): this;
    /**
     * Set fill style of Intensity Heatmap Series.
     * * SolidFill: apply single solid color.
     * * IndividualPointFill: apply individual color per data-point.
     * * PalettedFill: apply palette using *LUT* lookup table of colors.
     *      - lookUpProperty = 'value': Pick colors based on values set using addRow, addColumn or invalidateValuesOnly.
     *      - lookUpProperty = 'y': Pick colors based on geometry Y coordinates.
     * * emptyFill: no color, empty rendering.
     * @param   fillstyle  Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns            Series itself for fluent interface.
     */
    setFillStyle(fillstyle: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of Intensity Heatmap Series.
     * * SolidFill: apply single solid color.
     * * IndividualPointFill: apply individual color per data-point.
     *      - lookUpProperty = 'value': Pick colors based on values set using addRow, addColumn or invalidateValuesOnly.
     *      - lookUpProperty = 'y': Pick colors based on geometry Y coordinates.
     * * emptyFill: no color, empty rendering.
     *  @return     FillStyle.
     */
    getFillStyle(): FillStyle;
    /**
     * Set style of wireframe.
     *
     * Wireframe is a line grid that highlights the edges of each cell of the 3D surface.
     *
     * By default, the wireframe is hidden. It can be displayed like so:
     * ```ts
     *  surfaceSeries.setWireframeStyle( new SolidFill({ color: ColorRGBA( 0, 0, 0, 100 ) }) )
     * ```
     * @param   value   Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @return          Series itself for fluent interface.
     */
    setWireframeStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get style of wireframe.
     *
     * Wireframe is a line grid that highlights the edges of each cell of the 3D surface.
     * @return          FillStyle.
     */
    getWireframeStyle(): FillStyle;
    /**
     * Treat the data of the matrix as *ColorValue*-based type of points.
     * *ColorValue*-based data is represented in format { ...color: Color } for *IndividualPointFill* style.
     *
     * Invalidates only the **color** without update the geometry data,
     * providing significantly faster rendering of dynamically changed colors.
     *
     * @param colors Matrix of new colors.
     * The resolution of the IntensityShape should be valid.
     * @param range  Optional configuration object to specify the range of the grid to be invalidated.
     * @returns      Series itself for fluent interface.
     */
    invalidateColorsOnly(colors: Matrix<Color>, range?: GridRangeOptions): this;
    /**
     * Treat the data of the matrix as *ColorValue*-based type of points.
     * *ColorValue*-based date is represented in format { ...color: Color } for *IndividualPointFill* style.
     *
     * Invalidates only the **color** without update the geometry data,
     * providing significantly faster rendering of dynamically changed colors.
     *
     * Example usage:
     * ```ts
     *   // Fill each surface cell with a color for demonstration purposes.
     *   SurfaceSeries3D
     *       .invalidateColorsOnly( ( row, column ) => ColorHSV( row * column ) )
     * ```
     *
     * @param callback Callback function to map through the input to modify the matrix colors.
     * The resolution of the IntensityShape should be valid.
     * @param range    Optional configuration object to specify the range of the grid to be invalidated.
     * @returns        Series itself for fluent interface.
     */
    invalidateColorsOnly(callback: UpdateColorCallback, range?: GridRangeOptions): this;
    /**
     * Treat the data of the matrix as *IntensityValue*-based type of points.
     * *IntensityValue*-based data is represented in format { ...intensity: number } for *PalettedFill* style.
     *
     * Invalidates only the **intensity** values without update the geometry data,
     * providing significantly faster rendering of dynamically changed intensity.
     *
     * @param values Matrix of new intensity values.
     * @param range  Optional configuration object to specify the range of the grid to be invalidated.
     * @returns      Series itself for fluent interface.
     */
    invalidateValuesOnly(values: Matrix<number>, range?: GridRangeOptions): this;
    /**
     * Treat the data of the matrix as *IntensityValue*-based type of points.
     * *IntensityValue*-based data is represented in format { ...intensity: number } for *PalettedFill* style.
     *
     * Invalidates only the **intensity** values without update the geometry data,
     * providing significantly faster rendering of dynamically changed intensity.
     *
     * Example usage:
     * ```ts
     *   // Fill each surface cell with a value for demonstration purposes.
     *   SurfaceSeries3D
     *       .invalidateValuesOnly( ( row, column ) => row + column )
     * ```
     *
     * @param callback Callback function to map through the input to modify the matrix of intensity values.
     * The resolution of the IntensityShape should be valid.
     * @param range  Optional configuration object to specify the range of the grid to be invalidated.
     * @returns      Series itself for fluent interface.
     */
    invalidateValuesOnly(callback: UpdateValueCallback, range?: GridRangeOptions): this;
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Series itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick?: boolean): this;
}
export interface SurfaceOptions3D {
    /**
     * Horizontal resolution of the Heatmap.
     */
    columns: number;
    /**
     * Vertical resolution of the Heatmap.
     */
    rows: number;
    /**
     * Starting point position of the Surface along the XZ plane.
     */
    start: PointXZ;
    /**
     * End point position of the Surface along the XZ plane.
     */
    end: PointXZ;
    /**
     * Data definition per cell / per vertex of the Heatmap.
     *
     * | Value                     | Desired result                        |
     * | :------------------------ | :------------------------------------ |
     * | *pixelate:* ***true***    | Intensity / Color applies per cell    |
     * | *pixelate:* ***false***   | Intensity / Color applies per vertex  |
     */
    pixelate: boolean;
}
/**
 * Class for visualization of a 3D height map inside a Chart3D.
 *
 * The grid is defined between two XZ locations, and an Array of Y values.
 *
 * Supports colouring cells by a look up table ([[LUT]]) based on user set *values* as well as geometry Y coordinates.
 *
 * *SurfaceGridSeries3D* are created with [[Chart3D.addSurfaceSeries]].
 *
 * Example usage:
 * ```ts
 * const resolution = 20
 * const grid = chart3D.addSurfaceSeries( {
 *     type: SurfaceSeriesTypes3D.Grid,
 *     rows: resolution,
 *     columns: resolution,
 *     start: { x: 0, z: 0 },
 *     end: { x: 100, z: 100 },
 *     pixelate: true
 * } )
 *     .invalidateYOnly( ( row, column, prev ) => {
 *         return Math.sin( row * 2 * Math.PI / resolution )
 *     } )
 *     .setFillStyle( new PalettedFill( {
 *          // Refer to "palette" examples for LUT creation.
 *          lut,
 *          lookUpProperty: 'y'
 *      } ) )
 * ```
 *
 * **Color shading style**.
 *
 * By default, `SurfaceGridSeries3D` uses _Simple_ shading style.
 *
 * This can be changed with `SurfaceGridSeries3D.setColorShadingStyle(new ColorShadingStyles.Phong())`
 *
 * @deprecated          Will be removed in v.4.0 in favour of newer and more powerful [[NewSurfaceGridSeries3D]].
 */
export declare class SurfaceGridSeries3D extends SurfaceSeries3D {
    /**
     * Append new row of Color data to the end of the Grids **Z dimension**.
     * Example:
     * ```ts
     * // Shift previous (1 row, 10 columns) of Colors and push new ones
     * SurfaceGridSeries3D.addRow(1, 'color', [
     *  [
     *      ColorHSV(0),
     *      ColorHSV(30),
     *      ColorHSV(60),
     *      ColorHSV(90),
     *      ColorHSV(120),
     *      ColorHSV(150),
     *      ColorHSV(180),
     *      ColorHSV(210),
     *      ColorHSV(240),
     *      ColorHSV(270)
     *  ]
     * ])
     * ```
     */
    addRow(rows: number, type: 'color', colors: Matrix<Color>): this;
    /**
     * Append new row of Intensity data to the end of the Grids **Z dimension**.
     * Example:
     * ```ts
     * // Shift previous (1 row, 10 columns) of Intensity values and push new ones
     * SurfaceGridSeries3D.addRow(1, 'value', [
     *  [0, 10, 20, 30, 40, 50, 40, 30, 20, 10, 0]
     * ])
     * ```
     */
    addRow(rows: number, type: 'value', values: Matrix<number>): this;
    /**
     * Append new row of Y coordinate data to the end of the Grids **Z dimension**.
     * Example:
     * ```ts
     * // Shift previous (1 row, 10 columns) of Y coordinates and push new ones
     * SurfaceGridSeries3D.addRow(1, 'y', [
     *  [10, 20, 30, 40, 50, 40, 30, 20, 10, 0],
     * ])
     * ```
     */
    addRow(rows: number, type: 'y', values: Matrix<number>): this;
    /**
     * Append new column of Color data to the end of the Grids **X dimension**.
     * Example:
     * ```ts
     * // Shift previous (1 column, 10 rows) of Colors and push new ones
     * heatmap.addColumn(1, 'color', [
     *  [
     *      ColorHSV(0),
     *      ColorHSV(30),
     *      ColorHSV(60),
     *      ColorHSV(90),
     *      ColorHSV(120),
     *      ColorHSV(150),
     *      ColorHSV(180),
     *      ColorHSV(210),
     *      ColorHSV(240),
     *      ColorHSV(270)
     *  ]
     * ])
     * ```
     */
    addColumn(columns: number, type: 'color', colors: Matrix<Color>): this;
    /**
     * Append new column of Intensity data to the end of the **Grids X dimension**.
     * Example:
     * ```ts
     * // Shift previous (1 column, 10 rows) of Intensity values and push new ones
     * heatmap.addColumn(1, 'value', [
     *  [0, 10, 20, 30, 40, 50, 40, 30, 20, 10, 0]
     * ])
     * ```
     */
    addColumn(columns: number, type: 'value', values: Matrix<number>): this;
    /**
     * Append new column of Y coordinate data to the end of the **Grids X dimension**.
     * Example:
     * ```ts
     * // Shift previous (1 column, 10 rows) of Y coordinates and push new ones
     * heatmap.addColumn(1, 'y', [
     *  [10, 20, 30, 40, 50, 40, 30, 20, 10, 0],
     * ])
     * ```
     */
    addColumn(columns: number, type: 'y', values: Matrix<number>): this;
    /**
     * Treat the data of the matrix as Y coordinates.
     *
     * Invalidates only the **geometry** coordinates without update the intensity or color data,
     * providing significantly faster rendering of dynamically changed geometry.
     *
     * @param range Matrix of new Y values.
     * The resolution of the IntensityMesh should be valid.
     * @param range    Optional configuration object to specify the range of the grid to be invalidated.
     * @returns   Series itself for fluent interface.
     */
    invalidateYOnly(matrix: Matrix<number>, range?: GridRangeOptions): this;
    /**
     * Treat the data of the matrix as Y coordinates.
     *
     * Invalidates only the **geometry** coordinates without update the intensity or color data,
     * providing significantly faster rendering of dynamically changed geometry.
     *
     * Example usage:
     * ```ts
     * const resolution = 20
     * SurfaceGridSeries3D
     *     .invalidateYOnly( ( row, column, prev ) => {
     *         return Math.sin( row * 2 * Math.PI / resolution )
     *     } )
     * ```
     *
     * @param callback Callback function to map through the input to modify the geometry by Y coordinates.
     * The resolution of the IntensityMesh should be valid.
     * @param range    Optional configuration object to specify the range of the grid to be invalidated.
     * @returns   Series itself for fluent interface.
     */
    invalidateYOnly(callback: UpdateYCallback, range?: GridRangeOptions): this;
}
/**
 * Class for visualization of a 3D surface mesh inside a Chart3D.
 *
 * The series behaves exactly like [[SurfaceGridSeries3D]], a grid defined between two XZ locations, but on top of this,
 * it allows the user to map each cell of the grid into any arbitrary XYZ location.
 *
 * Supports colouring cells by a look up table ([[LUT]]) based on user set *values* as well as geometry Y coordinates.
 *
 * *SurfaceMeshSeries3D* are created with [[Chart3D.addSurfaceMeshSeries]].
 *
 * **Color shading style**.
 *
 * By default, `SurfaceMeshSeries3D` uses _Simple_ shading style.
 *
 * This can be changed with `SurfaceMeshSeries3D.setColorShadingStyle(new ColorShadingStyles.Phong())`
 */
export declare class SurfaceMeshSeries3D extends SurfaceSeries3D {
    /**
     * Treat the data of the matrix as any of the *Point3D*-based type of points.
     * *Point3D*-based data is represented in format { x: number, y: number, z: number } to modify the geometry only.
     *
     * Invalidates only the **geometry** coordinates without update the intensity or color data,
     * providing significantly faster rendering of dynamically changed geometry.
     *
     * @param vertices Matrix of new vertices.
     * The resolution of the IntensityMesh should be valid.
     * @param range    Optional configuration object to specify the range of the grid to be invalidated.
     * @returns   Series itself for fluent interface.
     */
    invalidateGeometryOnly(vertices: Matrix<Point3D>, range?: GridRangeOptions): this;
    /**
     * Treat the data of the matrix as any of the *Point*-based type of points.
     * *Point*-based data is represented in format { x: number, y: number } to modify the geometry only.
     *
     * Invalidates only the **geometry** coordinates without update the intensity or color data,
     * providing significantly faster rendering of dynamically changed geometry.
     *
     * Example usage:
     * ```ts
     *  const resolution = 20
     *  SurfaceMeshSeries3D
     *      .invalidateGeometryOnly( ( row, column, prev ) => {
     *          const angle = 2 * Math.PI * row / ( resolution - 1 )
     *          const radius = 2 + Math.cos( column * .resolution )
     *          return {
     *              x: Math.cos( angle ) * radius,
     *              y: column,
     *              z: Math.sin( angle ) * radius
     *          }
     *      } )
     * ```
     *
     * @param callback Callback function to map through the input to modify the matrix geometry.
     * The resolution of the IntensityMesh should be valid.
     * @param range    Optional configuration object to specify the range of the grid to be invalidated.
     * @returns   Series itself for fluent interface.
     */
    invalidateGeometryOnly(vertices: UpdateGeometryCallback<Point3D>, range?: GridRangeOptions): this;
}
/**
 * Available Surface Series 3D types.
 *
 * Used internally for proper type casting. Should not be included in docs,
 * as it overrides the selection object just below, that has the same name.
 * @hidden
 */
export declare type SurfaceSeriesTypes3D = typeof SurfaceSeriesTypes3D[keyof typeof SurfaceSeriesTypes3D];
/**
 * Collection of *SurfaceSeries3D* implementations.
 *
 * Used when creating an *SurfaceSeries3D* with [[Chart3D.addSurfaceSeries]].
 * Selected option tells what the returned *Series* type will be - *SurfaceSeries3D* implementations are otherwise equal, except *Mesh* type
 * has additional methods to freely manipulate the surface geometry, not just in Y plane, but also XZ.
 */
export declare const SurfaceSeriesTypes3D: {
    /**
     * Type of *Surface Series 3D* that exists on the XZ plane, and allows the user to define a height map from given Y values.
     */
    Grid: typeof SurfaceGridSeries3D;
    /**
     * Type of *Surface Series 3D* that can be warped to any 3 dimensional surface.
     */
    Mesh: typeof SurfaceMeshSeries3D;
};
/**
 * Utility function for constructing a 3D point style that matches a given line style.
 * @internal
 */
export declare const _getPointStyleForLineJoints3D: (lineStyle: LineStyle) => TriangulatedPoints3D | EmptyPoints3D;
/**
 * Interval info for an Axis
 */
export interface AxisInterval {
    /**
     * The start value of the axis scale interval.
     */
    start: number;
    /**
     * The end value of the axis scale interval.
     */
    end: number;
}
/**
 * Abstract super class for 2D/3D Axis implementations.
 * @hidden
 */
export declare abstract class GenericAxis<ScaleType extends AxisScale, ChartType extends ChartWithAxis<GenericAxis<any, any, any, any, any, any, any>>, SeriesType extends Series, StrategyType extends AbstractAxisStrategy<SeriesType>, TickType extends AbstractAxisTick, TickPlottingVariables extends AbstractTickPlottingVariables, TickSpecificPlottingVariables> implements AxisState {
    /**
     * @returns Axis title string
     */
    getTitle(): string;
    /**
     * Specifies an Axis title string
     * @param   title  Axis title as a string
     * @returns        Axis itself for fluent interface
     */
    setTitle(title: string): this;
    /**
     * @returns Axis title fillstyle
     */
    getTitleFillStyle(): FillStyle;
    /**
     * Specifies Axis title FillStyle
     * @param   fillStyle   FillStyle of Axis title or mutator to modify existing one
     * @returns             Axis itself for fluent interface
     */
    setTitleFillStyle(fillStyle: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get font of axis labels.
     * @return          FontSettings
     */
    getTitleFont(): FontSettings;
    /**
     * Set font of Axis title.
     * @param   value   FontSettings or mutator function for existing settings
     * @return          Object itself
     */
    setTitleFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
    /**
     * Set rotation of Axis title.
     * @param value Rotation in degrees
     * @returns Object itself
     */
    setTitleRotation(value: number): this;
    /**
     * Get rotation of Axis title.
     * @returns Rotation in degrees
     */
    getTitleRotation(): number;
    /**
     * Set *TickStrategy* of *Axis*.
     *
     * The *TickStrategy* defines the positioning and formatting logic of *Axis* ticks
     * as well as the style of created ticks.
     *
     * **Example usage**:
     *
     * **DateTime Axis**:
     *  ```javascript
     *  Axis.setTickStrategy( AxisTickStrategies.DateTime )
     * ```
     *
     * **Disable automatic ticks completely**:
     *  ```javascript
     *  Axis.setTickStrategy( AxisTickStrategies.Empty )
     * ```
     *
     * **Customized TickStrategy**:
     *  ```javascript
     *  Axis.setTickStrategy( AxisTickStrategies.Numeric, ( tickStrategy: NumericTickStrategy ) => tickStrategy
     *      .setNumericUnits( true )
     *      .setMajorTickStyle( ( tickStyle ) => tickStyle
     *          .setLabelFont( ( font ) => font
     *              .setWeight( 'bold' )
     *          )
     *      )
     *  )
     * ```
     *
     * **Type table for optional second parameter ('styler')**:
     *
     * | tickStrategy   | styler                                                        |
     * | :------------- | :------------------------------------------------------------ |
     * | 'Numeric'      | ( tickStrategy: **NumericTickStrategy** ) => tickStrategy     |
     * | 'Time'         | ( tickStrategy: **TimeTickStrategy** ) => tickStrategy        |
     * | 'DateTime'     | ( tickStrategy: **DateTimeTickStrategy** ) => tickStrategy    |
     * | 'Empty'        | **undefined**                                                 |
     *
     *
     * @param   tickStrategy    Selected TickStrategy.
     *                          See [[AxisTickStrategies]] for a collection of options.
     * @param   styler          Optional callback that can be used to customize the *TickStrategy*.
     *                          The type of supplied *TickStrategy* object depends on what was supplied to 'tickStrategy' parameter;
     *                          See the above method documentation for a value table.
     * @return                  Object itself for fluent interface.
     */
    setTickStrategy<TickStrategy extends TickStrategyType>(tickStrategy: TickStrategy, styler?: TickStrategyStyler<TickStrategyParameters, TickStrategy>): this;
    /**
     * Get the currently used tick strategy
     */
    getTickStrategy(): TickStrategyType;
    /**
     * @deprecated  Will be removed in v.4.0.0. For styling ticks, use [[setTickStrategy]].
     */
    setTickStyle<TickStrategy extends TickStrategyType>(styler: TickStrategyStyler<TickStrategyParameters, TickStrategy>): this;
    /**
     * Set axis scale interval.
     * @param  start                Start scale value
     * @param  end                  End scale value
     * @param  animate              Boolean for animation enabled, or number for animation duration in milliseconds
     * @param  disableScrolling     If true, disables automatic scrolling after setting interval
     * @returns                     Object itself for fluent interface
     */
    setInterval(start: number, end: number, animate?: number | boolean | undefined, disableScrolling?: boolean | undefined): this;
    /**
     * Get the currently applied axis scale interval.
     * @return Object containing the current start and end of Axis.
     */
    getInterval(): AxisInterval;
    /**
     * Stop scrolling of axis until restored.
     */
    stop(): this;
    /**
     * Undo effects of 'stop'.
     */
    readonly release: () => void;
    /**
     * Get is axes' scrolling currently prevented by usage of mouse-interactions or 'stop()' method.
     * @return  Boolean flag
     */
    isStopped(): boolean;
    /**
     * Fit axis view to attached series.
     * @param   animate Boolean for animation enabled, or number for animation duration in milliseconds
     * @param   freeze  Freeze axis to fitted view? False by default.
     */
    fit(animate?: number | boolean, freeze?: boolean): this;
    /**
     * Specify *ScrollStrategy* of the *Axis*. This decides where the *Axis* scrolls based on current view and series boundaries.
     * @param   scrollStrategy  *AxisScrollStrategy* or undefined to disable automatic scrolling.
     *                          See [[AxisScrollStrategies]] for all options.
     * @return                  Object itself for fluent interface.
     */
    setScrollStrategy(scrollStrategy?: AxisScrollStrategy): this;
    /**
     * @return Current *AxisScrollStrategy*
     */
    getScrollStrategy(): AxisScrollStrategy | undefined;
    /**
     * Specifies scroll animation.
     * @param   enabled     Boolean flag for whether scrolling should be animated or not.
     */
    setAnimationScroll(enabled: boolean | undefined): this;
    /**
     * Specifies zoom animation to use.
     *
     * Example usage:
     *
     * | Desired result              | Argument                                         | Parameters                                                                                                                            |
     * | :-------------------------  | :----------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------ |
     * | Change animation            | setAnimationZoom(AnimationEasings.easeOut, 500)  | First parameter defines the easing to use for the animation. Second parameter is optional, and defines the duration for the animation |
     * | Disable zooming animations  | axis.setAnimationZoom(undefined)                 | Passing **undefined** as the parameter will disable the zooming animations for the Axis.                                              |
     *
     * @param   easing      Easing of animation. Undefined disables zoom animations. See 'common/animator.Easings' for defaults
     * @param   duration    Optional default duration for zooming animations in milliseconds
     */
    setAnimationZoom(easing: AnimationEasing | undefined, duration?: number): this;
    /**
     *  Disable/Enable all animations of the Chart.
     * @param animationsEnabled Boolean value to enable/disable animations.
     * @returns                 Axis itself for fluent interface.
     */
    setAnimationsEnabled(animationsEnabled: boolean | undefined): this;
    /**
     * Get animations disable/enable state.
     * @returns Animations default state.
     */
    getAnimationsEnabled(): boolean;
    /**
     * Disable all animations for the Axis.
     *
     * After calling this function, animations (Zooming, scaling) will be disabled.
     * Animations must be recreated manually afterwards.
     * @return          Axis itself for fluent interface.
     */
    disableAnimations(): this;
    /**
     * Subscribe to on scale change event
     *
     * The onScaleChange event triggers on change of the interval of an Axis
     * and accept a callback function with 2 parameters that return start and end values of the Axis
     *
     * **Example usage**:
     *
     *  ```javascript
     *  Axis.onScaleChange((start, end) => {
     *      console.log(`start value: ${start}, end value : ${end}`);
     *    }
     *  )
     * ```
     * @param listener  Event listener
     * @param start     Scale start value
     * @param end       Scale end value
     * @returns         Token that is used to unsubscribe from the event
     */
    onScaleChange(listener: (start: number, end: number) => void): Token;
    /**
     * Remove subscription from scale change event
     * @param token Event listener
     * @returns True if the listener is successfully removed and false if it is not found
     */
    offScaleChange(token: Token): boolean;
    /**
     * Enable / disable all interactions of Axis.
     * @param   enabled Interactions enabled or not.
     * @return          Object itself for fluent interface.
     */
    abstract setMouseInteractions(enabled: boolean): this;
    /**
     * Format a value along axis to string. Behavior depends on the Axis' TickStrategy.
     * Eq. A DateTime-Axis will interpret 'value' as a Date.
     * @param   value   Value along axis
     * @return          Value formated to string
     */
    formatValue: (value: number) => string;
}
/**
 * Minimum interface for implementation specific values necessary for tick plotting.
 * @hidden
 */
export interface AbstractTickPlottingVariables {
    /**
     * Physical (visible) axis size as pixels.
     */
    physicalAxisSize: number;
}
/**
 * Internal object that describes an Axis interval (start, end), and provides ability to mutate it.
 * @hidden
 */
export interface AxisScale {
    /**
     * Get Scale start value.
     * @return  number.
     */
    getInnerStart(): number;
    /**
     * Get Scale end value.
     * @return  number.
     */
    getInnerEnd(): number;
}
/**
 * Abstract super class for 2D/3D Axis ticks implementations.
 *
 * Tick doesn't contain any positioning logic, that is done in Axis !
 * @hidden
 */
export declare abstract class AbstractAxisTick implements Disposable {
    tickLevel: AxisTickLevel;
    value: number;
    private _removeFromAxis;
    private _restoreToAxis;
    protected readonly _labelLayer: Layer2D;
    protected readonly _labelScale: LinearScaleXY | RadialScale | MixedScaleXY;
    readonly label: Text;
    /**
     * @param   tickLevel       AxisTickLevel tick belongs to.
     * @param   value           Position of Tick on Axis.
     * @param   _removeFromAxis Remove handler for Tick.
     * @param   _restoreToAxis  Restore handler for Tick.
     * @param   _labelLayer     Layer for rendering Tick Label.
     * @param   _labelScale     Scale for rendering Tick label.
     * @param   label           Optionally injectable Tick Label shape.
     *                          Injection can be useful to reuse Tick shapes for performance.
     */
    constructor(tickLevel: AxisTickLevel, value: number, _removeFromAxis: RemoveHandler<AbstractAxisTick>, _restoreToAxis: RestoreHandler<AbstractAxisTick>, _labelLayer: Layer2D, _labelScale: LinearScaleXY | RadialScale | MixedScaleXY, label?: Text);
    /**
     * Restores all custom tick sub-elements
     * @returns This for fluid interface
     */
    restore(): this;
    /**
     * Disposes all tick sub-elements
     * @returns This for fluid interface
     */
    dispose(): this;
    /**
     * @return True if all sub-elements are disposed, false if not.
     */
    isDisposed(): boolean;
}
/**
 * Type union of AxisTickLevel types that have physical ticks.
 * @hidden
 */
export declare type AxisTickLevel = IndependentAxisTickLevel | PhysicalLayeredAxisTickLevel;
/**
 * @hidden
 */
export interface AbstractAxisStrategy<SeriesType extends Series> {
}
/**
 * Internal data structure for describing Axis Type.
 *
 * Equal to AxisType, but parsed to a lower level, less complex format.
 * @hidden
 */
export declare type InternalAxisType = Readonly<{
    type: 'linear';
} | {
    type: 'linear-highPrecision';
} | {
    type: 'logarithmic';
    base: LogarithmicBaseInternal;
}>;
/**
 * @hidden
 */
export interface StylableAxisLine {
    /**
     * Specifies axis stroke
     * @param  value        Axis stroke style
     * @returns             Axis itself for fluent interface
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * @returns Axis stroke as a LineStyle object
     */
    getStrokeStyle(): LineStyle;
}
/**
 * @hidden
 */
export interface StylableAxisTitle {
    /**
     * @returns Axis title string
     */
    getTitle(): string;
    /**
     * Specifies an Axis title string
     * @param   title  Axis title as a string
     * @returns        Axis itself for fluent interface
     */
    setTitle(title: string): this;
    /**
     * @returns Axis title fillstyle
     */
    getTitleFillStyle(): FillStyle;
    /**
     * Specifies Axis title FillStyle
     * @param   fillStyle   FillStyle of Axis title or mutator to modify existing one
     * @returns             Axis itself for fluent interface
     */
    setTitleFillStyle(fillStyle: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get font of axis labels.
     * @return          FontSettings
     */
    getTitleFont(): FontSettings;
    /**
     * Set font of Axis title.
     * @param   value   FontSettings or mutator function for existing settings
     * @return          Object itself
     */
    setTitleFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
}
/**
 * Interface that describes state of Axis, as in is it scrolling, is user panning it, etc.
 *
 * Used for passing realtime Axis information to rendering Engine for application and situation specific optimizations.
 * @hidden
 */
export interface AxisState {
}
/**
 * Type of a scroll strategy.
 * Consists of two scrolling functions:
 * 'start' and 'end'
 * @hidden
 */
export interface AxisScrollStrategy {
    /**
     * Scroll function for 'start' value.
     * Scrolls from interval 'scaleStart' - 'scaleEnd' according to 'contentMin' - 'contentMax' taking 'interpolation' into account
     * @param   scaleStart      'start' value of starting scale (not necessarily min!)
     * @param   scaleEnd        'end' value of starting scale (not necessarily max!)
     * @param   contentMin      Minimum value of content to scroll according to
     * @param   contentMax      Maximum value of content to scroll according to
     * @return                  'start' of resulting scale
     */
    start: (scaleStart: number, scaleEnd: number, contentMin: number, contentMax: number) => number;
    /**
     * Scroll function for 'end' value.
     * Scrolls from interval 'scaleStart' - 'scaleEnd' according to 'contentMin' - 'contentMax' taking 'interpolation' into account
     * @param   scaleStart      'start' value of starting scale (not necessarily min!)
     * @param   scaleEnd        'end' value of starting scale (not necessarily max!)
     * @param   contentMin      Minimum value of content to scroll according to
     * @param   contentMax      Maximum value of content to scroll according to
     * @return                  'end' of resulting scale
     */
    end: (scaleStart: number, scaleEnd: number, contentMin: number, contentMax: number) => number;
}
/**
 * Collection of available *AxisScrollStrategies*.
 *
 * *AxisScrollStrategies* can be used to customize the behavior of *Axis scrolling*.
 *
 * Use with [[Axis.setScrollStrategy]]
 */
export declare const AxisScrollStrategies: {
    /**
     * *Axis* will constantly scroll to fit attached *Series*.
     */
    fitting: AxisScrollStrategy;
    /**
     * *Axis* will scroll to fit *Series* that are out of view, but it won't shrink even if there is empty space (like "fitting" does).
     */
    expansion: AxisScrollStrategy;
    /**
     * *Axis* will scroll to show new, **progressive** data, but will keep its interval constant - leaving older data out of view.
     */
    progressive: AxisScrollStrategy;
    /**
     * *Axis* will scroll to show new, **regressive** data, but will keep its interval constant - leaving older data out of view.
     */
    regressive: AxisScrollStrategy;
};
/**
 * Properties of a (visible) TickStyle.
 */
export interface TickStyleProperties {
    /**
     * Length of GridStroke, where 1 = full and 0 = zero.
     */
    gridStrokeLength: number;
    /**
     * Style of GridStroke as a SolidLine object.
     */
    gridStrokeStyle: LineStyle;
    /**
     * Length of Tick itself as pixels.
     */
    tickLength: pixel;
    /**
     * Style of Tick itself as a SolidLine object.
     */
    tickStyle: LineStyle;
    /**
     * Padding after Tick as pixels.
     */
    tickPadding: pixel;
    /**
     * Font of Label as FontSettings.
     */
    labelFont: FontSettings;
    /**
     * FillStyle of Label.
     */
    labelFillStyle: FillStyle;
    /**
     * Padding after label as pixels.
     */
    labelPadding: pixel;
    /**
     * Horizontal alignment of Label respective to tick line.
     *
     * **left**: -1
     *
     * **center**: 0
     *
     * **right**: +1
     */
    labelAlignment: number;
    /**
     * Label rotation in degrees.
     */
    labelRotation: number;
}
/**
 * Abstract base class of an immutable Settings object for Axis Ticks.
 *
 * For implementations, see [[VisibleTicks]] and [[emptyTick]].
 * @hidden Internal class
 */
export declare abstract class TickStyle {
}
/**
 * Class which is used to style *Axis* *Ticks*. Use with [[Axis.setTickStyle]]
 *
 * Instances of VisibleTicks are *immutable*, meaning that its setters don't modify the object,
 * but instead return a completely new modified object.
 *
 * When creating a new VisibleTicks object from scratch, parameters can be passed like follows:
 * - new VisibleTicks({ labelFillStyle: new SolidFill({ color: ColorHEX('#F00'), tickLength: 8 })
 */
export declare class VisibleTicks extends TickStyle {
    /**
     * When creating a new VisibleTicks object from scratch, parameters can be passed like follows:
     * - new VisibleTicks({ labelFillStyle: new SolidFill({ color: ColorHEX('#F00'), tickLength: 8 })
     * @param   props   Optional object containing parameters for creation of VisibleTicks
     */
    constructor(props?: Partial<TickStyleProperties>);
    /**
     * Construct a new VisibleTicks object based on this one, but with modified gridstroke length.
     * @param   length  Length of GridStroke, where 1 = full and 0 = zero.
     * @return          New VisibleTicks object
     */
    setGridStrokeLength(length: number): this;
    /**
     * Get length of GridStroke.
     * @return  Length of GridStroke, where 1 = full and 0 = zero.
     */
    getGridStrokeLength(): number;
    /**
     * Construct a new VisibleTicks object based on this one, but with modified GridStroke style.
     *
     * Example usage:
     *```javascript
     * // Specified SolidLine
     * VisibleTicks.setGridStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * VisibleTicks.setGridStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden
     * VisibleTicks.setGridStrokeStyle(emptyLine)
     * ```
     * @param   value   Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
     * @return          New VisibleTicks object
     */
    setGridStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of GridStrokes.
     * @return  LineStyle object
     */
    getGridStrokeStyle(): LineStyle;
    /**
     * Set length of Ticks.
     * @param   length  Length of Ticks as pixels.
     * @return          New VisibleTicks object
     */
    setTickLength(length: pixel): this;
    /**
     * Get length of Ticks.
     * @return  Length of Ticks as pixels
     */
    getTickLength(): pixel;
    /**
     * Construct a new VisibleTicks object based on this one, but with modified Tick style.
     *
     * Example usage:
     *```javascript
     * // Specified SolidLine
     * VisibleTicks.setGridStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * VisibleTicks.setGridStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden
     * VisibleTicks.setGridStrokeStyle(emptyLine)
     * ```
     * @param   value   Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
     * @return          New VisibleTicks object
     */
    setTickStyle(style: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of Ticks.
     * @return  LineStyle object
     */
    getTickStyle(): LineStyle;
    /**
     * Set padding after Tick as pixels.
     * @param   padding Padding after Tick as pixels.
     * @return          New VisibleTicks object with modified Tick padding
     */
    setTickPadding(padding: pixel): this;
    /**
     * Get padding after Tick as pixels.
     * @return  Padding after Tick as pixels.
     */
    getTickPadding(): pixel;
    /**
     * Set fill style of Labels.
     *
     * Example usage:
     *```javascript
     * // Specified FillStyle
     * VisibleTicks.setLabelFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * VisibleTicks.setLabelFillStyle((solidFill) => solidFill.setA(80))
     * // Hidden
     * VisibleTicks.setLabelFillStyle(emptyFill)
     * ```
     * @param   value   Either a VisibleFill object or a function, which will be used to create a new VisibleFill based on current value.
     * @returns         New VisibleTicks object
     */
    setLabelFillStyle(style: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of Label.
     * @return  Fill style of Label as a VisibleFill object
     */
    getLabelFillStyle(): FillStyle;
    /**
     * Construct a new VisibleTicks object based on this one, but with modified Label font.
     *
     * Example usage:
     *```javascript
     * // Specified FontSettings
     * VisibleTicks.setLabelFont(new FontSettings({ size: 24, style: 'italic' }))
     * // Set to bold
     * VisibleTicks.setLabelFont((fontSettings) => fontSettings.setWeight('bold'))
     * ```
     * @param   value   Either a FontSettings object or a function, which will be used to create a new FontSettings based on current value.
     * @return          New VisibleTicks object
     */
    setLabelFont(font: FontSettings | ImmutableMutator<FontSettings>): this;
    /**
     * Get font of Labels.
     * @return  FontSettings object
     */
    getLabelFont(): FontSettings;
    /**
     * Set padding after label as pixels.
     * @param   padding Padding after label as pixels.
     * @return          New VisibleTicks object with modified Label padding
     */
    setLabelPadding(padding: pixel): this;
    /**
     * Get padding after label as pixels.
     * @return  Padding after label as pixels.
     */
    getLabelPadding(): pixel;
    /**
     * Set alignment of Label respective to tick line.
     *
     * **after**: -1
     *
     * **center**: 0
     *
     * **before**: +1
     * @param   alignment   Label alignment [-1, 1].
     * @return              New VisibleTicks object with modified Label alignment
     */
    setLabelAlignment(alignment: number): this;
    /**
     * Get horizontal alignment of Label respective to tick line.
     * @return  Horizontal alignment [-1, 1].
     */
    getLabelAlignment(): number;
    /**
     * Set rotation of Label title.
     * @param value Rotation in degrees
     * @returns Object itself
     */
    setLabelRotation(rotation: number): this;
    /**
     * Get rotation of Label title.
     * @returns Rotation in degrees
     */
    getLabelRotation(): number;
}
/**
 * *TickStyle* singleton, which can be used to indicate that *Ticks* shouldn't be displayed.
 *
 * Can be used with *TickStrategies*.
 *
 * Example usage:
 * ```javascript
 * // Get Default Y Axis of XY Chart.
 * chart.getDefaultAxisY()
 *   // Modify the Axis' TickStrategy.
 *   .setTickStrategy(
 *      // Using a Numeric TickStrategy, modify it's Styler.
 *      AxisTickStrategies.Numeric, ( numericTickStrategy ) => numericTickStrategy
 *          // Set the Minor TickStyle of the TickStrategy as EmptyTick.
 *          .setMinorTickStyle( emptyTick )
 * )
 * ```
 */
export declare const emptyTick: TickStyle;
/**
 * Contains strategies for auto-fitting of Cursors.
 */
/**
 * Type of factory for AutoFitStrategy.
 *
 * This is the type passed to Cursors to set auto-fitting strategy.
 * @param   resultTable ResultTable object to operate with
 * @param   scale       Scale that ResultTable should fit inside
 * @hidden  Excluded from API document, even though it is public API.
 *          The types involved are not required and just reveal inside information.
 */
export declare type AutoFitStrategyFactory<ResultTableBackgroundType extends UIBackground> = (resultTable: ResultTable<ResultTableBackgroundType>, scale: ScaleXY) => AutoFitStrategy<ResultTableBackgroundType>;
/**
 * Strategy that tries to automatically fit the ResultTable of Cursors into an arbitrary scale somehow.
 * AutoFitStrategy keeps track of its changes to the ResultTable and as such is aware if user has modified some relevant trait of it.
 * @hidden Internal class
 */
export declare abstract class AutoFitStrategy<ResultTableBackgroundType extends UIBackground> {
    protected _resultTable: InternalResultTable<ResultTableBackgroundType>;
    protected _scale: ScaleXY;
    /**
     * @param   _resultTable ResultTable object to operate with
     * @param   _scale       Scale that ResultTable should fit inside
     * @hidden
     */
    constructor(_resultTable: InternalResultTable<ResultTableBackgroundType>, _scale: ScaleXY);
    /**
     * Attempt to auto-fit ResultTable to scale.
     * @returns True, when ResultTable fits the scale after auto-fit
     */
    update(): boolean;
    /**
     * Restore any changes that strategy has made to ResultTable.
     */
    resetTable(): this;
}
/**
 * Auto fitting strategy that tries to fit ResultTable by flipping its origin.
 * @hidden Internal class
 */
declare class Flip<ResultTableBackgroundType extends UIBackground> extends AutoFitStrategy<ResultTableBackgroundType> {
}
/**
 * Auto fitting strategy that tries to fit ResultTable by reducing its fontSize
 * @hidden Internal class
 */
declare class FontSize<ResultTableBackgroundType extends UIBackground> extends AutoFitStrategy<ResultTableBackgroundType> {
    protected _minimumFontSize: number;
    protected _stepCount: number;
    /**
     * @param   resultTable     ResultTable object to operate with
     * @param   scale           Scale that ResultTable should fit inside
     * @param   _minimumFontSize Minimum font size that must be retained at all times
     */
    constructor(resultTable: InternalResultTable<ResultTableBackgroundType>, scale: ScaleXY, _minimumFontSize: number, _stepCount: number);
}
interface AutoFitStrategies {
    Flip: <ResultTableBackgroundType extends UIBackground>(resultTable: InternalResultTable<ResultTableBackgroundType>, scale: ScaleXY) => Flip<ResultTableBackgroundType>;
    FontSize: (minimumFontSize: number, stepCount: number) => (resultTable: InternalResultTable, scale: ScaleXY) => FontSize<UIBackground>;
}
/**
 * Collection of *AutoFitStrategyFactories*.
 *
 * Used with *AutoCursor*s and *Marker*s **setAutoFitStrategy()** to customize logic for keeping *ResultTable* in view.
 */
export declare const AutoFitStrategies: AutoFitStrategies;
export {};
/**
 * File contains definition of a 'Cursor' + builder for their creation
 */
/**
 * Interface that is used to point a Cursor to a specific data-point.
 */
export interface CursorPoint<T extends Series2D = Series2D> {
    /**
     * Location of point
     */
    location: Point;
    /**
     * Scale where point is located
     */
    scale: ScaleXY;
    /**
     * Contents for ResultTable
     */
    resultTableContent: ResultTableContent;
    /**
     * Series that contains point
     */
    series: T;
    /**
     * Optional attached fillStyle
     */
    fillStyle?: FillStyle;
}
/**
 * Cursor is a hidable element that can be positioned on a point using a
 * data-structure called 'DataPoint'. Cursors are formed from two
 * distinct parts, PointMarker and ResultTable, first of which
 * shows the location of the Cursor clearly and the second
 * to display information about the pointed DataPoint.
 */
export interface Cursor<PointMarkerType extends PointMarker = PointMarker, ResultTableBackgroundType extends UIBackground = UIBackground> extends Plotable, Disposable, Removable {
    /**
     * Points the Cursor at a given CursorPoint.
     * Updating its position and displayed data.
     */
    pointAt: (point: CursorPoint) => this;
    /**
     * Get current position of Cursor on its scale
     * @return              Position on Cursors scale
     */
    getPosition: () => Point;
    /**
     * Dispose PointMarker
     * @return Object itself for fluent interface
     */
    restorePointMarker(): this;
    /**
     * Restore PointMarker
     * @return Object itself for fluent interface
     */
    disposePointMarker(): this;
    /**
     * @return Weather PointMarker is disposed
     */
    isDisposedPointMarker: () => boolean;
    /**
     * Mutator function for PointMarker.
     * PointMarker is a visual that is displayed at the Cursors position
     * @param   mutator     Mutator function for PointMarker
     * @return              Object itself for fluent interface
     */
    setPointMarker: (mutator: Mutator<PointMarkerType>) => this;
    /**
     * Get PointMarker object.
     * PointMarker is a visual that is displayed at the Cursors position
     * @returns             PointMarker object
     */
    getPointMarker: () => PointMarkerType;
    /**
     * Dispose ResultTable
     * @return Object itself for fluent interface
     */
    disposeResultTable: () => this;
    /**
     * Restore ResultTable
     * @return Object itself for fluent interface
     */
    restoreResultTable: () => this;
    /**
     * @return Weather ResultTable is disposed
     */
    isDisposeResultTable: () => boolean;
    /**
     * Mutator function for ResultTable.
     * ResultTable is a visual that displays currently pointed data next to its location
     * @param   mutator     Mutator function for ResultTable
     * @return              Object itself for fluent interface
     */
    setResultTable: (mutator: Mutator<ResultTable<ResultTableBackgroundType>>) => this;
    /**
     * Get ResultTable object.
     * ResultTable is a visual that displays currently pointed data next to its location
     * @returns             ResultTable object
     */
    getResultTable: () => ResultTable<ResultTableBackgroundType>;
    /**
     * Set AutoFitStrategy of Cursor. Customizable logic which attempts to fit ResultTable to view.
     *
     * See [[AutoFitStrategies]] for available options.
     * @param   autoFitStrategy     AutoFitStrategy or undefined to disable auto-fitting
     * @returns                     Object itself for fluent interface
     */
    setAutoFitStrategy(autoFitStrategy?: AutoFitStrategyFactory<ResultTableBackgroundType>): this;
    /**
     * Get is AutoFitStrategy enabled. Customizable logic which attempts to fit ResultTable to view.
     * @returns                     Boolean flag whether auto-fit is enabled
     */
    getAutoFitStrategy(): boolean;
}
/**
 * Internal type for cursor
 * @hidden
 */
export declare type InternalCursor<PointMarkerType extends PointMarker, ResultTableBackgroundType extends UIBackground> = Cursor<PointMarkerType, ResultTableBackgroundType>;
/**
 * DynamicCursors can change their positioning scale whenever.
 */
export interface AutoCursor<PointMarkerType extends PointMarker = PointMarker, ResultTableBackgroundType extends UIBackground = UIBackground> extends Cursor<PointMarkerType, ResultTableBackgroundType> {
    /**
     * Set is ResultTable auto text fill style enabled.
     * When enabled, text of ResultTable will be automatically filled based on pointed data.
     * @param   enabled     Boolean flag
     * @return              Object itself
     * @sideEffect          When enabled, any fill style set operation on ResultTable might get overridden
     */
    setResultTableAutoTextStyle(enabled: boolean): this;
    /**
     * Get is ResultTable auto text fill style enabled.
     * When enabled, text of ResultTable will be automatically filled based on pointed data.
     * @return              Boolean flag
     */
    getResultTableAutoTextStyle(): boolean;
}
/**
 * StaticCursors are always positioned on the same scale.
 */
export interface StaticCursor<PointMarkerType extends PointMarker, ResultTableBackgroundType extends UIBackground> extends Cursor<PointMarkerType, ResultTableBackgroundType> {
    /**
     * Set the position of the Cursor,
     * moving it without modifying displayed data.
     */
    setPosition: (position: Point) => this;
}
/**
 * Base class for all cursors.
 * @hidden Internal class
 */
declare abstract class CursorBase<PointMarkerType extends PointMarker, ResultTableBackgroundType extends UIBackground> implements InternalCursor<PointMarkerType, ResultTableBackgroundType> {
    protected readonly _layer: Layer2D;
    protected readonly renderingScale: LinearScaleXY;
    readonly scale: ScaleXY;
    protected _pointMarkerConstructor: PointMarkerConstructor<PointMarkerType & InternalPointMarker>;
    protected _resultTableBackgroundConstructor: BackgroundConstructor<ResultTableBackgroundType & InternalBackground>;
    /**
     * @param _layer                                Top layer of the rendering Engine
     * @param renderingScale                        Rendering scale of cursor. For dynamic cursor this is naturally not based on any axis
     * @param _pointMarkerConstructor               Constructor for PointMarker
     * @param _resultTableBackgroundConstructor     Constructor for ResultTableBackground
     */
    constructor(_layer: Layer2D, renderingScale: LinearScaleXY, scale: ScaleXY, _pointMarkerConstructor: PointMarkerConstructor<PointMarkerType & InternalPointMarker>, _resultTableBackgroundConstructor: BackgroundConstructor<ResultTableBackgroundType & InternalBackground>, _theme: Theme);
    /**
     * Points the Cursor at a given CursorPoint.
     * Updating its position and displayed data.
     * @param   cursorPoint Specifies new cursor location and content of result table
     */
    pointAt(cursorPoint: CursorPoint): this;
    /**
     * Get current position of Cursor
     * @return              Position on Cursors scale
     */
    getPosition(): Point;
    /**
     * Dispose of the owned pointMarker and resultTable.
     * @return  Object itself.
     */
    dispose(): this;
    /**
     * Restore the owned pointMarker and resultTable, restoring their child objects.
     * @return Object itself.
     */
    restore(): this;
    /**
     * @return True if all of this Cursor's child objects are disposed, false if not.
     */
    isDisposed(): boolean;
    /**
     * Dispose PointMarker
     * @return Object itself for fluent interface
     */
    disposePointMarker(): this;
    /**
     * Restore PointMarker
     * @return Object itself for fluent interface
     */
    restorePointMarker(): this;
    /**
     * @return Weather PointMarker is disposed
     */
    isDisposedPointMarker(): boolean;
    /**
     * Mutator function for Cursors PointMarker.
     * PointMarker is a visual that is displayed at the Cursors position
     * @param   mutator     Mutator function for PointMarker
     * @return              Object itself for fluent interface
     */
    setPointMarker(mutator: Mutator<PointMarkerType>): this;
    /**
     * Get PointMarker object.
     * PointMarker is a visual that is displayed at the Cursors position
     * @returns             PointMarker object
     */
    getPointMarker(): PointMarkerType;
    /**
     * Dispose ResultTable
     * @return Object itself for fluent interface
     */
    restoreResultTable(): this;
    /**
     * Restore ResultTable
     * @return Object itself for fluent interface
     */
    disposeResultTable(): this;
    /**
     * @return Weather ResultTable is disposed
     */
    isDisposeResultTable(): boolean;
    /**
     * Mutator function for Cursors ResultTable.
     * ResultTable is a visual that displays currently pointed data next to its location
     * @param   mutator     Mutator function for ResultTable
     * @return              Object itself for fluent interface
     */
    setResultTable(mutator: Mutator<ResultTable<ResultTableBackgroundType>>): this;
    /**
     * Get ResultTable object.
     * ResultTable is a visual that displays currently pointed data next to its location
     * @returns             ResultTable object
     */
    getResultTable(): ResultTable<ResultTableBackgroundType>;
    /**
     * Set auto-fit strategy of Cursor.
     * Affects logic of automatic fitting of Cursors ResultTable to the screen.
     * @param   autoFitStrategy     AutoFitStrategy factory or undefined to disable auto-fitting
     * @returns                     Object itself for fluent interface
     */
    setAutoFitStrategy(autoFitStrategy?: AutoFitStrategyFactory<ResultTableBackgroundType>): this;
    /**
     * Get is auto-fit enabled.
     * Affects logic of automatic fitting of Cursors ResultTable to the screen.
     * @returns                     Boolean flag whether auto-fit is enabled
     */
    getAutoFitStrategy(): boolean;
}
/**
 * Base class for Auto cursors.
 * Users should create only using builders, not with constructor
 * @hidden Internal class
 */
export declare class InternalAutoCursor<PointMarkerType extends PointMarker, ResultTableBackgroundType extends UIBackground> extends CursorBase<PointMarkerType, ResultTableBackgroundType> implements AutoCursor<PointMarkerType, ResultTableBackgroundType> {
    /**
     * Points the Cursor at a given CursorPoint.
     * Updating its position and displayed data.
     */
    pointAt(cursorPoint: CursorPoint): this;
    /**
     * Set is ResultTable auto text fill style enabled.
     * When enabled, text of ResultTable will be automatically filled based on pointed data.
     * @param   enabled     Boolean flag
     * @return              Object itself
     * @sideEffect          When enabled, any fill style set operation on ResultTable might get overridden
     */
    setResultTableAutoTextStyle(enabled: boolean): this;
    /**
     * Get is ResultTable auto text fill style enabled.
     * When enabled, text of ResultTable will be automatically filled based on pointed data.
     * @return              Boolean flag
     */
    getResultTableAutoTextStyle(): boolean;
}
/**
 * Base class for Static cursors.
 * Users should create only using builders, not with constructor
 * @hidden Internal class
 */
export declare class InternalStaticCursor<PointMarkerType extends PointMarker, ResultTableBackgroundType extends UIBackground> extends CursorBase<PointMarkerType, ResultTableBackgroundType> implements StaticCursor<PointMarkerType, ResultTableBackgroundType> {
    /**
     * Set position of cursor,
     * moving it without modifying displayed data.
     * @param   position    Position on Cursors scale
     * @return              Object itself
     */
    setPosition(position: Point): this;
}
/**
 * Mutator function that is used for modifying a Cursor during runtime.
 */
export declare type CursorStyler<T extends Cursor> = Mutator<T>;
/**
 * Base class for cursor builders.
 * Cursor builders build cursors with parts of types as indicated by the builders type.
 * All setters of Cursor builders create new builders based on their current state and don't modify the actual object.
 * @hidden Internal class. At the moment we do not allow users to create own cursors.
 */
export declare abstract class CursorBuilder<PointMarkerType extends PointMarker, ResultTableBackgroundType extends UIBackground, CursorType extends Cursor<PointMarkerType, ResultTableBackgroundType>> {
    protected _pointMarkerConstructor: PointMarkerConstructor<PointMarkerType & InternalPointMarker>;
    protected _resultTableBackgroundConstructor: BackgroundConstructor<ResultTableBackgroundType & InternalBackground>;
    protected _stylers: CursorStyler<CursorType>[];
    /**
     * @param _pointMarkerConstructor            Constructor for PointMarker
     * @param _resultTableBackgroundConstructor  Constructor for Background of ResultTable
     * @param _stylers                           List of stylers
     * @hidden
     */
    constructor(_pointMarkerConstructor: PointMarkerConstructor<PointMarkerType & InternalPointMarker>, _resultTableBackgroundConstructor: BackgroundConstructor<ResultTableBackgroundType & InternalBackground>, _stylers?: CursorStyler<CursorType>[]);
    /**
     * Create new CursorBuilder with an additional styler.
     * @param   cursorStyler    Cursor styler function
     * @returns                 CursorBuilder of same type
     */
    abstract addStyler: (cursorStyler: CursorStyler<CursorType>) => ThisType<this>;
    /**
     * Create new CursorBuilder with a different PointMarker.
     * @param   pointMarkerConstructor  Constructor for PointMarker. See [[PointMarkers]] for a collection of options.
     * @returns                         CursorBuilder of same type
     */
    abstract setPointMarker: <T extends InternalPointMarker & PointMarkerType>(pointMarkerConstructor: PointMarkerConstructor<T>) => ThisType<this>;
    /**
     * Create new CursorBuilder with a different ResultTable Background.
     * @param   resultTableBackgroundConstructor    Constructor for Background
     * @returns                                     CursorBuilder of same type
     */
    abstract setResultTableBackground: <T extends InternalBackground & ResultTableBackgroundType>(resultTableBackgroundConstructor: BackgroundConstructor<T>) => ThisType<this>;
}
/**
 * Builder for auto cursors
 * @hidden
 */
export interface AutoCursorBuilder<CursorType extends Cursor> {
}
/**
 * Builder for auto-cursors without axes.
 */
export declare class AutoCursor2DBuilder<PointMarkerType extends PointMarker = PointMarker, ResultTableBackgroundType extends UIBackground = UIBackground> extends CursorBuilder<PointMarkerType, ResultTableBackgroundType, AutoCursor<PointMarkerType, ResultTableBackgroundType>> implements AutoCursorBuilder<AutoCursor<PointMarkerType, ResultTableBackgroundType>> {
    /**
     * Create new CursorBuilder with an additional styler.
     * @param   cursorStyler    Cursor styler function
     * @returns                 CursorBuilder of same type
     */
    addStyler: (cursorStyler: CursorStyler<AutoCursor<PointMarkerType, ResultTableBackgroundType>>) => AutoCursor2DBuilder<PointMarkerType, ResultTableBackgroundType>;
    /**
     * Create new CursorBuilder with a different PointMarker.
     * @param   pointMarkerConstructor  Constructor for PointMarker. See [[PointMarkers]] for a collection of options.
     * @returns                         CursorBuilder of same type
     */
    setPointMarker: <T extends UIElement & PointMarker & PointMarkerType>(pointMarkerConstructor: PointMarkerConstructor<T>) => AutoCursor2DBuilder<T, ResultTableBackgroundType>;
    /**
     * Create new CursorBuilder with a different ResultTable Background.
     * @param   resultTableBackgroundConstructor Constructor for Background
     * @returns                                  CursorBuilder of same type
     */
    setResultTableBackground: <T extends InternalBackground & ResultTableBackgroundType>(resultTableBackgroundConstructor: BackgroundConstructor<T>) => AutoCursor2DBuilder<PointMarkerType, T>;
}
/**
 * Builder for static cursors without axes.
 */
export declare class StaticCursor2DBuilder<PointMarkerType extends PointMarker = PointMarker, ResultTableBackgroundType extends UIBackground = UIBackground> extends CursorBuilder<PointMarkerType, ResultTableBackgroundType, StaticCursor<PointMarkerType, ResultTableBackgroundType>> {
    /**
     * Create new CursorBuilder with an additional styler.
     * @param   cursorStyler    Cursor styler function
     * @returns                 CursorBuilder of same type
     */
    addStyler: (cursorStyler: CursorStyler<StaticCursor<PointMarkerType, ResultTableBackgroundType>>) => StaticCursor2DBuilder<PointMarkerType, ResultTableBackgroundType>;
    /**
     * Create new CursorBuilder with a different PointMarker.
     * @param   pointMarkerConstructor  Constructor for PointMarker. See [[PointMarkers]] for a collection of options.
     * @returns                         CursorBuilder of same type
     */
    setPointMarker: <T extends UIElement & PointMarker & PointMarkerType>(pointMarkerConstructor: PointMarkerConstructor<T>) => StaticCursor2DBuilder<T, ResultTableBackgroundType>;
    /**
     * Create new CursorBuilder with a different ResultTable Background.
     * @param   resultTableBackgroundConstructor    Constructor for Background
     * @returns                                     CursorBuilder of same type
     */
    setResultTableBackground: <T extends InternalBackground & ResultTableBackgroundType>(resultTableBackgroundConstructor: BackgroundConstructor<T>) => StaticCursor2DBuilder<PointMarkerType, T>;
}
export {};
/**
 * File contains definition and default implementations of PointMarker,
 * a purely decorative visual part of all Cursors
 */
/**
 * Visual that is displayed at the Cursors position.
 * Has customizable fill and border.
 */
export interface PointMarker extends Marginable {
    /**
     * Set origin position of PointMarker
     * @param   origin  (-1 to 1 which specifies position of origin, 0 is center of the object)
     * @returns         Object itself for fluent interface
     */
    setOrigin: (origin: Point) => this;
    /**
     * Get origin position of PointMarker
     * @returns         (-1 to 1 which specifies position of origin, 0 is center of the object)
     */
    getOrigin: () => Point;
    /**
     * Set size of PointMarker
     * @param   size        Size of PointMarker in pixels
     * @returns             Object itself
     */
    setSize: (size: Point) => this;
    /**
     * Get size of PointMarker
     * @returns             Size of PointMarker in pixels
     */
    getSize: () => Point;
    /**
     * Set fillStyle of PointMarker
     * @param   fillStyle   FillStyle object or mutator to modify existing one
     * @returns             Object itself
     */
    setFillStyle: (fillStyle: FillStyle | ImmutableMutator<FillStyle>) => this;
    /**
     * Get fillStyle of PointMarker
     * @returns             FillStyle object
     */
    getFillStyle: () => FillStyle;
    /**
     * Set stroke style of PointMarker
     * @param   value   LineStyle object
     * @returns         Object itself
     */
    setStrokeStyle: (value: LineStyle | ImmutableMutator<LineStyle>) => this;
    /**
     * Get stroke style of PointMarker
     * @returns         LineStyle object
     */
    getStrokeStyle: () => LineStyle;
    /**
     * @return True if all child objects are disposed, false if not.
     */
    isDisposed(): boolean;
}
/**
 * Internal type used to limit access to PointMarker
 * @hidden
 */
export declare type InternalPointMarker = UIElement & PointMarker;
/**
 * Type of constructor for PointMarker
 * @hidden
 */
export declare type PointMarkerConstructor<T extends InternalPointMarker = InternalPointMarker> = new (layer: Layer2D, renderingScale: LinearScaleXY, scale: ScaleXY, remove: RemoveHandler<UIElement>, restore: RestoreHandler<UIElement>, theme: Theme) => T;
/**
 * File contains definition and implementations of ResultTable,
 * a visual part of all Cursors whose purpose is to show information about the data-point the Cursor is pointing at.
 */
/**
 * Interface that represents content displayable by a ResultTable.
 *
 * Currently simply a grid of strings, but in the future this could be extended to contain images or such.
 */
export declare type ResultTableContent = Array<string | undefined>[];
/**
 * Class for user customizable building of 'TableContent'.
 * Basically the way users modify what cursors show (on level of a single series), is to
 * set a function that builds TableContent based on information given by the series.
 * Internal class
 */
export declare abstract class TableContentBuilder {
    /**
     * Add a row to built content.
     * @param   cells   Any amount of cells row should contain. Undefined or '' marks a "gap", which will occupy any extra space of row.
     * @return          Object itself
     */
    addRow(...cells: (string | undefined)[]): this;
}
/**
 * Internal class for TableContentBuilder.
 * This contains the methods that are not visible to users.
 * @hidden Internal class
 */
export declare class InternalTableContentBuilder extends TableContentBuilder {
}
/**
 * Public interface for ResultTable.
 * Part of Cursor that displays information about current data-point.
 */
export interface ResultTable<BackgroundType extends UIBackground = UIBackground> extends Marginable {
    /**
     * Set displayed data of ResultTable
     * @param   data    TableContent
     * @returns         Object itself for fluent interface
     */
    setContent: (data: ResultTableContent) => this;
    /**
     * Set origin position of ResultTable
     * @param   origin  (-1 to 1 which specifies position of origin, 0 is center of the object)
     * @returns         Object itself for fluent interface
     */
    setOrigin: (origin: Point) => this;
    /**
     * Get origin position of v
     * @returns         (-1 to 1 which specifies position of origin, 0 is center of the object)
     */
    getOrigin: () => Point;
    /**
     * Set text fillStyle of ResultTable text
     * @param   fillStyle   FillStyle object or mutator to modify existing one
     * @returns             Object itself
     */
    setTextFillStyle: (fillStyle: FillStyle | ImmutableMutator<FillStyle>) => this;
    /**
     * Get text fillStyle of ResultTable
     * @returns             FillStyle object
     */
    getTextFillStyle: () => FillStyle;
    /**
     * Set text font of ResultTable text
     * @param   value   FontSettings or mutator function for existing settings
     * @return          Object itself for fluent interface
     */
    setTextFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
    /**
     * Get text font of ResultTable text
     * @return          FontSettings
     */
    getTextFont(): FontSettings;
    /**
     * Set rotation of ResultTable label.
     * @param value Rotation in degrees
     * @returns Object itself
     */
    setTextRotation(value: number): this;
    /**
     * Get rotation of ResultTable text.
     * @returns Rotation in degrees
     */
    getTextRotation(): number;
    /**
     * Mutator function for Background of ResultTable.
     * @param   mutator Mutator function
     * @return          Object itself for fluent interface
     */
    setBackground(mutator: Mutator<BackgroundType>): this;
    /**
     * Get background object of ResultTable
     * @return          Background object
     */
    getBackground(): BackgroundType;
}
/**
 * Internal ResultTable class.
 * @hidden Internal class
 */
export declare class InternalResultTable<BackgroundClass extends UIBackground = UIBackground> extends UIRowGrid<BackgroundClass> implements ResultTable<BackgroundClass> {
    /**
     * Set displayed data of ResultTable
     * @param   content TableContent
     * @returns         Object itself for fluent interface
     */
    setContent(content: ResultTableContent): this;
    restore(): this;
    /**
     * Set text fill style
     * @param value Fill style object or mutator to modify existing one
     * @return      Object itself for fluent interface
     */
    setTextFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * @return Current fill style object
     */
    getTextFillStyle(): FillStyle;
    /**
     * Set font of Label.
     * @param   value   FontSettings or mutator function for existing settings
     * @return          Object itself
     */
    setTextFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
    /**
     * Get font of Label.
     * @return          FontSettings
     */
    getTextFont(): FontSettings;
    /**
     * Set rotation of Label.
     * @param value Rotation in degrees
     * @returns Object itself
     */
    setTextRotation(value: number): this;
    /**
     * Get rotation of Label.
     * @returns Rotation in degrees
     */
    getTextRotation(): number;
}
/**
 * Chart class for visualizing a Map of a selected part of the world. Defaults to the entire world.
 *
 * `MapChart` can be created in two different ways - to learn more about creation time configuration of `MapChart`, please refer to:
 * - [[LightningChart.Map]] (stand-alone chart).
 * - [[Dashboard.createMapChart]] (chart inside *dashboard*).
 *
 * **MapChart features**
 *
 * 1. Map Types
 *
 * `MapChart` supports 9 different *map types*, each of which depicts a different part of the world.
 * *Map types* can also be split based on different types of *regions*, like *countries, states, territories, provinces*, etc.
 *
 * Supported map types:
 *
 * - [[MapTypes.World]]         | Map of the whole world, regions as countries.
 * - [[MapTypes.Europe]]        | Map of Europe, regions as countries.
 * - [[MapTypes.Africa]]        | Map of Africa, regions as countries.
 * - [[MapTypes.Asia]]          | Map of Asia, regions as countries.
 * - [[MapTypes.NorthAmerica]]  | Map of North America, regions as countries.
 * - [[MapTypes.SouthAmerica]]  | Map of South America, regions as countries.
 * - [[MapTypes.Australia]]     | Map of Australia, regions as Australian territories.
 * - [[MapTypes.USA]]           | Map of the United States of America, regions as states.
 * - [[MapTypes.Canada]]        | Map of Canada, regions as Canadian territories and provinces.
 *
 * Map type is selected when the `MapChart` is created, with the `type` argument:
 *
 * ```typescript
 *  // Example, specify map type.
 *  const mapChart = lightningChart().Map({
 *      type: MapTypes.Europe,
 *  })
 * ```
 *
 * 2. Style and dynamic region coloring
 *
 * `MapChart` has two style properties: region *fill* style and *stroke* style.
 * The style is shared for all regions.
 *
 * Style is configured with
 * - [[MapChart.setFillStyle]].
 * - [[MapChart.setStrokeStyle]].
 *
 * Dynamic region coloring is possibly by configuring *fill* style with [[PalettedFill]].
 *
 * ```typescript
 *  // Example, enable dynamic region coloring based on a color look-up table.
 *  MapChart.setFillStyle(new PalettedFill({
 *      lut: new LUT({
 *          interpolate: true,
 *          steps: [
 *              { value: 0, color: ColorRGBA(255, 0, 0) },
 *              { value: 100, color: ColorRGBA(0, 255, 0) }
 *          ]
 *      })
 *  }))
 * ```
 *
 * Region values used for color look-up are configured with [[MapChart.invalidateRegionValues]].
 * This method is very flexible and can be used in a variety of ways - refer to the method documentation for more examples.
 *
 * ```typescript
 *  // Example, set value of "Finland" region to `0`.
 *  MapChart.invalidateRegionValues([
 *      { value: 0, ISO_A3: 'FIN' }
 *  ])
 * ```
 *
 * 3. AutoCursor
 *
 * `MapChart` has built-in *AutoCursor* functionality, which is activated when
 * user pointer is above any region.
 *
 * *Auto cursor* can be configured in a variety of ways:
 * - [[MapChart.setCursorResultTableFormatter]] | configure formatting of *result table* contents.
 * - [[MapChart.setAutoCursor]] | style auto cursor.
 * - [[MapChart.setAutoCursorMode]] | disable / enable *auto cursor*.
 *
 *
 * **Required resources:**
 *
 * `MapChart` requires external file resources in order to work.
 * These resources are distributed along with the LightningChart JS package (`node_modules/@arction/lcjs/dist/resources`).
 *
 * In order to use `MapChart` the map resources need to be hosted on a file server.
 * When `MapChart` is created, a GET request will be issued to URL: `<resourcesBaseUrl>/maps/<mapDataFile>`.
 *
 * The file server location can be specified by supplying a `resourcesBaseUrl`, please see [[LightningChartOptions.resourcesBaseUrl]] for general information and troubleshooting on LCJS resources.
 *
 * The following table documents which resource files are required based on used *Map type*:
 *
 * | Map type                   | Map data file                             |
 * | :------------------------- | :---------------------------------------- |
 * | `MapTypes.World`           | `'countries_world.json'`                  |
 * | `MapTypes.Europe`          | `'countries_europe.json'`                 |
 * | `MapTypes.NorthAmerica`    | `'countries_northAmerica.json'`           |
 * | `MapTypes.SouthAmerica`    | `'countries_southAmerica.json'`           |
 * | `MapTypes.Africa`          | `'countries_africa.json'`                 |
 * | `MapTypes.Asia`            | `'countries_asia.json'`                   |
 * | `MapTypes.USA`             | `'states_usa.json'`                       |
 * | `MapTypes.Canada`          | `'territoriesProvinces_canada.json'`      |
 * | `MapTypes.Australia`       | `'territories_australia.json'`            |
 */
export declare class MapChart<SelectedMapType extends MapType = MapType, CursorPointMarkerType extends PointMarker = PointMarker, CursorResultTableBackgroundType extends UIBackground = UIBackground, CursorType extends StaticCursor<CursorPointMarkerType, CursorResultTableBackgroundType> = StaticCursor<CursorPointMarkerType, CursorResultTableBackgroundType>> extends Chart implements AttachableWithLUT {
    /**
     * Set Fill Style of Map regions.
     *
     * **Example usage:**
     *
     * [[SolidFill]]:
     *
     * All Map regions are filled with a single color.
     *
     * ```typescript
     *  // Example, solid color MapChart.
     *  MapChart.setFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
     * ```
     *
     * [[PalettedFill]]:
     *
     * Each Map region is colored with an individual color.
     * Coloring basis is further based on `lookUpProperty` of the `PalettedFill`:
     *
     * `lookUpProperty: 'value'`:
     *
     * Each region is colored with a solid color that is looked up from the attached [[LUT]]
     * by the active value of that region, as configured with [[invalidateRegionValues]] method.
     *
     * ```typescript
     *  // Example, MapChart color look-up based on region values.
     *  const mapChart = lightningChart().Map({
     *      type: MapTypes.Europe
     *  })
     *  mapChart.setFillStyle(new PalettedFill({
     *      lookUpProperty: 'value',
     *      lut: new LUT({
     *          interpolate: true,
     *          steps: [
     *              { value: 0, color: ColorRGBA(0, 0, 0) },
     *              { value: 100, color: ColorRGBA(0, 255, 0) }
     *          ]
     *      })
     *  }))
     *  // Assign value for "Finland" region.
     *  mapChart.invalidateRegionValues([{ value: 100, ISO_A3: 'FIN' }])
     * ```
     *
     * `lookUpProperty: 'x' | 'y'`:
     *
     * Each pixel color of the map is looked up from the attached [[LUT]] by the respective
     * *longitude* (`'x'`), or *latitude* (`'y'`) coordinate.
     *
     * ```typescript
     *  // Example, MapChart color look-up based on longitude.
     *  const mapChart = lightningChart().Map({
     *      type: MapTypes.Europe
     *  })
     *  mapChart.setFillStyle(new PalettedFill({
     *      lookUpProperty: 'x',
     *      lut: new LUT({
     *          interpolate: false,
     *          steps: [
     *              { value: -180, color: ColorRGBA(0, 0, 0) },
     *              { value: 20, color: ColorRGBA(0, 255, 0) },
     *              { value: 32, color: ColorRGBA(0, 0, 0) },
     *          ]
     *      })
     *  }))
     * ```
     *
     * [[LinearGradientFill]]:
     *
     * Each pixel color of the map is colored according to a *linear gradient*.
     *
     * ```typescript
     *  // Example, color MapChart with linear gradient.
     *  MapChart.setFillStyle(new LinearGradientFill({
     *      angle: 45,
     *      stops: [
     *          { offset: 0.0, color: ColorRGBA(255, 0, 0) },
     *          { offset: 1.0, color: ColorRGBA(0, 255, 0) }
     *      ]
     *  }))
     * ```
     *
     * [[RadialGradientFill]]:
     *
     * Each pixel color of the map is colored according to a *radial gradient*.
     *
     * ```typescript
     *  // Example, color MapChart with radial gradient.
     *  MapChart.setFillStyle(new RadialGradientFill({
     *      position: { x: 0.8, y: 0.7 },
     *      stops: [
     *          { offset: 0.0, color: ColorRGBA(255, 0, 0) },
     *          { offset: 1.0, color: ColorRGBA(0, 0, 255) }
     *      ]
     *  }))
     * ```
     *
     * [[emptyFill]]:
     *
     * Map regions are not filled.
     *
     * @param   value       Either a [[FillStyle]] object or a function,
     *                      which will be used to create a new FillStyle based on current Fill Style.
     * @returns             MapChart itself.
     */
    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get Fill Style of Map regions.
     * @returns             FillStyle.
     */
    getFillStyle(): FillStyle;
    /**
     * Set Stroke style of Map regions.
     *
     * **Example usage:**
     *
     * [[SolidLine]]:
     *
     * All Map regions edges are drawn with a stroke.
     *
     * ```typescript
     *  // Example, solid region stroke
     *  MapChart.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
     *  }))
     * ```
     *
     * [[emptyLine]]:
     *
     * Regions edges are not drawn with a stroke.
     *
     * @param   value       `LineStyle` or function which mutates the active `LineStyle`.
     * @return              Object itself
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get Stroke Style of Map regions.
     * @return          [[LineStyle]].
     */
    getStrokeStyle(): LineStyle;
    /**
     * Set [[FillStyle]] of *outlier regions* (parts of map that are visible, but not interactable with active map type).
     *
     * ```typescript
     *  // Example usage,
     *  MapChart.setOutlierRegionFillStyle(new SolidFill({ color: ColorRGBA( 80, 0, 0 ) }))
     * ```
     * @param   value       `FillStyle` or function which mutates the active `FillStyle`.
     * @return              Object itself
     */
    setOutlierRegionFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get [[FillStyle]] of *outlier regions* (parts of map that are visible, but not interactable with active map type).
     *
     * @return              FillStyle
     */
    getOutlierRegionFillStyle(): FillStyle;
    /**
     * Set [[LineStyle]] of *outlier regions* (parts of map that are visible, but not interactable with active map type).
     *
     * ```typescript
     *  // Example usage,
     *  MapChart.setOutlierRegionStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
     *  }))
     * ```
     * @param   value       `LineStyle` or function which mutates the active `LineStyle`.
     * @return              Object itself
     */
    setOutlierRegionStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get [[LineStyle]] of *outlier regions* (parts of map that are visible, but not interactable with active map type).
     *
     * @return              LineStyle
     */
    getOutlierRegionStrokeStyle(): LineStyle;
    /**
     * Set [[FillStyle]] of *separate regions*, which are visual components surrounding areas such as *Alaska* and *Hawaii*.
     *
     * Separate regions are present in following Map types:
     * - [[MapTypes.USA]].
     *
     * ```typescript
     *  // Example usage,
     *  MapChart.setSeparateRegionFillStyle(new SolidFill({ color: ColorRGBA( 80, 0, 0 ) }))
     * ```
     * @param   value       `FillStyle` or function which mutates the active `FillStyle`.
     * @return              Object itself
     */
    setSeparateRegionFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get [[FillStyle]] of *Separate regions*, which are visual components surrounding areas such as *Alaska* and *Hawaii*.
     *
     * Separate regions are present in following Map types:
     * - [[MapTypes.USA]].
     * @return              FillStyle
     */
    getSeparateRegionFillStyle(): FillStyle;
    /**
     * Set [[LineStyle]] of *Separate regions*, which are visual components surrounding areas such as *Alaska* and *Hawaii*.
     *
     * Separate regions are present in following Map types:
     * - [[MapTypes.USA]].
     *
     * ```typescript
     *  // Example usage,
     *  MapChart.setSeparateRegionStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
     *  }))
     * ```
     * @param   value       `LineStyle` or function which mutates the active `LineStyle`.
     * @return              Object itself
     */
    setSeparateRegionStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get [[LineStyle]] of *Separate regions*, which are visual components surrounding areas such as *Alaska* and *Hawaii*.
     *
     * Separate regions are present in following Map types:
     * - [[MapTypes.USA]].
     * @return              LineStyle
     */
    getSeparateRegionStrokeStyle(): LineStyle;
    /**
     * Invalidate numeric values associated with each *region* of the Map using a callback function that is called for every region.
     *
     * Region values can be used in conjuction with:
     *
     * - DataCursor:
     *
     * The values can be displayed when user puts the mouse above a *region*. Modify DataCursor parsing with
     * [[MapChart.setCursorResultTableFormatter]]
     *
     * - FillStyle:
     *
     * Each *region* can be styled based on its assigned value, by setting the MapCharts' fill style to a
     * [[PalettedFill]].
     *
     * **Example usage:**
     *
     * ``` ts
     *  // Example, Set a random value [0, 100] for each region.
     *  MapChart.invalidateRegionValues( ( region, prev ) => Math.random() * 100 )
     * ```
     *
     * In a more realistic application, you would look up a value from an external data set based on the `region`.
     * The properties available from `region` are based on the used [[MapType]], see [[MapTypeRegionProperties]] for a list of supported properties.
     *
     * ```typescript
     *  // Example, invalidate region values by external data set.
     *  fetch(...)
     *      .then((data) => {
     *          MapChart.invalidateRegionValues((region) => {
     *              // Look up value for `region`.
     *              const value = data[region.name]
     *              return value || 0
     *          })
     *      })
     * ```
     *
     * @param   callback    Function that is called for each region.
     *                      First parameter is a region data structure, that can be used to identify each region.
     *                      Second parameter is the previous value if any.
     * @return              MapChart itself.
     */
    invalidateRegionValues(callback: (region: MapTypeRegionProperties[SelectedMapType], prev?: number) => number | undefined): this;
    /**
     * Invalidate numeric values associated with each *region* of the Map using an Array of identifier-value objects.
     *
     * Region values can be used in conjuction with:
     *
     * - DataCursor:
     *
     * The values can be displayed when user puts the mouse above a *region*. Modify DataCursor parsing with
     * [[MapChart.setCursorResultTableFormatter]]
     *
     * - FillStyle:
     *
     * Each *region* can be styled based on its assigned value, by setting the MapCharts' fill style to a
     * [[PalettedFill]]
     *
     * **Example usage**:
     *
     * - Select region by name or other property supported by the used [[MapTypes]].
     *
     * ``` ts
     *  MapChart.invalidateRegionValues([
     *      { value: 0, name: 'Finland' }
     *  ])
     * ```
     *
     * In place of 'name', any property supported by the used [[MapType]] can be supplied.
     * Look up [[MapTypeRegionProperties]] for a map of supported properties per *MapType*.
     *
     * ``` ts
     *  // MapTypes that plot *Countries* (for example, 'World', 'Europe') also support 'ISO_A3' country codes.
     *  MapChart.invalidateRegionValues([
     *      { value: 0, ISO_A3: 'FIN' }
     *  ])
     * ```
     *
     * - For quick access, you can also refer to the *region* list of the used *MapType* that is accessed through [[MapRegions]].
     *
     * ``` ts
     *  MapChart.invalidateRegionValues([
     *      { value: 0, ...MapRegions[ MapTypes.World ].Finland }
     *  ])
     * ```
     *
     * @param   values      Array of identifier-value objects.
     * @return              MapChart itself.
     */
    invalidateRegionValues(values: Array<(Partial<MapTypeRegionProperties[SelectedMapType]> & {
        value: number;
    }) | undefined>): this;
    /**
     * Mutator function for charts auto cursor.
     * @param   mutator     Mutator function for a Cursor
     * @return              Object itself for fluent interface
     */
    setAutoCursor(mutator: Mutator<CursorType>): this;
    /**
     * @returns Auto cursor object
     */
    getAutoCursor(): CursorType;
    /**
     * Set mode of charts Auto cursor
     * @param   mode    Either [[AutoCursorModes.onHover]] or [[AutoCursorModes.disabled]].
     * @returns         Object itself for fluent interface
     */
    setAutoCursorMode(mode: AutoCursorModes.onHover | AutoCursorModes.disabled): this;
    /**
     * Get current mode of charts Auto cursor
     * @returns         [[AutoCursorModes]].
     */
    getAutoCursorMode(): AutoCursorModes.onHover | AutoCursorModes.disabled;
    /**
     * Set *ResultTable* formatter. Can be used to specify the information that is displayed, when hovering mouse/pointer
     * over a Map region.
     *
     * **Example usage:**
     *
     * - Display *country* name and ISO_A3 code.
     *
     * ``` ts
     *  MapChart.setCursorResultTableFormatter( ( tableContentBuilder, mapRegion, mapRegionValue, longitude, latitude, mapChart ) => tableContentBuilder
     *      .addRow( mapRegion.name )
     *      .addRow( mapRegion.ISO_A3 )
     *  )
     * ```
     *
     * @param   formatter   Function which builds ResultTable content.
     *                      See definition of [[MapChartFormatter]] for supplied formatting information.
     * @return              Object itself
     */
    setCursorResultTableFormatter(formatter: MapChartFormatter<SelectedMapType>): this;
    /**
     * Get ResultTable Formatter.
     * @return  Function which builds ResultTable content for MapChart.
     */
    getCursorResultTableFormatter(): MapChartFormatter;
    /**
     * Add event listener to Enter Event
     * @param   clbk    Event listener for Mouse Enter Event
     * @return          Token of the event listener
     */
    onMouseEnter: (clbk: MouseEventHandler<this>) => Token;
    /**
     * Add event listener to Mouse Leave Event
     * @param   clbk    Event listener for Mouse Leave Event
     * @return          Token of the event listener
     */
    onMouseLeave: (clbk: AbruptMouseEventHandler<this>) => Token;
    /**
     * Add event listener to Mouse Click Event
     * @param   clbk    Event listener for Mouse Click Event
     * @return          Token of the event listener
     */
    onMouseClick: (clbk: MouseEventHandler<this>) => Token;
    /**
     * Add event listener to Mouse Double Click Event
     * @param   clbk    Event listener for Mouse Double Click Event
     * @return          Token of the event listener
     */
    onMouseDoubleClick: (clbk: MouseEventHandler<this>) => Token;
    /**
     * Add event listener to Mouse Down Event
     * @param   clbk    Event listener for Mouse Down Event
     * @return          Token of the event listener
     */
    onMouseDown: (clbk: MouseEventHandler<this>) => Token;
    /**
     * Add event listener to Mouse Up Event
     * @param   clbk    Event listener for Mouse Up Event
     * @return          Token of the event listener
     */
    onMouseUp: (clbk: MouseEventHandler<this>) => Token;
    /**
     * Add event listener to Mouse Move Event
     * @param   clbk    Event listener for Mouse Move Event
     * @return          Token of the event listener
     */
    onMouseMove: (clbk: MouseEventHandler<this>) => Token;
    /**
     * Subscribe to Mouse Drag Start event
     */
    onMouseDragStart(clbk: MouseDragStartEventHandler<this>): Token;
    /**
     * Subscribe to Mouse Drag event
     */
    onMouseDrag(clbk: MouseDragEventHandler<this>): Token;
    /**
     * Subscribe to Mouse Drag Stop event
     */
    onMouseDragStop(clbk: MouseDragStopEventHandler<this>): Token;
    /**
     * Subscribe to Mouse Wheel event
     * @param   clbk        Event handler function
     * @returns             Token of subscription
     */
    onMouseWheel(clbk: MouseWheelEventHandler<this>): Token;
    /**
     * Subscribe to Touch Start event
     * @param   clbk        Event handler function
     * @returns             Token of subscription
     */
    onTouchStart(clbk: TouchEventHandler<this>): Token;
    /**
     * Subscribe to Touch Move event
     * @param   clbk        Event handler function
     * @returns             Token of subscription
     */
    onTouchMove(clbk: TouchEventHandler<this>): Token;
    /**
     * Subscribe to Touch End event
     * @param   clbk        Event handler function
     * @returns             Token of subscription
     */
    onTouchEnd(clbk: TouchEventHandler<this>): Token;
    /**
     * Remove event listener from Mouse Enter Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseEnter: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Leave Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseLeave: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Click Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseClick: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Double Click Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseDoubleClick: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Down Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseDown: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Up Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseUp: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Move Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseMove: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Drag Start Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseDragStart: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Drag Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseDrag: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Drag Stop Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseDragStop: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Wheel Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseWheel: (token: Token) => boolean;
    /**
     * Remove event listener from Touch Start Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offTouchStart(token: Token): boolean;
    /**
     * Remove event listener from Touch Move Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offTouchMove(token: Token): boolean;
    /**
     * Remove event listener from Touch End Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offTouchEnd(token: Token): boolean;
    /**
     * Set mouse interactions enabled or disabled.
     *
     * Disabling mouse interactions will also disable auto-cursor and triggering of events such as:
     * `onMouseClick`, `onMouseMove`.
     *
     * Disabling mouse interactions can have a positive impact on performance.
     *
     * @param state Specifies state of mouse interactions
     * @return      Object itself for fluent interface
     */
    setMouseInteractions(state: boolean): this;
    /**
     * Get mouse interactions enabled or disabled.
     * @return Mouse interactions state
     */
    getMouseInteractions(): boolean;
    /**
     * Add event listener to Map Data Ready.
     *
     * If map data is ready when event is attached the callback will be called on the next JS event loop cycle.
     * @param   clbk    Event listener for Map Data Ready Event
     * @return          Token of the event listener
     */
    onMapDataReady: (clbk: () => void) => Token;
    /**
     * Remove event listener from Map Data Ready event.
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMapDataReady(token: Token): boolean;
    /**
     * Subscribe to on View Change event.
     *
     * This event is triggered when the geographical view of the Map chart is changed as a side effect of chart resize, padding change, or other reason.
     *
     * It is also fired when the Map chart is first displayed.
     *
     * The view change event can be used for aligning other geographically positioned components over the Map chart.
     * Mainly, it is designed for convenience of usage with `ChartXY` that is laid over a `MapChart`.
     *
     * See our [Interactive Examples gallery for examples of this](https://www.arction.com/lightningchart-js-interactive-examples/search.html?t=map).
     *
     * ```typescript
     *  // Example syntax.
     *  mapChart.onViewChange((view) => {
     *      console.log(view)
     *  })
     * ```
     *
     * @param   clbk    Callback to trigger when the event is fired.
     * @return          Token of the event listener
     */
    onViewChange: (clbk: (view: MapChartView) => unknown) => Token;
    /**
     * Remove event listener from View Change event.
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offViewChange(token: Token): boolean;
    /**
     * Disable/Enable all animations of the Chart.
     * @param animationsEnabled Boolean value to enable or disable animations.
     * @return                  Chart itself for fluent interface.
     */
    setAnimationsEnabled(animationsEnabled: boolean | undefined): this;
    /**
     * Get animations disable/enable state.
     * @returns Animations default state.
     */
    getAnimationsEnabled(): boolean;
    /**
     * Disable all animations for the chart.
     *
     * All animations have to be re-enabled individually if you wish to re-enable animations.
     * @return      Chart itself for fluent interface.
     * @deprecated  Deprecated in v3.1.0. Will be removed in v4.0.0. Use [[setAnimationsEnabled]] instead.
     */
    disableAnimations(): this;
    /**
     * Get minimum size of Panel.
     * Depending on the type of class this value might be automatically computed to fit different elements.
     * @return  Vec2 minimum size or undefined if unimplemented
     */
    getMinimumSize(): Point | undefined;
    /**
     * **Permanently** dispose the component.
     *
     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
     * **to the component and its children** in application code.
     * ```javascript
     * let chart = ...ChartXY()
     * let axisX = chart.getDefaultAxisX()
     * // Dispose Chart, and remove all references so that they can be garbage-collected.
     * chart.dispose()
     * chart = undefined
     * axisX = undefined
     * ```
     * @return  Object itself for fluent interface
     */
    dispose(): this;
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Series itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick: boolean): this;
}
/**
 * Interface that can be used to define *Map Chart* configurations that can't be changed after creation.
 *
 * **Example usage:**
 *
 * - Specify *MapType*.
 *
 * ``` ts
 *  const mapChart = lightningChart().Map({
 *      type: MapTypes.USA
 *  })
 * ```
 */
export interface MapChartOptions<SelectedMapType extends MapType, CursorPointMarkerType extends PointMarker = PointMarker, CursorResultTableBackgroundType extends UIBackground = UIBackground> extends CommonChartOptions {
    /**
     * Preset selection that defines the displayed Map region as well as the type of
     * associated region data (eq. USA -> states, World -> countries).
     *
     * Valid options can be referenced via [[MapTypes]]:
     *
     * ``` ts
     *  const mapChart = lightningChart().Map({
     *      type: MapTypes.USA
     *  })
     * ```
     */
    type?: SelectedMapType;
    /**
     * Builder for the Charts AutoCursor. If omitted, a default one will be used.
     * AutoCursorBuilders.Map can be used to build a custom one from scratch.
     */
    autoCursorBuilder?: StaticCursor2DBuilder<CursorPointMarkerType, CursorResultTableBackgroundType>;
}
/**
 * Interface for a function which builds ResultTable content when pointing at a SeriesXY.
 *
 * **Example usage:**
 *
 * - Display *country* name and ISO_A3 code.
 *
 * ``` ts
 *  MapChart.setCursorResultTableFormatter( ( tableContentBuilder, mapRegion, mapRegionValue, longitude, latitude, mapChart ) => tableContentBuilder
 *      .addRow( mapRegion.name )
 *      .addRow( mapRegion.ISO_A3 )
 *  )
 * ```
 *
 * @param   tableContentBuilder     Builder that is used to build contents of ResultTable.
 *                                  Use addRow() method for adding content.
 * @param   mapRegion               Currently pointed *region* on the Map. Type depends on the [[MapTypes]] of the *MapChart*.
 *                                  Refer to [[MapTypeRegionProperties]] if you're unsure.
 * @param   mapRegionValue          Data value of pointed *region*, as configured with [[MapChart.invalidateRegionValues]].
 * @param   longitude               Pointed map coordinate *longitude*.
 * @param   latitude                Pointed map coordinate *latitude*.
 * @param   mapChart                Reference to the [[MapChart]] object.
 * @return                          TableContentBuilder that was supplied.
 */
export declare type MapChartFormatter<SelectedMapType extends MapType = MapType> = <T extends TableContentBuilder>(tableContentBuilder: T, mapRegion: MapTypeRegionProperties[SelectedMapType], mapRegionValue: undefined | number, longitude: number, latitude: number, mapChart: MapChart<SelectedMapType>) => T;
/**
 * Function for formatting a longitude + latitude value into degrees and minutes formatted string.
 * @param   longitude       Longitude value.
 * @param   latitude        Latitude value.
 * @return                  Formatted String.
 */
export declare const formatLongitudeLatitude: (longitude: number, latitude: number) => string;
/**
 * Data structure which describes the geographical view of a [[MapChart]].
 *
 * Can be received via [[MapChart.onViewChange]] method.
 */
export interface MapChartView {
    /**
     * Displayed longitude range (east-west position).
     */
    longitudeRange: {
        start: number;
        end: number;
    };
    /**
     * Displayed latitude range (north-south position).
     */
    latitudeRange: {
        start: number;
        end: number;
    };
    /**
     * Margins around Map chart edges as pixels.
     */
    margin: {
        left: number;
        top: number;
        right: number;
        bottom: number;
    };
}
/**
 * @hidden
 */
declare type PossibleRegionProperties = MapTypeRegionProperties[keyof MapTypeRegionProperties];
/**
 * Interface that describes the format of JSON files that hold our internal map data.
 * @hidden
 */
export interface MapData<RegionSpecificProperties extends PossibleRegionProperties = PossibleRegionProperties> {
    /**
     * Scale view, where X = Longitude and Y = Latitude.
     */
    view?: Interval<Point>;
    /**
     * List of Regions.
     */
    regions: MapRegion<RegionSpecificProperties>[];
    /**
     * List of outlier Regions.
     *
     * Displayed, but not interactable.
     */
    outliers: MapRegion[];
}
/**
 * @hidden
 */
export declare type MapRegion<RegionSpecificProperties extends PossibleRegionProperties = PossibleRegionProperties> = {
    /**
     * List of polygons.
     */
    geometry: Point[][];
    /**
     * Is region an outlier?
     *
     * Meaning, that it is really far away from other relevant regions.
     * In this case, the geometry is translated / scaled.
     */
    outlier?: boolean;
    /**
     * Transformation that has been applied to `geometry`.
     */
    transform?: undefined | {
        translate: Point;
        scale: Point;
        vertexBoundaries: Interval<Point>;
    };
} & RegionSpecificProperties;
export {};
/**
 * Collection of [[MapChart]] types for selecting a section of the world to show.
 *
 * Map type is selected when the `MapChart` is created, with the `type` argument:
 *
 * ```typescript
 *  // Example, specify map type.
 *  const mapChart = lightningChart().Map({
 *      type: MapTypes.Europe,
 *  })
 * ```
 */
export declare const MapTypes: {
    /**
     * Map of whole world, with regions as countries.
     */
    World: "World";
    /**
     * Map of the United States of America with regions as states.
     */
    USA: "USA";
    /**
     * Map of North America, with regions as countries.
     */
    NorthAmerica: "NorthAmerica";
    /**
     * Map of South America, with regions as countries.
     */
    SouthAmerica: "SouthAmerica";
    /**
     * Map of Canada, with regions as Canadian provinces and territories.
     */
    Canada: "Canada";
    /**
     * Map of Europe, with regions as countries.
     */
    Europe: "Europe";
    /**
     * Map of Asia, with regions as countries.
     */
    Asia: "Asia";
    /**
     * Map of Africa, with regions as countries.
     */
    Africa: "Africa";
    /**
     * Map of Australia, with regions as Australian territories.
     */
    Australia: "Australia";
};
/**
 * Collection object for all possible [[MapChart]] types.
 *
 * Selected type defines the displayed Map region as well as the type of associated region data (eq. USA -> states, World -> countries).
 *
 * *MapType* can be specified when the *MapChart* is created:
 *
 * ``` ts
 *  const mapChart = lightningChart().Map({
 *      type: MapTypes.USA
 *  })
 * ```
 * @hidden
 */
export declare type MapType = typeof MapTypes[keyof typeof MapTypes];
/**
 * Type map that indicates what data is available for each *Map Region*, based on the selected *Map Type*.
 *
 * For example, [[MapTypes.World]] works with [[Country]] data structures, whereas [[MapTypes.USA]] works with [[State]] data structures.
 *
 * This affects the usage of
 * - [[MapChart.setCursorResultTableFormatter]]
 * - [[MapChart.invalidateRegionValues]]
 */
export interface MapTypeRegionProperties {
    World: Country;
    USA: State;
    NorthAmerica: Country;
    SouthAmerica: Country;
    Canada: CanadaProvinceOrTerritory;
    Europe: Country;
    Asia: Country;
    Africa: Country;
    Australia: AustraliaTerritory;
}
/**
 * Data structure of a **country**.
 */
export interface Country {
    /**
     * Name of the country. Eq. 'Finland'. This is case insensitive.
     *
     * Roughly follows the [M49 standard](https://unstats.un.org/unsd/methodology/m49/).
     */
    name: string;
    /**
     * ISO_A3 code of the country. Eq. 'FIN'. This is case insensitive.
     *
     * Roughly follows the [M49 standard](https://unstats.un.org/unsd/methodology/m49/).
     */
    ISO_A3: string;
}
/**
 * Data structure of a **state**.
 */
export interface State {
    /**
     * Name of the state. Eq. 'Florida'. This is case insensitive.
     */
    name: string;
}
/**
 * Data structure of a province / territory of Canada.
 */
export interface CanadaProvinceOrTerritory {
    /**
     * Name of the province / territory. Eq. 'Ontario'. This is case insensitive.
     */
    name: string;
}
/**
 * Data structure of a territory of Australia.
 */
export interface AustraliaTerritory {
    /**
     * Name of the territory. Eq. 'Queensland'. This is case insensitive.
     */
    name: string;
}
/**
 * Chart for visualizing data in a *Polar coordinate system* ( **angle** + **amplitude** ).
 * It has a multitude of methods for adding various types of Series. For example:
 * - [[PolarChart.addPointLineSeries]]
 * - [[PolarChart.addAreaSeries]]
 * - [[PolarChart.addPolygonSeries]]
 * - [[PolarChart.addSector]]
 *
 * *PolarCharts* *Axes* can be styled similarly as those of [[ChartXY]].
 * Refer to them via methods:
 * - [[PolarChart.getAmplitudeAxis]]
 * - [[PolarChart.getRadialAxis]]
 *
 * *Charts* are created by methods of [[LightningChart]] interface or a [[Dashboard]].
 */
export declare class PolarChart<CursorPointMarkerType extends PointMarker = PointMarker, CursorResultTableBackgroundType extends UIBackground = UIBackground> extends ChartWithCursor<PolarSeries, CursorPointMarkerType, CursorResultTableBackgroundType, AutoCursor<CursorPointMarkerType, CursorResultTableBackgroundType>> implements ChartWithAxis<PolarAxis> {
    /**
     * Add a Line series to the PolarChart.
     *
     * [[PolarLineSeries]] are used to render a list of [[PolarPoint]]s
     * by a continuous line that can be styled arbitrarily.
     *
     * **Example usage:**
     *
     * ```ts
     *  const lineSeries = polarChart.addLineSeries().setData(
     *      new Array( 90 ).fill( 0 ).map(( _, i ) => ({
     *          angle: i,
     *          amplitude: 60 + 25 * Math.cos( 5 * i * Math.PI / 180 )
     *      }))
     *  )
     * ```
     * @return  [[PolarLineSeries]].
     */
    addLineSeries(): PolarLineSeries;
    /**
     * Add a Point series to the PolarChart.
     *
     * [[PolarPointSeries]] are used to render a list of [[PolarPoint]]s
     * by different shapes.
     *
     * **Example usage:**
     *
     * ```ts
     *  const pointSeries = polarChart.addPointSeries().setData(
     *      new Array( 90 ).fill( 0 ).map(( _, i ) => ({
     *          angle: i,
     *          amplitude: 60 + 25 * Math.cos( 5 * i * Math.PI / 180 )
     *      }))
     *  )
     * ```
     * @return  [[PolarPointSeries]].
     */
    addPointSeries(): PolarPointSeries;
    /**
     * Add a Point Line series to the PolarChart.
     *
     * [[PolarPointLineSeries]] are used to render a list of [[PolarPoint]]s
     * by a continuous line drawn between the points plus configurable shapes over each data point.
     *
     * **Example usage:**
     *
     * ```ts
     *  const pointLineSeries = polarChart.addPointLineSeries().setData(
     *      new Array( 90 ).fill( 0 ).map(( _, i ) => ({
     *          angle: i,
     *          amplitude: 60 + 25 * Math.cos( 5 * i * Math.PI / 180 )
     *      }))
     *  )
     * ```
     * @return  [[PolarPointLineSeries]].
     */
    addPointLineSeries(): PolarPointLineSeries;
    /**
     * Add a Area series to the PolarChart.
     *
     * [[PolarAreaSeries]] are used to render a list of [[PolarPoint]]s
     * by filling the enclosed area.
     *
     * **Example usage:**
     *
     * - *Plot sub section (< 360 degrees) of the Polar Chart*
     * ```ts
     *  const areaSeries = polarChart.addAreaSeries()
     *      .setData(
     *          new Array( 90 ).fill( 0 ).map(( _, i ) => ({
     *              angle: i,
     *              amplitude: 60 + 25 * Math.cos( 5 * i * Math.PI / 180 )
     *          }))
     *      )
     * ```
     *
     * - *Plot a fully connected (360 degrees) section of the Polar Chart*
     * ```ts
     *  const areaSeries = polarChart.addAreaSeries()
     *      .setConnectDataAutomaticallyEnabled(true)
     *      .setData(
     *          new Array(360).fill(0).map((_, i) => ({
     *              angle: i,
     *              amplitude: 60 + 25 * Math.cos((5 * i * Math.PI) / 180),
     *          })),
     *      )
     * ```
     * @return  [[PolarAreaSeries]].
     */
    addAreaSeries(): PolarAreaSeriesInterior;
    /**
     * Add a Polygon series to the PolarChart.
     *
     * [[PolarPolygonSeries]] are used to render a collection of *polygons* inside the Polar coordinate system. They are especially useful for highlighting parts of the Polar coordinate system.
     *
     * **Example usage:**
     *
     * ```ts
     *  const polygonSeries = polarChart.addPolygonSeries()
     *  let ang = 45
     *  let amplitude = 50
     *  const polygon = polygonSeries.addPolygon()
     *      .setGeometry([
     *          { angle: (ang += 10), amplitude: (amplitude += 10) },
     *          { angle: (ang += 10), amplitude: (amplitude += 5) },
     *          { angle: (ang += 10), amplitude: (amplitude += 10) },
     *          { angle: (ang += 10), amplitude: (amplitude -= 5) },
     *          { angle: (ang += 10), amplitude: (amplitude += 5) },
     *          { angle: (ang += 5), amplitude: (amplitude -= 5) },
     *          { angle: (ang += 0), amplitude: (amplitude -= 10) },
     *          { angle: (ang -= 5), amplitude: (amplitude -= 5) },
     *          { angle: (ang -= 10), amplitude: (amplitude -= 10) },
     *          { angle: (ang -= 10), amplitude: (amplitude -= 5) },
     *          { angle: (ang -= 10), amplitude: (amplitude += 5) },
     *          { angle: (ang -= 10), amplitude: (amplitude += 10) },
     *      ])
     * ```
     * @return  [[PolarPolygonSeries]].
     */
    addPolygonSeries(): PolarPolygonSeries;
    /**
     * Get reference to all series inside `PolarChart`.
     * @return  List of Polar series.
     */
    getSeries(): PolarSeries[];
    /**
     * Add a Sector highlighter to the PolarChart.
     *
     * [[PolarSector]]s can be used to highlight areas in the *polar coordinate system*.
     * @return  [[PolarSector]].
     */
    addSector(): PolarSector;
    /**
     * Get [[PolarAxisAmplitude]] object that represents the PolarCharts *amplitude* dimension,
     * which is depicted as a distance away from the Charts center.
     * @return  [[PolarAxisAmplitude]].
     */
    getAmplitudeAxis(): PolarAxisAmplitude;
    /**
     * Get [[PolarAxisRadial]] object that represents the PolarCharts *radial* dimension,
     * which is depicted as an angle on the Charts center.
     * @return  [[PolarAxisRadial]].
     */
    getRadialAxis(): PolarAxisRadial;
    /**
     * Disable/enable all animations for the chart.
     * @param   animationsEnabled   Boolean value to enable/disable animations.
     * @return                      Chart itself for fluent interface.
     */
    setAnimationsEnabled(animationsEnabled: boolean | undefined): this;
    /**
     * Get animations disable/enable state.
     * @returns Animations default state.
     */
    getAnimationsEnabled(): boolean;
    /**
     * Disable all animations for the chart.
     *
     * All animations have to be re-enabled individually if you wish to re-enable animations.
     * @return          Chart itself for fluent interface.
     * @deprecated      Deprecated in v3.1.0. Will be removed in v4.0.0. Use [[setAnimationsEnabled]] instead.
     */
    disableAnimations(): this;
    /**
     * Set if mouse-interactions on chart are enabled or not
     * @param   enabled     Boolean flag
     * @return              Object itself
     */
    setMouseInteractions(enabled: boolean): this;
    /**
     * Get are mouse-interactions on chart enabled or not
     * @return              Boolean flag
     */
    getMouseInteractions(): boolean;
    /**
     * Get minimum size of Panel.
     * Depending on the type of class this value might be automatically computed to fit different elements.
     * @return  Vec2 minimum size or undefined if unimplemented
     */
    getMinimumSize(): Point | undefined;
    /**
     * Iterate over each Axis of Chart.
     * @param   clbk    Callback function for each Axis.
     */
    forEachAxis(clbk: (axis: PolarAxis) => void): void;
    /**
     * **Permanently** dispose the component.
     *
     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
     * **to the component and its children** in application code.
     * ```javascript
     * let chart = ...ChartXY()
     * let axisX = chart.getDefaultAxisX()
     * // Dispose Chart, and remove all references so that they can be garbage-collected.
     * chart.dispose()
     * chart = undefined
     * axisX = undefined
     * ```
     * @return  Object itself for fluent interface
     */
    dispose(): this;
}
/**
 * Interface for readonly configuration of [PolarChart](../classes/polarchart.html).
 *
 * Some properties of `PolarChart` can only be configured when it is created. These arguments are all optional, and are wrapped in a single object parameter:
 *
 * ```typescript
 *  // Example, create chart with specified color theme.
 *  const chart = LightningChart.Polar({
 *      theme: Themes.light,
 *  })
 * ```
 *
 * *Watch out!* The full set of available readonly configuration parameters depends on if the chart is *standalone*, or inside a *dashboard*:
 *
 * For *standalone* `PolarChart`, more parameters are documented in [[LightningChart.Polar]].
 *
 * For *dashboard* `PolarChart`, more parameters are documented in [[Dashboard.createPolarChart]].
 *
 *
 * **Commonly used properties:**
 *
 * - [[PolarChartOptions.theme]]: Specify chart color *theme*.
 * - [[PolarChartOptions.disableAnimations]]: Convenience flag to disable all animations from chart.
 *
 * **Example usage:**
 *
 * ```typescript
 *  // Example 1, create chart with default configuration.
 *  const chart = LightningChart.Polar({})
 * ```
 *
 * ```typescript
 *  // Example 2, create chart with specified color theme.
 *  const chart = LightningChart.Polar({
 *      theme: Themes.light,
 *  })
 * ```
 */
export interface PolarChartOptions<CursorPointMarkerType extends PointMarker = PointMarker, CursorResultTableBackgroundType extends UIBackground = UIBackground> extends CommonChartOptions {
    /**
     * Builder for the charts' *auto cursor*. Use [[AutoCursorBuilders.Polar]] to modify the default builder, using methods of [[AutoCursor2DBuilder]].
     *
     * ```typescript
     *  // Example, change cursor ResultTable background shape.
     *  const chart = LightningChart.Polar({
     *      autoCursorBuilder: AutoCursorBuilders.Polar
     *          .setResultTableBackground(UIBackgrounds.Circle)
     *  })
     * ```
     */
    autoCursorBuilder?: AutoCursor2DBuilder<CursorPointMarkerType, CursorResultTableBackgroundType>;
}
/**
 * Highlighter component that lives under [[PolarChart]].
 *
 * Can be used to highlight sectors in the *polar coordinate* system,
 * specified by four values:
 * - **start angle**
 * - **end angle**
 * - **start amplitude**
 * - **end amplitude**
 *
 * Created with [[PolarChart.addSector]].
 */
export declare class PolarSector extends ChartComponent<Arc> {
    /**
     * Set Sectors start angle in degrees.
     * @param angleStart    Start angle in degrees, restricted to [0, 360].
     *                      This doesn't have to be less than angle end value.
     * @return              Object itself for fluent interface.
     */
    setAngleStart(angleStart: number): this;
    /**
     * Get Sectors start angle in degrees.
     * @return              Start angle  in degrees, restricted to [0, 360].
     *                      This doesn't have to be less than angle end value.
     */
    getAngleStart(): number;
    /**
     * Set Sectors end angle in degrees.
     * @param angleEnd      End angle in degrees, restricted to [0, 360].
     *                      This doesn't have to be greater than angle start value.
     * @return              Object itself for fluent interface.
     */
    setAngleEnd(angleEnd: number): this;
    /**
     * Get Sectors end angle in degrees.
     * @return              End angle in degrees, restricted to [0, 360].
     *                      This doesn't have to be greater than angle start value.
     */
    getAngleEnd(): number;
    /**
     * Set Sectors start amplitude.
     * @param amplitudeStart    Start amplitude. Setting to *undefined* results in tracking the *PolarAxes* start value.
     *                          This doesn't have to be less than amplitude end value.
     * @return                  Object itself for fluent interface.
     */
    setAmplitudeStart(amplitudeStart: number): this;
    /**
     * Get Sectors start amplitude.
     * @return              Start amplitude. Setting to *undefined* results in tracking the *PolarAxes* start value.
     *                      This doesn't have to be less than amplitude end value.
     */
    getAmplitudeStart(): number | undefined;
    /**
     * Set Sectors end amplitude.
     * @param amplitudeEnd  End amplitude. Setting to *undefined* results in tracking the *PolarAxes* end value.
     *                      This doesn't have to be greater than amplitude start value.
     * @return              Object itself for fluent interface.
     */
    setAmplitudeEnd(amplitudeEnd: number | undefined): this;
    /**
     * Get Sectors end amplitude.
     * @return              End amplitude. Setting to *undefined* results in tracking the *PolarAxes* end value.
     *                      This doesn't have to be greater than amplitude start value.
     */
    getAmplitudeEnd(): number | undefined;
    /**
     * Set Fill Style of Sector.
     *
     * Example use:
     *
     *```javascript
     * // Create a new style
     * PolarSector.setFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Change transparency
     * PolarSector.setFillStyle((solidFill) => solidFill.setA(80))
     * // Set hidden
     * PolarSector.setFillStyle(emptyFill)
     *
     * @param   value   FillStyle object or function which mutates existing value.
     * @return          Object itself for fluent interface.
     */
    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get Fill Style of Sector.
     * @return          FillStyle
     */
    getFillStyle(): FillStyle;
    /**
     * Set Fill Style of Sector when highlighted.
     *
     * Example use:
     *
     *```javascript
     * // Create a new style
     * PolarSector.setFillStyleHighlight(new SolidFill({ color: ColorHEX('#F00') }))
     * // Change transparency
     * PolarSector.setFillStyleHighlight((solidFill) => solidFill.setA(80))
     * // Set hidden
     * PolarSector.setFillStyleHighlight(emptyFill)
     * // Automatic
     * PolarSector.setFillStyleHighlight(undefined)
     * ```
     * @param   value   FillStyle object, function which mutates existing value or *undefined* for automatic assignment.
     * @return          Object itself for fluent interface.
     */
    setFillStyleHighlighted(value: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * Get Fill Style of Sector when highlighted.
     * @return          FillStyle or undefined (automatic assignment)
     */
    getFillStyleHighlighted(): FillStyle | undefined;
    /**
     * Set stroke style of PolarSector.
     *
     * Example usage:
     *```javascript
     * // Specified SolidLine
     * PolarSector.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * PolarSector.setStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden
     * PolarSector.setStrokeStyle(emptyLine)
     * ```
     * @param   value   Either a LineStyle object or a function, which will be used to create a new SolidLine based on current value.
     * @returns         Chart itself
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stroke style of PolarSector.
     * @return  Normal StrokeStyle
     */
    getStrokeStyle(): LineStyle;
    /**
     * Set stroke style of PolarSector when it is highlighted.
     * Highlighting is activated by placing mouse on top / touching PolarSector (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     *
     * Example usage:
     *```javascript
     * // Specified LineStyle
     * PolarSector.setStrokeStyleHighlight(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * PolarSector.setStrokeStyleHighlight((solidLine) => solidLine.setThickness(5))
     * // Hidden
     * PolarSector.setStrokeStyleHighlight(emptyLine)
     * // Automatic
     * PolarSector.setStrokeStyleHighlight(undefined)
     * ```
     * @param   value   Either a LineStyle object or a function, which will be used to modify current value or
     *                  undefined for automatic value based on normal style.
     * @returns         Chart itself
     */
    setStrokeStyleHighlight(value: LineStyle | ImmutableMutator<LineStyle> | undefined): this;
    /**
     * Get highlight stroke style of PolarSector.
     * @return  StrokeStyle.
     */
    getStrokeStyleHighlight(): LineStyle;
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Series itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick?: boolean): this;
}
/**
 * Abstract super class for all PolarSeries.
 * @hidden
 */
export declare abstract class PolarSeries<VisualType extends ChartVisual = ChartVisual, CursorPointInterface extends CursorPoint<PolarSeries> = any> extends Series2D<VisualType, CursorPointInterface> {
    /**
     * Scale of the series
     */
    readonly scale: RadialScale;
    /**
     * Get min amplitude value of PolarSeries' data points.
     * @return      number or undefined if no data is set.
     */
    getAmplitudeMin(): number | undefined;
    /**
     * Get max amplitude value of PolarSeries' data points.
     * @return      number or undefined if no data is set.
     */
    getAmplitudeMax(): number | undefined;
    /**
     * Configure formatting of *Cursor ResultTable* when pointing at this *series*.
     *
     * ```typescript
     *  // Example usage
     *  PolarLineSeries.setCursorResultTableFormatter((tableBuilder, series, angleDeg, amplitude) => {
     *      return tableBuilder
     *          .addRow(`Pointing at`, '', series.getName())
     *          .addRow(`Angle:`, '', angleDeg.toFixed(0) + ' deg')
     *          .addRow(`Amplitude:`, '', amplitude.toFixed(1))
     *  })
     * ```
     *
     * The general syntax of configuring *ResultTable* formatting is shared between all *series* types;
     * You specify a callback function, which receives a [[TableContentBuilder]]. The contents of the table are then set using methods of the *table builder*:
     *
     * ```typescript
     *  // Using TableContentBuilder.
     *  PolarLineSeries.setCursorResultTableFormatter((tableBuilder, series, angleDeg, amplitude) => {
     *      // addRow adds a list of strings to a new row in the table. Empty strings ('') will allocate any extra horizontal space within the row.
     *      tableBuilder
     *          .addRow('Item 0:', '', 'Value 0')
     *          .addRow('Item 1:', '', 'Value 1')
     *          .addRow('Long row that highlights the idea of empty strings')
     *
     *      // After configuration, the table builder must be returned!
     *      return tableBuilder
     *  })
     * ````
     *
     * The additional values that are supplied to the callback function vary between different chart types,
     * refer to the *series* documentation of `setCursorResultTableFormatter` to learn the exact available information.
     * All `Polar Series` receive three extra parameters:
     * 1. `series` | reference to the series itself.
     * 2. `angleDeg` | pointed data point angle as degrees.
     * 3. `amplitude` | pointed data point amplitude.
     *
     * **Related API:**
     *
     * - [[setCursorEnabled]] | configure whether *cursors* should pick on this particular *series* or not.
     * - [[PolarChart.setAutoCursorMode]] | configure behavior when auto cursor is visible.
     *
     * @param   formatter   Function which builds *ResultTable* content.
     * @return              Object itself
     */
    setCursorResultTableFormatter(formatter: PolarSeriesFormatter): this;
    /**
     * Get ResultTable Formatter.
     * @return  Function which builds ResultTable content for SpiderSeries.
     */
    getCursorResultTableFormatter(): PolarSeriesFormatter;
}
/**
 * Interface for a function which builds ResultTable content when pointing at a PolarSeries.
 * @param   tableContentBuilder     Builder that is used to build contents of ResultTable.
 *                                  Use addRow() method for adding content.
 * @param   series                  PolarSeries
 * @param   angleDeg                Angle of data point as degrees
 * @param   amplitude               Amplitude of data point
 * @param   formatAmplitude         Formating function for similar formatting as Charts Amplitude Axis.
 * @return                          TableContentBuilder that was supplied
 */
export declare type PolarSeriesFormatter = <T extends TableContentBuilder>(tableContentBuilder: T, series: PolarSeries, angleDeg: number, amplitude: number, formatAmplitude: (amplitude: number) => string) => T;
/**
 * Data-structure for describing a point in a Polar coordinate system.
 *
 * Used with [[PolarChart]] and *Polar series*.
 */
export interface PolarPoint {
    /**
     * Angle value in degrees [ 0, 360 ].
     */
    readonly angle: number;
    /**
     * Amplitude value.
     */
    readonly amplitude: number;
    /**
     * Optional point specific color.
     *
     * Usable with [[PolarPointSeries]] when styled with [[IndividualPointFill]].
     */
    readonly color?: Color;
}
/**
 * Enum that defines layer indices of PieChart.
 * @hidden
 */
export declare enum LayerIndices {
    bg = 0,
    bottom = 1,
    top = 2,
    ui = 3
}
declare type SliceTypes = PieSlice | FunnelSlice;
/**
 * SliceLabelIndices enum defines types of Slice labels .
 */
export declare enum SliceLabelIndices {
    LabelsInsideSlices = 0,
    LabelsOnSides = 1
}
/**
 * Interface exists for enforcing shared APIs between Pie, Funnel and Pyramid Charts.
 * @hidden
 */
export interface SlicedCharts<T extends SliceTypes> {
    /**
     * Set lookup table
     * @value lookup table
     * @return Chart itself
     */
    setLUT(value: LUT): this;
    /**
     * Set fill style of Slices Labels.
     * @param   value   FillStyle object or function which creates a new style based on previous
     * @return          Chart itself
     */
    setLabelFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of Slice Labels.
     * @return  FillStyle object
     */
    getLabelFillStyle(): FillStyle;
    /**
     * Set font of Slice Labels.
     * @param   value   FontSettings or mutator function for existing settings
     * @return          Chart itself
     */
    setLabelFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
    /**
     * Get font of Slice Labels.
     * @return  FontSettings
     */
    getLabelFont(): FontSettings;
    /**
     * Set formatter of Slice Labels.
     *
     * See [[SliceLabelFormatters]] for a collection of default options.
     * @param   labelFormatter  SliceLabelFormatter - function which generates text of Labels per Slice.
     * @return                  Chart itself
     */
    setLabelFormatter(labelFormatter: SliceLabelFormatter<T>): this;
    /**
     * Get formatter of Slice Labels.
     * @return  SliceLabelFormatter - function which generates text of Labels per Slice.
     */
    getLabelFormatter(): SliceLabelFormatter<T>;
    /**
     * Set style of Slices fill.
     * This style is managed as a continuous Palette of FillStyle objects. Each Slice of Chart will be assigned an incremental index,
     * which will be used to pick its fill style from this Palette.
     *
     * So, for example... We have a Sliced Chart with 5 Slices, and we give it a Palette with only 3 possible values
     * (0 = red, 1 = green, 2 = blue). The resulting Slice fill styles will be: red, green, blue, red, green.
     * Note that this means, that the supplied Palette will have to work in a continuous manner!
     *
     * @param   sliceFillStylePalette   Palette for FillStyle objects
     * @return                          Chart itself
     */
    setSliceFillStyle(sliceFillStylePalette: Palette<FillStyle>): this;
    /**
     * Get style of Slices fill.
     * This style is managed as a continuous Palette of FillStyle objects. Each Slice of Chart will be assigned an incremental index,
     * which will be used to pick its fill style from this Palette.
     *
     * So, for example... We have a Sliced Chart with 5 Slices, and we give it a Palette with only 3 possible values
     * (0 = red, 1 = green, 2 = blue). The resulting Slice fill styles will be: red, green, blue, red, green.
     * Note that this means, that the supplied Palette will have to work in a continuous manner!
     *
     * @return  Palette<FillStyle>
     */
    getSliceFillStyle(): Palette<FillStyle>;
    /**
     * Set style of Slices Stroke.
     * @param   value   LineStyle object or function which creates a new style based on previous
     * @return          Chart itself
     */
    setSliceStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of Slices Stroke.
     * @return  LineStyle object
     */
    getSliceStrokeStyle(): LineStyle;
    /**
     * Set sorter of Slices as a comparator-function.
     *
     * For some commonly needed default implementations, can refer to [[SliceSorters]] collection.
     * @param   sliceSorter SliceSorter - function which sorts Slices of the Chart with JavaScript API: Array.sort.
     * @return              Chart itself
     */
    setSliceSorter(sliceSorter: SliceSorter<T>): this;
    /**
     * Get sorter of Slices as a comparator-function.
     * @return  SliceSorter - function which sorts Slices of the Chart with JavaScript API: Array.sort.
     */
    getSliceSorter(): SliceSorter<T>;
    /**
     * This method is used for the adding slices in the Chart.
     * @param title Slice title
     * @param value  Slice value
     */
    addSlice(title: string, value: number): T;
    /**
     * This method is used for the adding multiple slices in the Chart.
     * @param multiSlice Array of slices
     */
    addSlices(multiSlice: {
        name: string;
        value: number;
    }[]): Array<T>;
    /**
     * Set if Slice should be highlighted when hovered over for all Slices.
     * @param state True if Slice should highlight on hover, false if not.
     * @return      Chart itself
     */
    setSliceHighlightOnHover(state: boolean): this;
}
/**
 * Type of function which is used to sort Slices of a Chart with Slices.
 * It is a comparator function used with JavaScript API: Array.sort.
 *
 * See [[SliceSorters]] collection for quick access to some example implementations.
 *
 * Use with [[SlicedCharts.setSliceSorter]]
 *
 * Example usage:
 *```javascript
 * // Use a default implementation
 * SlicedCharts.setSliceSorter(SliceSorters.SortByValueDescending)
 * // Use a custom implementation
 * SlicedCharts.setSliceSorter((a, b) => a.getValue() - b.getValue())
 * ```
 * @param   sliceA  Slice A
 * @param   sliceB  Slice B
 * @return          Number which implies the sorted order between Slices A and B.
 *                  For more details, refer to Array documentation.
 */
export declare type SliceSorter<T extends SliceTypes> = (sliceA: T, sliceB: T) => number;
/**
 * Collection of some example implementations of [[SliceSorter]]
 *
 * Use with [[SlicedCharts.setSliceSorter]]
 *
 * Example usage:
 *```javascript
 * // Use a default implementation
 * SlicedCharts.setSliceSorter(SliceSorters.SortByValueDescending)
 * // Use a custom implementation
 * SlicedCharts.setSliceSorter((a, b) => a.getValue() - b.getValue())
 * ```
 */
export declare const SliceSorters: {
    /**
     * SliceSorter that sorts Slices based on their names using JS API: String.localeCompare.
     */
    SortByName: SliceSorter<SliceTypes>;
    /**
     * SliceSorter that sorts Slices to ascending value order.
     */
    SortByValueAscending: SliceSorter<SliceTypes>;
    /**
     * SliceSorter that sorts Slices to descending value order.
     */
    SortByValueDescending: SliceSorter<SliceTypes>;
    /**
     * Disabled Slice sorting.
     */
    None: SliceSorter<SliceTypes>;
};
/**
 * Type of function which is used to format text of Slice Labels.
 * It is a function which generates a string based on a Slice along with some additional information.
 *
 * See [[SliceLabelFormatters]]-collection for quick access to some example implementations.
 *
 * Use with [[SlicedCharts.setLabelFormatter]]
 *
 * Example usage:
 *```javascript
 * // Use a default implementation
 * SlicedCharts.setLabelFormatter(SliceLabelFormatters.NamePlusRelativeValue)
 * // Use a custom implementation
 * SlicedCharts.setLabelFormatter((slice, relativeValue) => slice.getValue() + ' €')
 * ```
 * @param   slice           Slice
 * @param   relativeValue   Value of the Slice as a % of all Slice values
 * @return                  String text for Label
 */
export declare type SliceLabelFormatter<T extends SliceTypes> = (slice: T, relativeValue: number) => string;
/**
 * Collection of some example implementations of [[SliceLabelFormatters]].
 *
 * Use with [[SlicedCharts.setLabelFormatter]]
 *
 * Example usage:
 *```javascript
 * // Use a default implementation
 * SlicedCharts.setLabelFormatter(SliceLabelFormatters.NamePlusRelativeValue)
 * // Use a custom implementation
 * SlicedCharts.setLabelFormatter((slice, relativeValue) => slice.getValue() + ' €')
 * ```
 */
export declare const SliceLabelFormatters: {
    /**
     * Slice Label formatter for `${name}`.
     */
    Name: SliceLabelFormatter<SliceTypes>;
    /**
     * Slice Label formatter for `${name}: ${Math.round(animatedValue)}`.
     */
    NamePlusValue: SliceLabelFormatter<SliceTypes>;
    /**
     * Slice Label formatter for `${name}: ${(relativeValue * 100).toFixed(1)}%`.
     */
    NamePlusRelativeValue: SliceLabelFormatter<SliceTypes>;
};
export {};
/**
 * Class that represents a single Slice of a Pie Chart.
 */
export declare abstract class Slice<SliceVisual extends ChartVisual> extends ChartComponent<SliceVisual> {
    /**
     * Set value of Slice.
     * @param   value   Numeric value
     * @return          Slice itself
     */
    abstract setValue(value: number): this;
    /**
     * Get value of Slice.
     * @return          Numeric value
     */
    abstract getValue(): number;
    /**
     * Get animated value of Slice.
     *
     * This always returns the currently **rendered value** of the Slice, which might be delayed by animations.
     * @return          Numeric value
     */
    abstract getAnimatedValue(): number;
}
/**
 * Type of data-structure that defines how an axis label is positioned.
 */
export interface SpiderAxisLabelPosition {
    /**
     * Alignment X [-1, 1], where -1 is left and 1 is right extreme
     */
    alignmentX: number;
    /**
     * Alignment Y [-1, 1], where -1 is bottom and 1 is top extreme
     */
    alignmentY: number;
    /**
     * Padding in X direction as pixels
     */
    paddingX: number;
    /**
     * Padding in Y direction as pixels
     */
    paddingY: number;
}
/**
 * Type of an axis label strategy function.
 * Defines how axis labels are aligned.
 * @param   result              DataStructure that is used to pass result
 * @param   axisIndex           Index of axis. 0 is always directly up
 * @param   axisCount           Amount of axes in chart
 * @param   axisTag             Name of axis
 * @param   axisAngle           Angle of axis in radians
 * @param   labelPadding        Label padding as set in chart
 * @return                      SpiderAxisLabelPosition (modified first parameter of function)
 */
export declare type SpiderAxisLabelStrategy = (result: SpiderAxisLabelPosition, axisIndex: number, axisCount: number, axisTag: string, axisAngle: number, labelPadding: number) => SpiderAxisLabelPosition;
/**
 * Default axis label strategy for spider charts.
 * @hidden
 */
export declare const _defaultSpiderAxisLabelStrategy: SpiderAxisLabelStrategy;
/**
 * Type of data-structure that defines how an axis label is positioned on a Spider Chart.
 */
export interface SpiderScaleLabelPosition {
    /**
     * Alignment X [-1, 1], where -1 is left and 1 is right extreme
     */
    alignmentX: number;
    /**
     * Alignment Y [-1, 1], where -1 is bottom and 1 is top extreme
     */
    alignmentY: number;
    /**
     * Padding in X direction as pixels
     */
    paddingX: number;
    /**
     * Padding in Y direction as pixels
     */
    paddingY: number;
}
/**
 * Type of a scale label strategy function.
 * Defines how scale labels are aligned.
 * @param   result              DataStructure that is used to pass result
 * @param   axisIndex           Index of axis. 0 is always directly up
 * @param   axisCount           Amount of axes in chart
 * @param   axisTag             Name of axis
 * @param   axisAngle           Angle of axis in radians
 * @param   webIndex            Index of web. 0 is always the outer-edge of spider
 * @param   webCount            Amount of webs in chart
 * @param   labelPadding        Label padding as set in chart
 * @return                      SpiderScaleLabelPosition (modified first parameter of function) or undefined to not display label
 */
export declare type SpiderScaleLabelStrategy = (result: SpiderScaleLabelPosition, axisIndex: number, axisCount: number, axisTag: string, axisAngle: number, webIndex: number, webCount: number, labelPadding: number) => SpiderScaleLabelPosition | undefined;
/**
 * Default scale label strategy for spider charts.
 * Displays scale labels only on first axis of spider chart.
 * @hidden
 */
export declare const _defaultSpiderScaleLabelStrategy: SpiderScaleLabelStrategy;
/**
 * Container for shapes of spider axes and drawing logic.
 * @hidden Internal class
 */
export declare class SpiderAxis {
    readonly gridLayer: Layer2D;
    readonly labelLayer: Layer2D;
    readonly scale: LinearScaleXY;
    readonly chart: SpiderChart;
    readonly tag: string;
    readonly axisScale: Scale1D;
    private _setupMouseInteractions;
    private readonly _remove;
    private readonly _restore;
    /**
     * Axis line
     */
    shapeAxis: Line;
    /**
     * Axis tag label
     */
    shapeTag: Text;
    /**
     * Nib shape
     */
    shapeNib: LineSet;
    /**
     * @param  gridLayer                Rendering layer for axis line
     * @param  labelLayer               Rendering layer for axis labels and nib
     * @param  scale                    Scale object used in rendering axis shapes. Must be in pixels!
     * @param  chart                    SpiderChart object which would contain this axis. Is used to query chart margins
     * @param  tag                      String tag of the axis
     * @param  axisScale                Reference to axisScale of chart. Mainly used for cursor formating
     * @param  _setupMouseInteractions   Injected method that adds mouse-interactions to axis nib
     * @param  _remove                   Injected remove method from owner, used to remove Axis from the collection it's in.
     */
    constructor(gridLayer: Layer2D, labelLayer: Layer2D, scale: LinearScaleXY, chart: SpiderChart, tag: string, axisScale: Scale1D, _setupMouseInteractions: (axis: SpiderAxis, nib: LineSet) => LineSet, _remove: RemoveHandler<SpiderAxis>, _restore: RestoreHandler<SpiderAxis>);
    /**
     * Update axis label style and return its computed size.
     * Used for computation of chart margins before drawing.
     */
    getLabelSize(): Point;
    /**
     * Disposes SpiderAxis' shapes from its rendering engine, then tell owner to remove this SpiderAxis from its collections.
     */
    dispose(): void;
    /**
     * Restore the SpiderAxis back to the SpiderChart it belongs to.
     */
    restore(): void;
    /**
     * Get the isDisposed state of child objects.
     * @return  True if all child objects are disposed, false if any are not.
     */
    isDisposed(): boolean;
}
/**
 * Interface for readonly configuration of [SpiderChart](../classes/spiderchart.html).
 *
 * Some properties of `SpiderChart` can only be configured when it is created. These arguments are all optional, and are wrapped in a single object parameter:
 *
 * ```typescript
 *  // Example, create chart with specified color theme.
 *  const chart = LightningChart.Spider({
 *      theme: Themes.light,
 *  })
 * ```
 *
 * *Watch out!* The full set of available readonly configuration parameters depends on if the chart is *standalone*, or inside a *dashboard*:
 *
 * For *standalone* `SpiderChart`, more parameters are documented in [[LightningChart.Spider]].
 *
 * For *dashboard* `SpiderChart`, more parameters are documented in [[Dashboard.createSpiderChart]].
 *
 *
 * **Commonly used properties:**
 *
 * - [[SpiderChartOptions.theme]]: Specify chart color *theme*.
 * - [[SpiderChartOptions.disableAnimations]]: Convenience flag to disable all animations from chart.
 *
 * **Example usage:**
 *
 * ```typescript
 *  // Example 1, create chart with default configuration.
 *  const chart = LightningChart.Spider({})
 * ```
 *
 * ```typescript
 *  // Example 2, create chart with specified color theme.
 *  const chart = LightningChart.Spider({
 *      theme: Themes.light,
 *  })
 * ```
 */
export interface SpiderChartOptions<CursorPointMarkerType extends PointMarker = PointMarker, CursorResultTableBackgroundType extends UIBackground = UIBackground> extends CommonChartOptions {
    /**
     * Builder for the charts' *auto cursor*. Use [[AutoCursorBuilders.Spider]] to modify the default builder, using methods of [[AutoCursor2DBuilder]].
     *
     * ```typescript
     *  // Example, change cursor ResultTable background shape.
     *  const chart = LightningChart.Spider({
     *      autoCursorBuilder: AutoCursorBuilders.Spider
     *          .setResultTableBackground(UIBackgrounds.Circle)
     *  })
     * ```
     */
    autoCursorBuilder?: AutoCursor2DBuilder<CursorPointMarkerType, CursorResultTableBackgroundType>;
}
/**
 * Chart for visualizing data in a radial form as dissected by named axes.
 *
 * *Charts* are created by methods of [[LightningChart]] interface or a [[Dashboard]].
 *
 * A **SpiderChart** can have any number of [[SpiderSeries]] added to it using [[SpiderChart.addSeries]].
 * Data can then be pushed in with [[SpiderSeries.addPoints]]
 *
 * By default, *SpiderChart* automatically creates *Axes* based on the data that are pushed to its *Series*.
 */
export declare class SpiderChart<CursorPointMarkerType extends PointMarker = PointMarker, CursorResultTableBackgroundType extends UIBackground = UIBackground> extends ChartWithCursor<SpiderSeries, CursorPointMarkerType, CursorResultTableBackgroundType, AutoCursor<CursorPointMarkerType, CursorResultTableBackgroundType>> {
    /**
     * Scale of axes. Used for formatting and scaling series.
     *
     * @hidden
     */
    protected readonly axisScale: any;
    /**
     * @param   layerSupplier           Rendering layer supplier
     * @param   scaleFactory            Scale Factory
     * @param   logoFactory             Logo factory.
     * @param   autoCursorBuilder       AutoCursorBuilder. If undefined or omitted, auto cursor will be disabled
     * @param   resizeEventInterface    Injectable event interface for resizing Panel (used for dashboard)
     * @param   theme                   Theme used to style elements in the Chart.
     * @hidden
     */
    constructor(_lcjsOptions: InternalLightningChartOptions, layerSupplier: LayerSupplier, scaleFactory: ScaleFactory, removeChart: (chart: Panel) => void, logoFactory?: LogoFactory, spiderChartOptions?: SpiderChartOptions<CursorPointMarkerType, CursorResultTableBackgroundType>, resizeEventInterface?: DashboardResizeEventInterface);
    /**
     * Add a new axis to Spider Chart
     * @param axis  Axis tag
     * @returns     Object itself
     */
    addAxis(tagOrAxis: string): this;
    /**
     * Remove axis from Spider Chart
     * @param tagOrAxis     Axis or tag of an Axis which has to be removed
     * @returns             Object itself for fluent interface
     */
    removeAxis: (tagOrAxis: string | SpiderAxis) => this;
    /**
     * Restore given axis to the Spider Chart.
     * @param   axis    Axis to restore.
     * @return          This.
     */
    restoreAxis: (axis: SpiderAxis) => this;
    /**
     * Check if Chart has an Axis with specified tag
     * @param tag   Name of desirable axis
     * @returns     True if axis exists, false if not.
     */
    hasAxis: (tag: string) => boolean;
    /**
     * Format value along an axis.
     * @param   value       Value along an axis
     * @param   formatter   Optional explicit formating function
     * @return              Value formated to string
     */
    formatValue: (value: number) => string;
    /**
     * Adds a new SpiderSeries to the SpiderChart.
     * @param   pointShape  Shape of points for SpiderSeries. Defaults to PointShape.Circle
     *
     * @returns             SpiderSeries instance
     */
    addSeries(pointShape?: PointShape): SpiderSeries;
    /**
     * Get number of series inside chart.
     * @return Amount of series inside chart
     */
    getSeriesCount(): number;
    /**
     * Get series of a chart
     * @return  series
     */
    getSeries(): SpiderSeries[];
    /**
     * Set mode of SpiderCharts web and background.
     * @param   webMode     Enum SpiderWebMode
     * @return              Object itself
     */
    setWebMode(webMode: SpiderWebMode): this;
    /**
     * Get mode of SpiderCharts web and background.
     * @return              Enum SpiderWebMode
     */
    getWebMode(): SpiderWebMode;
    /**
     * Set count of 'webs' displayed.
     * @param   webCount    Count of web lines
     * @return              Object itself
     */
    setWebCount(webCount: number): this;
    /**
     * Get count of 'webs' displayed
     * @return              Count of web lines
     */
    getWebCount(): number;
    /**
     * Set style of spider charts webs as LineStyle.
     * @param   value   LineStyle object or mutator to modify existing one
     * @return          Object itself
     */
    setWebStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get fill style of web lines.
     * @return              LineStyle object
     */
    getWebStyle(): LineStyle;
    /**
     * Set fill style of scale labels.
     * @param   value   FillStyle object or mutator to modify existing one
     */
    setScaleLabelStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of scale labels.
     * @return              FillStyle object
     */
    getScaleLabelStyle(): FillStyle;
    /**
     * Set font of scale labels.
     * @param   value   FontSettings or mutator function for existing settings
     * @return          Object itself
     */
    setScaleLabelFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
    /**
     * Get font of scale labels.
     * @return          FontSettings
     */
    getScaleLabelFont(): FontSettings;
    /**
     * Set padding of scale labels.
     * @param   padding     Padding in pixels
     * @return              Object itself
     */
    setScaleLabelPadding(padding: pixel): this;
    /**
     * Get padding of scale labels.
     * @return              Padding in pixels
     */
    getScaleLabelPadding(): pixel;
    /**
     * Set strategy for drawing scale labels.
     * Defines on which positions labels are drawn and whether they are flipped or not.
     * @param   scaleLabelStrategy  SpiderScaleLabelStrategy or undefined to never show scale labels
     * @return                      Object itself
     */
    setScaleLabelStrategy(scaleLabelStrategy?: SpiderScaleLabelStrategy): this;
    /**
     * Set strategy for formatting scale labels.
     *
     * ```javascript
     *  chart.setScaleLabelFormatter((value) => `${value} km`)
     * ```
     * @param   formatter           cb function that formats the values of scale
     * @return                      Object itself
     */
    setScaleLabelFormatter(formatter: (value: number) => string): this;
    /**
     * Set fill style of axis labels.
     * @param   value   FillStyle object or mutator to modify existing one
     * @return                      Object itself
     */
    setAxisLabelStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of axis labels.
     * @return              FillStyle object
     */
    getAxisLabelStyle(): FillStyle;
    /**
     * Set font of axis labels.
     * @param   value   FontSettings or mutator function for existing settings
     * @return          Object itself
     */
    setAxisLabelFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
    /**
     * Get font of axis labels.
     * @return          FontSettings object
     */
    getAxisLabelFont(): FontSettings;
    /**
     * Set padding of axis labels.
     * NOTE: The value of this padding is simply passed to the axis label strategy of chart,
     * so overriding the default strategy will naturally leave the handling of padding logic up to you.
     * @param   padding     Padding in pixels
     * @return              Object itself
     */
    setAxisLabelPadding(padding: pixel): this;
    /**
     * Get padding of axis labels.
     * NOTE: The value of this padding is simply passed to the axis label strategy of chart,
     * so overriding the default strategy will naturally leave the handling of padding logic up to you.
     * @return              Padding in pixels
     */
    getAxisLabelPadding(): pixel;
    /**
     * Set strategy for drawing axis labels.
     * Defines how axis labels are aligned.
     * @param   axisLabelStrategy   SpiderAxisLabelStrategy or undefined to never show axis labels
     * @return                      Object itself
     */
    setAxisLabelStrategy(axisLabelStrategy?: SpiderAxisLabelStrategy): this;
    /**
     * Set style of axes as SolidLine.
     * @param   value       SolidLine object or mutator to modify existing one
     * @return              Object itself
     */
    setAxisStyle(value: SolidLine | ImmutableMutator<SolidLine>): this;
    /**
     * Get style of axes as SolidLine.
     * @return              SolidLine object
     */
    getAxisStyle(): SolidLine;
    /**
     * Set style of axis nibs as SolidLine.
     * @param   value       SolidLine object or mutator to modify existing one
     * @return              Object itself
     */
    setNibStyle(value: SolidLine | ImmutableMutator<SolidLine>): this;
    /**
     * Get style of axis nibs as SolidLine.
     * @return              SolidLine object
     */
    getNibStyle(): SolidLine;
    /**
     * Set length of axis nibs in pixels.
     * @param   length      Sum length of nibs in pixels (both directions)
     */
    setNibLength(length: number): this;
    /**
     * Get length of axis nibs in pixels.
     * @return              Length of nibs in pixels
     */
    getNibLength(): number;
    /**
     * Specifies if auto creation of axis is turned on or not
     * @param   createAxesAutomatically     State of automatic axis creation
     * @returns                             Object itself for fluent interface
     */
    setAutoAxis(createAxesAutomatically: boolean): this;
    /**
     * @return Automatic axis creation state
     */
    getAutoAxis(): boolean;
    /**
     * Sets if animations are enabled or not
     */
    setAnimationsEnabled(animationsEnabled: boolean): this;
    /**
     * Gets if animations are enabled or not
     */
    getAnimationsEnabled(): boolean;
    /**
     * Disable all animations for the chart.
     *
     * All animations have to be re-enabled individually if you wish to re-enable animations.
     * @return      Chart itself for fluent interface.
     * @deprecated  Deprecated in v3.1.0. Will be removed in v4.0.0. Use [[setAnimationsEnabled]] instead.
     */
    disableAnimations(): this;
    /**
     * Set if mouse-interactions on chart are enabled or not
     * @param   enabled     Boolean flag
     * @return              Object itself
     */
    setMouseInteractions(enabled: boolean): this;
    /**
     * Get are mouse-interactions on chart enabled or not
     * @return              Boolean flag
     */
    getMouseInteractions(): boolean;
    /**
     * Sets the AxisScrollStrategy of Charts Axes
     * @param scrollStrategy    AxisScrollStrategy or undefined to disable automatic scrolling.
     *                          See [[AxisScrollStrategies]] for a collection of options.
     * @returns                 Object itself
     */
    setAxisScrollStrategy(scrollStrategy?: AxisScrollStrategy): this;
    /**
     * Gets the AxisScrollStrategy of Charts Axes
     */
    getAxisScrollStrategy(): AxisScrollStrategy | undefined;
    /**
     * Set interval of Charts Axes
     * @param   edge    Value at edges of chart
     * @param   center  Value at center of chart. Defaults to zero
     * @return          Object itself
     */
    setAxisInterval(edge: number, center?: number): this;
    /**
     * Get axis value at center of chart
     * @return          Value at center of chart
     */
    getOriginValue(): number;
    /**
     * Get axis value at edges of chart
     * @return          Value at edges of chart
     */
    getEdgeValue(): number;
    /**
     * **Permanently** dispose the component.
     *
     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
     * **to the component and its children** in application code.
     * ```javascript
     * let chart = ...ChartXY()
     * let axisX = chart.getDefaultAxisX()
     * // Dispose Chart, and remove all references so that they can be garbage-collected.
     * chart.dispose()
     * chart = undefined
     * axisX = undefined
     * ```
     * @return  Object itself for fluent interface
     */
    dispose(): this;
    /**
     * Get minimum size of Panel.
     * Depending on the type of class this value might be automatically computed to fit different elements.
     * @return  Vec2 minimum size or undefined if unimplemented
     */
    getMinimumSize(): Point | undefined;
}
/**
 * Interface for a function which builds ResultTable content when pointing at a SpiderSeries.
 * @param   tableContentBuilder     Builder that is used to build contents of ResultTable.
 *                                  Use addRow() method for adding content.
 * @param   series                  SpiderSeries
 * @param   value                   Value along axis
 * @param   axis                    Name of axis
 * @param   formatValue             Formating function for values along axis
 * @return                          TableContentBuilder that was supplied
 */
export declare type SpiderSeriesFormatter = <T extends TableContentBuilder>(tableContentBuilder: T, series: SpiderSeries, value: number, axis: string, formatValue: (value: number) => string) => T;
/**
 * Interface for data-structure that is used to pass data-points to SpiderSeries.
 */
export interface SpiderPoint {
    /**
     * Name of Axis in SpiderChart.
     */
    axis: string;
    /**
     * Numeric data value.
     */
    value: number;
}
/**
 * Type of visual plotted by SpiderSeries.
 * @hidden
 */
export declare type SpiderChartVisual = Polygon | PointSet;
/**
 * Class that represents a collection of linked data-points inside a [[SpiderChart]].
 *
 * Given data is visualized in the form of a *polygon*, where each [[SpiderPoint]] is an edge
 * along an *Axis*. This *polygon* can be styled with 3 independent areas:
 * - fill
 * - border
 * - points
 *
 * Data is pushed with [[SpiderSeries.addPoints]] in form: **{ axis: string, value: number }**
 */
export declare class SpiderSeries extends Series2D<SpiderChartVisual> implements Pointed {
    readonly scale: LinearScaleXY;
    /**
     * Adds an arbitrary amount of SpiderPoints to the Series.
     *
     * Animates transition if its enabled on owning chart.
     * @param   points  List of SpiderPoints as {'axis': string, 'value': number}
     * @returns         Object itself
     */
    addPoints(...points: SpiderPoint[]): this;
    /**
     * Returns the respective value of a data-point with the given tag (if any)
     * @param   animated    If set to true, will take series animating into account for result
     */
    getValue(tag: string, animated?: boolean): number | undefined;
    /**
     * Set animation for adding points.
     * @param   easing      Type of easing for animation or undefined to disable animations
     * @param   duration    Custom duration for animation in milliseconds.
     * @return              Object itself
     */
    setAnimationAddPoints(easing?: AnimationEasing, duration?: number): this;
    /**
     * Set animation for disabling/enabling series.
     * @param   easing      Type of easing for animation or undefined to disable animations
     * @param   duration    Custom duration for animation in milliseconds.
     * @return              Object itself
     */
    setDisposeAnimation(easing?: AnimationEasing, duration?: number): this;
    /**
     * Configure formatting of *Cursor ResultTable* when pointing at this *series*.
     *
     * ```typescript
     *  // Example usage
     *  SpiderSeries.setCursorResultTableFormatter((tableBuilder, series, value, axis) => {
     *      return tableBuilder
     *          .addRow(`Pointing at`, '', series.getName())
     *          .addRow(`Category:`, '', axis)
     *          .addRow(`Value:`, '', value.toFixed(1))
     *  })
     * ```
     *
     * The general syntax of configuring *ResultTable* formatting is shared between all *series* types;
     * You specify a callback function, which receives a [[TableContentBuilder]]. The contents of the table are then set using methods of the *table builder*:
     *
     * ```typescript
     *  // Using TableContentBuilder.
     *  SpiderSeries.setCursorResultTableFormatter((tableBuilder, series, value, axis) => {
     *      // addRow adds a list of strings to a new row in the table. Empty strings ('') will allocate any extra horizontal space within the row.
     *      tableBuilder
     *          .addRow('Item 0:', '', 'Value 0')
     *          .addRow('Item 1:', '', 'Value 1')
     *          .addRow('Long row that highlights the idea of empty strings')
     *
     *      // After configuration, the table builder must be returned!
     *      return tableBuilder
     *  })
     * ````
     *
     * The additional values that are supplied to the callback function vary between different chart types,
     * refer to the *series* documentation of `setCursorResultTableFormatter` to learn the exact available information.
     * All `Spider Series` receive three extra parameters:
     * 1. `series` | reference to the series itself.
     * 2. `value` | pointed data point value.
     * 3. `axis` | pointed data point category (name of spider axis).
     *
     * **Related API:**
     *
     * - [[setCursorEnabled]] | configure whether *cursors* should pick on this particular *series* or not.
     * - [[SpiderChart.setAutoCursorMode]] | configure behavior when auto cursor is visible.
     *
     * @param   formatter   Function which builds *ResultTable* content.
     * @return              Object itself
     */
    setCursorResultTableFormatter(formatter: SpiderSeriesFormatter): this;
    /**
     * Get ResultTable Formatter.
     * @return  Function which builds ResultTable content for SpiderSeries.
     */
    getCursorResultTableFormatter(): SpiderSeriesFormatter;
    /**
     * Set fill style of the Polygon that represents the shape of the Series.
     *
     * Example use:
     *```javascript
     * // Create a new style
     * SpiderSeries.setFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Change transparency
     * SpiderSeries.setFillStyle((solidFill) => solidFill.setA(80))
     * // Set hidden
     * SpiderSeries.setFillStyle(emptyFill)
     * ```
     *
     * @param value  FillStyle which has to be used for recoloring or mutator to modify existing one.
     * @returns      Series itself for fluent interface.
     */
    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * @return  Current series fill style
     */
    getFillStyle(): FillStyle;
    /**
     * Set fill style of the highlighted Polygon that represents the shape of the Series.
     *
     * Example use:
     *```javascript
     * // Create a new style
     * SpiderSeries.setFillStyleHighlight(new SolidFill({ color: ColorHEX('#F00') }))
     * // Change transparency
     * SpiderSeries.setFillStyleHighlight((solidFill) => solidFill.setA(80))
     * // Set hidden
     * SpiderSeries.setFillStyleHighlight(emptyFill)
     * // Automatic
     * SpiderSeries.setFillStyleHighlight(undefined)
     * ```
     *
     * @param value  FillStyle which has to be used for recoloring or mutator to modify existing one.
     * @returns      Series itself for fluent interface.
     */
    setFillStyleHighlight(value: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * Gets the highlighted fillStyle of the Polygon that represents the shape of this Series
     */
    getFillStyleHighlight(): FillStyle | undefined;
    /**
     * Set stroke style of the Polygon that represents the shape of the Series.
     *
     * Example usage:
     *```javascript
     * // Specified LineStyle
     * SpiderSeries.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * SpiderSeries.setStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden
     * SpiderSeries.setStrokeStyle(emptyLine)
     * ```
     * @param   value        Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
     * @returns              Chart itself
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Gets the stroke style of the Polygon that represents the shape of this Series
     */
    getStrokeStyle(): LineStyle;
    /**
     * Set stroke style of the highlighted Polygon that represents the shape of the Series.
     * Highlighting is activated by placing mouse on top / touching Series (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     *
     * Example usage:
     *```javascript
     * // Specified LineStyle
     * SpiderSeries.setStrokeStyleHighlight(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * SpiderSeries.setStrokeStyleHighlight((solidLine) => solidLine.setThickness(5))
     * // Hidden
     * SpiderSeries.setStrokeStyleHighlight(emptyLine)
     * // Automatic
     * SpiderSeries.setStrokeStyleHighlight(undefined)
     * ```
     * @param   value       Either a SolidLine object or a function, which will be used to modify current value.
     * @returns             Chart itself
     */
    setStrokeStyleHighlight(value: LineStyle | ImmutableMutator<LineStyle> | undefined): this;
    /**
     * Get stroke style of highlighted polygon.
     * @return              LineStyle or undefined for auto assignment
     */
    getStrokeStyleHighlight(): LineStyle | undefined;
    /**
     * Set point fill style of Series.
     * Use [[IndividualPointFill]] object to enable individual coloring of points.
     *
     * Example usage:
     *```javascript
     * // Create a new style
     * SpiderSeries.setPointFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Change transparency
     * SpiderSeries.setPointFillStyle((solidFill) => solidFill.setA(80))
     * // Set hidden
     * SpiderSeries.setPointFillStyle(emptyFill)
     * ```
     *
     * @param fillStyle     FillStyle which has to be used for recoloring or mutator to modify existing one.
     * @returns             Series itself for fluent interface.
     */
    setPointFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * @return  Current point fill style
     */
    getPointFillStyle(): FillStyle;
    /**
     * Set point fill style of Series when it is highlighted.
     *
     * Example usage:
     *```javascript
     * // Create a new style
     * SpiderSeries.setPointFillStyleHighlight(new SolidFill({ color: ColorHEX('#F00') }))
     * // Change transparency
     * SpiderSeries.setPointFillStyleHighlight((solidFill) => solidFill.setA(80))
     * // Set hidden
     * SpiderSeries.setPointFillStyleHighlight(emptyFill)
     * // Automatic
     * SpiderSeries.setPointFillStyleHighlight(undefined)
     * ```
     * @param value FillStyle which has to be used during highlighting or mutator to modify existing one or undefined for auto.
     * @returns     Series itself for fluent interface.
     */
    setPointFillStyleHighlight(fillStyle: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * @return  Current highlight point fill style
     */
    getPointFillStyleHighlight(): FillStyle | undefined;
    /**
     * Set size of point in pixels
     * @param   size    Size of point in pixels
     * @returns         Object itself for fluent interface
     */
    setPointSize(size: number): this;
    /**
     * @returns Size of point in pixels
     */
    getPointSize(): number;
    /**
     * Get shape of points.
     *
     * This is defined upon creation of series, and cannot be changed afterwards.
     * @returns PointShape
     */
    getPointShape(): PointShape;
    /**
     * Set the rotation of points in degrees.
     * @param angle Rotation angle in degrees
     */
    setPointRotation(angle: number): this;
    /**
     * Get the current rotation of points.
     */
    getPointRotation(): number;
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Series itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick?: boolean): this;
    /**
     * Solves the nearest datapoint to a given coordinate on screen.
     * @param   location    Location on screen
     * @return              Undefined or data-structure for positioning of cursors
     */
    solveNearestFromScreen(location: Point): undefined | CursorPoint;
    /**
     * Solves the nearest datapoint to a given coordinate on a screen from a specific segment.
     * @param   location    Location on screen
     * @param   segment     Segment to solve from
     * @return              Undefined or data-structure for positioning of cursors
     */
    solveNearestFromSegment(location: Point): undefined | CursorPoint;
    /**
     * Enable or disable the series
     * @param enabled True for enabled and false for disabled
     * @returns       Series itself for fluent interface
     */
    dispose(): this;
    /**
     * Enable or disable the series
     * @param enabled True for enabled and false for disabled
     * @returns       Series itself for fluent interface
     */
    restore(): this;
    /**
     * Enable or disable forced highlighting of series
     * @param highLight True for enabled and false for disabled
     * @returns         Series itself for fluent interface
     */
    setHighlighted(highLight: boolean): this;
}
/**
 * Enum for selecting shape of [[SpiderChart]] "webs" - background, GridStrokes and nibs.
 *
 * Use with [[SpiderChart.setWebMode]]
 */
export declare enum SpiderWebMode {
    /**
     * Traditional Spider Chart with non-curved edges.
     */
    Normal = 0,
    /**
     * Background, GridStrokes and nibs will be drawn circular.
     */
    Circle = 1
}
/**
 * Includes the so-called "BasicSeries"
 * Which is a XY-Series that relies on ShapeSet's as its segments.
 * Extends to CurveSeries, PointSeries and their combination PointLineSeries
 *
 */
/**
 * Interface for a function which builds ResultTable content when pointing at a SeriesXY.
 * @param   tableContentBuilder     Builder that is used to build contents of ResultTable.
 *                                  Use addRow() method for adding content.
 * @param   series                  SeriesXY
 * @param   x                       X coordinate
 * @param   y                       Y coordinate
 * @param   dataPoint               The pointed data point. Contains `x`, `y` as well as any additional information that user supplied.
 * @return                          TableContentBuilder that was supplied
 */
export declare type SeriesXYFormatter = <T extends TableContentBuilder>(tableContentBuilder: T, series: SeriesXY, x: number, y: number, dataPoint: Point) => T;
/**
 * Type requirement for Shapes which are used to render a SeriesXY.
 * @hidden
 */
export declare type BasicChartVisual = ChartVisual & Region & Shape;
/**
 * Type requirement for Shapes which are used to render a BasicSeries and implements ShapeSet interface.
 * @hidden
 */
export declare type BasicChartVisualShapeSet = BasicChartVisual & DataSet<Point[]>;
/**
 * The class implements the most part of logic general for point and line series
 * @typeparam   InputType           Implementations should use Point here if they only accept Points, otherwise pass
 *                                  ONLY the additionally supported input type. For example, PointSeries will give "ColorPoint".
 *
 * @hidden      Internal class
 */
export declare abstract class BasicSeries<VisualType extends BasicChartVisualShapeSet = BasicChartVisualShapeSet, InputType extends Point = Point, ScaleType extends ScaleXY = ScaleXY> extends SeriesXY<VisualType, CursorPoint, ScaleType> implements DataInputXY, DataInput, DataInputX, DataInputY, ObservableXYData<Point>, SeriesWithDataCleaning {
    protected readonly _dataPattern: DeprecatedDataPatternInterface;
    /**
     * @param chart                 Owning Chart
     * @param _removeFromChart      Handler for removing reference to series from owning chart
     * @param _restoreFromChart     Handler for restoring reference to series from owning chart
     * @param _layer                Rendering layer
     * @param xAxis                 Axis X
     * @param yAxis                 Axis Y
     * @param xAxisAttachHandler    Attach handler for Axis X
     * @param yAxisAttachHandler    Attach handler for Axis Y
     * @param _newUILayer           Factory for creating new UI layers for drawing SeriesMarkers
     * @param _dataPattern          Data-Pattern for enabling case-specific optimizations
     * @param _theme                Theme from owning Chart, used for styling
     * @hidden
     */
    constructor(chart: ChartXY, _removeFromChart: RemoveHandler<ChartComponent>, _restoreFromChart: RestoreHandler<ChartComponent>, _layer: Layer2D, xAxis: Axis, yAxis: Axis, xAxisAttachHandler: AxisAttachHandler, yAxisAttachHandler: AxisAttachHandler, _newUILayer: () => Layer2D, _dataPattern: DeprecatedDataPatternInterface, _theme: Theme);
    /**
     * Disable automatic data cleaning.
     *
     * ```js
     *  // Example syntax, disable data cleaning.
     *  series.setDataCleaning(undefined)
     * ```
     *
     * @param   arg             Data cleaning configuration.
     * @return                  Object itself for fluent interface.
     */
    setDataCleaning(arg: undefined): this;
    /**
     * Enable automatic data cleaning by `minDataPointCount` configuration.
     *
     * Specifying `minDataPointCount` enables _lazy_ cleaning of data that is **outside view** as long as the remaining data amount doesn't go below the configured threshold.
     *
     * ```js
     *  // Example syntax for specifying minDataPointCount
     *  series.setDataCleaning({ minDataPointCount: 10000 })
     * ```
     *
     * Usage of `minDataPointCount` is recommended in most common applications that require automatic data cleaning.
     * The actual value is often not very particular, just setting it above `0` to enable it is usually enough (lazy data cleaning of out of view data).
     *
     * ```js
     *  // Example, enable lazy data cleaning of out of view data.
     *  series.setDataCleaning({ minDataPointCount: 1 })
     * ```
     *
     * @param   arg             Data cleaning configuration.
     * @return                  Object itself for fluent interface.
     */
    setDataCleaning(arg: {
        minDataPointCount: number | undefined;
    }): this;
    /**
     * Append a single `XY` coordinate or list of `XY` coordinates into the *series*.
     *
     * ```ts
     *  // Example syntax
     *  LineSeries.add({ x: 0, y: 100 })
     *
     *  LineSeries.add([
     *      { x: 0, y: 100 },
     *      { x: 10, y: 50 },
     *      { x: 20, y: 75 },
     *  ])
     * ```
     *
     * For more methods of appending data into series, see:
     *
     * - [[addArrayY]] | Append only Y coordinates.
     * - [[addArrayX]] | Append only X coordinates.
     * - [[addArraysXY]] | Append X and Y coordinates in separate arrays.
     *
     * **Data gaps**
     *
     * When using [[LineSeries]], [[AreaSeries]] or other series types which connect data points together,
     * the connections between specific data points can be removed by adding gap data points.
     *
     * A gap data point is specified by using `Number.NaN` as either X or Y coordinate.
     *
     * ```ts
     *  // Example, data gap syntax.
     *  LineSeries.add([
     *      { x: 0, y: 10 },
     *      { x: 1, y: 12 },
     *      { x: 2, y: Number.NaN },
     *      { x: 3, y: 15 },
     *      { x: 4, y: 20 }
     *  ])
     * ```
     *
     * @param    points  Single XY coordinate or list of coordinates.
     * @returns          Object itself for fluent interface.
     */
    add(points: InputType | InputType[]): this;
    /**
     * Append new data points into the series by only supplying X coordinates.
     *
     * ```ts
     *  // Example syntax, number array
     *  LineSeries.addArrayX([ 5, 1, 2, 0 ])
     * ```
     *
     * This method supports binary data input by using *Typed arrays*.
     * If your data comes in any binary format, then using the typed array syntax is recommended for best performance.
     *
     * ```ts
     *  // Example syntax, typed array (Float32)
     *  const float32Array = new Float32Array(4)
     *  float32Array[0] = 5
     *  float32Array[1] = 1
     *  float32Array[2] = 2
     *  float32Array[3] = 0
     *  LineSeries.addArrayX(float32Array)
     * ```
     *
     * Each X coordinate will be paired with an automatically generated Y coordinate.
     *
     * By default, this continues from the last data point in the series.
     * However, the behavior of assigning Y coordinates can be controlled with the optional `step` and `start` parameters.
     *
     * For more methods of appending data into series, see:
     *
     * - [[add]] | Append XY coordinates.
     * - [[addArrayY]] | Append only Y coordinates.
     * - [[addArraysXY]] | Append X and Y coordinates in separate arrays.
     *
     * **Data gaps**
     *
     * When using [[LineSeries]], [[AreaSeries]] or other series types which connect data points together,
     * the connections between specific data points can be removed by adding gap data points.
     *
     * A gap data point is specified by using `Number.NaN`.
     *
     * ```ts
     *  // Example, data gap syntax.
     *  LineSeries.addArrayX([ 10, 12, Number.NaN, 15, 20 ])
     * ```
     *
     * @param   arrayX  Array of X-values.
     * @param   step    Optional step between each Y coordinate. Defaults to 1.
     * @param   start   Optional value for first generated Y-value. If undefined, will continue after last point's Y value in series,
     *                  or 0 if there are no points in series.
     * @return          Object itself for fluent interface.
     */
    addArrayX(arrayX: number[] | TypedArray, step?: number, start?: number): this;
    /**
     * Append new data points into the series by only supplying Y coordinates.
     *
     * ```ts
     *  // Example syntax, number array
     *  LineSeries.addArrayY([ 5, 1, 2, 0 ])
     * ```
     *
     * This method supports binary data input by using *Typed arrays*.
     * If your data comes in any binary format, then using the typed array syntax is recommended for best performance.
     *
     * ```ts
     *  // Example syntax, typed array (Float32)
     *  const float32Array = new Float32Array(4)
     *  float32Array[0] = 5
     *  float32Array[1] = 1
     *  float32Array[2] = 2
     *  float32Array[3] = 0
     *  LineSeries.addArrayY(float32Array)
     * ```
     *
     * Each Y coordinate will be paired with an automatically generated X coordinate.
     *
     * By default, this continues from the last data point in the series.
     * However, the behavior of assigning X coordinates can be controlled with the optional `step` and `start` parameters.
     *
     * For more methods of appending data into series, see:
     *
     * - [[add]] | Append XY coordinates.
     * - [[addArrayX]] | Append only X coordinates.
     * - [[addArraysXY]] | Append X and Y coordinates in separate arrays.
     *
     * **Data gaps**
     *
     * When using [[LineSeries]], [[AreaSeries]] or other series types which connect data points together,
     * the connections between specific data points can be removed by adding gap data points.
     *
     * A gap data point is specified by using `Number.NaN`.
     *
     * ```ts
     *  // Example, data gap syntax.
     *  LineSeries.addArrayY([ 10, 12, Number.NaN, 15, 20 ])
     * ```
     *
     * @param   arrayY  Array of Y-values.
     * @param   step    Optional step between each X coordinate. Defaults to 1.
     * @param   start   Optional value for first generated X-value. If undefined, will continue after last point's X value in series,
     *                  or 0 if there are no points in series.
     * @return          Object itself for fluent interface.
     */
    addArrayY(arrayY: number[] | TypedArray, step?: number, start?: number): this;
    /**
     * Append new data points into the series by supplying X and Y coordinates in two separated arrays.
     *
     * ```ts
     *  // Example syntax, number array
     *  LineSeries.addArraysXY([0, 1, 2, 3], [ 5, 1, 2, 0 ])
     * ```
     *
     * This method supports binary data input by using *Typed arrays*.
     * If your data comes in any binary format, then using the typed array syntax is recommended for best performance.
     *
     * ```ts
     *  // Example syntax, typed array (Float32)
     *  const float32Array = new Float32Array(4)
     *  float32Array[0] = 5
     *  float32Array[1] = 1
     *  float32Array[2] = 2
     *  float32Array[3] = 0
     *  LineSeries.addArraysXY([0, 1, 2, 3], float32Array)
     * ```
     *
     * For more methods of appending data into series, see:
     *
     * - [[add]] | Append XY coordinates.
     * - [[addArrayX]] | Append only X coordinates.
     * - [[addArrayY]] | Append only Y coordinates.
     *
     * **Data gaps**
     *
     * When using [[LineSeries]], [[AreaSeries]] or other series types which connect data points together,
     * the connections between specific data points can be removed by adding gap data points.
     *
     * A gap data point is specified by using `Number.NaN`.
     *
     * ```ts
     *  // Example, data gap syntax.
     *  LineSeries.addArraysXY(
     *      [ 0, 1, 2, 3, 4 ],
     *      [ 10, 12, Number.NaN, 15, 20 ]
     *  )
     * ```
     *
     * @param   arrayX  Array of X-values.
     * @param   arrayY  Array of Y-values. Length should be equal to length of *arrayX*.
     * @return          Object itself for fluent interface.
     */
    addArraysXY(arrayX: number[] | TypedArray, arrayY: number[] | TypedArray): this;
    /**
     * Configure formatting of *Cursor ResultTable* when pointing at this *series*.
     *
     * ```typescript
     *  // Example usage
     *  LineSeries.setCursorResultTableFormatter((tableBuilder, series, x, y, dataPoint) => {
     *      return tableBuilder
     *          .addRow(`Pointing at`, '', series.getName())
     *          .addRow(`X:`, '', dataPoint.x.toFixed(1))
     *          .addRow(`Y:`, '', dataPoint.y.toFixed(1))
     *  })
     * ```
     *
     * The general syntax of configuring *ResultTable* formatting is shared between all *series* types;
     * You specify a callback function, which receives a [[TableContentBuilder]]. The contents of the table are then set using methods of the *table builder*:
     *
     * ```typescript
     *  // Using TableContentBuilder.
     *  LineSeries.setCursorResultTableFormatter((tableBuilder, series, x, y) => {
     *      // addRow adds a list of strings to a new row in the table. Empty strings ('') will allocate any extra horizontal space within the row.
     *      tableBuilder
     *          .addRow('Item 0:', '', 'Value 0')
     *          .addRow('Item 1:', '', 'Value 1')
     *          .addRow('Long row that highlights the idea of empty strings')
     *
     *      // After configuration, the table builder must be returned!
     *      return tableBuilder
     *  })
     * ````
     *
     * Default Axis formatting can be referenced by using [[Axis.formatValue]] method.
     *
     * The additional values that are supplied to the callback function, **vary per series**,
     * refer to the *series* documentation of `setCursorResultTableFormatter` to learn the exact available information.
     * For example, `LineSeries` receives three extra parameters:
     * 1. `series` | reference to the series itself.
     * 2. `x` | pointed data point X coordinate.
     * 3. `y` | pointed data point Y coordinate.
     * 4. `dataPoint` | reference to the pointed data point as supplied by user.
     *
     * **Related API:**
     *
     * - [[setCursorEnabled]] | configure whether *cursors* should pick on this particular *series* or not.
     * - [[setCursorInterpolationEnabled]] | configure whether cursor interpolates solved data-points.
     * - [[setCursorSolveBasis]] | configure basis of finding nearest data point for the series (`'nearest-x'`, `'nearest'`, etc.).
     * - [[ChartXY.setAutoCursorMode]] | configure behavior when auto cursor is visible.
     *
     * @param   formatter   Function which builds *ResultTable* content.
     * @return              Object itself
     */
    setCursorResultTableFormatter(formatter: SeriesXYFormatter): this;
    /**
     * Get ResultTable Formatter.
     * @return  Function which builds ResultTable content for SeriesXY.
     */
    getCursorResultTableFormatter(): SeriesXYFormatter;
    /**
     * Configure automatic *data cleaning* by `maxPointCount`.
     * This allows the cleaning of all excess data points that are outside view, so that after cleaning at least `maxPointCount`
     * data points are retained.
     * Essentially it configures the *head length* of a series.
     *
     * ```ts
     *  // Example, progressive X line series with automatic data cleaning.
     *  const series = ChartXY.addLineSeries({
     *      dataPattern: {
     *          pattern: 'ProgressiveX'
     *      }
     *  })
     *      // Keep at least 1000 data points in series, otherwise excess out of view data can be cleaned for more memory.
     *      .setMaxPointCount(1000)
     *
     * // Setup automatically scrolling X Axis.
     * chart.getDefaultAxisX().setScrollStrategy(AxisScrollStrategies.progressive).setInterval(0, 1000)
     *
     *  // Continously stream data into series.
     *  let x = 0
     *  setInterval(() => {
     *      const newDataPoints = []
     *      for (let i = 0; i <= 10; i += 1) {
     *          newDataPoints.push({ x: x + i, y: Math.random() * 100 })
     *      }
     *      x += newDataPoints.length
     *      series.add(newDataPoints)
     *  }, 1000 / 60)
     * ```
     *
     * For *progressive* `Series`, there is another way to enable automatic *data cleaning*: [[setDataCleaningThreshold]].
     *
     * Enabling automatic *data cleaning* is crucial in applications that run for a long time, or even *forever*,
     * because it allows clearing memory for allocating new data points.
     *
     * @param   maxPointCount   Configuration for automatic *data cleaning* by `maxPointCount`.
     *                          If undefined or 0 is passed, automatic *data cleaning* by `maxPointCount` will be disabled.
     * @returns                 Object itself for fluent interface.
     * @deprecated              Will be removed in v4.0 in favour of [[setDataCleaning]].
     */
    setMaxPointCount(maxPointCount?: number): this;
    /**
     * Get amount of points that series should keep around at all times (data-cleaning won't touch them).
     * @return  Number of points, or undefined if data-cleaning is disabled
     * @deprecated              Will be removed in v4.0.
     */
    getMaxPointCount(): number | undefined;
    /**
     * Get amount of points that series currently has.
     * @return  Number of points
     */
    getPointAmount(): number;
    /**
     * Clear all previously pushed data points from the *series*.
     *
     * ```ts
     *  // Example usage
     *  LineSeries.clear()
     * ```
     *
     * @return      Object itself for fluent interface.
     */
    clear(): this;
    /**
     * @return Copy of last point added to the Series or undefined if it doesn't exist.
     */
    getLastPoint(): Point | undefined;
    /**
     * @return Max X value of the series or `0` if series has no data.
     */
    getXMax(): number;
    /**
     * @return Min X value of the series or `0` if series has no data.
     */
    getXMin(): number;
    /**
     * @return Max Y value of the series or `0` if series has no data.
     */
    getYMax(): number;
    /**
     * @return Min Y value of the series or `0` if series has no data.
     */
    getYMin(): number;
}
/**
 * Axis positioning Enum
 * @hidden
 */
export declare enum AxisPosition {
    Top = 0,
    Bottom = 1,
    Left = 2,
    Right = 3
}
/**
 * Type of Axis attach handler.
 * Essentially this is a more advanced Restore-handler, for handling case with 3-way-dispose/restore-relationship (chart,axis,series).
 * TODO: Should be unified with rest of dispose/restore system somehow.
 * @hidden
 */
export declare type AxisAttachHandler = (series: SeriesXY) => (series: SeriesXY) => void;
/**
 * Interface for specifying Axis (XY) configurations that can't be changed after creation of the Axis.
 *
 * **Example usage**:
 *
 * - Configure default Y Axis of chart on opposite side to default configuration (right).
 *
 * ```typescript
 *  ChartXY({
 *      defaultAxisY: {
 *          opposite: true,
 *      }
 *  })
 * ```
 *
 * - Configure default X Axis of chart as logarithmic (10 base).
 *
 * ```typescript
 *  ChartXY({
 *      defaultAxisX: {
 *          type: 'logarithmic',
 *          base: 10,
 *      }
 *  })
 * ```
 *
 * - Configure newly created X Axis of chart as logarithmic (natural base).
 *
 * ```typescript
 *  ChartXY.addAxisX({
 *      type: 'logarithmic',
 *      base: 'natural',
 *  })
 * ```
 *
 * NOTE: Some series / features do not support all available non-default Axis types (logarithmic, high precision, ..).
 *
 * Additionally, there can be further limitations in combinations of two Axis types.
 * For example, as of now `logarithmic` and `linear-highPrecision` can't be combined as X + Y Axes.
 *
 * Refer to documentation of [[AxisOptions.type]] for detailed information.
 */
export interface AxisOptions {
    /**
     * Specify Axis position in chart.
     *
     * Default is bottom for X Axes, and left for Y Axes.
     *
     * Setting to `true` will result in the opposite side (top for X Axes, right for Y Axes).
     */
    opposite?: boolean;
    /**
     * Type of Axis.
     *
     * Each type section contains information about related Axis zooming limits,
     * as in constraints on the magnitude of Axis interval, which is calculated as `Math.abs(end - start)`.
     * When the limit is reached, the Axis will not be able to zoom in and out further by programmatic calls ([[Axis.setInterval]]) or user interactions.
     *
     * `linear`:
     *
     * Default Axis type. Same behavior as `type: undefined`.
     *
     * Achievable zoom range depends on the magnitude of Axis interval start;
     * Following table contains *reference values* on the achievable zoom ranges - in practice zoom range might be limited sooner or later.
     *
     * | Axis interval start | Min interval | Max interval |
     * | :------------------ | :----------- | :----------- |
     * | `0`                 | `1e-4`       | `1e+16`       |
     * | `100`               | `1e-2`       | `1e+16`       |
     * | `10 000`            | `1.00`       | `1e+16`       |
     * | `1 000 000`         | `100`        | `1e+16`       |
     * | `Date.now()` (UNIX) | `73600000`   | `1e+16`       |
     *
     * `logarithmic`:
     *
     * Logarithmic Axis. By default base number will be `10`.
     *
     * With Logarithmic Axis, **range must always start above 0!** (log is not defined at 0).
     *
     * NOTE: Not all series types support logarithmic axes! Attaching a non-supported Series will crash the application.
     *
     * List of series that support logarithmic Axes:
     * - [[LineSeries]]
     * - [[PointSeries]]
     * - [[PointLineSeries]]
     * - [[StepSeries]]
     * - [[SplineSeries]]
     * - [[AreaSeries]]
     * - [[AreaRangeSeries]]
     * - [[OHLCSeries]] (Y Axis can be logarithmic, but not X Axis)
     * - [[RectangleSeries]]
     * - [[SegmentSeries]]
     *
     * List of series that do **not** support logarithmic Axes:
     * - [[IntensitySeries]]
     * - [[PolygonSeries]]
     *
     * As of yet `logarithmic` and `linear-highPrecision` can't be combined as X + Y Axes.
     *
     * `linear-highPrecision`:
     *
     * Behaves otherwise similarly as `linear`, but zoom range is significantly improved, with the drawback of a considerable performance drop.
     *
     * Achievable zoom range depends on the magnitude of Axis interval start;
     * Following table contains *reference values* on the achievable zoom ranges - in practice zoom range might be limited sooner or later.
     *
     * | Axis interval start | Min interval | Max interval |
     * | :------------------ | :----------- | :----------- |
     * | `0`                 | `1e-12`      | `1e+30`      |
     * | `100`               | `1e-10`      | `1e+30`      |
     * | `10 000`            | `1e-8`       | `1e+30`      |
     * | `1 000 000`         | `1e-6`       | `1e+30`      |
     * | `Date.now()` (UNIX) | `1.00`       | `1e+30`      |
     *
     * NOTE: Not all series types support high precision axes! Attaching a non-supported Series will crash the application.
     *
     * List of series that support high precision Axes:
     * - [[LineSeries]]
     * - [[PointSeries]]
     * - [[PointLineSeries]]
     * - [[StepSeries]]
     * - [[SplineSeries]]
     * - [[AreaSeries]]
     * - [[AreaRangeSeries]]
     * - [[OHLCSeries]]
     * - [[RectangleSeries]]
     * - [[SegmentSeries]]
     *
     * List of series that do **not** support high precision Axes:
     * - [[HeatmapGridSeries]]
     * - [[IntensitySeries]]
     *
     * As of yet `logarithmic` and `linear-highPrecision` can't be combined as X + Y Axes.
     *
     * **High precision Axis is an experimental feature**, which means that it can be significantly altered in minor version releases.
     */
    type?: 'linear' | 'logarithmic' | 'linear-highPrecision';
    /**
     * Specification of Logarithmic Base number (e.g. 10, 2, natural log).
     *
     * Defaults to 10 if omitted.
     *
     * Examples:
     *
     * - `10` | powers of ten (1, 10, 100, 1000, 10000, ...).
     * - `e`  | natural logarithm (1e, 2e, 3e, 4e, ...)
     *
     * `type` must be set to `'logarithmic'` for this to effect!
     */
    base?: number | 'E' | 'e' | 'natural';
}
/**
 * Interface for readonly configuration of [ChartXY](../classes/chartxy.html).
 *
 * Some properties of `ChartXY` can only be configured when it is created. These arguments are all optional, and are wrapped in a single object parameter:
 *
 * ```typescript
 *  // Example, configure default X Axis.
 *  const chart = LightningChart.ChartXY({
 *      defaultAxisX: {
 *          type: 'linear',
 *      }
 *  })
 * ```
 *
 * *Watch out!* The full set of available readonly configuration parameters depends on if the chart is *standalone*, or inside a *dashboard*:
 *
 * For *standalone* `ChartXY`, more parameters are documented in [[LightningChart.ChartXY]].
 *
 * For *dashboard* `ChartXY`, more parameters are documented in [[Dashboard.createChartXY]].
 *
 *
 * **Commonly used properties:**
 *
 * - [[ChartXYOptions.theme]]: Specify chart color *theme*.
 * - [[ChartXYOptions.disableAnimations]]: Convenience flag to disable all animations from chart.
 * - [[ChartXYOptions.defaultAxisX]]: Configure default X Axis.
 * - [[ChartXYOptions.defaultAxisY]]: Configure default Y Axis.
 *
 * **Example usage:**
 *
 * ```typescript
 *  // Example 1, create chart with default configuration.
 *  const chart = LightningChart.ChartXY({})
 * ```
 *
 * ```typescript
 *  // Example 2, create chart with specified color theme.
 *  const chart = LightningChart.ChartXY({
 *      theme: Themes.light,
 *  })
 * ```
 *
 * ```typescript
 *  // Example 3, create chart with specified default axis configurations.
 *  const chart = LightningChart.ChartXY({
 *      defaultAxisX: {
 *          type: 'linear',
 *      },
 *      defaultAxisY: {
 *          type: 'logarithmic',
 *          base: 10,
 *      }
 *  })
 * ```
 */
export interface ChartXYOptions<CursorPointMarkerType extends PointMarker = PointMarker, CursorResultTableBackgroundType extends UIBackground = UIBackground> extends CommonChartOptions {
    /**
     * Builder for the charts' *auto cursor*. Use [[AutoCursorBuilders.XY]] to modify the default builder, using methods of [[AutoCursorXYBuilder]].
     *
     * ```typescript
     *  // Example, change cursor ResultTable background shape.
     *  const chart = LightningChart.ChartXY({
     *      autoCursorBuilder: AutoCursorBuilders.XY
     *          .setResultTableBackground(UIBackgrounds.Circle)
     *  })
     * ```
     */
    autoCursorBuilder?: AutoCursorXYBuilder<CursorPointMarkerType, CursorResultTableBackgroundType>;
    /**
     * Interface for specifying Axis X configurations that can't be changed after creation of the Axis.
     *
     * **Example usage**:
     *
     * - Configure default X Axis of chart on opposite side to default configuration (top).
     *
     * ```typescript
     *  ChartXY({
     *      defaultAxisX: {
     *          opposite: true,
     *      }
     *  })
     * ```
     *
     * - Configure default X Axis of chart as logarithmic (10 base).
     *
     * ```typescript
     *  ChartXY({
     *      defaultAxisX: {
     *          type: 'logarithmic',
     *          base: 10,
     *      }
     *  })
     * ```
     *
     * NOTE: Not all series types support logarithmic axes! Attaching a non-supported Series will crash the application.
     *
     * List of series that support logarithmic Axes:
     * - [[LineSeries]]
     * - [[PointSeries]]
     * - [[PointLineSeries]]
     * - [[StepSeries]]
     * - [[SplineSeries]]
     * - [[AreaSeries]]
     * - [[AreaRangeSeries]]
     * - [[OHLCSeries]] (Y Axis can be logarithmic, but not X Axis)
     * - [[RectangleSeries]]
     * - [[SegmentSeries]]
     *
     * List of series that do **not** support logarithmic Axes:
     * - [[IntensitySeries]]
     * - [[PolygonSeries]]
     */
    defaultAxisX?: AxisOptions;
    /**
     * Interface for specifying Axis Y configurations that can't be changed after creation of the Axis.
     *
     * **Example usage**:
     *
     * - Configure default Y Axis of chart on opposite side to default configuration (top).
     *
     * ```typescript
     *  ChartXY({
     *      defaultAxisY: {
     *          opposite: true,
     *      }
     *  })
     * ```
     *
     * - Configure default Y Axis of chart as logarithmic (10 base).
     *
     * ```typescript
     *  ChartXY({
     *      defaultAxisY: {
     *          type: 'logarithmic',
     *          base: 10,
     *      }
     *  })
     * ```
     *
     * NOTE: Not all series types support logarithmic axes! Attaching a non-supported Series will crash the application.
     *
     * List of series that support logarithmic Axes:
     * - [[LineSeries]]
     * - [[PointSeries]]
     * - [[PointLineSeries]]
     * - [[StepSeries]]
     * - [[SplineSeries]]
     * - [[AreaSeries]]
     * - [[AreaRangeSeries]]
     * - [[OHLCSeries]] (Y Axis can be logarithmic, but not X Axis)
     * - [[RectangleSeries]]
     * - [[SegmentSeries]]
     *
     * List of series that do **not** support logarithmic Axes:
     * - [[IntensitySeries]]
     * - [[PolygonSeries]]
     */
    defaultAxisY?: AxisOptions;
}
/**
 * Chart type for visualizing data between two dimensions, **X** and **Y**.
 * It has built-in *Axis* functionality, and supports a large set of *series* types.
 *
 * `ChartXY` can be created in two different ways - to learn more about creation time configuration of `ChartXY`, please refer to:
 * - [[LightningChart.ChartXY]] (stand-alone chart).
 * - [[Dashboard.createChartXY]] (chart inside *dashboard*).
 *
 * **ChartXY features**
 *
 * 1. Axes
 *
 * `ChartXY` always has at least one X and Y *axes*.
 *
 * The default `Axis` can be referenced with [[ChartXY.getDefaultAxisX]] and
 * [[ChartXY.getDefaultAxisY]].
 * See [[Axis]] for features of *axis*.
 *
 * `ChartXY` doesn't have a limit on number of *axes*.
 * Additional *axes* can be created with [[ChartXY.addAxisX]] and
 * [[ChartXY.addAxisY]].
 * Multiple *Axes* can be stacked on top of another, and *axes* can be positioned on either side of
 * the *chart* (left, right, top, bottom, see [[AxisOptions]]).
 *
 * 2. Series
 *
 * `ChartXY` supports a variety of different *series* types, each with their own method of data visualization.
 * *Series* are created with `ChartXY.add...Series` methods, for example:
 * - [[ChartXY.addLineSeries]]
 * - [[ChartXY.addPointSeries]]
 * - [[ChartXY.addHeatmapGridSeries]]
 * - [[ChartXY.addOHLCSeries]]
 *
 * When created, a *series* is always attached to a pair of *X* and *Y Axes*.
 * The *Axes* can be specified by user, or the *chart default Axes* will be used.
 *
 * 3. AutoCursor
 *
 * *Auto cursor* is activated when the users mouse is over the chart.
 * It automatically solves the nearest *data point* to the mouse, and displays it to the user over the chart in a *result table*.
 *
 * *Auto cursor* can be configured in a variety of ways;
 * on *chart level*, the cursor behavior and style can be specified using:
 * - [[ChartXY.setAutoCursorMode]] | set auto cursor behavior.
 * - [[ChartXY.setAutoCursor]] | style auto cursor.
 *
 * On *series level*, the cursor behavior can be configured individually for each *series*:
 * - [[LineSeries.setCursorEnabled]] | configure whether cursor should pick on the series or not.
 * - [[LineSeries.setCursorResultTableFormatter]] | configure formatting of *result table* contents, when this series is pointed.
 * - [[LineSeries.setCursorInterpolationEnabled]] | configure whether cursor should interpolate the displayed data point between the two closest data points, or snap to the nearest *real* data point.
 * - [[LineSeries.setCursorSolveBasis]] | configure basis of finding nearest data point for the series (`'nearest-x'`, `'nearest'`, etc.).
 *
 * 4. LegendBox
 *
 * `ChartXY` has built-in *legend box* functionality for listing the *series* names in a *user interface*.
 * The *legend box* also provides additional logic, like hiding selected *series* by clicking on the *legend box*,
 * and visualizing *color look-up tables* ([[LUT]]) in applications where they are used.
 *
 * *Legend box* is added using [[ChartXY.addLegendBox]].
 *
 * 5. Title
 *
 * `ChartXY` has a built-in *title* component, which can be configured using [[ChartXY.setTitle]].
 *
 * 6. Backgrounds
 *
 * `ChartXY` contains two separate *background* components:
 * - *Background* ([[ChartXY.setBackgroundFillStyle]]).
 * - *Series Background* ([[ChartXY.setSeriesBackgroundFillStyle]]).
 *
 * 7. UI Elements
 *
 * Custom *UI elements* can be placed on `ChartXY` in same way as all other *charts*, using [[ChartXY.addUIElement]].
 *
 * **Other APIs worthy of mention:**
 *
 * - Empty space around `ChartXY` can be configured with [[ChartXY.setPadding]].
 * - Additional vertical padding around *chart title* can be configured with [[ChartXY.setTitleMarginTop]] and [[ChartXY.setTitleMarginBottom]].
 * - All animations can be conveniently disabled with [[ChartXY.disableAnimations]].
 * - `ChartXY` can be removed permanently with [[ChartXY.dispose]].
 * - Some useful events that can be subscribed to:
 *      * *Resize events* ([[ChartXY.onResize]]).
 *      * *Background events* ([[ChartXY.onBackgroundMouseMove]]).
 *      * *Series Background events* ([[ChartXY.onSeriesBackgroundMouseMove]]).
 *
 */
export declare class ChartXY<CursorPointMarkerType extends PointMarker = PointMarker, CursorResultTableBackgroundType extends UIBackground = UIBackground> extends ChartWithCursor<SeriesXY, CursorPointMarkerType, CursorResultTableBackgroundType, AutoCursorXY<CursorPointMarkerType, CursorResultTableBackgroundType>> implements ChartWithScrollingAnimations, ChartWithZoomingAnimations, ChartWithAxis<Axis> {
    /**
     * @param   _lcjsOptions            LightningChart options
     * @param   layerSupplier           Rendering layer supplier
     * @param   scaleFactory            Scale factory.
     * @param   logoFactory             Flag for drawing LC logo
     * @param   removeChart 	        Injectable panel/chart remove method
     * @param   chartXYOptions          Settings union used to define ChartXY.
     * @param   resizeEventInterface    Injectable event interface for resizing Panel (used for dashboard)
     * @hidden
     */
    constructor(_lcjsOptions: InternalLightningChartOptions, layerSupplier: LayerSupplier, scaleFactory: ScaleFactory, removeChart: (chart: Panel) => void, logoFactory?: LogoFactory, chartXYOptions?: ChartXYOptions<CursorPointMarkerType, CursorResultTableBackgroundType>, resizeEventInterface?: DashboardResizeEventInterface);
    /**
     * Get minimum size of Panel.
     * Depending on the type of class this value might be automatically computed to fit different elements.
     * @return  Vec2 minimum size or undefined if unimplemented
     */
    getMinimumSize(): Point | undefined;
    /**
     * Get series of a chart
     * @return  series
     */
    getSeries(): SeriesXY[];
    /**
     * Create new XY Chart Marker to be rendered as part of UI.
     * @param   cursorBuilder   Optional StaticCursorBuilderXY to customize structure/style of chartMarker.
     *                          MarkerBuilders.XY can be used to build a custom one from scratch.
     * @param   axisX           Optional arbitrary X axis to attach ChartMarker on
     * @param   axisY           Optional arbitrary Y axis to attach ChartMarker on
     * @return                  Created ChartMarker
     */
    addChartMarkerXY<PointMarkerType extends PointMarker = PointMarker, ResultTableBackgroundType extends UIBackground = UIBackground>(cursorBuilder?: StaticCursorXYBuilder<PointMarkerType, ResultTableBackgroundType>, axisX?: Axis, axisY?: Axis): ChartMarkerXY<PointMarkerType, ResultTableBackgroundType>;
    /**
     * Add new *X Axis* to the *Chart*.
     *
     * **Example usage**:
     *
     * - Configure Axis on opposite side to default configuration (right).
     *
     * ```typescript
     *  ChartXY.addAxisX({
     *      opposite: true,
     *  })
     * ```
     *
     * - Configure Axis as logarithmic (10 base).
     *
     * ```typescript
     *  ChartXY.addAxisX({
     *      type: 'logarithmic',
     *      base: 10,
     *  })
     * ```
     *
     * - Configure Axis as logarithmic (natural base).
     *
     * ```typescript
     *  ChartXY.addAxisX({
     *      type: 'logarithmic',
     *      base: 'natural',
     *  })
     * ```
     *
     * NOTE: Not all series types support logarithmic axes! Attaching a non-supported Series will crash the application.
     *
     * List of series that support logarithmic Axes:
     * - [[LineSeries]]
     * - [[PointSeries]]
     * - [[PointLineSeries]]
     * - [[StepSeries]]
     * - [[SplineSeries]]
     * - [[AreaSeries]]
     * - [[AreaRangeSeries]]
     * - [[OHLCSeries]] (Y Axis can be logarithmic, but not X Axis)
     * - [[RectangleSeries]]
     * - [[SegmentSeries]]
     *
     * List of series that do **not** support logarithmic Axes:
     * - [[IntensitySeries]]
     * - [[PolygonSeries]]
     *
     * @param   opts    Optional [[AxisOptions]] object for specifying Axis configurations that can't be changed
     *                  during runtime.
     * @return          *Axis* object.
     */
    addAxisX(opts?: AxisOptions): Axis;
    /**
     * Add new *Y Axis* to the *Chart*.
     *
     * **Example usage**:
     *
     * - Configure Axis on opposite side to default configuration (right).
     *
     * ```typescript
     *  ChartXY.addAxisY({
     *      opposite: true,
     *  })
     * ```
     *
     * - Configure Axis as logarithmic (10 base).
     *
     * ```typescript
     *  ChartXY.addAxisY({
     *      type: 'logarithmic',
     *      base: 10,
     *  })
     * ```
     *
     * - Configure Axis as logarithmic (natural base).
     *
     * ```typescript
     *  ChartXY.addAxisY({
     *      type: 'logarithmic',
     *      base: 'natural',
     *  })
     * ```
     *
     * NOTE: Not all series types support logarithmic axes! Attaching a non-supported Series will crash the application.
     *
     * List of series that support logarithmic Axes:
     * - [[LineSeries]]
     * - [[PointSeries]]
     * - [[PointLineSeries]]
     * - [[StepSeries]]
     * - [[SplineSeries]]
     * - [[AreaSeries]]
     * - [[AreaRangeSeries]]
     * - [[OHLCSeries]] (Y Axis can be logarithmic, but not X Axis)
     * - [[RectangleSeries]]
     * - [[SegmentSeries]]
     *
     * List of series that do **not** support logarithmic Axes:
     * - [[IntensitySeries]]
     * - [[PolygonSeries]]
     *
     * @param   opts    Optional [[AxisOptions]] object for specifying Axis configurations that can't be changed
     *                  during runtime.
     * @return          *Axis* object.
     */
    addAxisY(opts?: AxisOptions): Axis;
    /**
     * **Permanently** dispose the component.
     *
     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
     * **to the component and its children** in application code.
     * ```javascript
     * let chart = ...ChartXY()
     * let axisX = chart.getDefaultAxisX()
     * // Dispose Chart, and remove all references so that they can be garbage-collected.
     * chart.dispose()
     * chart = undefined
     * axisX = undefined
     * ```
     * @return  Object itself for fluent interface
     */
    dispose(): this;
    /**
     * Get reference to the *default X Axis* of the `ChartXY`.
     *
     * This will always return reference to the *X Axis* that is closest to the chart (starting from bottom).
     * The user can safely destroy the *default Axis* (with [[Axis.dispose]], as long as there are no *series* attached to it).
     * @returns     Default X Axis of chart.
     */
    getDefaultAxisX(): Axis;
    /**
     * Get reference to the *default Y Axis* of the `ChartXY`.
     *
     * This will always return reference to the *Y Axis* that is closest to the chart (starting from left).
     * The user can safely destroy the *default Axis* (with [[Axis.dispose]], as long as there are no *series* attached to it).
     * @returns     Default Y Axis of chart.
     */
    getDefaultAxisY(): Axis;
    /**
     * Convenience method to get a tuple of the Charts default X and Y axes.
     *
     * Equal to `[ChartXY.getDefaultAxisX(), ChartXY.getDefaultAxisY()]`
     *
     * Intended for conveniently applying same modifications to both X and Y axes.
     *
     * ```typescript
     * // Example, disable mouse interactions from both default axes.
     * ChartXY.getDefaultAxes().forEach((axis) => axis.setMouseInteractions(false))
     * ```
     *
     * @returns     [chart.getDefaultAxisX(), chart.getDefaultAxisY()]
     */
    getDefaultAxes(): [Axis, Axis];
    /**
     * @param  axisPositions    array of axis positions which have to be included to the output
     *                          empty array indicates all of positions are included
     * @returns                 An array of axis
     */
    getAxes(...axisPositions: AxisPosition[]): Axis[];
    /**
     * Operate on each x axis of chart
     * @param   clbk    Callback function for axis
     */
    forEachAxisX(clbk: (axis: Axis, i: number, arr: Axis[]) => void): void;
    /**
     * Operate on each y axis of chart
     * @param   clbk    Callback function for axis
     */
    forEachAxisY(clbk: (axis: Axis, i: number, arr: Axis[]) => void): void;
    /**
     * Method for adding a new `LineSeries` to the chart. This series type visualizes a list of [[Point]]s (pair of X and Y coordinates),
     * with a continuous stroke. `LineSeries` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
     *
     * - A static data set in tens of millions range is rendered in a matter of seconds.
     * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
     *
     * To learn more about its features and usage, refer to [[LineSeries]].
     *
     * **Readonly configuration:**
     *
     * Some properties of `LineSeries` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example,
     *  const lineSeries = ChartXY.addLineSeries({
     *      // Specify non-default X Axis to attach series to.
     *      xAxis: myNonDefaultAxisX
     *  })
     * ```
     *
     * To learn about available properties, refer to [[LineSeriesOptions]].
     * @param   options         Optional object with readonly configuration arguments for `LineSeries`.
     * @return                  New series.
     */
    addLineSeries(options?: LineSeriesOptions): LineSeries;
    /**
     * Method for adding a new `PointSeries` to the chart. This series type visualizes a list of [[Point]]s (pair of X and Y coordinates),
     * with configurable *markers* over each coordinate. `PointSeries` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
     *
     * - A static data set in tens of millions range is rendered in a matter of seconds.
     * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
     *
     * To learn more about its features and usage, refer to [[PointSeries]].
     *
     * **Readonly configuration:**
     *
     * Some properties of `PointSeries` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example,
     *  const pointSeries = ChartXY.addPointSeries({
     *      // Specify non-default X Axis to attach series to.
     *      xAxis: myNonDefaultAxisX
     *  })
     * ```
     *
     * To learn about available properties, refer to [[PointSeriesOptions]].
     *
     * @param   options         Optional object with readonly configuration arguments for `PointSeries`.
     * @return                  New series.
     */
    addPointSeries(options?: PointSeriesOptions): PointSeries;
    /**
     * Method for adding a new `PointLineSeries` to the chart. This series type visualizes a list of [[Point]]s (pair of X and Y coordinates),
     * with a continuous stroke and configurable *markers* over each coordinate. `PointLineSeries` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
     *
     * - A static data set in tens of millions range is rendered in a matter of seconds.
     * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
     *
     * To learn more about its features and usage, refer to [[PointLineSeries]].
     *
     * **Readonly configuration:**
     *
     * Some properties of `PointLineSeries` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example,
     *  const pointLineSeries = ChartXY.addPointLineSeries({
     *      // Specify non-default X Axis to attach series to.
     *      xAxis: myNonDefaultAxisX
     *  })
     * ```
     *
     * To learn about available properties, refer to [[PointLineSeriesOptions]].
     *
     * @param   options         Optional object with readonly configuration arguments for `PointLineSeries`.
     * @return                  New series.
     */
    addPointLineSeries(options?: PointLineSeriesOptions): PointLineSeries;
    /**
     * Method for adding a new `StepSeries` to the chart. This series type visualizes a list of [[Point]]s (pair of X and Y coordinates),
     * with a *stepped* stroke + *point markers* over each data point.
     *
     * Possible *step* modes are: `'before'`, `'middle'` and `'after'`.
     *
     * To learn more about its features and usage, refer to [[StepSeries]].
     *
     * **Readonly configuration:**
     *
     * Some properties of `StepSeries` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example,
     *  const stepSeries = ChartXY.addStepSeries({
     *      // Select shape of point markers.
     *      pointShape: PointShape.Circle
     *  })
     * ```
     *
     * To learn about available properties, refer to [[StepSeriesOptions]].
     *
     * @param   options         Optional object with readonly configuration arguments for `StepSeries`.
     * @return                  New series.
     */
    addStepSeries(options?: StepSeriesOptions): StepSeries;
    /**
     * Method for adding a new `SplineSeries` to the chart. This series type visualizes a list of [[Point]]s (pair of X and Y coordinates),
     * with a smoothed curve stroke + *point markers* over each data point.
     *
     * To learn more about its features and usage, refer to [[SplineSeries]].
     *
     * **Readonly configuration:**
     *
     * Some properties of `SplineSeries` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example,
     *  const splineSeries = ChartXY.addSplineSeries({
     *      // Select shape of point markers.
     *      pointShape: PointShape.Circle
     *  })
     * ```
     *
     * To learn about available properties, refer to [[SplineSeriesOptions]].
     *
     * @param   options         Optional object with readonly configuration arguments for `SplineSeries`.
     * @return                  New series.
     */
    addSplineSeries(options?: SplineSeriesOptions): SplineSeries;
    /**
     * Method for adding a new `RectangleSeries` to the chart. This series type visualizes a collection of *rectangles*.
     *
     * To learn more about its features and usage, refer to [[RectangleSeries]].
     *
     * **Readonly configuration:**
     *
     * Some properties of `RectangleSeries` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example,
     *  const rectSeries = ChartXY.addRectangleSeries({
     *      // Specify non-default X Axis to attach series to.
     *      xAxis: myNonDefaultAxisX
     *  })
     * ```
     *
     * To learn about available properties, refer to [[RectangleSeriesOptions]].
     *
     * @param   options         Optional object with readonly configuration arguments for `RectangleSeries`.
     * @return                  New series.
     */
    addRectangleSeries(options?: RectangleSeriesOptions): RectangleSeries;
    /**
     * Method for adding a new `PolygonSeries` to the chart. This series type visualizes a collection of *polygons*.
     *
     * To learn more about its features and usage, refer to [[PolygonSeries]].
     *
     * **Readonly configuration:**
     *
     * Some properties of `PolygonSeries` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example,
     *  const polygonSeries = ChartXY.addPolygonSeries({
     *      // Specify non-default X Axis to attach series to.
     *      xAxis: myNonDefaultAxisX
     *  })
     * ```
     *
     * To learn about available properties, refer to [[PolygonSeriesOptions]].
     *
     * @param   options         Optional object with readonly configuration arguments for `PolygonSeries`.
     * @return                  New series.
     */
    addPolygonSeries(options?: PolygonSeriesOptions): PolygonSeries;
    /**
     * Method for adding a new `SegmentSeries` to the chart. This series type visualizes a collection of *line segments* (A -> B).
     *
     * To learn more about its features and usage, refer to [[SegmentSeries]].
     *
     * **Readonly configuration:**
     *
     * Some properties of `SegmentSeries` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example,
     *  const series = ChartXY.addSegmentSeries({
     *      // Specify non-default X Axis to attach series to.
     *      xAxis: myNonDefaultAxisX
     *  })
     * ```
     *
     * To learn about available properties, refer to [[SegmentSeriesOptions]].
     *
     * @param   options         Optional object with readonly configuration arguments for `SegmentSeries`.
     * @return                  New series.
     */
    addSegmentSeries(options?: SegmentSeriesOptions): SegmentSeries;
    /**
     * Method for adding a new `EllipseSeries` to the chart. This series type visualizes a collection of *ellipses*.
     *
     * To learn more about its features and usage, refer to [[EllipseSeries]].
     *
     * **Readonly configuration:**
     *
     * Some properties of `EllipseSeries` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example,
     *  const series = ChartXY.addEllipseSeries({
     *      // Specify non-default X Axis to attach series to.
     *      xAxis: myNonDefaultAxisX
     *  })
     * ```
     *
     * To learn about available properties, refer to [[EllipseSeriesOptions]].
     *
     * @param   options         Optional object with readonly configuration arguments for `EllipseSeries`.
     * @return                  New series.
     */
    addEllipseSeries(options?: EllipseSeriesOptions): EllipseSeries;
    /**
     * Method for adding a new `OHLCSeries` to the chart. This series type is used for visualizing trading figures.
     *
     * To learn more about its features and usage, refer to [[OHLCSeries]].
     *
     * **Readonly configuration:**
     *
     * Some properties of `OHLCSeries` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example,
     *  const series = ChartXY.addOHLCSeries({
     *      // Specify non-default X Axis to attach series to.
     *      xAxis: myNonDefaultAxisX
     *  })
     * ```
     *
     * To learn about available properties, refer to [[OHLCSeriesOptions]].
     *
     * @param   options         Optional object with readonly configuration arguments for `OHLCSeries`.
     * @return                  New series.
     */
    addOHLCSeries<PositiveFigure extends OHLCFigure = OHLCCandleStick, NegativeFigure extends OHLCFigure = PositiveFigure, OHLCSeriesType extends OHLCSeriesTypes<PositiveFigure, NegativeFigure> = OHLCSeriesTraditional<PositiveFigure, NegativeFigure>>(options?: OHLCSeriesOptions<PositiveFigure, NegativeFigure, OHLCSeriesType>): OHLCSeriesType;
    /**
     * Method for adding a new `BoxSeries` to the chart. This series type is used for visualizing data groups through quartiles.
     *
     * To learn more about its features and usage, refer to [[BoxSeries]].
     *
     * **Readonly configuration:**
     *
     * Some properties of `BoxSeries` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example,
     *  const series = ChartXY.addBoxSeries({
     *      // Specify non-default X Axis to attach series to.
     *      xAxis: myNonDefaultAxisX
     *  })
     * ```
     *
     * To learn about available properties, refer to [[BoxSeriesOptions]].
     *
     * @param   options         Optional object with readonly configuration arguments for `BoxSeries`.
     * @return                  New series.
     */
    addBoxSeries<FigureType extends BoxFigure = BoxAndWhiskers>(options?: BoxSeriesOptions<FigureType>): BoxSeries<FigureType>;
    /**
     * Method for adding a new `AreaSeries` to the chart. This series type is used for visualizing *area* between a static *base line* and supplied *curve data*.
     * `AreaSeries` is optimized for *large* amounts of data - here are some reference specs to give an idea:
     *
     * - A static data set in millions range is rendered in a matter of seconds.
     * - With streaming data, tens of thousands data points can be streamed in every second, while retaining an interactive document.
     *
     * To learn more about its features and usage, refer to [[AreaSeries]].
     *
     * **Readonly configuration:**
     *
     * Some properties of `AreaSeries` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example,
     *  const series = ChartXY.addAreaSeries({
     *      // Specify non-default X Axis to attach series to.
     *      xAxis: myNonDefaultAxisX
     *  })
     * ```
     *
     * To learn about available properties, refer to [[AreaSeriesOptions]].
     *
     * **Return type:**
     *
     * `AreaSeries` return type depends on supplied readonly configuration! Specifically, [[AreaSeriesOptions.type]].
     *
     * | Configuration `type` | Return series type |
     * | :------------------- | :---------------- |
     * | `undefined` or omitted | [[AreaSeriesPositive]] |
     * | `AreaSeriesTypes.Positive` | [[AreaSeriesPositive]] |
     * | `AreaSeriesTypes.Negative` | [[AreaSeriesNegative]] |
     * | `AreaSeriesTypes.Bipolar` | [[AreaSeriesBipolar]] |
     *
     * @param   options         Optional object with readonly configuration arguments for `AreaSeries`.
     * @return                  New series.
     */
    addAreaSeries: <AreaType extends AreaSeriesTypes = typeof AreaSeriesPositive>(options?: AreaSeriesOptions<AreaType> | undefined) => InstanceType<AreaType>;
    /**
     * Method for adding a new `AreaRangeSeries` to the chart. This series type is used for visualizing bands of data between two curves of data.
     * `AreaRangeSeries` is optimized for *large* amounts of data - here are some reference specs to give an idea:
     *
     * - A static data set in millions range is rendered in a matter of seconds.
     * - With streaming data, tens of thousands data points can be streamed in every second, while retaining an interactive document.
     *
     * To learn more about its features and usage, refer to [[AreaRangeSeries]].
     *
     * **Readonly configuration:**
     *
     * Some properties of `AreaRangeSeries` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example,
     *  const series = ChartXY.addAreaRangeSeries({
     *      // Specify non-default X Axis to attach series to.
     *      xAxis: myNonDefaultAxisX
     *  })
     * ```
     *
     * To learn about available properties, refer to [[AreaRangeSeriesOptions]].
     *
     * @param   options         Optional object with readonly configuration arguments for `AreaRangeSeries`.
     * @return                  New series.
     */
    addAreaRangeSeries: (options?: AreaRangeSeriesOptions | undefined) => AreaRangeSeries;
    /**
     * Method for adding a new `HeatmapSeries` to the chart. This series type is used for visualizing multi-dimensional *intensity* matrixes.
     *
     * **NOTE:** this method exists mainly for keeping backwards compatibility. New, optimized 2D heatmap series have been already published
     * and can be created with [[addHeatmapGridSeries]] and [[addHeatmapScrollingGridSeries]] methods.
     *
     * This method will be removed in next major release (v4.0), at which point all migrations to newest version will have to use the new optimized features instead.
     *
     * `HeatmapSeries` is optimized for *large* amounts of data - here are some reference specs to give an idea:
     *
     * - A static data set in 1000 x 1000 grid range (million intensity values) is rendered in a matter of seconds.
     *
     * To learn more about its features and usage, refer to [[IntensitySeries]].
     *
     * **Readonly configuration:**
     *
     * Some properties of `HeatmapSeries` can only be configured when it is created. Some of these arguments are **mandatory**, while some are optional.
     * They are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example,
     *  const series = ChartXY.addHeatmapSeries({
     *      columns: 100,
     *      rows: 100,
     *      start: { x: 0, y: 0 },
     *      end: { x: 100, y: 100 },
     *      pixelate: true,
     *  })
     * ```
     *
     * To learn about available properties, refer to [[IntensitySeriesOptions]].
     *
     * **Return type:**
     *
     * `HeatmapSeries` return type depends on supplied readonly configuration! Specifically, [[IntensitySeriesOptions.type]].
     *
     * | Configuration `type` | Return series type |
     * | :------------------- | :---------------- |
     * | `undefined` or omitted | [[IntensityGridSeries]] |
     * | `IntensitySeriesTypes.Grid` | [[IntensityGridSeries]] |
     * | `IntensitySeriesTypes.Mesh` | [[IntensityMeshSeries]] |
     *
     * @param   options         Optional object with readonly configuration arguments for `HeatmapSeries`.
     * @return                  New series.
     * @deprecated Will be removed in v4.0 in favor of new optimized `Heatmap Series`.
     */
    addHeatmapSeries: <IntensityType extends IntensitySeriesTypes = typeof IntensityGridSeries>(options: IntensitySeriesOptions<IntensityType>) => InstanceType<IntensityType>;
    /**
     * Add a Series for visualizing a *Heatmap Grid* with a static column and grid count. Has API for fast modification of cell values.
     *
     * `HeatmapGridSeries` is optimized for *massive* amounts of data - here are some reference specs on average PC to give an idea:
     *
     * - Heatmap Chart with 1 million data points (`1000x1000`) is cold started in ~0.3 seconds.
     * - Heatmap Chart with 1 million data points (`1000x1000`) is re-populated (change data set) in ~0.050 seconds.
     * - Heatmap Chart with 16 million data points (`4000x4000`) is cold started in ~2.0 seconds.
     * - Heatmap Chart with 16 million data points (`4000x4000`) is re-populated (change data set) in ~0.5 seconds.
     *
     * `HeatmapGridSeries` max data amount is entirely restricted by the client hardware RAM and more specifically amount of RAM usable by the context running LightningChart JS.
     * If by increasing the amount of `columns` and `rows` you encounter suddenly weak performance, it is likely that there is not enough RAM memory available.
     *
     * To learn more about its features and usage, refer to [[HeatmapGridSeriesIntensityValues]].
     *
     * **Readonly configuration:**
     *
     * Some properties of `HeatmapSeries` can only be configured when it is created. Some of these arguments are **mandatory**, while some are optional.
     * They are wrapped in a single object parameter:
     *
     * ```js
     *  // Example,
     *  const series = ChartXY.addHeatmapGridSeries({
     *      columns: 100,
     *      rows: 100
     *  })
     * ```
     *
     * To learn about available properties, refer to [[HeatmapGridSeriesOptions]].
     *
     * Heatmap data format is specified with `heatmapDataType: 'intensity'` property;
     * in this case, each cell of the heatmap is associated with a *numeric intensity value*, which can be used in conjuction with a
     * Color look up table ([[LUT]]).
     *
     * For *scrolling heatmap grids*, see [[addHeatmapScrollingGridSeries]].
     *
     * @param   options     Configuration parameters for Heatmap Grid Series.
     * @return              Heatmap Grid Series.
     */
    addHeatmapGridSeries(options: HeatmapGridSeriesOptions<'intensity'>): HeatmapGridSeriesIntensityValues;
    /**
     * Add a Series for visualizing a *Heatmap Grid*, with API for pushing data in a scrolling manner (append new data on top of existing data).
     *
     * `HeatmapScrollingGridSeries` is optimized for *massive* amounts of data - here are some reference specs on average PC to give an idea:
     *
     * - Scrolling Heatmap Chart with 2 million incoming data points **per second** (`rows: 2048`, 1000 columns/s) runs consistently and smoothly with 60 FPS and no stuttering. CPU usage stays easily below 40%.
     * - Scrolling Heatmap Chart with 8 million incoming data points **per second** (`rows: 4096`, 2000 columns/s) runs consistently and smoothly with 60 FPS and minor stuttering.
     *
     * `HeatmapScrollingGridSeries` max data amount is entirely restricted by the client hardware RAM and more specifically amount of RAM usable by the context running LightningChart JS.
     * If performance suddenly plummets at some approximate data threshold, then it is likely that there is not enough RAM available.
     * Use data cleaning configuration and suitable Axis intervals to adjust to your hardware limitations.
     *
     * To learn more about its features and usage, refer to [[HeatmapScrollingGridSeriesIntensityValues]].
     *
     * **Readonly configuration:**
     *
     * Some properties of `ScrollingHeatmapSeries` can only be configured when it is created. Some of these arguments are **mandatory**, while some are optional.
     * They are wrapped in a single object parameter:
     *
     * ```js
     *  // Example,
     *  const series = ChartXY.addHeatmapGridSeries({
     *      resolution: 100
     *  })
     * ```
     *
     * To learn about available properties, refer to [[HeatmapScrollingGridSeriesOptions]].
     *
     * Heatmap data format is specified with `heatmapDataType: 'intensity'` property;
     * in this case, each cell of the heatmap is associated with a *numeric intensity value*, which can be used in conjuction with a
     * Color look up table ([[LUT]]).
     *
     * For *static heatmap grids*, see [[addHeatmapGridSeries]].
     *
     * @param   options     Configuration parameters for Heatmap Grid Series.
     * @return              Scrolling Heatmap Grid Series.
     */
    addHeatmapScrollingGridSeries(options: HeatmapScrollingGridSeriesOptions<'intensity'>): HeatmapScrollingGridSeriesIntensityValues;
    /**
     * Api to add OSM menu to the chart
     *
     * @beta                    This feature is considered experimental and might be changed in minor release.
     * @param controls          A 2d array which describes the type of buttons to be added and their positions (row, column).
     * @param osmButtonShape    Optional parameter to specify the shape of the on-screen menu icons.
     */
    addOnScreenMenu(controls: (OnScreenMenuButtonType | OnScreenMenuCustomButtonParams)[][], osmButtonShape?: OnScreenMenuButtonShape): OnScreenMenu;
    /**
     * Set mouse style when hovering over series background.
     * @param   mouseStyle  Mouse-style preset name (see [[MouseStyles]])
     * @return              Object itself
     */
    setMouseBackgroundStyle(mouseStyle?: string): this;
    /**
     * Set mouse style when zooming over series background.
     * @param   mouseStyle  Mouse-style preset name (see [[MouseStyles]])
     * @return              Object itself
     */
    setMouseZoomStyle(mouseStyle?: string): this;
    /**
     * Set mouse style when fitting over series background.
     * @param   mouseStyle  Mouse-style preset name (see [[MouseStyles]])
     * @return              Object itself
     */
    setMouseFitStyle(mouseStyle?: string): this;
    /**
     * Set mouse style when panning over series background.
     * @param   mouseStyle  Mouse-style preset name (see [[MouseStyles]])
     * @return              Object itself
     */
    setMousePanStyle(mouseStyle?: string): this;
    /**
     * Set all mouse-interaction flags at once.
     * @param   enabled     Are mouse-interactions enabled
     * @return              Object itself
     */
    setMouseInteractions(enabled: boolean): this;
    /**
     * Set is mouse-interaction enabled:
     * Zooming axes by capturing rectangle on frame.
     * @param   enabled     Boolean flag
     * @return              Object itself
     */
    setMouseInteractionRectangleZoom(enabled: boolean): this;
    /**
     * Get is mouse-interaction enabled:
     * Zooming axes by capturing rectangle on frame.
     * @return  Boolean flag
     */
    getMouseInteractionRectangleZoom(): boolean;
    /**
     * Set is mouse-interaction enabled:
     * Fitting axes by capturing rectangle on frame.
     * @param   enabled     Boolean flag
     * @return              Object itself
     */
    setMouseInteractionRectangleFit(enabled: boolean): this;
    /**
     * Get is mouse-interaction enabled:
     * Fitting axes by capturing rectangle on frame.
     * @return  Boolean flag
     */
    getMouseInteractionRectangleFit(): boolean;
    /**
     * Set is mouse-interaction enabled:
     * Panning axes by dragging mouse on frame.
     * @param   enabled     Boolean flag
     * @return              Object itself
     */
    setMouseInteractionPan(enabled: boolean): this;
    /**
     * Get is mouse-interaction enabled:
     * Panning axes by dragging mouse on frame.
     * @return  Boolean flag
     */
    getMouseInteractionPan(): boolean;
    /**
     * Set is mouse-interaction enabled:
     * Zooming axes with mouse-wheel on frame (also touch pinch currently).
     * @param   enabled     Boolean flag
     * @return              Object itself
     */
    setMouseInteractionWheelZoom(enabled: boolean): this;
    /**
     * Get is mouse-interaction enabled:
     * Zooming axes with mouse-wheel on frame.
     * @return  Boolean flag
     */
    getMouseInteractionWheelZoom(): boolean;
    /**
     * Set fillStyle for zooming rectangle when zooming.
     * @param   value   FillStyle or mutator to modify existing one
     * @return          Object itself
     */
    setZoomingRectangleFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fillStyle for zooming rectangle when zooming.
     * @return  FillStyle
     */
    getZoomingRectangleFillStyle(): FillStyle;
    /**
     * Set stroke style for zooming rectangle when zooming.
     * @param   value   LineStyle or mutator to modify existing one
     * @return          Object itself
     */
    setZoomingRectangleStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stroke style for zooming rectangle when zooming.
     * @return  LineStyle
     */
    getZoomingRectangleStrokeStyle(): LineStyle;
    /**
     * Set fillStyle for zooming rectangle when fitting.
     * @param   value       FillStyle or mutator to modify existing one
     * @return              Object itself
     */
    setFittingRectangleFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fillStyle for fitting rectangle when fitting.
     * @return  FillStyle
     */
    getFittingRectangleFillStyle(): FillStyle;
    /**
     * Set stroke style for zooming rectangle when fitting.
     * @param   value       LineStyle or mutator to modify existing one
     * @return              Object itself
     */
    setFittingRectangleStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stroke style for fitting rectangle when fitting.
     * @return  LineStyle
     */
    getFittingRectangleStrokeStyle(): LineStyle;
    /**
     * Add a *legendbox*.
     *
     * *Legendbox* is a type of *UI element*, that floats inside the chart/component it is created inside. It can be freely moved around
     * with user interactions, as well as positioned in application code.
     *
     * The purpose of *legendbox* is to describe the *series* and other visual components of the *chart*, by displaying their names and colors.
     * Hovering over a *series'* *legendbox entry* will highlight that *series*, and clicking on the *entry* will toggle that *series'* visibility.
     *
     * **Legendbox alignment:**
     *
     * Alignment of legendbox can be selected by supplying one of the available [[LegendBoxBuilders]] to `addLegendBox`:
     *
     * ```typescript
     *  // Default (vertical) LegendBox.
     *  const legendBox = ChartXY.addLegendBox()
     *
     *  // Horizontal LegendBox.
     *  const horizontalLegendBox = ChartXY.addLegendBox(LegendBoxBuilders.HorizontalLegendBox)
     * ```
     *
     * **Custom Legendbox positioning:**
     *
     * By default LegendBoxes are placed on the right side, or bottom of the *chart* (depending on *alignment*).
     *
     * A custom location can be configured with [[UIElement]] API:
     * - [[UIElement.setPosition]]
     * - [[UIElement.setOrigin]]
     * - [[UIElement.setMargin]]
     *
     * *Position coordinate system* is specified when creating *legendbox*.
     *
     * 1) LegendBox with default positioning coordinate system.
     *
     * ```typescript
     *  addLegendBox( LegendBoxBuilders.VerticalLegendBox )
     *      // Position = [0, 100] as percentages.
     *      .setPosition({ x: 50, y: 50 })
     * ```
     *
     * 2) Position in pixel coordinate system.
     *
     * ```typescript
     *  addLegendBox( LegendBoxBuilders.VerticalLegendBox, chart.pixelScale )
     *      // Position = pixels.
     *      .setPosition({ x: 300, y: 100 })
     * ```
     *
     * 3) Position on Axes.
     *
     * ```typescript
     *  addLegendBox( LegendBoxBuilders.VerticalLegendBox, { x: chartXY.getDefaultAxisX(), y: chartXY.getDefaultAxisY() } )
     *      // Position = Axis values.
     *      .setPosition({ x: 5, y: 5 })
     * ```
     *
     * For more information on `LegendBox` features, and usage, see [[LegendBox]].
     *
     * @param       builder *LegendBoxBuilder*. If omitted, *VerticalLegendBox* will be selected. Use [[LegendBoxBuilders]] for selection.
     * @param       scale   Optional parameter for altering the coordinate system used for positioning the LegendBox. Defaults to whole Chart in percentages [0, 100].
     * @returns             Object with two interfaces: LegendBox and UIElement.
     */
    addLegendBox(builder?: UILegendBoxBuilder, scale?: UserScaleDefinition): LegendBox & UIElement;
    /**
     * Method pans axes by pixels.
     *
     * ```js
     * // Pan the chart 100 pixels to right.
     * chart.pan({x: 100, y: 0})
     * ```
     * @param   delta   Amount to pan X/Y in pixels
     */
    pan(delta: Point): void;
    /**
     * Method zooms axes by pixels.
     *
     * ```js
     * // Zoom the chart out.
     * chart.zoom({x: 500, y: 500}, {x: 1, y: 1})
     * ```
     * @param   location    Origin location for zooming as viewport pixels
     * @param   amount      Amount to zoom X/Y in pixels
     */
    zoom(location: Point, amount: Point): void;
    /**
     * Disable/Enable all animations of the Chart.
     * @param animationsEnabled Boolean value to enable or disable animations.
     * @return                  Chart itself for fluent interface.
     */
    setAnimationsEnabled(animationsEnabled: boolean | undefined): this;
    /**
     * Get animations disable/enable state.
     * @returns Animations default state.
     */
    getAnimationsEnabled(): boolean;
    /**
     * Disable all animations for the chart.
     *
     * After calling this function, animations (Zooming, scaling) for all Axes will be disabled.
     * Animations must be recreated manually afterwards.
     * @return          Chart itself for fluent interface.
     * @deprecated      Deprecated in v3.1.0. Will be removed in v4.0.0. Use [[setAnimationsEnabled]] instead.
     */
    disableAnimations(): this;
    /**
     * Set if mouse and cursor interactions should be disabled during scrolling animations for the chart's series.
     * @param   state   True if mouse and cursor interactions should be disabled during scrolling animations, false if not.
     * @return          Chart itself for fluent interface.
     */
    setMouseInteractionsWhileScrolling(state: boolean): this;
    /**
     * Get if mouse and cursor interactions are disabled during scrolling animations for the chart's series.
     * @return True if interactions with series are disabled, false if not.
     */
    getMouseInteractionsWhileScrolling(): boolean;
    /**
     * Set if mouse and cursor interactions should be disabled during zooming animations for the chart's series.
     * @param   state   True if mouse and cursor interactions should be disabled during zooming animations, false if not.
     * @return          Chart itself for fluent interface.
     */
    setMouseInteractionsWhileZooming(state: boolean): this;
    /**
     * Get if mouse and cursor interactions are disabled during zooming animations for the chart's series.
     * @return True if interactions with series are disabled, false if not.
     */
    getMouseInteractionsWhileZooming(): boolean;
    /**
     * Operate on each axis of chart, x and y
     * @param   clbk    Callback function for axis
     */
    forEachAxis(clbk: (axis: Axis) => void): void;
}
/**
 * A type of Cursor that is plotted along two axes.
 * Adds customizable gridStrokes and tickMarkers
 */
export interface CursorXY<PointMarkerType extends PointMarker = PointMarker, ResultTableBackgroundType extends UIBackground = UIBackground> extends Cursor<PointMarkerType, ResultTableBackgroundType> {
    /**
     * Set is GridStrokeX cut at cursor location.
     * @param   cut         Boolean flag
     * @returns             Object itself for fluent interface
     */
    setGridStrokeXCut: (cut: boolean) => this;
    /**
     * Get is GridStrokeX cut at cursor location.
     * @returns             Boolean flag
     */
    getGridStrokeXCut: () => boolean;
    /**
     * Set is GridStrokeY cut at cursor location.
     * @param   cut         Boolean flag
     * @returns             Object itself for fluent interface
     */
    setGridStrokeYCut: (cut: boolean) => this;
    /**
     * Get is GridStrokeY cut at cursor location.
     * @returns             Boolean flag
     */
    getGridStrokeYCut: () => boolean;
    /**
     * Set style of x gridstroke
     * @param   value      LineStyle object
     * @returns            Object itself for fluent interface
     */
    setGridStrokeXStyle: (value: LineStyle | ImmutableMutator<LineStyle>) => this;
    /**
     * Get style of x gridstroke
     * @returns             LineStyle of gridstroke
     */
    getGridStrokeXStyle: () => LineStyle;
    /**
     * Set style of y gridstroke
     * @param   value       LineStyle object
     * @returns             Object itself for fluent interface
     */
    setGridStrokeYStyle: (value: LineStyle | ImmutableMutator<LineStyle>) => this;
    /**
     * Get style of y gridstroke
     * @returns             LineStyle of gridstroke
     */
    getGridStrokeYStyle: () => LineStyle;
    /**
     * Set TickMarkerX.
     * @param   mutator     Mutator function for cursors X tickMarker
     * @return              Object itself for fluent interface
     */
    setTickMarkerX: (mutator: Mutator<TickMarker>) => this;
    /**
     * Set TickMarkerY.
     * @param   mutator     Mutator function for cursors Y tickMarker
     * @return              Object itself for fluent interface
     */
    setTickMarkerY: (mutator: Mutator<TickMarker>) => this;
    /**
     * Dispose TickMarker part of Y CustomTick
     * @return Object itself for fluent interface
     */
    disposeTickMarkerY(): this;
    /**
     * Restore TickMarker part of Y CustomTick
     * @return Object itself for fluent interface
     */
    restoreTickMarkerY(): this;
    /**
     * @return Whether TickMarker part of Y CustomTick is disposed
     */
    isDisposedTickMarkerY(): boolean;
    /**
     * Dispose TickMarker part of X CustomTick
     * @return Object itself for fluent interface
     */
    disposeTickMarkerX(): this;
    /**
     * Restore TickMarker part of X CustomTick
     * @return Object itself for fluent interface
     */
    restoreTickMarkerX(): this;
    /**
     * @return Whether TickMarker part of X CustomTick is disposed
     */
    isDisposedTickMarkerX(): boolean;
}
/**
 * A type of CursorXY that can be plotted dynamically between different axes.
 */
export interface AutoCursorXY<PointMarkerType extends PointMarker = PointMarker, ResultTableBackgroundType extends UIBackground = UIBackground> extends CursorXY<PointMarkerType, ResultTableBackgroundType>, AutoCursor<PointMarkerType, ResultTableBackgroundType> {
    /**
     * Set is TickMarkerX auto text fill style enabled.
     * When enabled, text of TickMarkerX will be automatically filled based on pointed data.
     * @param   enabled     Boolean flag
     * @return              Object itself
     * @sideEffect          When enabled, any fill style set operation on TickMarkerX might get overridden
     */
    setTickMarkerXAutoTextStyle(enabled: boolean): this;
    /**
     * Get is TickMarkerX auto text fill style enabled.
     * When enabled, text of TickMarkerX will be automatically filled based on pointed data.
     * @return              Boolean flag
     */
    getTickMarkerXAutoTextStyle(): boolean;
    /**
     * Set is TickMarkerY auto text fill style enabled.
     * When enabled, text of TickMarkerY will be automatically filled based on pointed data.
     * @param   enabled     Boolean flag
     * @return              Object itself
     * @sideEffect          When enabled, any fill style set operation on TickMarkerY might get overridden
     */
    setTickMarkerYAutoTextStyle(enabled: boolean): this;
    /**
     * Get is TickMarkerY auto text fill style enabled.
     * When enabled, text of TickMarkerY will be automatically filled based on pointed data.
     * @return              Boolean flag
     */
    getTickMarkerYAutoTextStyle(): boolean;
}
/**
 * Static XY cursor interface
 */
export interface StaticCursorXY<PointMarkerType extends PointMarker, ResultTableBackgroundType extends UIBackground> extends StaticCursor<PointMarkerType, ResultTableBackgroundType>, CursorXY<PointMarkerType, ResultTableBackgroundType> {
    /**
     * Get x tick marker
     * @returns             X customTick of cursor
     */
    getTickMarkerX: () => TickMarker;
    /**
     * Get y tick marker
     * @returns             Y customTick of cursor
     */
    getTickMarkerY: () => TickMarker;
}
/**
 * Internal class for static xy cursors.
 * Static cursors are attached to a pair of axes on creation
 * and don't move from there.
 * @hidden Internal class
 */
export declare class InternalStaticCursorXY<PointMarkerType extends PointMarker, ResultTableBackgroundType extends UIBackground> extends InternalStaticCursor<PointMarkerType, ResultTableBackgroundType> implements CursorXY<PointMarkerType, ResultTableBackgroundType>, StaticCursor<PointMarkerType, ResultTableBackgroundType> {
    /**
     * Points the Cursor at a given CursorPoint.
     * Updating its position and displayed data.
     */
    pointAt(cursorPoint: CursorPoint): this;
    /**
     * Set the position of the Cursor,
     * moving it without modifying displayed data.
     */
    setPosition(position: Point): this;
    /**
     * Dispose of the cursor and its custom ticks.
     */
    dispose(): this;
    /**
     * Dispose of the cursor and its custom ticks.
     */
    restore(): this;
    /**
     * Set is GridStrokeX cut at cursor location.
     * @param   cut         Boolean flag
     * @returns             Object itself for fluent interface
     */
    setGridStrokeXCut(cut: boolean): this;
    /**
     * Get is GridStrokeX cut at cursor location.
     * @returns             Boolean flag
     */
    getGridStrokeXCut(): boolean;
    /**
     * Set is GridStrokeY cut at cursor location.
     * @param   cut         Boolean flag
     * @returns             Object itself for fluent interface
     */
    setGridStrokeYCut(cut: boolean): this;
    /**
     * Get is GridStrokeY cut at cursor location.
     * @returns             Boolean flag
     */
    getGridStrokeYCut(): boolean;
    /**
     * Set style of x gridstroke
     * @param   value       LineStyle object
     * @returns             Object itself for fluent interface
     */
    setGridStrokeXStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of x gridstroke
     * @returns             LineStyle of gridstroke
     */
    getGridStrokeXStyle(): LineStyle;
    /**
     * Set style of y gridstroke
     * @param   value       LineStyle object
     * @returns             Object itself for fluent interface
     */
    setGridStrokeYStyle: (value: LineStyle | ImmutableMutator<LineStyle>) => this;
    /**
     * Get style of y gridstroke
     * @returns             LineStyle of gridstroke
     */
    getGridStrokeYStyle: () => LineStyle;
    /**
     * Dispose TickMarker part of X CustomTick
     * @return Object itself for fluent interface
     */
    disposeTickMarkerX(): this;
    /**
     * Restore TickMarker part of X CustomTick
     * @return Object itself for fluent interface
     */
    restoreTickMarkerX(): this;
    /**
     * @return Whether TickMarker part of X CustomTick is disposed
     */
    isDisposedTickMarkerX(): boolean;
    /**
     * Dispose TickMarker part of Y CustomTick
     * @return Object itself for fluent interface
     */
    disposeTickMarkerY(): this;
    /**
     * Restore TickMarker part of Y CustomTick
     * @return Object itself for fluent interface
     */
    restoreTickMarkerY(): this;
    /**
     * @return Whether TickMarker part of Y CustomTick is disposed
     */
    isDisposedTickMarkerY(): boolean;
    /**
     * Mutator function for x tick marker
     * @param   mutator     TickMarker mutator function
     * @returns             Object itself for fluent interface
     */
    setTickMarkerX(mutator: Mutator<TickMarker>): this;
    /**
     * Mutator function for y tick marker
     * @param   mutator     TickMarker mutator function
     * @returns              Object itself for fluent interface
     */
    setTickMarkerY(mutator: Mutator<TickMarker>): this;
    /**
     * Get x tick marker
     * @returns             X customTick of cursor
     */
    getTickMarkerX(): TickMarker;
    /**
     * Get y tick marker
     * @returns             Y customTick of cursor
     */
    getTickMarkerY(): TickMarker;
}
/**
 * Internal class for dynamic xy cursors.
 * Dynamic cursors can be positioned to any pair of axes at any time.
 * @hidden Internal class
 */
export declare class InternalAutoCursorXY<PointMarkerType extends PointMarker, ResultTableBackgroundType extends UIBackground> extends InternalAutoCursor<PointMarkerType, ResultTableBackgroundType> implements CursorXY<PointMarkerType, ResultTableBackgroundType>, AutoCursorXY<PointMarkerType, ResultTableBackgroundType> {
    protected _pointMarkerConstructor: PointMarkerConstructor<PointMarkerType & InternalPointMarker>;
    protected _resultTableBackgroundConstructor: BackgroundConstructor<ResultTableBackgroundType & InternalBackground>;
    protected _tickMarkerXBuilder: UIElementBuilder<InternalTickMarker>;
    protected _tickMarkerYBuilder: UIElementBuilder<InternalTickMarker>;
    readonly _theme: Theme;
    /**
     * @param _layer                             Top layer of the rendering Engine
     * @param scale                              Rendering scale of cursor. For dynamic cursor this is naturally not based on any axis
     * @param _pointMarkerConstructor            Constructor for PointMarker
     * @param _resultTableBackgroundConstructor  Constructor for Background of ResultTable
     * @param _tickMarkerXBuilder                Builder for TickMarkerX
     * @param _tickMarkerYBuilder                Builder for TickMarkerY
     * @hidden
     */
    constructor(_layer: Layer2D, renderingScale: LinearScaleXY, scale: ScaleXY, _pointMarkerConstructor: PointMarkerConstructor<PointMarkerType & InternalPointMarker>, _resultTableBackgroundConstructor: BackgroundConstructor<ResultTableBackgroundType & InternalBackground>, _tickMarkerXBuilder: UIElementBuilder<InternalTickMarker>, _tickMarkerYBuilder: UIElementBuilder<InternalTickMarker>, _theme: Theme);
    /**
     * Tell the cursor to restore of its ticks.
     */
    restore(): this;
    /**
     * Tell the cursor to dispose of its ticks.
     */
    dispose(): this;
    /**
     * Points the Cursor at a given CursorPoint.
     * Updating its position and displayed data.
     */
    pointAt(cursorPoint: CursorPoint): this;
    /**
     * Set is GridStrokeX cut at cursor location.
     * @param   cut         Boolean flag
     * @returns             Object itself for fluent interface
     */
    setGridStrokeXCut(cut: boolean): this;
    /**
     * Get is GridStrokeX cut at cursor location.
     * @returns             Boolean flag
     */
    getGridStrokeXCut(): boolean;
    /**
     * Set is GridStrokeY cut at cursor location.
     * @param   cut         Boolean flag
     * @returns             Object itself for fluent interface
     */
    setGridStrokeYCut(cut: boolean): this;
    /**
     * Get is GridStrokeY cut at cursor location.
     * @returns             Boolean flag
     */
    getGridStrokeYCut(): boolean;
    /**
     * Set style of x gridstroke
     * @param   value       LineStyle object
     * @returns             Object itself for fluent interface
     */
    setGridStrokeXStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of x gridstroke
     * @returns             LineStyle of gridstroke
     */
    getGridStrokeXStyle(): LineStyle;
    /**
     * Set lineStyle of y gridstroke
     * @param   lineStyle   LineStyle object
     * @returns             Object itself for fluent interface
     */
    setGridStrokeYStyle(lineStyle: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of y gridstroke
     * @returns             LineStyle of gridstroke
     */
    getGridStrokeYStyle(): LineStyle;
    /**
     * Dispose TickMarker part of X CustomTick
     * @return Object itself for fluent interface
     */
    disposeTickMarkerX(): this;
    /**
     * Restore TickMarker part of X CustomTick
     * @return Object itself for fluent interface
     */
    restoreTickMarkerX(): this;
    /**
     * @return Whether TickMarker part of X CustomTick is disposed
     */
    isDisposedTickMarkerX(): boolean;
    /**
     * Dispose TickMarker part of Y CustomTick
     * @return Object itself for fluent interface
     */
    disposeTickMarkerY(): this;
    /**
     * Restore TickMarker part of Y CustomTick
     * @return Object itself for fluent interface
     */
    restoreTickMarkerY(): this;
    /**
     * @return Whether TickMarker part of Y CustomTick is disposed
     */
    isDisposedTickMarkerY(): boolean;
    /**
     * Mutator function for x tick marker.
     * Applies function to current tick marker if it exists and for any newly created
     * tick marker in order of adding.
     * @param   mutator     Mutator function for TickMarker
     * @return              Object itself
     * @sideEffect          Method can't currently be implemented in a clean way so its usage currently will consume unneeded memory.
     *                      It's repeating usage should be avoided for now.
     */
    setTickMarkerX(mutator: Mutator<TickMarker>): this;
    /**
     * Mutator function for y tick marker.
     * Applies function to current tick marker if it exists and for any newly created
     * tick marker in order of adding.
     * @param   mutator     Mutator function for TickMarker
     * @return              Object itself
     * @sideEffect          Method can't currently be implemented in a clean way so its usage currently will consume unneeded memory.
     *                      It's repeating usage should be avoided for now.
     */
    setTickMarkerY(mutator: Mutator<TickMarker>): this;
    /**
     * Set is TickMarkerX auto text fill style enabled.
     * When enabled, text of TickMarkerX will be automatically filled based on pointed data.
     * @param   enabled     Boolean flag
     * @return              Object itself
     * @sideEffect          When enabled, any fill style set operation on TickMarkerX might get overridden
     */
    setTickMarkerXAutoTextStyle(enabled: boolean): this;
    /**
     * Get is TickMarkerX auto text fill style enabled.
     * When enabled, text of TickMarkerX will be automatically filled based on pointed data.
     * @return              Boolean flag
     */
    getTickMarkerXAutoTextStyle(): boolean;
    /**
     * Set is TickMarkerY auto text fill style enabled.
     * When enabled, text of TickMarkerY will be automatically filled based on pointed data.
     * @param   enabled     Boolean flag
     * @return              Object itself
     * @sideEffect          When enabled, any fill style set operation on TickMarkerY might get overridden
     */
    setTickMarkerYAutoTextStyle(enabled: boolean): this;
    /**
     * Get is TickMarkerY auto text fill style enabled.
     * When enabled, text of TickMarkerY will be automatically filled based on pointed data.
     * @return              Boolean flag
     */
    getTickMarkerYAutoTextStyle(): boolean;
}
/**
 * Base class for cursorXY builders
 */
export declare abstract class CursorBuilderXY<PointMarkerType extends PointMarker, ResultTableBackgroundType extends UIBackground, CursorType extends CursorXY<PointMarkerType, ResultTableBackgroundType>> extends CursorBuilder<PointMarkerType, ResultTableBackgroundType, CursorType> {
    protected _pointMarkerConstructor: PointMarkerConstructor<PointMarkerType & InternalPointMarker>;
    protected _resultTableBackgroundConstructor: BackgroundConstructor<ResultTableBackgroundType & InternalBackground>;
    protected _tickMarkerXBuilder: UIElementBuilder<InternalTickMarker>;
    protected _tickMarkerYBuilder: UIElementBuilder<InternalTickMarker>;
    protected _stylers: CursorStyler<CursorType>[];
    /**
     * @param _pointMarkerConstructor            Constructor for PointMarker
     * @param _resultTableBackgroundConstructor  Constructor for Background of ResultTable
     * @param _tickMarkerXBuilder                Builder for TickMarkerX
     * @param _tickMarkerYBuilder                Builder for TickMarkerY
     * @param _stylers                           List of stylers
     * @hidden
     */
    constructor(_pointMarkerConstructor: PointMarkerConstructor<PointMarkerType & InternalPointMarker>, _resultTableBackgroundConstructor: BackgroundConstructor<ResultTableBackgroundType & InternalBackground>, _tickMarkerXBuilder: UIElementBuilder<InternalTickMarker>, _tickMarkerYBuilder: UIElementBuilder<InternalTickMarker>, _stylers: CursorStyler<CursorType>[]);
}
/**
 * Builder for *AutoCursor* of [[ChartXY]].
 *
 * Used to modify structure of *AutoCursor*, by passing one when creating a [[ChartXY]].
 * Reference from [[AutoCursorBuilders.XY]]
 */
export declare class AutoCursorXYBuilder<PointMarkerType extends PointMarker = PointMarker, ResultTableBackgroundType extends UIBackground = UIBackground> extends CursorBuilderXY<PointMarkerType, ResultTableBackgroundType, AutoCursorXY<PointMarkerType, ResultTableBackgroundType>> implements AutoCursorBuilder<CursorXY<PointMarkerType, ResultTableBackgroundType>> {
    /**
     * Create new CursorBuilder with an additional styler.
     * @param   cursorStyler    Cursor styler function
     * @returns                 New builder with extended style
     */
    addStyler: (cursorStyler: CursorStyler<AutoCursorXY<PointMarkerType, ResultTableBackgroundType>>) => AutoCursorXYBuilder<PointMarkerType, ResultTableBackgroundType>;
    /**
     * Create new CursorBuilder with a different PointMarker.
     * @param   pointMarkerConstructor  Constructor for PointMarker
     * @returns                         New builder with different pointMarker
     */
    setPointMarker: <T extends UIElement & PointMarker & PointMarkerType>(pointMarkerConstructor: PointMarkerConstructor<T>) => AutoCursorXYBuilder<T, ResultTableBackgroundType>;
    /**
     * Create new CursorBuilder with a different ResultTable Background.
     * @param   resultTableBackground   Constructor for Background
     * @returns                         New builder with different resultTable background
     */
    setResultTableBackground: <T extends InternalBackground & ResultTableBackgroundType>(resultTableBackground: BackgroundConstructor<T>) => AutoCursorXYBuilder<PointMarkerType, T>;
}
/**
 * Builder for static xy-cursors
 */
export declare class StaticCursorXYBuilder<PointMarkerType extends PointMarker = PointMarker, ResultTableBackgroundType extends UIBackground = UIBackground> extends CursorBuilderXY<PointMarkerType, ResultTableBackgroundType, StaticCursorXY<PointMarkerType, ResultTableBackgroundType>> {
    /**
     * Create new CursorBuilder with an additional styler.
     * @param   cursorStyler    Cursor styler function
     * @returns                 New builder with extended style
     */
    addStyler: (cursorStyler: CursorStyler<StaticCursorXY<PointMarkerType, ResultTableBackgroundType>>) => StaticCursorXYBuilder<PointMarkerType, ResultTableBackgroundType>;
    /**
     * Create new CursorBuilder with a different PointMarker.
     * @param   pointMarkerConstructor  Constructor for PointMarker
     * @returns                         New builder with different pointMarker
     */
    setPointMarker: <T extends UIElement & PointMarker & PointMarkerType>(pointMarkerConstructor: PointMarkerConstructor<T>) => StaticCursorXYBuilder<T, ResultTableBackgroundType>;
    /**
     * Create new CursorBuilder with a different ResultTable Background.
     * @param   resultTableBackgroundConstructor    Constructor for Background
     * @returns                                     New builder with different resultTable background
     */
    setResultTableBackground: <T extends InternalBackground & ResultTableBackgroundType>(resultTableBackgroundConstructor: BackgroundConstructor<T>) => StaticCursorXYBuilder<PointMarkerType, T>;
}
/**
 * Interface for supplying single XY data-points to a component.
 *
 * The primary way of adding points is the **add()** method. All other methods are for end user utility,
 * and simply transform given data to the format of *add()*. As such, they cause additional performance overhead,
 * so use *add()* whenever possible.
 * @hidden
 */
export interface DataInput {
    /**
     * Append a single `XY` coordinate or list of coordinates into the *series*.
     *
     * ```ts
     *  // Example syntax
     *  LineSeries.add({ x: 0, y: 100 })
     *
     *  LineSeries.add([
     *      { x: 0, y: 100 },
     *      { x: 10, y: 50 },
     *      { x: 20, y: 75 },
     *  ])
     * ```
     *
     * @param    points  Single XY coordinate or list of coordinates.
     * @returns          Object itself for fluent interface.
     */
    add(points: Point | Point[]): this;
}
/**
 * Interface for supplying an Array of X data to a component.
 *
 * Given data is expected to be number values, which will be transformed into an array of XY-compatible points.
 * This method is for end user utility, and simply transform given data to the format of *add()*.
 * As such, they cause additional performance overhead, so use *add()* whenever possible.
 * @hidden
 */
export interface DataInputX {
    /**
     * Append new data points into the series by only supplying X coordinates.
     *
     * ```ts
     *  // Example syntax, number array
     *  LineSeries.addArrayX([ 5, 1, 2, 0 ])
     * ```
     *
     * This method supports binary data input by using *Typed arrays*.
     * If your data comes in any binary format, then using the typed array syntax is recommended for best performance.
     *
     * ```ts
     *  // Example syntax, typed array (Float32)
     *  const float32Array = new Float32Array(4)
     *  float32Array[0] = 5
     *  float32Array[1] = 1
     *  float32Array[2] = 2
     *  float32Array[3] = 0
     *  LineSeries.addArrayX(float32Array)
     * ```
     *
     * Each X coordinate will be paired with an automatically generated Y coordinate.
     *
     * By default, this continues from the last data point in the series.
     * However, the behavior of assigning Y coordinates can be controlled with the optional `step` and `start` parameters.
     *
     * @param   arrayX  Array of X-values.
     * @param   step    Optional step between each Y coordinate. Defaults to 1.
     * @param   start   Optional value for first generated Y-value. Defaults to 0.
     * @return          Object itself for fluent interface.
     */
    addArrayX(arrayX: number[] | TypedArray, step?: number, start?: number): this;
}
/**
 * Interface for supplying an Array of High Low data to a component.
 *
 * Given data is expected to be two number Arrays of equal length, which will be transformed into
 * a single array of AreaPoints.
 * This method is for end user utility, and simply transform given data to the format of *add()*.
 * As such, they cause additional performance overhead, so use *add()* whenever possible.
 * @hidden
 */
export interface DataInputHighLow {
    /**
     * Add an Array of High Low values.
     * Each HighLow value will be paired with an automatically generated HighLow value, based on *step*-argument.
     * **For optimal performance, use add() if possible.**
     * @param   arrayHigh  Array of first High values.
     * @param   arrayLow  Array of Second Low values
     * @param   step    Optional step between each HighLow coordinate. Defaults to 1.
     * @param   start   Optional value for first generated HighLow value. Defaults to 0.
     * @return          Object itself for fluent interface.
     */
    addArraysHighLow(arrayHigh: number[] | TypedArray, arrayLow: number[] | TypedArray, step?: number, start?: number): this;
}
/**
 * Interface for supplying an Array of Y data to a component.
 *
 * Given data is expected to be number values, which will be transformed into an array of XY-compatible points.
 * This method is for end user utility, and simply transform given data to the format of *add()*.
 * As such, they cause additional performance overhead, so use *add()* whenever possible.
 * @hidden
 */
export interface DataInputY {
    /**
     * Append new data points into the series by only supplying Y coordinates.
     *
     * ```ts
     *  // Example syntax, number array
     *  LineSeries.addArrayY([ 5, 1, 2, 0 ])
     * ```
     *
     * This method supports binary data input by using *Typed arrays*.
     * If your data comes in any binary format, then using the typed array syntax is recommended for best performance.
     *
     * ```ts
     *  // Example syntax, typed array (Float32)
     *  const float32Array = new Float32Array(4)
     *  float32Array[0] = 5
     *  float32Array[1] = 1
     *  float32Array[2] = 2
     *  float32Array[3] = 0
     *  LineSeries.addArrayY(float32Array)
     * ```
     *
     * Each Y coordinate will be paired with an automatically generated X coordinate.
     *
     * By default, this continues from the last data point in the series.
     * However, the behavior of assigning X coordinates can be controlled with the optional `step` and `start` parameters.
     *
     * @param   arrayY  Array of Y-values.
     * @param   step    Optional step between each X coordinate. Defaults to 1.
     * @param   start   Optional value for first generated X-value. Defaults to 0.
     * @return          Object itself for fluent interface.
     */
    addArrayY(arrayY: number[] | TypedArray, step?: number, start?: number): this;
}
/**
 * Interface for supplying Arrays of data to a component.
 *
 * Given data is expected to be two number Arrays of equal length, which will be transformed into a single Array of XY-compatible points.
 * This method is for end user utility, and simply transform given data to the format of *add()*.
 * As such, they cause additional performance overhead, so use *add()* whenever possible.
 * @hidden
 */
export interface DataInputXY {
    /**
     * Append new data points into the series by supplying X and Y coordinates in two separated arrays.
     *
     * ```ts
     *  // Example syntax, number array
     *  LineSeries.addArraysXY([0, 1, 2, 3], [ 5, 1, 2, 0 ])
     * ```
     *
     * This method supports binary data input by using *Typed arrays*.
     * If your data comes in any binary format, then using the typed array syntax is recommended for best performance.
     *
     * ```ts
     *  // Example syntax, typed array (Float32)
     *  const float32Array = new Float32Array(4)
     *  float32Array[0] = 5
     *  float32Array[1] = 1
     *  float32Array[2] = 2
     *  float32Array[3] = 0
     *  LineSeries.addArraysXY([0, 1, 2, 3], float32Array)
     * ```
     *
     * @param   arrayX  Array of X-values.
     * @param   arrayY  Array of Y-values.
     * @return          Object itself for fluent interface.
     */
    addArraysXY(arrayX: number[] | TypedArray, arrayY: number[] | TypedArray): this;
}
/**
 * Interface for an object that can be used to enable optimizations applicable only to data that follows a specific pattern.
 *
 * Deprecated over new DataPatterns implementation approach. Atm, only used internally for avoiding extra changes to library logic.
 * Will be removed sooner or later.
 *
 * @hidden
 */
export interface DeprecatedDataPatternInterface {
    /**
     * @return Max X value of the series
     */
    getXMax<VisualType extends BasicChartVisualShapeSet>(segments: VisualType[], newPointsBound: Interval<Point> | undefined): number | undefined;
    /**
     * @return Min X value of the series
     */
    getXMin<VisualType extends BasicChartVisualShapeSet>(segments: VisualType[], newPointsBound: Interval<Point> | undefined): number | undefined;
    /**
     * @return Max Y value of the series
     */
    getYMax<VisualType extends BasicChartVisualShapeSet>(segments: VisualType[], newPointsBound: Interval<Point> | undefined): number | undefined;
    /**
     * @return Min Y value of the series
     */
    getYMin<VisualType extends BasicChartVisualShapeSet>(segments: VisualType[], newPointsBound: Interval<Point> | undefined): number | undefined;
}
/**
 * Base class for Freeform series
 * @hidden
 */
export declare class FreeFormPattern implements DeprecatedDataPatternInterface {
    /**
     * @return Max X value of the series
     */
    getXMax<VisualType extends BasicChartVisualShapeSet>(segments: VisualType[] | undefined, newPointsBound: Interval<Point> | undefined): number | undefined;
    /**
     * @return Min X value of the series
     */
    getXMin<VisualType extends BasicChartVisualShapeSet>(segments: VisualType[] | undefined, newPointsBound: Interval<Point> | undefined): number | undefined;
    /**
     * @return Max Y value of the series
     */
    getYMax<VisualType extends BasicChartVisualShapeSet>(segments: VisualType[] | undefined, newPointsBound: Interval<Point> | undefined): number | undefined;
    /**
     * @return Min Y value of the series
     */
    getYMin<VisualType extends BasicChartVisualShapeSet>(segments: VisualType[] | undefined, newPointsBound: Interval<Point> | undefined): number | undefined;
}
/**
 * Progressive data pattern record properties
 * @hidden
 */
interface ProgressivePatternRecordProperties {
}
/**
 * Progressive pattern record
 * @hidden
 */
declare const ProgressivePatternRecord: Record.Factory<ProgressivePatternRecordProperties>;
/**
 * Base class for Progressive DataPattern objects.
 * @noInheritDoc
 * @hidden
 */
export declare abstract class ProgressivePattern extends ProgressivePatternRecord implements DeprecatedDataPatternInterface {
    /**
     * @return Max X value of the series
     */
    abstract getXMax<VisualType extends BasicChartVisualShapeSet>(segments: VisualType[], newPointsBound: Interval<Point> | undefined): number | undefined;
    /**
     * @return Min X value of the series
     */
    abstract getXMin<VisualType extends BasicChartVisualShapeSet>(segments: VisualType[], newPointsBound: Interval<Point> | undefined): number | undefined;
    /**
     * @return Max Y value of the series
     */
    abstract getYMax<VisualType extends BasicChartVisualShapeSet>(segments: VisualType[], newPointsBound: Interval<Point> | undefined): number | undefined;
    /**
     * @return Min Y value of the series
     */
    abstract getYMin<VisualType extends BasicChartVisualShapeSet>(segments: VisualType[], newPointsBound: Interval<Point> | undefined): number | undefined;
    /**
     * Set precision of data packing optimization.
     *
     * Example usage:
     *
     * **Normal precision**
     * ```javascript
     *  DataPatterns.horizontalProgressive.setPrecision( 'normal' )
     * ```
     *
     * **High precision**
     *
     * Sometimes needed if data is very dense, yet still detailed.
     * ```javascript
     *  DataPatterns.horizontalProgressive.setPrecision( 'high' )
     * ```
     * @param precision     Data packing precision.
     * @return              New DataPattern object.
     */
    abstract setPrecision(precision: 'normal' | 'high'): this;
}
/**
 * Abstract class which contains a part of logic which is generic for Horizontal progressive and regressive Line Series
 *
 * Y Max and Min are found by iteration over entire collection of segments
 * @hidden
 */
export declare abstract class HorizontalPattern extends ProgressivePattern {
    /**
     * @return Max Y value of the series
     */
    getYMax<VisualType extends BasicChartVisualShapeSet>(segments: VisualType[] | undefined, newPointsBound: Interval<Point> | undefined): number | undefined;
    /**
     * @return Min Y value of the series
     */
    getYMin<VisualType extends BasicChartVisualShapeSet>(segments: VisualType[] | undefined, newPointsBound: Interval<Point> | undefined): number | undefined;
}
/**
 * DataPattern for horizontally progressive data
 * @hidden
 */
export declare class HorizontalProgressivePattern extends HorizontalPattern {
    constructor();
    /**
     * @return Max X value of the series
     */
    getXMax<VisualType extends BasicChartVisualShapeSet>(segments: VisualType[] | undefined, newPointsBound: Interval<Point> | undefined): number | undefined;
    /**
     * @return Min X value of the series
     */
    getXMin<VisualType extends BasicChartVisualShapeSet>(segments: VisualType[] | undefined, newPointsBound: Interval<Point> | undefined): number | undefined;
    /**
     * Set precision of data packing optimization.
     * @param precision  Data packing precision.
     */
    setPrecision(precision: 'normal' | 'high'): this;
}
/**
 * DataPattern for horizontally regressive data
 * @hidden
 */
export declare class HorizontalRegressivePattern extends HorizontalPattern {
    constructor();
    /**
     * @return Max X value of the series
     */
    getXMax<VisualType extends BasicChartVisualShapeSet>(segments: VisualType[] | undefined, newPointsBound: Interval<Point> | undefined): number | undefined;
    /**
     * @return Min X value of the series
     */
    getXMin<VisualType extends BasicChartVisualShapeSet>(segments: VisualType[] | undefined, newPointsBound: Interval<Point> | undefined): number | undefined;
    /**
     * Set precision of data packing optimization.
     * @param precision Data packing precision.
     */
    setPrecision(precision: 'normal' | 'high'): this;
}
/**
 * Abstract class which contains a part of logic which is generic for Vertical progressive and regressive Line Series
 *
 * X Max and Min are found by iteration over entire collection of segments
 * @hidden
 */
export declare abstract class VerticalPattern extends ProgressivePattern {
    /**
     * @return Max X value of the series
     */
    getXMax<VisualType extends BasicChartVisualShapeSet>(segments: VisualType[] | undefined, newPointsBound: Interval<Point> | undefined): number | undefined;
    /**
     * @return Min X value of the series
     */
    getXMin<VisualType extends BasicChartVisualShapeSet>(segments: VisualType[] | undefined, newPointsBound: Interval<Point> | undefined): number | undefined;
}
/**
 * DataPattern for vertically progressive data
 * @hidden
 */
export declare class VerticalProgressivePattern extends VerticalPattern {
    constructor();
    /**
     * @return Max Y value of the series
     */
    getYMax<VisualType extends BasicChartVisualShapeSet>(segments: VisualType[] | undefined, newPointsBound: Interval<Point> | undefined): number | undefined;
    /**
     * @return Min Y value of the series
     */
    getYMin<VisualType extends BasicChartVisualShapeSet>(segments: VisualType[] | undefined, newPointsBound: Interval<Point> | undefined): number | undefined;
    /**
     * Set precision of data packing optimization.
     * @param precision  Data packing precision.
     */
    setPrecision(precision: 'normal' | 'high'): this;
}
/**
 * DataPattern for vertically regressive data
 * @hidden
 */
export declare class VerticalRegressivePattern extends VerticalPattern {
    constructor();
    /**
     * @return Max Y value of the series
     */
    getYMax<VisualType extends BasicChartVisualShapeSet>(segments: VisualType[] | undefined, newPointsBound: Interval<Point> | undefined): number | undefined;
    /**
     * @return Min Y value of the series
     */
    getYMin<VisualType extends BasicChartVisual>(segments: VisualType[] | undefined, newPointsBound: Interval<Point> | undefined): number | undefined;
    /**
     * Set precision of data packing optimization.
     * @param precision  Data packing precision.
     */
    setPrecision(precision: 'normal' | 'high'): this;
}
/**
 * Options collection for selecting optimizations for data with a specific pattern.
 * Knowing the pattern of incoming data can enable massive optimizations.
 *
 * This must be specified when *Series* is created. Note, that not all *Series* support specifying pattern of data.
 *
 * Example usage:
 *```javascript
 * // Create LineSeries with progressive data on X
 * ChartXY.addLineSeries({ dataPattern: DataPatterns.horizontalProgressive })
 * ```
 * If the Series is supplied with data that does not respect the given [[DataPattern]], it might behave unexpectedly.
 * @hidden
 */
export declare const DataPatterns: {
    /**
     * Indicates that incoming data always progresses in positive X direction and enables optimizations for this scenario.
     *
     * Example usage:
     *```javascript
     * // Create LineSeries with progressive data on X
     * ChartXY.addLineSeries({ dataPattern: DataPatterns.horizontalProgressive })
     * ```
     */
    horizontalProgressive: ProgressivePattern;
    /**
     * Indicates that incoming data always progresses in negative X direction and enables optimizations for this scenario.
     *
     * Example usage:
     *```javascript
     * // Create LineSeries with regressive data on X
     * ChartXY.addLineSeries({ dataPattern: DataPatterns.horizontalRegressive })
     * ```
     */
    horizontalRegressive: ProgressivePattern;
    /**
     * Indicates that incoming data always progresses in positive Y direction and enables optimizations for this scenario.
     *
     * Example usage:
     *```javascript
     * // Create LineSeries with progressive data on Y
     * ChartXY.addLineSeries({ dataPattern: DataPatterns.verticalProgressive })
     * ```
     */
    verticalProgressive: ProgressivePattern;
    /**
     * Indicates that incoming data always progresses in negative Y direction and enables optimizations for this scenario.
     *
     * Example usage:
     *```javascript
     * // Create LineSeries with progressive data on Y
     * ChartXY.addLineSeries({ dataPattern: DataPatterns.verticalRegressive })
     * ```
     */
    verticalRegressive: ProgressivePattern;
    /**
     * Indicates that incoming data has no pattern, and can go in any direction from any given point.
     * Data-point solving is EXTREMELY HEAVY for freeform data, consider using other *DataPattern*s if possible.
     *
     * Example usage:
     *```javascript
     * // Create freeform LineSeries
     * ChartXY.addLineSeries({ dataPattern: DataPatterns.freeform })
     * ```
     */
    freeform: FreeFormPattern;
};
/**
 * Type of constructor for DataPattern
 * @hidden
 */
export declare type DataPatternConstructor<T extends DeprecatedDataPatternInterface = DeprecatedDataPatternInterface> = new () => T;
export {};
/**
 * Interface describing options for series that can be specified during creation time.
 * @hidden
 */
export interface SeriesOptions {
    /**
     * Optional non-default X Axis to attach series to.
     *
     * By default, series are attached to the same X Axis, that is returned by [[ChartXY.getDefaultAxisX]].
     */
    xAxis?: Axis;
    /**
     * Optional non-default Y Axis to attach series to.
     *
     * By default, series are attached to the same Y Axis, that is returned by [[ChartXY.getDefaultAxisY]].
     */
    yAxis?: Axis;
    /**
     * Optional index to use for automatic coloring of series.
     *
     * Normally series are automatically colored differently when you create several series in the same chart.
     * However, in some cases you might want to alter this order of automatic coloring, or use the automatic color palettes on series that belong to different charts.
     *
     * In these scenarios you can use `automaticColorIndex` to tell each series individually what is its place in the default color palette.
     *
     * ```ts
     *  // Create series using the first color in default Theme palette.
     *  const series1 = chart.addLineSeries({ automaticColorIndex: 0 })
     *  // Create another series colored with the 3rd color.
     *  const series2 = chart.addLineSeries({ automaticColorIndex: 2 })
     * ```
     */
    automaticColorIndex?: number;
}
/**
 * Interface that describes API for configuring data cleaning. There are a multitude of different basis' of configuring automatic data cleaning.
 *
 * Data cleaning by `minDataPointCount`:
 *
 * Specifying `minDataPointCount` enables _lazy_ cleaning of data that is **outside view** as long as the remaining data amount doesn't go below the configured threshold.
 *
 * ```js
 *  // Example syntax for specifying minDataPointCount
 *  series.setDataCleaning({ minDataPointCount: 10000 })
 * ```
 *
 * Usage of `minDataPointCount` is recommended in most common applications that require automatic data cleaning.
 * The actual value is often not very particular, just setting it above `0` to enable it is usually enough (lazy data cleaning of out of view data).
 *
 * **Partially supported data cleaning configurations:**
 *
 * These syntaxes are supported by only some select series types, refer to that particular series' API documentation to learn more.
 *
 * Data cleaning by `maxDataPointCount`:
 *
 * Specifying `maxDataPointCount` results in data cleaning always happening **exactly** when total data amount exceeds the supplied threshold.
 *
 * ```js
 *  // Example syntax for specifying maxDataPointCount
 *  series.setDataCleaning({ maxDataPointCount: 10000 })
 * ```
 *
 * `maxDataPointCount` is usually used in memory limited applications to prevent running out of memory.
 *
 * **`maxDataPointCount` is currently only supported by only select series:**
 * - [[HeatmapScrollingGridSeries]].
 * - [[OHLCSeries]].
 *
 * If the feature receives good support and usage from the user base, it might be expanded to all series types in a future release.
 */
export interface SeriesWithDataCleaning {
    /**
     * Disable automatic data cleaning.
     *
     * ```js
     *  // Example syntax, disable data cleaning.
     *  series.setDataCleaning(undefined)
     * ```
     *
     * @param   arg             Data cleaning configuration.
     * @return                  Object itself for fluent interface.
     */
    setDataCleaning(arg: undefined): this;
    /**
     * Enable automatic data cleaning by `minDataPointCount` configuration.
     *
     * Specifying `minDataPointCount` enables _lazy_ cleaning of data that is **outside view** as long as the remaining data amount doesn't go below the configured threshold.
     *
     * ```js
     *  // Example syntax for specifying minDataPointCount
     *  series.setDataCleaning({ minDataPointCount: 10000 })
     * ```
     *
     * Usage of `minDataPointCount` is recommended in most common applications that require automatic data cleaning.
     * The actual value is often not very particular, just setting it above `0` to enable it is usually enough (lazy data cleaning of out of view data).
     *
     * ```js
     *  // Example, enable lazy data cleaning of out of view data.
     *  series.setDataCleaning({ minDataPointCount: 1 })
     * ```
     *
     * @param   arg             Data cleaning configuration.
     * @return                  Object itself for fluent interface.
     */
    setDataCleaning(arg: {
        minDataPointCount: number | undefined;
    }): this;
}
/**
 * LineSeries, extension of BasicSeries using LineSets
 * + Lined -interface
 */
/**
 * Series type for visualizing a list of [[Point]]s (pair of X and Y coordinates),
 * with a continuous stroke. `LineSeries` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
 *
 * - A static data set in tens of millions range is rendered in a matter of seconds.
 * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
 *
 * **Creating LineSeries:**
 *
 * `LineSeries` are created with [[ChartXY.addLineSeries]] method.
 *
 * Some properties of `LineSeries` can only be configured when it is created. These arguments are all optional,
 * and are wrapped in a single object parameter:
 *
 * ```typescript
 *  // Example,
 *  const lineSeries = ChartXY.addLineSeries({
 *      // Specify non-default X Axis to attach series to.
 *      xAxis: myNonDefaultAxisX
 *  })
 * ```
 *
 * To learn about available properties, refer to [[LineSeriesOptions]].
 *
 * **Frequently used methods:**
 *
 * - Append data points to series | [[add]]
 * - Remove all data points from series | [[clear]]
 * - Configure style of line stroke | [[setStrokeStyle]]
 * - Configure automatic cursor interpolation between data points | [[setCursorInterpolationEnabled]]
 * - Configure cursor enabled | [[setCursorEnabled]]
 * - Configure basis of solving nearest data point for cursor | [[setCursorSolveBasis]]
 * - Remove series temporarily, or permanently | [[dispose]]
 * - Restore series after `dispose` | [[restore]]
 * - Configure automatic data cleaning | [[setDataCleaning]]
 * - Solve nearest data point from specified location | [[solveNearestFromScreen]]
 *
 *
 * **LineSeries mouse interactions:**
 *
 * Contrary to other features, `LineSeries` mouse interactions are disabled by default since version 3.0.1.
 *
 * If mouse interactions are required, you need to enable them with [[LineSeries.setMouseInteractions]].
 * With mouse interactions enabled, using a data pattern is _heavily recommended_, especially with large data amounts.
 * `Line Series` mouse interactions function significantly faster with a data pattern.
 *
 * To learn of `LineSeries` *data patterns*, refer to [[LineSeriesOptions.dataPattern]].
 *
 * Additionally, `LineSeries` mouse interactions do not work when the series is placed on a *logarithmic axis*.
 *
 * These issues will be resolved in the immediate future (2021) until all interactions work as expected.
 */
export declare class LineSeries extends BasicSeries<LineSet, Point, LinearScaleXY> implements Lined, AttachableWithLUT {
    /**
     * Append a single `XY` coordinate or list of `XY` coordinates into the *series*.
     *
     * ```ts
     *  // Example syntax
     *  LineSeries.add({ x: 0, y: 100 })
     *
     *  LineSeries.add([
     *      { x: 0, y: 100 },
     *      { x: 10, y: 50 },
     *      { x: 20, y: 75 },
     *  ])
     * ```
     *
     * For more methods of appending data into series, see:
     *
     * - [[addArrayY]] | Append only Y coordinates.
     * - [[addArrayX]] | Append only X coordinates.
     * - [[addArraysXY]] | Append X and Y coordinates in separate arrays.
     *
     * **Data gaps**
     *
     * When using [[LineSeries]], [[AreaSeries]] or other series types which connect data points together,
     * the connections between specific data points can be removed by adding gap data points.
     *
     * A gap data point is specified by using `Number.NaN` as either X or Y coordinate.
     *
     * ```ts
     *  // Example, data gap syntax.
     *  LineSeries.add([
     *      { x: 0, y: 10 },
     *      { x: 1, y: 12 },
     *      { x: 2, y: Number.NaN },
     *      { x: 3, y: 15 },
     *      { x: 4, y: 20 }
     *  ])
     * ```
     *
     * **Additional extra data point properties**
     *
     * There is also a set of extra properties that can be supplied for each data point:
     *
     * - `value`    | Associate data point with a value. Can be used for paletted line coloring, see [[LineSeriesOptions.individualLookupValuesEnabled]] for more details.
     *
     * ```ts
     *  // Example, data point with `value` property
     *  LineSeries.add({
     *      x: 0,
     *      y: 0,
     *      value: 62.5
     *  })
     * ```
     *
     * @param    points  Single XY coordinate or list of coordinates.
     * @returns          Object itself for fluent interface.
     */
    add(points: Point | Point[]): this;
    /**
     * Set mouse interactions enabled or disabled.
     * Disabling mouse-interactions will naturally prevent mouse-driven highlighting from ever happening.
     *
     * Line series mouse interactions are disabled by default.
     * @param state Specifies state of mouse interactions
     * @return      Object itself for fluent interface
     */
    setMouseInteractions(state: boolean): this;
    /**
     * Set stroke style of Series.
     *
     * ```ts
     *  // Example syntax, specify LineStyle
     *  LineSeries.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorHEX('#F00') })
     *  }))
     * ```
     *
     * ```ts
     *  // Example syntax, change active LineStyle
     *  LineSeries.setStrokeStyle((stroke) => stroke.setThickness(5))
     * ```
     *
     * Use `-1` thickness to enable primitive line rendering.
     * Primitive line rendering can have slightly better rendering performance than line with `1` thickness but the quality of line is not as good.
     * ```typescript
     *  LineSeries.setStrokeStyle((solidLine) => solidLine.setThickness(-1))
     * ```
     *
     * **Supported fill styles:**
     *
     * [[SolidFill]]:
     *
     * Solid color for entire line series.
     *
     * ```ts
     *  // Example, solid colored line.
     *  LineSeries.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
     *  }))
     * ```
     *
     * To learn more about available *Color* factories, see [[ColorRGBA]]
     *
     * [[PalettedFill]]:
     *
     * Line series supports following look-up modes: `x`, `y` and `value`.
     *
     * `lookUpProperty: 'x' | 'y'`:
     *
     * Color line stroke dynamically based on `x` or `y` coordinate.
     *
     * ```ts
     *  // Example, dynamic color by Y coordinates
     *  LineSeries.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new PalettedFill({
     *          lookUpProperty: 'y',
     *          lut: new LUT({
     *              interpolate: true,
     *              steps: [
     *                  { value: 0, color: ColorRGBA(255, 0, 0) },
     *                  { value: 100, color: ColorRGBA(0, 255, 0) },
     *              ]
     *          })
     *      })
     *  }))
     * ```
     *
     * To learn more about Color lookup tables, see [[LUT]].
     *
     * `lookUpProperty: 'value'`:
     *
     * Color line stroke dynamically based on separately supplied `value` data set.
     *
     * `value`s are specified when adding data points with [[add]] method.
     *
     * ```ts
     *  // Example, dynamic color by Value data set
     *  LineSeries
     *      .setStrokeStyle(new SolidLine({
     *           thickness: 2,
     *           fillStyle: new PalettedFill({
     *               lookUpProperty: 'value',
     *               lut: new LUT({
     *                   interpolate: true,
     *                   steps: [
     *                       { value: 0, color: ColorRGBA(255, 0, 0) },
     *                       { value: 100, color: ColorRGBA(0, 255, 0) },
     *                   ]
     *               })
     *           })
     *      }))
     *      .add([ {x: 0, y: 0, value: 0}, {x: 1, y: 10, value: 100} ])
     * ```
     *
     * **Data point value properties have to be explicitly enabled before they can be used**, see [[LineSeriesOptions.individualLookupValuesEnabled]] for more details.
     *
     * To learn more about Color lookup tables, see [[LUT]].
     *
     * [[LinearGradientFill]]:
     *
     * Color line stroke with a linear configurable gradient palette.
     *
     * ```ts
     *  // Example, linear gradient line color
     *  LineSeries.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new LinearGradientFill()
     *  }))
     * ```
     *
     * To learn more about linear gradient configurations, see [[LinearGradientFill]].
     *
     * [[RadialGradientFill]]:
     *
     * Color line stroke with a radial configurable gradient palette.
     *
     * ```ts
     *  // Example, radial gradient line color
     *  LineSeries.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new RadialGradientFill()
     *  }))
     * ```
     *
     * To learn more about radial gradient configurations, see [[RadialGradientFill]].
     *
     * @param   value   Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
     * @returns         Object itself for fluent interface.
     */
    setStrokeStyle(value: SolidLine | ImmutableMutator<SolidLine>): this;
    /**
     * Get stroke style of Series.
     * @return  SolidLine object
     */
    getStrokeStyle(): SolidLine;
    /**
     * Set stroke style of Series when it is highlighted.
     * Highlighting is activated by placing mouse on top / touching Series (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     *
     * Example usage:
     *```javascript
     * // Specified LineStyle
     * LineSeries.setStrokeStyleHighlight(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * LineSeries.setStrokeStyleHighlight((solidLine) => solidLine.setThickness(5))
     * // Hidden must be done with transparentLine, emptyLine is not supported
     * LineSeries.setStrokeStyleHighlight(transparentLine)
     * // Automatic
     * LineSeries.setStrokeStyleHighlight(undefined)
     * ```
     * @param   value   Either a SolidLine object or a function, which will be used to modify current value or
     *                  undefined for automatic value based on normal style.
     * @returns         Chart itself
     */
    setStrokeStyleHighlight(value: SolidLine | ImmutableMutator<SolidLine> | undefined): this;
    /**
     * Get stroke style of Series when it is highlighted.
     * Highlighting is activated by placing mouse on top / touching Series (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     * @return  SolidLine object
     */
    getStrokeStyleHighlight(): SolidLine;
    /**
     * Disable automatic data cleaning.
     *
     * ```js
     *  // Example syntax, disable data cleaning.
     *  series.setDataCleaning(undefined)
     * ```
     *
     * @param   arg             Data cleaning configuration.
     * @return                  Object itself for fluent interface.
     */
    setDataCleaning(arg: undefined): this;
    /**
     * Enable automatic data cleaning by `minDataPointCount` configuration.
     *
     * Specifying `minDataPointCount` enables _lazy_ cleaning of data that is **outside view** as long as the remaining data amount doesn't go below the configured threshold.
     *
     * ```js
     *  // Example syntax for specifying minDataPointCount
     *  series.setDataCleaning({ minDataPointCount: 10000 })
     * ```
     *
     * Usage of `minDataPointCount` is recommended in most common applications that require automatic data cleaning.
     * The actual value is often not very particular, just setting it above `0` to enable it is usually enough (lazy data cleaning of out of view data).
     *
     * ```js
     *  // Example, enable lazy data cleaning of out of view data.
     *  series.setDataCleaning({ minDataPointCount: 1 })
     * ```
     *
     * @param   arg             Data cleaning configuration.
     * @return                  Object itself for fluent interface.
     */
    setDataCleaning(arg: {
        minDataPointCount: number | undefined;
    }): this;
    /**
     * Set *progressive data cleaning threshold*.
     *
     * This feature allows configuring automatic data cleaning in infinitely scrolling applications.
     *
     * **This feature is only intended for *progressive data patterns*!**
     * To learn of `LineSeries` *data patterns*, refer to [[LineSeriesOptions.dataPattern]].
     *
     * The *data cleaning threshold* is a position on a single *Axis* (either X or Y) of the series.
     * All data that exists *behind* this threshold, can be cleaned at any convenient time by the rendering engine, releasing memory for more data.
     *
     * The behavior of *data cleaning threshold* is based on the `pattern` argument supplied to [[LineSeriesOptions.dataPattern]]:
     *
     * - `'ProgressiveX'`   -> *data cleaning threshold* is a position on X Axis. All data points whose `X` coordinate is *less* than the *threshold*, can be cleaned.
     * - `'RegressiveX'`    -> *data cleaning threshold* is a position on X Axis. All data points whose `X` coordinate is *more* than the *threshold*, can be cleaned.
     * - `'ProgressiveY'`   -> *data cleaning threshold* is a position on Y Axis. All data points whose `Y` coordinate is *less* than the *threshold*, can be cleaned.
     * - `'RegressiveY'`    -> *data cleaning threshold* is a position on Y Axis. All data points whose `Y` coordinate is *more* than the *threshold*, can be cleaned.
     *
     * **Example usage:**
     *
     * - Infinitely streaming Line Chart.
     *
     * ```typescript
     *  const series = chart.addLineSeries({
     *      dataPattern: {
     *          // Specify progressive X data.
     *          pattern: 'ProgressiveX'
     *      }
     *  })
     *
     *  // Setup progressive scrolling X Axis.
     *  chart.getDefaultAxisX().setScrollStrategy(AxisScrollStrategies.progressive).setInterval(-1000, 0)
     *
     *  // Setup infinite data stream.
     *  let x = 0
     *  setInterval(() => {
     *      series.add({ x, y: Math.random() * 100 })
     *      x += 1
     *      // Move data cleaning threshold dynamically behind series data to allow data cleaning of old data.
     *      const dcThreshold = series.getXMax() - 1000
     *      series.setDataCleaningThreshold(dcThreshold)
     *  }, 1000 / 60)
     * ```
     *
     * @param   dataCleaningThreshold   Data cleaning threshold value or `undefined` to disable data cleaning based on *threshold*.
     * @return                          Object itself.
     * @deprecated                      Will be removed in v4.0 in favour of [[setDataCleaning]].
     */
    setDataCleaningThreshold(dataCleaningThreshold: number | undefined): this;
    /**
     * Get *progressive data cleaning threshold*.
     *
     * This feature allows configuring automatic data cleaning in infinitely scrolling applications.
     *
     * **This feature is only intended for *progressive data patterns*!**
     * To learn of `LineSeries` *data patterns*, refer to [[LineSeriesOptions.dataPattern]].
     *
     * The *data cleaning threshold* is a position on a single *Axis* (either X or Y) of the series.
     * All data that exists *behind* this threshold, can be cleaned at any convenient time by the rendering engine, releasing memory for more data.
     *
     * The behavior of *data cleaning threshold* is based on the `pattern` argument supplied to [[LineSeriesOptions.dataPattern]]:
     *
     * - `'ProgressiveX'`   -> *data cleaning threshold* is a position on X Axis. All data points whose `X` coordinate is *less* than the *threshold*, can be cleaned.
     * - `'RegressiveX'`    -> *data cleaning threshold* is a position on X Axis. All data points whose `X` coordinate is *more* than the *threshold*, can be cleaned.
     * - `'ProgressiveY'`   -> *data cleaning threshold* is a position on Y Axis. All data points whose `Y` coordinate is *less* than the *threshold*, can be cleaned.
     * - `'RegressiveY'`    -> *data cleaning threshold* is a position on Y Axis. All data points whose `Y` coordinate is *more* than the *threshold*, can be cleaned.
     * @return                          Data cleaning threshold value or `undefined`.
     * @deprecated                      Will be removed in v4.0 in favour of [[setDataCleaning]].
     */
    getDataCleaningThreshold(): number | undefined;
    /**
     * Set if cursor interpolates solved data-points along series by default.
     *
     * ```typescript
     *  // Example, disable default interpolation of progressiveX line series.
     *  const series = ChartXY.addLineSeries({
     *      dataPattern: {
     *          pattern: 'ProgressiveX'
     *      }
     *  })
     *      .setCursorInterpolationEnabled(false)
     * ```
     *
     * Cursor interpolation is only supported with a collection of configuration combinations:
     *
     * - *Freeform data* + *cursor solve basis* = `'nearest'`
     * - *ProgressiveX data* + *cursor solve basis* = `'nearestX'`
     * - *ProgressiveY data* + *cursor solve basis* = `'nearestY'`
     *
     * With any other combination, or if cursor intepolation is disabled, the closest actual data point will be selected.
     *
     * **Related information:**
     * - Information about specifying series *data pattern* [[LineSeriesOptions.dataPattern]]
     * - *Cursor solve basis* [[LineSeries.setCursorSolveBasis]]
     *
     * **Related API:**
     *
     * - [[setCursorEnabled]] | configure whether *cursors* should pick on this particular *series* or not.
     * - [[setCursorResultTableFormatter]] | configure formatting of *result table* contents, when this series is pointed.
     * - [[setCursorSolveBasis]] | configure basis of finding nearest data point for the series (`'nearest-x'`, `'nearest'`, etc.).
     * - [[ChartXY.setAutoCursorMode]] | configure behavior when auto cursor is visible.
     *
     * @param   state   Boolean flag
     * @returns         Object itself for fluent interface
     */
    setCursorInterpolationEnabled(state: boolean): this;
    /**
     * Get if cursor interpolates solved data-points along series by default.
     *
     * Cursor interpolation is only supported if the `LineSeries` follows a *progressive data-pattern*, refer to [[ChartXY.addLineSeries]] for
     * more information on *data-patterns*.
     * @returns         Boolean flag
     */
    getCursorInterpolationEnabled(): boolean;
    /**
     * Set basis of solving data point nearest to a given location from this series.
     *
     * Default configuration is `'nearest-x'`.
     *
     * ```typescript
     *  // Example, configure series cursor to snap to closest data point along both X and Y dimensions.
     *  LineSeries.setCursorSolveBasis('nearest')
     * ```
     *
     * **Related API:**
     *
     * - [[setCursorEnabled]] | configure whether *cursors* should pick on this particular *series* or not.
     * - [[setCursorResultTableFormatter]] | configure formatting of *result table* contents, when this series is pointed.
     * - [[setCursorInterpolationEnabled]] | configure automatic cursor interpolation between data points enabled.
     * - [[ChartXY.setAutoCursorMode]] | configure behavior when auto cursor is visible.
     *
     * @param   basis   String describing the desired solve behavior.
     */
    setCursorSolveBasis(basis: 'nearest' | 'nearest-x' | 'nearest-y'): this;
    /**
     * Get basis of solving data point nearest to a given location from this series.
     *
     * Default configuration is `'nearest'`.
     *
     * @return          String describing the desired solve behavior.
     */
    getCursorSolveBasis(): 'nearest' | 'nearest-x' | 'nearest-y';
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Series itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick?: boolean): this;
    /**
     * Configure automatic *data cleaning* by `maxPointCount`.
     * This allows the cleaning of all excess data points that are outside view, so that after cleaning at least `maxPointCount`
     * data points are retained.
     * Essentially it configures the *head length* of a series.
     *
     * ```ts
     *  // Example, progressive X line series with automatic data cleaning.
     *  const series = ChartXY.addLineSeries({
     *      dataPattern: {
     *          pattern: 'ProgressiveX'
     *      }
     *  })
     *      // Keep at least 1000 data points in series, otherwise excess out of view data can be cleaned for more memory.
     *      .setMaxPointCount(1000)
     *
     * // Setup automatically scrolling X Axis.
     * chart.getDefaultAxisX().setScrollStrategy(AxisScrollStrategies.progressive).setInterval(0, 1000)
     *
     *  // Continously stream data into series.
     *  let x = 0
     *  setInterval(() => {
     *      const newDataPoints = []
     *      for (let i = 0; i <= 10; i += 1) {
     *          newDataPoints.push({ x: x + i, y: Math.random() * 100 })
     *      }
     *      x += newDataPoints.length
     *      series.add(newDataPoints)
     *  }, 1000 / 60)
     * ```
     *
     * For *progressive* `LineSeries`, there is another way to enable automatic *data cleaning*: [[LineSeries.setDataCleaningThreshold]].
     *
     * Enabling automatic *data cleaning* is crucial in applications that run for a long time, or even *forever*,
     * because it allows clearing memory for allocating new data points.
     *
     * @param   maxPointCount   Configuration for automatic *data cleaning* by `maxPointCount`.
     *                          If undefined or 0 is passed, automatic *data cleaning* by `maxPointCount` will be disabled.
     * @returns                 Object itself for fluent interface.
     * @deprecated              Will be removed in v4.0 in favour of [[setDataCleaning]].
     */
    setMaxPointCount(maxPointCount?: number): this;
    /**
     * Solves the nearest datapoint to a given coordinate on screen.
     * @param   location    Location on screen
     * @return              Undefined or data-structure for positioning of cursors
     */
    solveNearestFromScreen(location: Point, interpolate?: boolean): undefined | CursorPoint;
    /**
     * Solves the nearest datapoint to a given coordinate on a screen from a specific segment.
     * @param   location    Location on screen
     * @param   segment     Segment to solve from
     * @return              Undefined or data-structure for positioning of cursors
     */
    solveNearestFromSegment(location: Point, segment: LineSet, interpolate?: boolean): undefined | CursorPoint;
}
/**
 * Interface for readonly configuration of [[LineSeries]].
 *
 * **Commonly used properties:**
 * - [[LineSeriesOptions.xAxis]]: Attach series on non-default X Axis.
 * - [[LineSeriesOptions.yAxis]]: Attach series on non-default Y Axis.
 * - [[LineSeriesOptions.dataPattern]]: Enable powerful application specific optimizations if input data follows a *specific pattern*.
 *
 * **Example usage:**
 *
 * ```typescript
 *  // Example 1, create series with default configuration.
 *  const series = ChartXY.addLineSeries({})
 * ```
 *
 * ```typescript
 *  // Example 2, attach series to non-default X Axis.
 *  const series = ChartXY.addLineSeries({
 *      xAxis: myNonDefaultAxisX
 *  })
 * ```
 *
 * ```typescript
 *  // Example 3, specify progressive X data pattern for enabling application specific optimizations.
 *  const series = ChartXY.addLineSeries({
 *      dataPattern: {
 *          // pattern: 'ProgressiveX' => Each consecutive data point has increased X coordinate.
 *          pattern: 'ProgressiveX',
 *          // regularProgressiveStep: true => The X step between each consecutive data point is regular (for example, always `1.0`).
 *          regularProgressiveStep: true,
 *      }
 *  })
 * ```
 *
 * See also [[ChartXY.addLineSeries]].
 */
export interface LineSeriesOptions extends SeriesOptions {
    /**
     * Interface for enabling powerful application specific optimizations if input data follows a *specific pattern*.
     *
     * See [[DataPattern]] to learn if your data is eligible for such optimizations.
     *
     * **Example usage:**
     *
     * ```typescript
     *  // Example, Line Chart with timestamp X values that always progress by exactly 1 minute (60000 ms).
     *  // => 'ProgressiveX' + regularProgressiveStep can be used
     *  ChartXY.addLineSeries({
     *      dataPattern: {
     *          // pattern: 'ProgressiveX' => Each consecutive data point has increased X coordinate.
     *          pattern: 'ProgressiveX',
     *          // regularProgressiveStep: true => The X step between each consecutive data point is regular (for example, always `1.0`).
     *          regularProgressiveStep: true,
     *      }
     *  })
     * ```
     */
    dataPattern?: DataPattern;
    /**
     * Flag that can be used to enable data points `value` property on top of `x` and `y`.
     * By default this is disabled.
     *
     * This feature can be used to color data points individually by dynamic color look up.
     *
     * If required, this must be enabled **when the series is created**.
     *
     * ```ts
     *  // Example, enable LineSeries data `value` property.
     *  const lineSeries = chart.addLineSeries({
     *      individualLookupValuesEnabled: true
     *  })
     *
     *  // 'value' property can now be included in data points.
     *  lineSeries.add([
     *      { x: 0, y: 0, z: 0, value: 5 }
     *  ])
     * ```
     *
     * `individualLookupValuesEnabled` must be enabled in order to style `LineSeries` with [[PalettedFill]] of `lookUpProperty: 'value'`.
     *
     * ```ts
     *  // Example, enable line coloring based on `value` property.
     *  lineSeries.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new PalettedFill({
     *          lookUpProperty: 'value',
     *          lut: new LUT({
     *              interpolate: true,
     *              steps: [
     *                  { value: 0, color: ColorRGBA(255, 0, 0) },
     *                  { value: 100, color: ColorRGBA(0, 255, 0) },
     *              ]
     *          })
     *      })
     *  }))
     * ```
     */
    individualLookupValuesEnabled?: boolean;
}
/**
 * Interface for a series which contains lines
 * @hidden
 */
export interface Lined {
    /**
     * Set lines style
     * @param   value     Line style object or function which modifies it
     * @returns           Series object (self)
     */
    setStrokeStyle: (value: SolidLine | ImmutableMutator<SolidLine>) => this;
    /**
     * @return Current lines style
     */
    getStrokeStyle: () => SolidLine;
    /**
     * Set highlight line style
     * @param   lineStyle  SolidLine for highlighted line or mutator to modify existing one or undefined for auto
     * @return             Object itself for fluent interface
     */
    setStrokeStyleHighlight: (lineStyle: SolidLine | ImmutableMutator<SolidLine> | undefined) => this;
    /**
     * @return  Current highlight line style
     */
    getStrokeStyleHighlight: () => SolidLine | undefined;
}
/**
 * Cursor-based visual that can be plotted on a XY Chart.
 * Like CursorXYs its built of four parts:
 * PointMarker shows the location of the Marker,
 * ResultTable displays information of the point
 * and X&Y tickMarkers to show gridstroke on its axes.
 * @hidden
 */
export interface MarkerXY<PointMarkerType extends PointMarker, ResultTableBackgroundType extends UIBackground> extends Marker<PointMarkerType, ResultTableBackgroundType, CursorXY<PointMarkerType, ResultTableBackgroundType>> {
    /**
     * Set visibility mode for gridstroke X.
     * @param   visibilityMode   Defines when part is visible
     * @return                  Object itself
     */
    setGridStrokeXVisibility(visibilityMode: UIVisibilityModes): this;
    /**
     * Get visibility mode for gridstroke X.
     * @return                  VisibilityMode
     */
    getGridStrokeXVisibility(): UIVisibilityModes;
    /**
     * Set visibility mode for gridstroke Y.
     * @param   visibilityMode   Defines when part is visible
     * @return                  Object itself
     */
    setGridStrokeYVisibility(visibilityMode: UIVisibilityModes): this;
    /**
     * Get visibility mode for gridstroke Y.
     * @return                  VisibilityMode
     */
    getGridStrokeYVisibility(): UIVisibilityModes;
    /**
     * Set visibility mode for tickMarker X.
     * @param   visibilityMode   Defines when part is visible
     * @return                  Object itself
     */
    setTickMarkerXVisibility(visibilityMode: UIVisibilityModes): this;
    /**
     * Get visibility mode for tickMarker X.
     * @return                  VisibilityMode
     */
    getTickMarkerXVisibility(): UIVisibilityModes;
    /**
     * Set visibility mode for tickMarker Y.
     * @param   visibilityMode   Defines when part is visible
     * @return                  Object itself
     */
    setTickMarkerYVisibility(visibilityMode: UIVisibilityModes): this;
    /**
     * Get visibility mode for tickMarker Y.
     * @return                  VisibilityMode
     */
    getTickMarkerYVisibility(): UIVisibilityModes;
}
/**
 * XY Marker that is basically a static cursor.
 * @hidden Internal class
 */
declare abstract class InternalChartMarkerXY<PointMarkerType extends PointMarker, ResultTableBackgroundType extends UIBackground> extends ChartMarker<PointMarkerType, ResultTableBackgroundType, InternalStaticCursorXY<PointMarkerType, ResultTableBackgroundType>> implements MarkerXY<PointMarkerType, ResultTableBackgroundType> {
    protected readonly _layer: Layer2D;
    readonly axisX: Axis;
    readonly axisY: Axis;
    protected _removeMarker: RemoveHandler<SeriesMarkerXY>;
    protected _restoreMarker: RestoreHandler<SeriesMarkerXY>;
    private gridStrokeStyleX;
    private gridStrokeStyleY;
    /**
     * @param   _layer          Rendering layer
     * @param   renderingScale  Rendering scale
     * @param   axisX           X axis of Marker
     * @param   axisY           Y axis of Marker
     * @param   CursorBuilder   CursorBuilder that defines look of Marker
     * @hidden
     */
    constructor(_layer: Layer2D, renderingScale: LinearScaleXY, axisX: Axis, axisY: Axis, CursorBuilder: StaticCursorXYBuilder<PointMarkerType, ResultTableBackgroundType>, _removeMarker: RemoveHandler<SeriesMarkerXY>, _restoreMarker: RestoreHandler<SeriesMarkerXY>, _theme: Theme);
    /**
     * Set visibility mode for gridstroke X.
     * @param   visibilityMode   Defines when part is visible
     * @return                  Object itself
     */
    setGridStrokeXVisibility(visibilityMode: UIVisibilityModes): this;
    /**
     * Get visibility mode for gridstroke X.
     * @return                  VisibilityMode
     */
    getGridStrokeXVisibility(): UIVisibilityModes;
    /**
     * Set visibility mode for gridstroke Y.
     * @param   visibilityMode   Defines when part is visible
     * @return                  Object itself
     */
    setGridStrokeYVisibility(visibilityMode: UIVisibilityModes): this;
    /**
     * Get visibility mode for gridstroke Y.
     * @return                  VisibilityMode
     */
    getGridStrokeYVisibility(): UIVisibilityModes;
    /**
     * Set visibility mode for tickMarker X.
     * @param   visibilityMode   Defines when part is visible
     * @return                  Object itself
     */
    setTickMarkerXVisibility(visibilityMode: UIVisibilityModes): this;
    /**
     * Get visibility mode for tickMarker X.
     * @return                  VisibilityMode
     */
    getTickMarkerXVisibility(): UIVisibilityModes;
    /**
     * Set visibility mode for tickMarker Y.
     * @param   visibilityMode   Defines when part is visible
     * @return                  Object itself
     */
    setTickMarkerYVisibility(visibilityMode: UIVisibilityModes): this;
    /**
     * Get visibility mode for tickMarker Y.
     * @return                  VisibilityMode
     */
    getTickMarkerYVisibility(): UIVisibilityModes;
    /**
     * Set is GridStrokeX cut at cursor location.
     * @param   cut         Boolean flag
     * @returns             Object itself for fluent interface
     */
    setGridStrokeXCut(cut: boolean): this;
    /**
     * Get is GridStrokeX cut at cursor location.
     * @returns             Boolean flag
     */
    getGridStrokeXCut(): boolean;
    /**
     * Set is GridStrokeY cut at cursor location.
     * @param   cut         Boolean flag
     * @returns             Object itself for fluent interface
     */
    setGridStrokeYCut(cut: boolean): this;
    /**
     * Get is GridStrokeY cut at cursor location.
     * @returns             Boolean flag
     */
    getGridStrokeYCut(): boolean;
    /**
     * Set style of x gridstroke
     * @param   value       LineStyle object or mutator to modify existing one
     * @returns             Object itself for fluent interface
     */
    setGridStrokeXStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of x gridstroke
     * @returns             LineStyle of gridstroke
     */
    getGridStrokeXStyle(): LineStyle;
    /**
     * Set style of y gridstroke
     * @param   value       LineStyle object or mutator to modify existing one
     * @returns             Object itself for fluent interface
     */
    setGridStrokeYStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of y gridstroke
     * @returns             LineStyle of gridstroke
     */
    getGridStrokeYStyle(): LineStyle;
    /**
     * Mutator function for x tick marker
     * @param   mutator     TickMarker mutator function
     * @returns             Object itself for fluent interface
     */
    setTickMarkerX(mutator: Mutator<TickMarker>): this;
    /**
     * Get x tick marker
     * @returns             X customTick of cursor
     */
    getTickMarkerX(): TickMarker;
    /**
     * Mutator function for y tick marker
     * @param   mutator     TickMarker mutator function
     * @returns             Object itself for fluent interface
     */
    setTickMarkerY(mutator: Mutator<TickMarker>): this;
    /**
     * Get y tick marker
     * @returns             Y customTick of cursor
     */
    getTickMarkerY(): TickMarker;
    /**
     * Set mouse interactions enabled or disabled
     * @param state Specifies state of mouse interactions
     * @return      Object itself for fluent interface
     */
    setMouseInteractions(state: boolean): this;
}
/**
 * Simple XY Marker that is basically a static cursor.
 * Like CursorXYs its built of four parts:
 * PointMarker shows the location of the Marker,
 * ResultTable displays information of the point
 * and X&Y tickMarkers to show gridstroke on its axes.
 */
export declare class ChartMarkerXY<PointMarkerType extends PointMarker = PointMarker, ResultTableBackgroundType extends UIBackground = UIBackground> extends InternalChartMarkerXY<PointMarkerType, ResultTableBackgroundType> {
}
/**
 * Marker that can be attached on a XY series.
 * Like CursorXYs its built of four parts:
 * PointMarker shows the location of the Marker,
 * ResultTable displays information of the point
 * and X&Y tickMarkers to show gridstroke on its axes.
 */
export declare class SeriesMarkerXY<PointMarkerType extends PointMarker = PointMarker, ResultTableBackgroundType extends UIBackground = UIBackground> extends ChartMarkerXY<PointMarkerType, ResultTableBackgroundType> {
    protected readonly _layer: Layer2D;
    readonly owningSeries: SeriesXY;
    protected _removeMarker: RemoveHandler<SeriesMarkerXY>;
    protected _restoreMarker: RestoreHandler<SeriesMarkerXY>;
    /**
     * @param   _layer          Rendering layer
     * @param   renderingScale  Rendering scale
     * @param   owningSeries    Series that owns marker
     * @param   CursorBuilder   CursorBuilder that defines look of Marker
     * @param   _removeMarker   Injected method to remove marker from owner's collection.
     * @hidden
     */
    constructor(_layer: Layer2D, renderingScale: LinearScaleXY, owningSeries: SeriesXY, CursorBuilder: StaticCursorXYBuilder<PointMarkerType, ResultTableBackgroundType>, _removeMarker: RemoveHandler<SeriesMarkerXY>, _restoreMarker: RestoreHandler<SeriesMarkerXY>, _theme: Theme);
    /**
     * Set position of SeriesMarker.
     * @param   position    Location on SeriesMarkers scale. Marker will be attached to closest datapoint on its series.
     * @returns             Object itself
     */
    setPosition(position: Point): this;
    /**
     * @returns True if object is attached or not attachable, false if it is not attached and attachable
     */
    isAttached(): boolean;
}
export {};
/**
 * PointLineSeries implementation of BasicSeries (actually extends PointSeries),
 * that uses both PointSets and LineSets as its segments
 */
/**
 * Implementation of *SeriesXY* for visualizing a collection of *Points* with a specifiable [[PointShape]]
 * and connected lines.
 *
 * *PointLineSeries* are created with [[ChartXY.addPointLineSeries]]
 */
export declare class PointLineSeries extends BasicSeries<LineSet, Point, LinearScaleXY> implements Lined, Pointed, IndividualPointed {
    /**
     * Append a single `XY` coordinate or list of `XY` coordinates into the *series*.
     *
     * ```ts
     *  // Example syntax
     *  LineSeries.add({ x: 0, y: 100 })
     *
     *  LineSeries.add([
     *      { x: 0, y: 100 },
     *      { x: 10, y: 50 },
     *      { x: 20, y: 75 },
     *  ])
     * ```
     *
     * Point series also allow a set of extra properties that can be supplied for each data point:
     *
     * - `color`    | Associate data point with a color. Can be used for individual point coloring, when point fill style is [[IndividualPointFill]].
     * - `size`     | Associate data point with a size. Can be used for individual point size. Must be enabled with [[setIndividualPointSizeEnabled]].
     * - `rotation` | Associate data point with a rotation. Can be used for individual point rotation. Must be enabled with [[setIndividualPointRotationEnabled]].
     * - `value`    | Associate data point with a value. Can be used for paletted point coloring. Must be enabled with [[setIndividualPointValueEnabled]].
     *
     * ```ts
     *  PointLineSeries
     *      .setIndividualPointSizeEnabled(true)
     *      .setIndividualPointRotationEnabled(true)
     *      .setIndividualPointValueEnabled(true)
     *      .add({
     *          x: 0,
     *          y: 0,
     *          color: ColorRGBA(255, 0, 0),
     *          size: 10,
     *          rotation: 45,
     *          value: 62.5
     *      })
     * ```
     *
     * For more methods of appending data into series, see:
     *
     * - [[addArrayY]] | Append only Y coordinates.
     * - [[addArrayX]] | Append only X coordinates.
     * - [[addArraysXY]] | Append X and Y coordinates in separate arrays.
     *
     * @param    points  Single XY coordinate or list of coordinates.
     * @returns          Object itself for fluent interface.
     */
    add(points: PointSeriesDataPoint | Array<PointSeriesDataPoint>): this;
    /**
     * Set stroke style of Series.
     *
     * ```ts
     *  // Example syntax, specify LineStyle
     *  LineSeries.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorHEX('#F00') })
     *  }))
     * ```
     *
     * ```ts
     *  // Example syntax, change active LineStyle
     *  LineSeries.setStrokeStyle((stroke) => stroke.setThickness(5))
     * ```
     *
     * Use `-1` thickness to enable primitive line rendering.
     * Primitive line rendering can have slightly better rendering performance than line with `1` thickness but the quality of line is not as good.
     * ```typescript
     *  LineSeries.setStrokeStyle((solidLine) => solidLine.setThickness(-1))
     * ```
     *
     * **Supported fill styles:**
     *
     * [[SolidFill]]:
     *
     * Solid color for entire line series.
     *
     * ```ts
     *  // Example, solid colored line.
     *  LineSeries.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
     *  }))
     * ```
     *
     * To learn more about available *Color* factories, see [[ColorRGBA]]
     *
     * [[PalettedFill]]:
     *
     * Color line stroke dynamically based on `x` or `y` coordinate.
     *
     * ```ts
     *  // Example, dynamic color by Y coordinates
     *  LineSeries.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new PalettedFill({
     *          lookUpProperty: 'y',
     *          lut: new LUT({
     *              interpolate: true,
     *              steps: [
     *                  { value: 0, color: ColorRGBA(255, 0, 0) },
     *                  { value: 100, color: ColorRGBA(0, 255, 0) },
     *              ]
     *          })
     *      })
     *  }))
     * ```
     *
     * To learn more about Color lookup tables, see [[LUT]].
     *
     * [[LinearGradientFill]]:
     *
     * Color line stroke with a linear configurable gradient palette.
     *
     * ```ts
     *  // Example, linear gradient line color
     *  LineSeries.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new LinearGradientFill()
     *  }))
     * ```
     *
     * To learn more about linear gradient configurations, see [[LinearGradientFill]].
     *
     * [[RadialGradientFill]]:
     *
     * Color line stroke with a radial configurable gradient palette.
     *
     * ```ts
     *  // Example, radial gradient line color
     *  LineSeries.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new RadialGradientFill()
     *  }))
     * ```
     *
     * To learn more about radial gradient configurations, see [[RadialGradientFill]].
     *
     * @param   value   Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
     * @returns         Object itself for fluent interface.
     */
    setStrokeStyle(value: SolidLine | ImmutableMutator<SolidLine>): this;
    /**
     * Get stroke style of Series.
     * @return  SolidLine object
     */
    getStrokeStyle(): SolidLine;
    /**
     * Set stroke style of Series when it is highlighted.
     * Highlighting is activated by placing mouse on top / touching Series (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     *
     * Example usage:
     *```javascript
     * // Specified LineStyle
     * LineSeries.setStrokeStyleHighlight(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * LineSeries.setStrokeStyleHighlight((solidLine) => solidLine.setThickness(5))
     * // Hidden must be done with transparentLine, emptyLine is not supported
     * LineSeries.setStrokeStyleHighlight(transparentLine)
     * // Automatic
     * LineSeries.setStrokeStyleHighlight(undefined)
     * ```
     * @param   value   Either a SolidLine object or a function, which will be used to modify current value or
     *                  undefined for automatic value based on normal style.
     * @returns         Chart itself
     */
    setStrokeStyleHighlight(value: SolidLine | ImmutableMutator<SolidLine> | undefined): this;
    /**
     * Get stroke style of Series when it is highlighted.
     * Highlighting is activated by placing mouse on top / touching Series (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     * @return  SolidLine object
     */
    getStrokeStyleHighlight(): SolidLine;
    /**
     * Set point fill style of Series.
     * Use [[IndividualPointFill]] to enable individual coloring of points.
     *
     * Example usage:
     *```javascript
     * // Create a new style
     * PointLineSeries.setPointFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Change transparency
     * PointLineSeries.setPointFillStyle((solidFill) => solidFill.setA(80))
     * // Set hidden
     * PointLineSeries.setPointFillStyle(emptyFill)
     * ```
     * @param fillStyle     Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns             Series itself for fluent interface.
     */
    setPointFillStyle(fillStyle: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get normal points fill style.
     * @return  Normal point fill style.
     */
    getPointFillStyle(): FillStyle;
    /**
     * Set point fill style of Series when it is highlighted.
     * Use [[IndividualPointFill]] to enable individual coloring of points.
     *
     * Example usage:
     *```javascript
     * // Create a new style
     * PointLineSeries.setPointFillStyleHighlight(new SolidFill({ color: ColorHEX('#F00') }))
     * // Change transparency
     * PointLineSeries.setPointFillStyleHighlight((solidFill) => solidFill.setA(80))
     * // Set hidden
     * PointLineSeries.setPointFillStyleHighlight(emptyFill)
     * // Automatic
     * PointLineSeries.setPointFillStyleHighlight(undefined)
     * ```
     * @param value Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value or
     *              undefined for automatic value based on normal style.
     * @returns     Series itself for fluent interface.
     */
    setPointFillStyleHighlight(value: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * @return  Current highlight point fill style
     */
    getPointFillStyleHighlight(): FillStyle;
    /**
     * Set size of point in pixels
     * @param   size    Size of point in pixels
     * @returns         Object itself for fluent interface
     */
    setPointSize(size: number): this;
    /**
     * @returns Size of point in pixels
     */
    getPointSize(): number;
    /**
     * Get shape of points.
     *
     * This is defined upon creation of series, and cannot be changed afterwards.
     * @returns PointShape
     */
    getPointShape(): PointShape;
    /**
     * Set the rotation of points.
     * @param angle Rotation angle in degrees
     */
    setPointRotation(angle: number): this;
    /**
     * Get the current rotation of points.
     */
    getPointRotation(): number;
    /**
     * Enable or disable individual point sizing.
     *
     * When enabled, size for each point can be provided with the location of the point.
     * ```js
     * pointSeries.add({x: 1, y: 2, size: 10 })
     * ```
     * @param enabled Boolean state for individual point size enabled
     */
    setIndividualPointSizeEnabled(enabled: boolean): this;
    /**
     * Gets if individual point sizing is enabled or not.
     */
    getIndividualPointSizeEnabled(): boolean;
    /**
     * Enable or disable individual point rotation.
     *
     * When enabled, rotation for each point can be provided with the location of the point.
     * ```js
     * pointSeries.add({x: 1, y: 2, rotation: 45 })
     * ```
     * @param enabled Boolean state for individual point size enabled
     */
    setIndividualPointRotationEnabled(enabled: boolean): this;
    /**
     * Gets if individual point rotation is enabled or not.
     */
    getIndividualPointRotationEnabled(): boolean;
    /**
     * Enable or disable individual point value attributes.
     *
     * When enabled, each added data point can be associated with a numeric `value` attribute.
     *
     * ```typescript
     *  PointLineSeries.add({ x: 1, y: 2, value: 10 })
     * ```
     *
     * Can be used for dynamic per data point coloring when points are styled with [[PalettedFill]].
     * See [[setPointFillStyle]].
     *
     * @param enabled   Individual point values enabled or disabled.
     */
    setIndividualPointValueEnabled(enabled: boolean): this;
    /**
     * Gets if individual point values are enabled or disabled.
     */
    getIndividualPointValueEnabled(): boolean;
    /**
     * Set if cursor interpolates solved data-points along series by default.
     *
     * ```typescript
     *  // Example, disable default interpolation of progressiveX point line series.
     *  const series = ChartXY.addPointLineSeries({
     *      dataPattern: {
     *          pattern: 'ProgressiveX'
     *      }
     *  })
     *      .setCursorInterpolationEnabled(false)
     * ```
     *
     * Cursor interpolation is only supported with a collection of configuration combinations:
     *
     * - *Freeform data* + *cursor solve basis* = `'nearest'`
     * - *ProgressiveX data* + *cursor solve basis* = `'nearestX'`
     * - *ProgressiveY data* + *cursor solve basis* = `'nearestY'`
     *
     * With any other combination, or if cursor intepolation is disabled, the closest actual data point will be selected.
     *
     * **Related API:**
     * - Information about specifying series *data pattern* [[ChartXY.addPointLineSeries]]
     * - *Cursor solve basis* [[PointLineSeries.setCursorSolveBasis]]
     *
     * **Related API:**
     *
     * - [[setCursorEnabled]] | configure whether *cursors* should pick on this particular *series* or not.
     * - [[setCursorResultTableFormatter]] | configure formatting of *result table* contents, when this series is pointed.
     * - [[setCursorSolveBasis]] | configure basis of finding nearest data point for the series (`'nearest-x'`, `'nearest'`, etc.).
     * - [[ChartXY.setAutoCursorMode]] | configure behavior when auto cursor is visible.
     *
     * @param   state   Boolean flag
     * @returns         Object itself for fluent interface
     */
    setCursorInterpolationEnabled(state: boolean): this;
    /**
     * Get if cursor interpolates solved data-points along series by default.
     * @returns         Boolean flag
     */
    getCursorInterpolationEnabled(): boolean;
    /**
     * Set basis of solving data point nearest to a given location from this series.
     *
     * Default configuration is `'nearest-x'`.
     *
     * ```typescript
     *  // Example, configure series cursor to snap to closest data point along both X and Y dimensions.
     *  PointLineSeries.setCursorSolveBasis('nearest')
     * ```
     *
     * **Related API:**
     *
     * - [[setCursorEnabled]] | configure whether *cursors* should pick on this particular *series* or not.
     * - [[setCursorResultTableFormatter]] | configure formatting of *result table* contents, when this series is pointed.
     * - [[setCursorInterpolationEnabled]] | configure automatic cursor interpolation between data points enabled.
     * - [[ChartXY.setAutoCursorMode]] | configure behavior when auto cursor is visible.
     *
     * @param   basis   String describing the desired solve behavior.
     */
    setCursorSolveBasis(basis: 'nearest' | 'nearest-x' | 'nearest-y'): this;
    /**
     * Get basis of solving data point nearest to a given location from this series.
     *
     * Default configuration is `'nearest'`.
     *
     * @return          String describing the desired solve behavior.
     */
    getCursorSolveBasis(): 'nearest' | 'nearest-x' | 'nearest-y';
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Series itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick?: boolean): this;
    /**
     * @hidden
     */
    getPointAmount(): number;
    /**
     * Enable or disable forced highlighting of series
     * @param highlight True for enabled and false for disabled
     * @returns         Series itself for fluent interface
     */
    setHighlighted(highlight: boolean): this;
    /**
     * Clear all previously pushed data points from the *series*.
     *
     * ```ts
     *  // Example usage
     *  LineSeries.clear()
     * ```
     *
     * @return      Object itself for fluent interface.
     */
    clear(): this;
    /**
     * Remove everything related to the object from all collections associated
     * with rendering cycle and allows the object to be collected by GC
     * @return Object itself for fluent interface
     */
    dispose(): this;
    /**
     * Tell the owning chart to restore this series.
     * @return  Object itself.
     */
    restore(): this;
    /**
     * Solves the nearest datapoint to a given coordinate on screen.
     * @param   location    Location on screen
     * @return              Undefined or data-structure for positioning of cursors
     */
    solveNearestFromScreen(location: Point, interpolate?: boolean): undefined | CursorPoint;
    /**
     * Solves the nearest datapoint to a given coordinate on a screen from a specific segment.
     * @param   location    Location on screen
     * @param   segment     Segment to solve from
     * @return              Undefined or data-structure for positioning of cursors
     */
    solveNearestFromSegment(location: Point, segment: LineSet | PointSet, interpolate?: boolean): undefined | CursorPoint;
}
/**
 * Interface for readonly configuration of [[PointLineSeries]].
 *
 * **Commonly used properties:**
 * - [[PointLineSeriesOptions.pointShape]]: Specify shape of *point markers*.
 * - [[PointLineSeriesOptions.xAxis]]: Attach series on non-default X Axis.
 * - [[PointLineSeriesOptions.yAxis]]: Attach series on non-default Y Axis.
 * - [[PointLineSeriesOptions.dataPattern]]: Enable powerful application specific optimizations if input data follows a *specific pattern*.
 *
 * **Example usage:**
 *
 * ```typescript
 *  // Example 1, create series with default configuration.
 *  const series = ChartXY.addPointLineSeries({})
 * ```
 *
 * ```typescript
 *  // Example 2, select shape of point markers.
 *  const series = ChartXY.addPointLineSeries({
 *      pointShape: PointShape.Circle
 *  })
 * ```
 *
 * ```typescript
 *  // Example 3, specify progressive X data pattern for enabling application specific optimizations.
 *  const series = ChartXY.addPointLineSeries({
 *      dataPattern: {
 *          // pattern: 'ProgressiveX' => Each consecutive data point has increased X coordinate.
 *          pattern: 'ProgressiveX',
 *          // regularProgressiveStep: true => The X step between each consecutive data point is regular (for example, always `1.0`).
 *          regularProgressiveStep: true,
 *      }
 *  })
 * ```
 */
export interface PointLineSeriesOptions extends SeriesOptions {
    /**
     * Shape of *point markers*.
     *
     * Select value from [[PointShape]].
     *
     * ```typescript
     *  // Example, select Circle shape of points.
     *  const series = ChartXY.addPointLineSeries({
     *      pointShape: PointShape.Circle
     *  })
     * ```
     */
    pointShape?: PointShape;
    /**
     * Interface for enabling powerful application specific optimizations if input data follows a *specific pattern*.
     *
     * See [[DataPattern]] to learn if your data is eligible for such optimizations.
     *
     * **Example usage:**
     *
     * ```typescript
     *  // Example, Line Chart with timestamp X values that always progress by exactly 1 minute (60000 ms).
     *  // => 'ProgressiveX' + regularProgressiveStep can be used
     *  ChartXY.addLineSeries({
     *      dataPattern: {
     *          // pattern: 'ProgressiveX' => Each consecutive data point has increased X coordinate.
     *          pattern: 'ProgressiveX',
     *          // regularProgressiveStep: true => The X step between each consecutive data point is regular (for example, always `1.0`).
     *          regularProgressiveStep: true,
     *      }
     *  })
     * ```
     */
    dataPattern?: DataPattern;
}
/**
 * PointSeries, extension of BasicSeries using PointSets
 */
/**
 * Interface for data points that can be added to a [[PointSeries]].
 */
export interface PointSeriesDataPoint extends Point, ColorValue, SizeValue, RotationValue, DataValue {
}
/**
 * Implementation of *SeriesXY* for visualizing a collection of *Points* by filling them with a specifiable [[PointShape]].
 *
 * *PointSeries* are created with [[ChartXY.addPointSeries]].
 *
 * NOTE: Points shape must be specified when series is created.
 *
 * Frequently used API:
 *
 * - Enable individual point size [[setIndividualPointSizeEnabled]]
 * - Enable individual point rotation [[setIndividualPointRotationEnabled]]
 * - Enable individual point palette coloring [[setIndividualPointValueEnabled]]
 * - Append data points to series | [[add]]
 * - Remove all data points from series | [[clear]]
 * - Configure style of points | [[setPointFillStyle]]
 * - Configure size of points | [[setPointSize]]
 * - Configure cursor enabled | [[setCursorEnabled]]
 * - Remove series temporarily, or permanently | [[dispose]]
 * - Restore series after `dispose` | [[restore]]
 * - Configure automatic data cleaning | [[setDataCleaning]]
 * - Solve nearest data point from specified location | [[solveNearestFromScreen]]
 */
export declare class PointSeries extends BasicSeries<PointSet, PointSeriesDataPoint, LinearScaleXY | MixedScaleXY> implements Pointed, IndividualPointed, AttachableWithLUT {
    protected readonly _pointShape: PointShape;
    /**
     * @param chart                 Owning Chart
     * @param _removeFromChart      Handler for removing reference to series from owning chart
     * @param _restoreFromChart     Handler for restoring reference to series from owning chart
     * @param _layer                Rendering layer
     * @param axisX                 Axis X
     * @param axisY                 Axis Y
     * @param axisXAttachHandler    Attach handler for Axis X
     * @param axisYAttachHandler    Attach handler for Axis Y
     * @param _newUILayer           Factory for creating new UI layers for drawing SeriesMarkers
     * @param _pointShape           Shape of rendered points
     * @param _theme                Theme from owning Chart, used for styling
     * @hidden
     */
    constructor(chart: ChartXY, _removeFromChart: RemoveHandler<ChartComponent>, _restoreFromChart: RestoreHandler<ChartComponent>, _layer: Layer2D, axisX: Axis, axisY: Axis, axisXAttachHandler: AxisAttachHandler, axisYAttachHandler: AxisAttachHandler, _newUILayer: () => Layer2D, _pointShape: PointShape, _theme: Theme, automaticColorIndex: number);
    /**
     * Append a single `XY` coordinate or list of coordinates into the *series*.
     *
     * ```ts
     *  // Example syntax
     *  PointSeries.add({ x: 0, y: 100 })
     *
     *  PointSeries.add([
     *      { x: 0, y: 100 },
     *      { x: 10, y: 50 },
     *      { x: 20, y: 75 },
     *  ])
     * ```
     *
     * **Additional extra data point properties**
     *
     * There is also a set of extra properties that can be supplied for each data point:
     *
     * - `color`    | Associate data point with a color. Can be used for individual point coloring, when point fill style is [[IndividualPointFill]].
     * - `size`     | Associate data point with a size. Can be used for individual point size. Must be enabled with [[setIndividualPointSizeEnabled]].
     * - `rotation` | Associate data point with a rotation. Can be used for individual point rotation. Must be enabled with [[setIndividualPointRotationEnabled]].
     * - `value`    | Associate data point with a value. Can be used for paletted point coloring. Must be enabled with [[setIndividualPointValueEnabled]].
     *
     * ```ts
     *  PointSeries
     *      .setIndividualPointSizeEnabled(true)
     *      .setIndividualPointRotationEnabled(true)
     *      .setIndividualPointValueEnabled(true)
     *      .add({
     *          x: 0,
     *          y: 0,
     *          color: ColorRGBA(255, 0, 0),
     *          size: 10,
     *          rotation: 45,
     *          value: 62.5
     *      })
     * ```
     *
     * @param    points  Single XY coordinate or list of coordinates.
     * @returns          Object itself for fluent interface.
     */
    add(points: PointSeriesDataPoint | Array<PointSeriesDataPoint>): this;
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Series itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick?: boolean): this;
    /**
     * Set point fill style of Series.
     * Use [[IndividualPointFill]] object to enable individual coloring of points.
     *
     * Example usage:
     *```javascript
     * // Create a new style
     * PointSeries.setPointFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Change transparency
     * PointSeries.setPointFillStyle((solidFill) => solidFill.setA(80))
     * // Set hidden
     * PointSeries.setPointFillStyle(emptyFill)
     * ```
     * @param fillStyle     Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns             Series itself for fluent interface.
     */
    setPointFillStyle(fillStyle: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get normal points fill style.
     * @return  Normal point fillStyle
     */
    getPointFillStyle(): FillStyle;
    /**
     * Set point fill style of Series when it is highlighted.
     *
     * Example usage:
     *```javascript
     * // Create a new style
     * PointSeries.setPointFillStyleHighlight(new SolidFill({ color: ColorHEX('#F00') }))
     * // Change transparency
     * PointSeries.setPointFillStyleHighlight((solidFill) => solidFill.setA(80))
     * // Set hidden
     * PointSeries.setPointFillStyleHighlight(emptyFill)
     * // Automatic
     * PointSeries.setPointFillStyleHighlight(undefined)
     * ```
     * @param value Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value or
     *              undefined for automatic value based on normal style.
     * @returns     Series itself for fluent interface.
     */
    setPointFillStyleHighlight(value: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * Get current highlight fill style of points.
     * @return  Current highlight point fill style
     */
    getPointFillStyleHighlight(): FillStyle;
    /**
     * Set size of point in pixels.
     * @param   size    Size of point in pixels.
     * @returns         Object itself for fluent interface.
     */
    setPointSize(size: number): this;
    /**
     * Get current size of points in pixels.
     * @returns Size of point in pixels.
     */
    getPointSize(): number;
    /**
     * Get shape of points.
     *
     * This is defined upon creation of series, and cannot be changed afterwards.
     * @returns PointShape
     */
    getPointShape(): PointShape;
    /**
     * Set the rotation of points in degrees.
     * @param angle Rotation angle in degrees
     */
    setPointRotation(angle: number): this;
    /**
     * Get the current rotation of points.
     */
    getPointRotation(): number;
    /**
     * Enable or disable individual point sizing.
     *
     * When enabled, size for each point can be provided with the location of the point.
     * ```js
     * pointSeries.add({x: 1, y: 2, size: 10 })
     * ```
     * @param enabled Boolean state for individual point size enabled
     */
    setIndividualPointSizeEnabled(enabled: boolean): this;
    /**
     * Gets if individual point sizing is enabled or not.
     */
    getIndividualPointSizeEnabled(): boolean;
    /**
     * Enable or disable individual point rotation.
     *
     * When enabled, rotation for each point can be provided with the location of the point.
     * ```js
     * pointSeries.add({x: 1, y: 2, rotation: 45 })
     * ```
     * @param enabled Boolean state for individual point size enabled
     */
    setIndividualPointRotationEnabled(enabled: boolean): this;
    /**
     * Gets if individual point rotation is enabled or not.
     */
    getIndividualPointRotationEnabled(): boolean;
    /**
     * Enable or disable individual point value attributes.
     *
     * When enabled, each added data point can be associated with a numeric `value` attribute.
     *
     * ```typescript
     *  PointSeries.add({ x: 1, y: 2, value: 10 })
     * ```
     *
     * Can be used for dynamic per data point coloring when points are styled with [[PalettedFill]].
     * See [[setPointFillStyle]].
     *
     * @param enabled   Individual point values enabled or disabled.
     */
    setIndividualPointValueEnabled(enabled: boolean): this;
    /**
     * Gets if individual point values are enabled or disabled.
     */
    getIndividualPointValueEnabled(): boolean;
    /**
     * Solves the nearest data point to a given coordinate on screen.
     * @param   location    Location on screen
     * @return              Undefined or data-structure for positioning of cursors
     */
    solveNearestFromScreen(location: Point): undefined | CursorPoint;
    /**
     * Solves the nearest datapoint to a given coordinate on a screen from a specific segment.
     * @param   location    Location on screen
     * @param   segment     Segment to solve from
     * @return              Undefined or data-structure for positioning of cursors
     */
    solveNearestFromSegment(location: Point, segment: PointSet): undefined | CursorPoint;
}
/**
 * Interface can be used to define the X and Y Axis that a series should be attached to,
 * and define Shape for points of series.
 */
export interface PointSeriesOptions extends SeriesOptions {
    /**
     * PointShape Shape for points of series.
     */
    pointShape?: PointShape;
}
/**
 * Interface for a series which contains points
 * @hidden
 */
export interface Pointed {
    /**
     * Set point fill style
     * @param   pointColor FillStyle for points or mutator to modify existing one
     * @returns            Series object (self)
     */
    setPointFillStyle: (pointColor: FillStyle | ImmutableMutator<FillStyle>) => this;
    /**
     * @return  Current point fill style
     */
    getPointFillStyle: () => FillStyle;
    /**
     * Set highlight point fill style
     * @param   fillStyle  FillStyle for highlighted points or mutator to modify existing one
     * @return             Object itself for fluent interface
     */
    setPointFillStyleHighlight(fillStyle: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * @return  Current highlight point fill style
     */
    getPointFillStyleHighlight: () => FillStyle | undefined;
    /**
     * Set size of point in pixels
     * @param   size    Size of point in pixels
     * @returns         Object itself for fluent interface
     */
    setPointSize(size: number): this;
    /**
     * @returns Size of point in pixels
     */
    getPointSize(): number;
    /**
     * Get shape of points.
     *
     * This is defined upon creation of Series, and cannot be changed afterwards.
     * @returns Shape of points
     */
    getPointShape(): PointShape;
    /**
     * Set the rotation of points.
     * @param angle Rotation angle in degrees
     */
    setPointRotation(angle: number): this;
    /**
     * Get the current rotation of points.
     */
    getPointRotation(): number;
}
/**
 * Interface for a series which contains individually sizeable an rotatable points
 * @hidden
 */
export interface IndividualPointed {
    /**
     * Enable or disable individual point sizing.
     *
     * When enabled, size for each point can be provided with the location of the point.
     * ```js
     * pointSeries.add({x: 1, y: 2, size: 10 })
     * ```
     * @param enabled Boolean state for individual point size enabled
     */
    setIndividualPointSizeEnabled(enabled: boolean): this;
    /**
     * Gets if individual point sizing is enabled or not.
     */
    getIndividualPointSizeEnabled(): boolean;
    /**
     * Enable or disable individual point rotation.
     *
     * When enabled, rotation for each point can be provided with the location of the point.
     * ```js
     * pointSeries.add({x: 1, y: 2, rotation: 45 })
     * ```
     * @param enabled Boolean state for individual point size enabled
     */
    setIndividualPointRotationEnabled(enabled: boolean): this;
    /**
     * Gets if individual point rotation is enabled or not.
     */
    getIndividualPointRotationEnabled(): boolean;
}
/**
 * SeriesXY
 *
 * Extension of Series2D
 * Adds Axes, filling, setEnabled, CursorXY, abstract hover functionality (for highlighting/custom cursor logic)
 *
 */
/**
 * Abstract super-class for 2D-series with X&Y axes
 * @hidden Internal class
 */
export declare abstract class SeriesXY<VisualType extends ChartVisual = ChartVisual, CursorPointInterface extends CursorPoint = CursorPoint, ScaleType extends ScaleXY = ScaleXY> extends Series2D<VisualType, CursorPointInterface> {
    readonly chart: ChartXY;
    protected readonly _layer: Layer2D;
    readonly axisX: Axis;
    readonly axisY: Axis;
    private axisXAttachHandler;
    private axisYAttachHandler;
    private readonly _newUILayer;
    /**
     * Scale of the series
     */
    readonly scale: ScaleType;
    /**
     * @param _chart                Parent Chart
     * @param _removeFromChart      Handler for removing reference to series from owning chart
     * @param _restoreFromChart     Handler for restoring reference to series from owning chart
     * @param _layer                Rendering layer
     * @param axisX                 Axis X
     * @param axisY                 Axis Y
     * @param axisXAttachHandler    Attach handler for Axis X
     * @param axisYAttachHandler    Attach handler for Axis Y
     * @param _newUILayer           Factory for creating new UI layers for drawing SeriesMarkers
     * @param _theme                Theme from owning Chart.
     * @hidden
     */
    constructor(chart: ChartXY, _removeFromChart: RemoveHandler<ChartComponent>, _restoreFromChart: RestoreHandler<ChartComponent>, _layer: Layer2D, axisX: Axis, axisY: Axis, axisXAttachHandler: AxisAttachHandler, axisYAttachHandler: AxisAttachHandler, _newUILayer: () => Layer2D, _theme: Theme);
    /**
     * Attach and cache returned remove handler
     */
    private attacheAxis;
    /**
     * Add Marker to the Series.
     * @param   cursorBuilder   StaticCursorBuilderXY object for customized look of marker.
     *                          MarkerBuilders.XY can be used to build a custom one from scratch.
     * @returns                 SeriesMarkerXY
     */
    addMarker: <PointMarkerType extends PointMarker, ResultTableBackgroundType extends UIBackground>(cursorBuilder?: StaticCursorXYBuilder<PointMarkerType, ResultTableBackgroundType>) => SeriesMarkerXY<PointMarkerType, ResultTableBackgroundType>;
    /**
     * Remove everything related to the object from all collections associated
     * with rendering cycle and allows the object to be collected by GC
     * @return Object itself for fluent interface
     */
    dispose(): this;
    /**
     * Tell the owning chart to restore this series.
     * @return  Object itself.
     */
    restore(): this;
    /**
     * Remove the given marker from the collection of markers this Series has.
     * @param   marker  Marker to remove.
     */
    private removeMarker;
    /**
     * Restores the given marker to the collection.
     * @param   marker  Marker to remove.
     */
    private restoreMarker;
    /**
     * @return Max X value of the series
     */
    abstract getXMax(): number | undefined;
    /**
     * @return Min X value of the series
     */
    abstract getXMin(): number | undefined;
    /**
     * @return Max Y value of the series
     */
    abstract getYMax(): number | undefined;
    /**
     * @return Min Y value of the series
     */
    abstract getYMin(): number | undefined;
    getBoundaries(): Interval<Point>;
}
/**
 * Interface for SeriesXY types whose data can be observed in detail.
 *
 * The intent is that all SeriesXY types implement this, apart from Figure series. It is used for ZoomBandChart functionality.
 * @typeparam   T   Type of data-point in Series (eq. Point, AreaPoint, XOHLC, ...).
 * @hidden
 */
export interface ObservableXYData<T> {
}
/**
 * Type union of Series supported by ZoomBandChart.
 * @hidden
 */
declare type ZoomBandChartSupportedSeries = BasicSeries | AreaSeries | AreaRangeSeries | OHLCSeries | HeatmapGridSeriesIntensityValues;
/**
 * Type of a function that is used to override the style of all Series created by ZoomBandChart.
 *
 * @param   series              The Series created by ZoomBandChart. The type of Series depends on the referenced series.
 * @param   referencedSeries    The Series that is being referenced.
 *                              If [[AreaRangeSeries]], series is also [[AreaRangeSeries]].
 *                              If [[HeatmapGridSeriesIntensityValues]], series is also [[HeatmapGridSeriesIntensityValues]].
 *                              Otherwise, series is always [[LineSeries]].
 */
export declare type ZoomBandChartSeriesStyler = {
    (series: LineSeries, referencedSeries: BasicSeries | AreaSeries | OHLCSeries): unknown;
    (series: AreaRangeSeries, referencedSeries: AreaRangeSeries): unknown;
    (series: HeatmapGridSeriesIntensityValues, referencedSeries: HeatmapGridSeriesIntensityValues): unknown;
    (series: StepSeries, referencedSeries: StepSeries): unknown;
};
/**
 * Chart that is attached to a single [[Axis]] of a [[ChartXY]].
 *
 * It shows a compilation of all data from all *Series* that are attached to that [[Axis]], and allows
 * the user to configure the view of the attached [[Axis]] easily by interacting with a [[Band]] on the *ZoomBandChart*.
 *
 * Created with [[Dashboard.createZoomBandChart]].
 * ```javascript
 *
 *  const dashboard = lightningChart().Dashboard( {
 *      numberOfColumns: 1,
 *      numberOfRows: 4
 *  } )
 *
 *  const chart = dashboard.createChartXY( {
 *      columnIndex: 0,
 *      columnSpan: 1,
 *      rowIndex: 0,
 *      rowSpan: 3
 *  })
 *
 *  const zoomBandChart = dashboard.createZoomBandChart({
 *      columnIndex: 0,
 *      columnSpan: 1,
 *      rowIndex: 3,
 *      rowSpan: 1,
 *      axis: chart.getDefaultAxisX()
 *  })
 *
 *  const line = chart.addLineSeries()
 *  createProgressiveTraceGenerator()
 *      .setNumberOfPoints( 1000 )
 *      .generate()
 *      .toPromise()
 *      .then( data => line.add( data ) )
 *
 * ```
 */
export declare class ZoomBandChart implements Control, DashboardPanel, ChartAPI {
    /**
     * Public, safe interface of rendering engine.
     */
    readonly engine: PublicEngine;
    /**
     * The Band of the ZoomBandChart.
     */
    readonly band: Band;
    /**
     * List of axes that are attached to the ZoomBandChart.
     */
    readonly attachedAxes: Axis[];
    /**
     * Axis that is attached to the ZoomBandChart.
     *
     * If ZoomBandChart is attached to several axis, this will reference only the first one.
     *
     * @deprecated  Will be removed in v.4.0 in favour of [[attachedAxes]]
     */
    readonly attachedAxis: Axis;
    /**
     * Dispose a Series reference from the ZoomBandChart.
     *
     * This ensures that all resources that were previously allocated for this series instance are released for Garbage Collection.
     * @param   series  Series object.
     * @return          Object itself.
     */
    disposeSeries(series: ZoomBandChartSupportedSeries): this;
    /**
     * Set style of Series of ZoomBandChart.
     *
     * ZoomBandChart creates series automatically based on the Series attached to the ZoomBandCharts reference Axis,
     * that is specified when it is created. This method lets the user specify a function that is called on each Series created by
     * ZoomBandChart, allowing the full configuration of these Series.
     */
    setSeriesStyle(styler: ZoomBandChartSeriesStyler): this;
    /**
     * Get the X Axis of the ZoomBandChart.
     * @returns Axis
     */
    getDefaultAxisX(): Axis;
    /**
     * Get the Y Axis of the ZoomBandChart.
     * @returns Axis
     */
    getDefaultAxisY(): Axis;
    /**
     * Get minimum size of Panel.
     * Depending on the type of class this value might be automatically computed to fit different elements.
     * @return  Point minimum size or undefined if unimplemented
     */
    getMinimumSize(): Point | undefined;
    /**
     * Returns the Theme currently being used.
     * @returns An object containing the Theme.
     */
    getTheme(): Theme;
    /**
     * Set text of Chart title.
     * @param   title  Chart title as a string.
     * @returns        Object itself for fluent interface.
     */
    setTitle(title: string): this;
    /**
     * Get text of Chart title.
     * @returns         Chart title as a string.
     */
    getTitle(): string;
    /**
     * Set fill style of Chart Title.
     *
     * Example usage:
     *```javascript
     * // Create a new style
     * ZoomBandChart.setTitleFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Change transparency
     * ZoomBandChart.setTitleFillStyle((solidFill) => solidFill.setA(80))
     * // Set hidden
     * ZoomBandChart.setTitleFillStyle(emptyFill)
     * ```
     * @param   value   Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns         Chart itself
     */
    setTitleFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of Chart Title.
     * @returns FillStyle object
     */
    getTitleFillStyle(): FillStyle;
    /**
     * Set font of Chart Title.
     *
     * Example usage:
     *```javascript
     * // Create a new FontSettings
     * ZoomBandChart.setTitleFont(new FontSettings({ size: 24, style: 'italic' }))
     * // Change existing settings
     * ZoomBandChart.setTitleFont((fontSettings) => fontSettings.setWeight('bold'))
     * ```
     * @param   value   Either a FontSettings object or a function, which will be used to create a new FontSettings based on current value.
     * @returns         Chart itself
     */
    setTitleFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
    /**
     * Get font of Chart title.
     * @return  FontSettings object
     */
    getTitleFont(): FontSettings;
    /**
     * Specifies padding before chart title.
     *
     * This does not have an effect if title is hidden (empty FillStyle).
     *
     * ```typescript
     *  // Example usage,
     *  // Add empty space at top of chart, before title.
     *  ZoomBandChart.setTitleMarginTop(32)
     * ```
     * @param  marginPixels Gap between the top of chart and its title in pixels.
     * @returns             Chart itself for fluent interface
     */
    setTitleMarginTop(marginPixels: pixel): this;
    /**
     * @returns Padding before Chart title
     */
    getTitleMarginTop(): number;
    /**
     * Specifies padding after chart title.
     *
     * This does not have an effect if title is hidden (empty FillStyle).
     *
     * ```typescript
     *  // Example usage,
     *  // Add empty space between title and series.
     *  ZoomBandChart.setTitleMarginBottom(32)
     * ```
     *
     * @param  marginPixels Gap after the chart title in pixels.
     * @returns             Chart itself for fluent interface
     */
    setTitleMarginBottom(marginPixels: pixel): this;
    /**
     * @returns Padding after Chart title
     */
    getTitleMarginBottom(): number;
    /**
     * Set padding around Chart in pixels.
     * @param   padding     Number with pixel margins for all sides or datastructure with individual pixel paddings
     *                      for each side. Any side can be omitted, only passed values will be overridden.
     * @return              Object itself for fluent interface
     */
    setPadding(padding: Partial<Margin> | number): this;
    /**
     * Get padding around Chart in pixels.
     * @return              Padding datastructure
     */
    getPadding(): Margin;
    /**
     * Set fillStyle of panel background.
     * @param   value       FillStyle or function which modifies it
     * @return              Object itself
     */
    setBackgroundFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fillstyle of chart background.
     * @return              FillStyle
     */
    getBackgroundFillStyle(): FillStyle;
    /**
     * Set stroke style of panel background.
     * @param   value       LineStyle or function which modifies it
     * @return              Object itself
     */
    setBackgroundStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stroke style of chart background.
     * @return              LineStyle
     */
    getBackgroundStrokeStyle(): LineStyle;
    /**
     * Add a stand-alone *UIElement* using a *builder*.
     *
     * @typeparam   UIElementType   Type of *UIElement* that is specified by 'builder'-*parameter*.
     *
     * @param       builder *UIElementBuilder*. If omitted, *TextBoxBuilder* will be selected. Use [[UIElementBuilders]] for selection.
     * @param       scale   Optional custom scale to position UIElement on. Defaults to whole component in percentages [0, 100].
     * @returns             Object that fulfills *interfaces*:  *UIElementType* (typeparam) and *UIElement*
     */
    addUIElement<UIElementType extends UIPart = UITextBox>(uiElementBuilder?: UIElementBuilder<UIElementType>, scale?: LinearScaleXY): UIElementType & UIElement;
    /**
     * Add a *legendbox*.
     *
     * *Legendbox* is a type of *UI element*, that floats inside the chart/component it is created inside. It can be freely moved around
     * with user interactions, as well as positioned in application code.
     *
     * The purpose of *legendbox* is to describe the *series* and other visual components of the *chart*, by displaying their names and colors.
     * Hovering over a *series'* *legendbox entry* will highlight that *series*, and clicking on the *entry* will toggle that *series'* visibility.
     *
     * **Legendbox alignment:**
     *
     * Alignment of legendbox can be selected by supplying one of the available [[LegendBoxBuilders]] to `addLegendBox`:
     *
     * ```typescript
     *  // Default (vertical) LegendBox.
     *  const legendBox = ChartXY.addLegendBox()
     *
     *  // Horizontal LegendBox.
     *  const horizontalLegendBox = ChartXY.addLegendBox(LegendBoxBuilders.HorizontalLegendBox)
     * ```
     *
     * **Custom Legendbox positioning:**
     *
     * By default LegendBoxes are placed on the right side, or bottom of the *chart* (depending on *alignment*).
     *
     * A custom location can be configured with [[UIElement]] API:
     * - [[UIElement.setPosition]]
     * - [[UIElement.setOrigin]]
     * - [[UIElement.setMargin]]
     *
     * *Position coordinate system* is specified when creating *legendbox*.
     *
     * 1) LegendBox with default positioning coordinate system.
     *
     * ```typescript
     *  addLegendBox( LegendBoxBuilders.VerticalLegendBox )
     *      // Position = [0, 100] as percentages.
     *      .setPosition({ x: 50, y: 50 })
     * ```
     *
     * 2) Position in pixel coordinate system.
     *
     * ```typescript
     *  addLegendBox( LegendBoxBuilders.VerticalLegendBox, chart.pixelScale )
     *      // Position = pixels.
     *      .setPosition({ x: 300, y: 100 })
     * ```
     *
     * 3) Position on Axes.
     *
     * ```typescript
     *  addLegendBox( LegendBoxBuilders.VerticalLegendBox, { x: chartXY.getDefaultAxisX(), y: chartXY.getDefaultAxisY() } )
     *      // Position = Axis values.
     *      .setPosition({ x: 5, y: 5 })
     * ```
     *
     * @param       builder *LegendBoxBuilder*. If omitted, *VerticalLegendBox* will be selected. Use [[LegendBoxBuilders]] for selection.
     * @param       scale   Optional parameter for altering the coordinate system used for positioning the LegendBox. Defaults to whole Chart in percentages [0, 100].
     * @returns             Object with two interfaces: LegendBox and UIElement.
     */
    addLegendBox(builder?: UILegendBoxBuilder, scale?: UserScaleDefinition): LegendBox & UIElement;
    /**
     * Capture rendered state in an image file. Prompts the browser to download the created file.
     *
     * **NOTE: The download might be blocked by browser/plugins as harmful.**
     * To prevent this, only call the method in events tied to user-interactions.
     * From mouse-event handlers, for example.
     *
     * Has two optional parameters which directly reference JavaScript API HTMLCanvasElement.toDataURL.
     * For supported image formats, compression quality, Etc. refer to:
     *
     * https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL
     *
     * Example usage:
     *```javascript
     * // Download 'screenshot.png'
     * saveToFile('screenshot')
     * // Attempt download 'maybeNotSupported.bmp'
     * saveToFile('maybeNotSupported', 'image/bmp')
     * // Attempt download jpeg.file with specified compression quality
     * saveToFile('fileName', 'image/jpeg', 0.50)
     * ```
     *
     * @sideEffect              **If 'type' is not supported by browser, an Error will be thrown.**
     *
     * @param   fileName        Name of prompted download file as string. **File extension shouldn't be included**
     *                          as it is automatically detected from 'type'-argument.
     * @param   type            A DOMString indicating the image format. The default format type is image/png.
     * @param   encoderOptions  A Number between 0 and 1 indicating the image quality to use for image formats
     *                          that use lossy compression such as image/jpeg and image/webp. If this argument is anything else,
     *                          the default value for image quality is used. The default value is 0.92.
     */
    saveToFile(fileName: string, type?: string, encoderOptions?: number): this;
    /**
     * **Permanently** dispose the component.
     *
     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
     * **to the component and its children** in application code.
     * ```javascript
     * let chart = ...ChartXY()
     * let axisX = chart.getDefaultAxisX()
     * // Dispose Chart, and remove all references so that they can be garbage-collected.
     * chart.dispose()
     * chart = undefined
     * axisX = undefined
     * ```
     * @return  Object itself for fluent interface
     */
    dispose(): this;
}
export {};
/**
 * Interface for defining an RGBA Color with channels ranging [0, 1].
 *
 */
interface ColorProperties {
    /**
     * Red value from 0 to 1
     */
    r: number;
    /**
     * Green value from 0 to 1
     */
    g: number;
    /**
     * Blue value from 0 to 1
     */
    b: number;
    /**
     * Alpha value from 0 to 1
     */
    a: number;
}
/**
 * Record class for ColorProperties,
 * Used as base for Color
 * @hidden
 */
declare const ColorRecord: Record.Factory<ColorProperties>;
/**
 * Style class for describing a *color*.
 *
 * Instances of Color, like all LCJS style classes, are *immutable*, meaning that its setters don't modify the actual object,
 * but instead return a completely new modified object.
 *
 * **Color creation:**
 *
 * Create *LCJS colors* using any of the many available *factories*:
 * - [[ColorRGBA]]
 * - [[ColorHEX]]
 * - [[ColorCSS]]
 * - [[ColorHSV]]
 *
 * **Color usage:**
 *
 * *Watch out!* A common misuse is to attempt styling components directly with *color*.
 * *Color* is the lowest level style class in whole LCJS library, and is never used directly for styling components,
 * instead it must be wrapped within a more descriptive style type.
 * For example, [[SolidFill]] describes coloring with single, solid color.
 *
 * **Example usage:**
 *
 * Example 1, specifying chart title color using [[ColorRGBA]] and [[SolidFill]]
 *
 * ```typescript
 *  ChartXY.setTitleFillStyle( new SolidFill({
 *      color: ColorRGBA( 255, 0, 0 )
 *  }) )
 * ```
 *
 * Example 2, specifying line series stroke style using ColorRGBA, SolidFill and SolidLine
 *
 * ```typescript
 *  LineSeries.setStrokeStyle(new SolidLine({
 *      thickness: 2,
 *      fillStyle: new SolidFill({
 *          color: ColorRGBA( 255, 0, 0 )
 *      })
 *  }))
 * ```
 * @noInheritDoc
 */
export declare class Color extends ColorRecord {
    /**
     * Color constructor should be hidden, even though the class is public in order to promote usage of Factories.
     * @hidden
     */
    constructor(color: Partial<ColorProperties>);
    /**
     * Get string description of the Color.
     * @return  String based on all properties of the Color.
     * @hidden
     */
    toString(): string;
    /**
     * Creates a new color that is equal to this but with a certain alpha value
     * @param   alpha   Value of alpha channel [0-255]
     * @return          New Color object
     */
    setA(alpha: number): Color;
    /**
     * Creates a new color that is equal to this but with a certain red value
     * @param   red   Value of red channel [0-255]
     * @return        New Color object
     */
    setR(red: number): Color;
    /**
     * Creates a new color that is equal to this but with a certain green value
     * @param   green   Value of green channel [0-255]
     * @return          New Color object
     */
    setG(green: number): Color;
    /**
     * Creates a new color that is equal to this but with a certain blue value
     * @param   blue   Value of blue channel [0-255]
     * @return         New Color object
     */
    setB(blue: number): Color;
    /**
     * @returns Value of alpha channel [0-255]
     */
    getA(): number;
    /**
     * @returns Value of red channel [0-255]
     */
    getR(): number;
    /**
     * @returns Value of green channel [0-255]
     */
    getG(): number;
    /**
     * @returns Value of blue channel [0-255]
     */
    getB(): number;
    /**
     * Compute a highlighted version of this Color.
     * @returns New Color object
     */
    getHighlight(): Color;
    /**
     * Returns a slightly lighter version from a Color.
     * @return New Color object
     */
    getLighter(): Color;
    /**
     * Returns a slightly darker version from a Color.
     * @return New Color object
     */
    getDarker(): Color;
    /**
     * @return Color string in format acceptable by CSS
     */
    toRGBAString(): string;
}
/**
 * One of the many available factories for [[Color]]. This variant receives individual values for *red*, *green*, *blue*, and optionally *alpha* channels.
 * **Input values are in range [0, 255].**
 *
 * **Example usage**:
 *
 * ```typescript
 *  // Create Color from RGB [0, 255] values (completely red).
 *  const color = ColorRGBA( 255, 0, 0 )
 *
 * // Create transparent Color.
 * const transparentColor = ColorRGBA( 255, 0, 0, 127 )
 * ```
 *
 * For more convenience factories, see:
 * - [[ColorHEX]]
 * - [[ColorCSS]]
 * - [[ColorHSV]]
 *
 * @param     r     Red from 0 to 255
 * @param     g     Green from 0 to 255
 * @param     b     Blue from 0 to 255
 * @param     a     Alpha from 0 to 255 (can be omitted, defaulting to 255)
 * @return          *Color* object. Please refer to [[Color]] API document, on extended information how to use *LCJS Colors*.
 */
export declare const ColorRGBA: (r: number, g: number, b: number, a?: number) => Color;
/**
 * One of the many available factories for [[Color]].
 * This variant has a single parameter that follows the *CSS* suite of describing colors as *hexadecimal strings*.
 *
 * **Example usage**:
 *
 * ```typescript
 *  const colorRed = ColorHEX('#ff0000')
 *  const colorTransparentGreen = ColorHEX('#00ff0010')
 * ```
 *
 * **Supported formats:**
 *
 * Basically all commonly used hexadecimal color syntaxes are supported, but here is a full list:
 *
 * - '#RRGGBB'
 * - '#RRGGBBAA'
 * - '#RGB'
 * - '#RGBA'
 * - 'RRGGBB'
 * - 'RRGGBBAA'
 * - 'RGB'
 * - 'RGBA'
 * - '0xRRGGBB'
 * - '0xRRGGBBAA'
 * - '0xRGB'
 * - '0xRGBA'
 *
 * For more convenience factories, see:
 * - [[ColorRGBA]]
 * - [[ColorCSS]]
 * - [[ColorHSV]]
 *
 * @param   hexColor    Hexadecimal value for constructing a Color. Eq. '#FF0000' = Red
 * @return              *Color* object. Please refer to [[Color]] API document, on extended information how to use *LCJS Colors*.
 */
export declare const ColorHEX: (hexColor: string) => Color;
/**
 * One of the many available factories for [[Color]].
 * This variant receives input arguments in *HSV* color space.
 * *HSV* is popular in generating smooth, looping color ranges, for example (red -> green -> blue -> red).
 *
 * **Example usage**:
 *
 * ```typescript
 *  // Hue = angle of color circle where 0 deg = red, 120 deg = green, 240 deg = blue.
 *  const colorRed = ColorHSV(0)
 *  const colorYellow = ColorHSV(60)
 *
 *  // Generate a simple color palette.
 *  const colors10 = new Array(10).fill(undefined).map((_, iColor) =>
 *      // Array will receive colors starting from red, moving through green, blue and ending just before red.
 *      ColorHSV( 0 + (iColor / 10) * 360 )
 *  )
 *
 *  // 'saturation' and 'value' arguments can be supplied optionally.
 *  const colorRedDim = ColorHSV(0, 1.0, 0.5)
 * ```
 *
 * For more convenience factories, see:
 * - [[ColorRGBA]]
 * - [[ColorHEX]]
 * - [[ColorCSS]]
 *
 * @param   hue         *Hue* value as degrees [0, 360] (0 = red, 120 = green, 240 = blue, 360 = red, and so on...).
 * @param   saturation  Saturation in range [0, 1]. Defaults to 1.
 * @param   value       Value in range [0, 1]. Defaults to 1.
 * @return              *Color* object. Please refer to [[Color]] API document, on extended information how to use *LCJS Colors*.
 */
export declare const ColorHSV: (hue: number, saturation?: number, value?: number) => Color;
/**
 * One of the many available factories for [[Color]].
 * This variant has a single parameter that follows the *CSS* suite of describing colors.
 * Can be especially useful when tying *LightningChart JS* styling together with user front-end application CSS.
 *
 * **Example usage**:
 *
 * ```typescript
 *  const colorRed = ColorCSS('red')
 *  const colorTransparentGreen = ColorCSS('rgba(0, 255, 0, 0.5)')
 * ```
 *
 * **Supported formats:**
 *
 * Basically all commonly used CSS color syntaxes are supported, but here is a list for reference:
 *
 * - HEX ('#FF00AA')
 * - HEX with transparency ('#FF00AABB')
 * - RGBA ('rgba(132, 15, 4, 1.0)')
 * - HSL ('hsl(0,100%, 50%)')
 * - Color Name ('blue')
 *
 * For more convenience factories, see:
 * - [[ColorRGBA]]
 * - [[ColorHEX]]
 * - [[ColorHSV]]
 *
 * @param   color     CSS string description of a color. For example, 'red'.
 * @return            *Color* object. Please refer to [[Color]] API document, on extended information how to use *LCJS Colors*.
 */
export declare const ColorCSS: (color: string) => Color;
export {};
/**
 * Base interface for *fill styles*.
 *
 * For implementations with more detailed documentation, see:
 * - [[SolidFill]]
 * - [[emptyFill]]
 * - [[IndividualPointFill]]
 * - [[PalettedFill]]
 * - [[RadialGradientFill]]
 * - [[LinearGradientFill]]
 * - [[ImageFill]]
 * @noInheritDoc
 */
export interface FillStyle {
    readonly type: 'fillstyle';
    /**
     * Get automatically computed highlight style.
     * @return  FillStyle object
     */
    getDefaultHighlightStyle(): this;
    /**
     * Get string description of the FillStyle.
     * @return  String based on all properties of the FillStyle.
     * @hidden
     */
    toString(): string;
}
/**
 * Interface for all properties of a empty FillStyle.
 * @hidden
 */
declare const EmptyFillRecord: Record.Factory<{}>;
/**
 * Abstract class which indicates that shape should not be filled.
 *
 * When *emptyFill* is used, the area that would be filled does **NOT** trigger mouse / touch -events, and
 * its rendering process is skipped, which results in saved performance.
 * @hidden
 */
export declare class EmptyFill extends EmptyFillRecord implements FillStyle {
    readonly type = "fillstyle";
    /**
     * @returns Object itself, because the entire style does not have any color information.
     */
    getDefaultHighlightStyle(): this;
    /**
     * Get string description of the FillStyle.
     * @return  String based on all properties of the FillStyle.
     * @hidden
     */
    toString(): string;
}
/**
 * Singleton object which indicates that component should not have *fill color*.
 *
 * When *emptyFill* is used, the area that would be filled does **NOT** trigger mouse / touch -events (if this is desired, use a transparent [[SolidFill]] instead).
 *
 * **emptyFill Usage:**
 *
 * Use emptyFill with:
 * - `setFillStyle` methods:
 *      * [[PointSeries.setPointFillStyle]]
 *      * [[ChartXY.setTitleFillStyle]]
 *
 * ```typescript
 *  // Example
 *  PointSeries.setPointFillStyle(emptyFill)
 * ```
 *
 * - [[SolidLine]], or other *line styles*.
 *
 * ```typescript
 *  // Example, construct a SolidLine.
 *  const lineStyle = new SolidLine({
 *      thickness: 1,
 *      fillStyle: emptyFill
 *  })
 * ```
 *
 * **Related information:**
 *
 * For more *fill styles*, see:
 * - [[SolidFill]]
 * - [[IndividualPointFill]]
 * - [[PalettedFill]]
 * - [[RadialGradientFill]]
 * - [[LinearGradientFill]]
 * - [[ImageFill]]
 */
export declare const emptyFill: EmptyFill;
/**
 * Interface for all properties of a visible FillStyle.
 */
export interface VisibleFillStyleProperties {
    /**
     * For SolidFill: Color which is used to fill shape.
     *
     * For IndividualPointFill: Fallback Color for filling shape if individual Color was not given.
     *
     * For PalettedFill: Fallback Color for filling shape if palette was not given.
     */
    color: Color;
}
/**
 * Record contractor for VisibleFillStyleProperties.
 * @hidden
 */
declare const VisibleFillRecord: Record.Factory<VisibleFillStyleProperties>;
/**
 * Abstract class that indicates some visible Filling.
 * Used only for instanceOf check at Engine
 * @hidden Internal class
 */
export declare abstract class VisibleFill extends VisibleFillRecord implements FillStyle {
    readonly type = "fillstyle";
    /**
     * Cache default highlight style to prevent recreation
     */
    private _defaultHighlightStyle?;
    /**
     * Get automatically computed highlight style.
     * @return  FillStyle object
     */
    getDefaultHighlightStyle(): this;
    /**
     * @return Newly created default highlight style of this one, with lighter fill color
     */
    protected abstract createDefaultHighlightStyle(): this;
}
/**
 * Style class for describing a *solid fill color*.
 *
 * Instances of SolidFill, like all LCJS style classes, are *immutable*, meaning that its setters don't modify the actual object,
 * but instead return a completely new modified object.
 *
 * **Properties of SolidFill:**
 * - `color`: fill color. Construct a *LCJS color* using one of the many available *factories*:
 *      * [[ColorRGBA]]
 *      * [[ColorHEX]]
 *      * [[ColorCSS]]
 *      * [[ColorHSV]]
 *
 * **SolidFill Usage:**
 *
 * Use SolidFill with:
 * - `setFillStyle` methods:
 *      * [[PointSeries.setPointFillStyle]]
 *      * [[ChartXY.setTitleFillStyle]]
 *
 * ```typescript
 *  // Example, style points fill with solid red color.
 *  PointSeries.setPointFillStyle(new SolidFill({
 *      color: ColorRGBA( 255, 0, 0 )
 *  }))
 * ```
 *
 * - Creating a [[SolidLine]], or other *line style*, which can be used for styling a stroke, or border.
 *
 * *Watch out!* A common misuse is to attempt styling strokes or borders directly using *fill style* or *color*.
 * Remember, when calling a `setStrokeStyle` method, a *line style* is expected! Carefully observe the order of wrapped styles: *line style <- fill style <- color*
 *
 * ```typescript
 *  // Example, style line series stroke with solid red line.
 *  LineSeries.setStrokeStyle(new SolidLine({
 *      thickness: 1,
 *      fillStyle: new SolidFill({ color: ColorRGBA( 255, 0, 0 ) })
 *  }))
 * ```
 *
 * **Related information:**
 *
 * For more *fill styles*, see:
 * - [[emptyFill]]
 * - [[IndividualPointFill]]
 * - [[PalettedFill]]
 * - [[RadialGradientFill]]
 * - [[LinearGradientFill]]
 * - [[ImageFill]]
 */
export declare class SolidFill extends VisibleFill {
    /**
     * Construct a SolidFill object, specifying any amount of its properties.
     *
     * ```typescript
     *  // Example using RGBA color factory.
     *  const solidRed = new SolidFill({
     *      color: ColorRGBA( 255, 0, 0 )
     *  })
     * ```
     *
     * ```typescript
     *  // Example using HEX color factory.
     *  const solidRed = new SolidFill({
     *      color: ColorHEX( '#ff0000' )
     *  })
     * ```
     * @param   props   Object containing any amount of SolidFill properties.
     */
    constructor(props?: Partial<VisibleFillStyleProperties>);
    /**
     * Get string description of the FillStyle.
     * @return  String based on all properties of the FillStyle.
     * @hidden
     */
    toString(): string;
    /**
     * Construct a new SolidFill object based on this one, but with modified color.
     *
     * Example:
     * ```javascript
     * // specify new color
     * solidfill.setColor( ColorHEX('#F00') )
     *
     * // change individual color properties
     * solidfill.setColor( color => color.setA(80) )
     * ```
     * @param   value   Either a Color object or a function, which will be used to create a new Color based on current value.
     * @return          New SolidFill object
     */
    setColor(value: Color | ImmutableMutator<Color>): this;
    /**
     * Get color of SolidFill.
     * @return  Color object
     */
    getColor(): Color;
    /**
     * Construct a new SolidFill object based on this one, but with a modified Alpha value.
     *
     * @param  alpha    Value of Alpha channel [0-255]
     * @return          New SolidFill object
     */
    setA(alpha: number): SolidFill;
    /**
     * Construct a new SolidFill object based on this one, but with a modified Red value.
     *
     * @param  alpha    Value of Red channel [0-255]
     * @return          New SolidFill object
     */
    setR(red: number): SolidFill;
    /**
     * Construct a new SolidFill object based on this one, but with a modified Green value.
     *
     * @param  green    Value of Green channel [0-255]
     * @return          New SolidFill object
     */
    setG(green: number): SolidFill;
    /**
     * Construct a new SolidFill object based on this one, but with a modified Blue value.
     *
     * @param  blue     Value of Blue channel [0-255]
     * @return          New SolidFill object
     */
    setB(blue: number): SolidFill;
    /**
     * @return Newly created default highlight style of this one, with lighter fill color
     */
    protected createDefaultHighlightStyle(): this;
}
/**
 * Style class for describing a *individually configured fill color*, enabling users to specify data-point
 * specific colors.
 *
 * Instances of IndividualPointFill, like all LCJS style classes, are *immutable*, meaning that its setters don't modify the actual object,
 * but instead return a completely new modified object.
 *
 * **Properties of IndividualPointFill:**
 * - `color`: fallback color to be used with data points that were not associated with a color.
 * Construct a *LCJS color* using one of the many available *factories*:
 *      * [[ColorRGBA]]
 *      * [[ColorHEX]]
 *      * [[ColorCSS]]
 *      * [[ColorHSV]]
 *
 * **IndividualPointFill Usage:**
 *
 * IndividualPointFill can be used with a select group of series:
 *
 * - [[PointSeries.setPointFillStyle]]
 * - [[IntensityGridSeries.setFillStyle]]
 * - [[IntensityMeshSeries.setFillStyle]]
 * - [[PointSeries3D.setPointStyle]]
 *
 * ```typescript
 *  // Example, individual points fill color.
 *  PointSeries.setPointFillStyle(new IndividualPointFill())
 * ```
 *
 * **Related information:**
 *
 * For more *fill styles*, see:
 * - [[SolidFill]]
 * - [[emptyFill]]
 * - [[PalettedFill]]
 * - [[RadialGradientFill]]
 * - [[LinearGradientFill]]
 * - [[ImageFill]]
 */
export declare class IndividualPointFill extends VisibleFill {
    /**
     * Construct a IndividualPointFill object, specifying any amount of its properties.
     *
     * ```typescript
     *  // Example, for most cases no arguments are necessary (fallback color will be black).
     *  const individualPointFill = new IndividualPointFill()
     * ```
     *
     * ```typescript
     *  // Example, specify fallback color for data points without associated color.
     *  const individualPointFill = new IndividualPointFill({
     *      color: ColorRGBA( 0, 255, 0 )
     *  })
     * ```
     * @param   props   Object containing any amount of IndividualPointFill properties.
     */
    constructor(props?: Partial<VisibleFillStyleProperties>);
    /**
     * Get string description of the FillStyle.
     * @return  String based on all properties of the FillStyle.
     * @hidden
     */
    toString(): string;
    /**
     * Construct a new IndividualPointFill object based on this one, but with modified fallback color.
     *
     * Example:
     * ```javascript
     * // specify new color
     * individualfill.setColor( ColorHEX('#F00') )
     *
     * // change individual color properties
     * individualfill.setColor( color => color.setA(80) )
     * ```
     * @param   value   Either a Color object or a function, which will be used to create a new Color based on current value.
     * @return          New IndividualPointFill object
     */
    setFallbackColor(value: Color | ImmutableMutator<Color>): this;
    /**
     * Get Fallback Color of IndividualPointFill.
     * @return  Color object
     */
    getFallbackColor(): Color;
    /**
     * Get automatically computed highlight style.
     * @return  Object itself, because the Color information is stored in *PointColor*
     */
    protected createDefaultHighlightStyle(): this;
}
/**
 * Type union of possible values for 'lookUpProperty' configuration of a [[PalettedFill]].
 *
 * Points to a property to be used when picking colours from a Look Up Table.
 *
 * - **"value"**: LUT value is taken from a separate value that can be set by user by some Series-specific logic.
 * - **"x"**: LUT value is taken directly from data points X coordinate.
 * - **"y"**: LUT value is taken directly from data points Y coordinate.
 * - **"z"**: LUT value is taken directly from data points Z coordinate.
 *
 * Use alongside [[PalettedFill]] and [[LUT]].
 */
export declare type LookUpProperty = 'value' | 'x' | 'y' | 'z';
/**
 * Interface for all properties of a PalettedFillStyle.
 */
export interface PalettedFillProperties<T extends LookUpProperty = LookUpProperty> {
    /**
     * Color lookup table, which describes the relation of `lookUpProperty` values to colors.
     */
    lut: LUT;
    /**
     * Identifier that points to a property to be used when picking colours from attached Look Up Table.
     *
     * Possible values are:
     * - **"value"**
     * - **"x"**
     * - **"y"**
     * - **"z"**
     *
     * Features that support assigning a [[PalettedFill]] contain additional per-feature information, which
     * properties are supported, and how they behave.
     */
    lookUpProperty: T;
}
/**
 * Record contractor for PalettedFillStyleProperties.
 * @hidden
 */
declare const PalettedFillStyleRecord: Record.Factory<PalettedFillProperties<LookUpProperty>>;
/**
 * Style class for describing a *dynamically looked up fill color*. Using a PalettedFill, each data point (or even pixel) can be colored individually.
 * The basis of coloring can be configured extensively, with a variety of different option combinations (read below for details).
 *
 * Instances of PalettedFill, like all LCJS style classes, are *immutable*, meaning that its setters don't modify the actual object,
 * but instead return a completely new modified object.
 *
 * **Properties of PalettedFill:**
 * - `lut`: color lookup table. Essentially a list of *colors* paired with numeric values. See [[LUT]] for more details.
 * - `lookUpProperty`: selects basis of color lookup. See [[LookUpProperty]] for possible options.
 *
 * **PalettedFill Usage:**
 *
 * PalettedFill can be used with a select group of features:
 *
 * - [[PointSeries.setPointFillStyle]]
 * - [[IntensityGridSeries.setFillStyle]]
 * - [[IntensityMeshSeries.setFillStyle]]
 * - [[SurfaceGridSeries3D.setFillStyle]]
 * - [[SurfaceMeshSeries3D.setFillStyle]]
 * - [[PointSeries3D.setPointStyle]]
 * - [[BoxSeries3D.setFillStyle]]
 * - [[MapChart.setFillStyle]]
 *
 * ```typescript
 *  // Example 1, paletted points fill by 'y' coordinates.
 *  PointSeries.setPointFillStyle(new PalettedFill({
 *      lookUpProperty: 'y',
 *      lut: new LUT({
 *          interpolate: true,
 *          steps: [
 *              { value: 0, color: ColorRGBA( 0, 0, 0 ) },
 *              { value: 10, color: ColorRGBA( 255, 0, 0 ) },
 *              { value: 20, color: ColorRGBA( 0, 255, 0 ) },
 *              { value: 30, color: ColorRGBA( 0, 0,255 ) },
 *          ]
 *      })
 *  }))
 * ```
 *
 * ```typescript
 *  // Example 2, paletted points fill by user supplied data point values.
 *  PointSeries
 *      .setPointFillStyle(new PalettedFill({
 *           lookUpProperty: 'value',
 *           lut: new LUT({
 *               interpolate: true,
 *               steps: [
 *                   { value: 0, color: ColorRGBA( 0, 0, 0 ) },
 *                   { value: 100, color: ColorRGBA( 255, 0, 0 ) },
 *               ]
 *           })
 *      }))
 *      .add([
 *          { x: Math.random() * 100, y: Math.random() * 100, value: Math.random() * 100 },
 *          { x: Math.random() * 100, y: Math.random() * 100, value: Math.random() * 100 },
 *          { x: Math.random() * 100, y: Math.random() * 100, value: Math.random() * 100 },
 *          { x: Math.random() * 100, y: Math.random() * 100, value: Math.random() * 100 },
 *          { x: Math.random() * 100, y: Math.random() * 100, value: Math.random() * 100 },
 *      ])
 * ```
 *
 * **Related information:**
 *
 * For more *fill styles*, see:
 * - [[SolidFill]]
 * - [[emptyFill]]
 * - [[IndividualPointFill]]
 * - [[RadialGradientFill]]
 * - [[LinearGradientFill]]
 *
 * @noInheritDoc
 */
export declare class PalettedFill<T extends LookUpProperty = LookUpProperty> extends PalettedFillStyleRecord implements FillStyle {
    readonly type = "fillstyle";
    /**
     * Construct a PalettedFill object, specifying any amount of its properties.
     *
     * ```typescript
     *  // Example 1, palette by 'y' coordinate.
     *  const paletteY = new PalettedFill({
     *      lookUpProperty: 'y',
     *      lut: new LUT({
     *          interpolate: true,
     *          steps: [
     *              { value: 0, color: ColorRGBA( 0, 0, 0 ) },
     *              { value: 10, color: ColorRGBA( 255, 0, 0 ) },
     *              { value: 20, color: ColorRGBA( 0, 255, 0 ) },
     *              { value: 30, color: ColorRGBA( 0, 0,255 ) },
     *          ]
     *      })
     *  })
     * ```
     *
     * ```typescript
     *  // Example 2, palette by user supplied data point values.
     *  const paletteValue = new PalettedFill({
     *      lookUpProperty: 'value',
     *      lut: new LUT({
     *          interpolate: true,
     *          steps: [
     *              { value: 0, color: ColorRGBA( 0, 0, 0 ) },
     *              { value: 100, color: ColorRGBA( 255, 0, 0 ) },
     *          ]
     *      })
     *  })
     * ```
     *
     * For more details, see [[LUT]], and [[LookUpProperty]].
     *
     * @param   props   Object containing any amount of PalettedFill properties.
     */
    constructor(props?: Partial<PalettedFillProperties<T>>);
    /**
     * Get string description of the FillStyle.
     * @return  String based on all properties of the FillStyle.
     * @hidden
     */
    toString(): string;
    /**
     * Get automatically computed highlight style.
     * @return  FillStyle object
     */
    getDefaultHighlightStyle(): this;
    /**
     * Get LUT lookup table.
     * @return  LUT object.
     */
    getPalette(): LUT;
    /**
     * Construct a new PalettedFill object based on this one, but with modified 'lookUpProperty'.
     *
     * Example:
     * ```ts
     * palettedFill.setLookUpProperty( 'y' )
     * ```
     * @param   value   [[LookUpProperty]].
     * @return          New PalettedFill object.
     */
    setLookUpProperty<PT extends LookUpProperty>(value: PT | ImmutableMutator<LookUpProperty, PT>): PalettedFill<PT>;
    /**
     * Get look up property of PalettedFill.
     * @return  [[LookUpProperty]].
     */
    getLookUpProperty(): LookUpProperty;
}
export {};
/**
 * Type definition for [[FontSettings.weight]] property.
 */
export declare type FontWeight = 'normal' | 'bold' | 'bolder' | 'lighter' | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900;
/**
 * Type definition for [[FontSettings.style]] property.
 */
export declare type FontStyle = 'normal' | 'italic' | 'oblique';
/**
 * Interface of all properties of [[FontSettings]].
 */
export interface FontProperties {
    /**
     * [CSS font size](https://www.w3schools.com/CSSref/pr_font_font-size.asp).
     *
     * For example, `16`.
     */
    size: number;
    /**
     * [CSS font family](https://www.w3schools.com/CSSref/pr_font_font-family.asp), or list of font families.
     *
     * For example, `'Arial, Helvetica, sans-serif'`.
     */
    family: string;
    /**
     * [CSS font weight](https://www.w3schools.com/CSSref/pr_font_weight.asp).
     *
     * For example, `'bold'`.
     */
    weight: FontWeight;
    /**
     * [CSS font style](https://www.w3schools.com/CSSref/pr_font_font-style.asp).
     *
     * For example, `'italic'`
     */
    style: FontStyle;
    /**
     * [CSS font variant](https://www.w3schools.com/CSSref/pr_font_font-variant.asp).
     *
     * `true` = 'small-caps', `false` = 'normal'.
     */
    variant: boolean;
}
/**
 * Constructor for a Record of FontProperties.
 * @hidden
 */
declare const FontSettingsRecord: Record.Factory<FontProperties>;
/**
 * Style class for describing a *font*.
 *
 * Instances of FontSettings, like all LCJS style classes, are *immutable*, meaning that its setters don't modify the actual object,
 * but instead return a completely new modified object.
 *
 * **Properties of FontSettings:**
 * - `size`: [CSS font size](https://www.w3schools.com/CSSref/pr_font_font-size.asp).
 * - `family`: [CSS font family](https://www.w3schools.com/CSSref/pr_font_font-family.asp), or list of font families.
 * - `weight`: [CSS font weight](https://www.w3schools.com/CSSref/pr_font_weight.asp).
 * - `style`: [CSS font style](https://www.w3schools.com/CSSref/pr_font_font-style.asp).
 * - `variant`: [CSS font variant](https://www.w3schools.com/CSSref/pr_font_font-variant.asp). `true` = 'small-caps', `false` = 'normal'.
 *
 * **FontSettings usage:**
 *
 * Use FontSettings with:
 * - `setFont` methods:
 *      * [[ChartXY.setTitleFont]]
 *      * [[UITextBox.setTextFont]]
 *      * [[ResultTable.setTextFont]]
 *
 * ```typescript
 *  // Example 1, set chart title font with explicit font.
 *  ChartXY.setTitleFont(new FontSettings({
 *      size: 20,
 *      family: 'Arial, Helvetica, sans-serif',
 *      weight: 'bold',
 *      style: 'italic'
 *  }))
 *
 *  // Example 2, override chart title font, specifying only a sub-set of properties.
 *  ChartXY.setTitleFont((font) => font
 *      .setSize(20)
 *  )
 * ```
 *
 * @noInheritDoc
 */
export declare class FontSettings extends FontSettingsRecord {
    /**
     * Construct a FontSettings object, specifying any amount of its properties.
     *
     * ```typescript
     *  // Example,
     *  const font = new FontSettings({
     *      size: 20,
     *      family: 'Arial, Helvetica, sans-serif',
     *      weight: 'bold',
     *      style: 'italic',
     *  })
     * ```
     *
     * @param   props   Object containing any amount of SolidFill properties.
     */
    constructor(props?: Partial<FontProperties>);
    /**
     * Create new FontSettings object with different `size`.
     *
     * [CSS font size](https://www.w3schools.com/CSSref/pr_font_font-size.asp).
     *
     * For example, `16`.
     * @param   size        Font size.
     * @returns             New FontSettings object.
     */
    setSize(size: number): this;
    /**
     * Create new FontSettings object with different `family`.
     *
     * [CSS font family](https://www.w3schools.com/CSSref/pr_font_font-family.asp), or list of font families.
     *
     * For example, `'Arial, Helvetica, sans-serif'`.
     * @param   family      Font family or list of families.
     * @returns             New FontSettings object.
     */
    setFamily(family: string): this;
    /**
     * Create new FontSettings object with different `weight`.
     *
     * [CSS font weight](https://www.w3schools.com/CSSref/pr_font_weight.asp).
     *
     * For example, `'bold'`.
     * @param   weight  Font weight.
     * @returns         New FontSettings object.
     */
    setWeight(weight: FontWeight): this;
    /**
     * Create new FontSettings object with different `style`.
     *
     * [CSS font style](https://www.w3schools.com/CSSref/pr_font_font-style.asp).
     *
     * For example, `'italic'`
     * @param   style       Font style.
     * @returns             New FontSettings object.
     */
    setStyle(style: FontStyle): this;
    /**
     * Create new FontSettings object with different `variant`.
     *
     * [CSS font variant](https://www.w3schools.com/CSSref/pr_font_font-variant.asp).
     *
     * `true` = 'small-caps', `false` = 'normal'
     * @param               Font variant.
     * @returns             New FontSettings object.
     */
    setVariant(smallCaps: boolean): this;
    /**
     * Get font `size`.
     *
     * [CSS font size](https://www.w3schools.com/CSSref/pr_font_font-size.asp).
     *
     * For example, `16`.
     * @return          Font size.
     */
    getSize(): number;
    /**
     * Get font `family`.
     *
     * [CSS font family](https://www.w3schools.com/CSSref/pr_font_font-family.asp), or list of font families.
     *
     * For example, `'Arial, Helvetica, sans-serif'`.
     * @return          Font family.
     */
    getFamily(): string;
    /**
     * Get font `weight`.
     *
     * [CSS font weight](https://www.w3schools.com/CSSref/pr_font_weight.asp).
     *
     * For example, `'bold'`.
     * @return          Font weight.
     */
    getWeight(): FontWeight;
    /**
     * Get font `style`.
     *
     * [CSS font style](https://www.w3schools.com/CSSref/pr_font_font-style.asp).
     *
     * For example, `'italic'`
     * @return          Font style.
     */
    getStyle(): FontStyle;
    /**
     * Get font `variant`.
     *
     * [CSS font variant](https://www.w3schools.com/CSSref/pr_font_font-variant.asp).
     *
     * `true` = 'small-caps', `false` = 'normal'.
     * @return          Font variant.
     */
    getVariant(): boolean;
}
/**
 * Default FontSettings instance.
 * New FontSettings can be created by either modifying it or by constructing a new instance with 'FontSettings'-constructor.
 *
 * Users should be instructed to use constructor, not this!
 * @hidden
 */
export declare const _fontSettings: FontSettings;
export {};
/**
 * Interface representing a Color Stop.
 * Each ColorStop has a color and an offset.
 */
export interface ColorStop {
    /**
     * Color for the color stop.
     */
    color: Color;
    /**
     * Offset for the color stop
     */
    offset: number;
}
/**
 * Common functions for any gradient implementation.
 * @hidden
 */
interface Gradient {
    /**
     * Set color stops for the gradient.
     * @param stops Color Stops
     */
    setColorStops(stops: ColorStop[]): void;
    /**
     * Get current color stops from the gradient.
     */
    getColorStops(): ColorStop[];
}
/**
 * Gradient Shapes
 */
export declare enum GradientShape {
    circle = "circle",
    ellipse = "ellipse"
}
/**
 * Gradient extents
 */
export declare enum GradientExtent {
    closestSide = "closest-side",
    closestCorner = "closest-corner",
    farthestSide = "farthest-side",
    farthestCorner = "farthest-corner"
}
/**
 * Interface for all properties of a RadialGradientFillStyle.
 */
export interface RadialGradientFillStyleProperties {
    /**
     * Gradient color stops
     */
    stops: ColorStop[];
    /**
     * Gradient center position.
     *
     * A element relative coordinate. 0 to 1 coordinate space.
     * `{ x: 0, y: 0 }` is bottom left.
     * `{ x: 1, y: 1 }` is top right.
     */
    position: Point;
    /**
     * The shape for the gradient
     */
    shape: GradientShape;
    /**
     * The extent for gradient.
     *
     * Defines where the gradient takes it's size.
     */
    extent: GradientExtent;
}
/**
 * Record contractor for RadialGradientFillStyleProperties.
 * @hidden
 */
declare const RadialGradientFillStyleRecord: Record.Factory<RadialGradientFillStyleProperties>;
/**
 * Radial Gradient fill style.
 *
 * Instances of RadialGradientFill are *immutable*, meaning that its setters don't modify the object,
 * but instead return a completely new modified object.
 */
export declare class RadialGradientFill extends RadialGradientFillStyleRecord implements Gradient, FillStyle {
    readonly type = "fillstyle";
    constructor(props?: Partial<RadialGradientFillStyleProperties>);
    /**
     * Get string description of the FillStyle.
     * @return  String based on all properties of the FillStyle.
     * @hidden
     */
    toString(): string;
    /**
     * Set color stops for the gradient.
     * @param stops Color Stops
     */
    setColorStops(stops: ColorStop[]): this;
    /**
     * Get current color stops from the gradient.
     */
    getColorStops(): ColorStop[];
    /**
     * Set the center position of the gradient.
     * @param position Local XY coordinate in x: [0-1], y: [0-1] range
     */
    setPosition(position: Point): this;
    /**
     * Get the center position of the gradient.
     */
    getPosition(): Point;
    /**
     * Set the shape of the gradient
     * @param shape Gradient Shape
     */
    setShape(shape: GradientShape): this;
    /**
     * Get the shape of the gradient
     */
    getShape(): GradientShape;
    /**
     * Set the extent of the gradient.
     * @param extent Gradient Extent
     */
    setExtent(extent: GradientExtent): this;
    /**
     * Get the extent of the gradient
     */
    getExtent(): GradientExtent;
    /**
     * @return Newly created default highlight style of this one, with lighter fill color
     */
    protected createDefaultHighlightStyle(): this;
    /**
     * Get automatically computed highlight style.
     * @return  FillStyle object
     */
    getDefaultHighlightStyle(): this;
}
/**
 * Interface for all properties of a LinearGradient.
 */
export interface LinearGradientFillStyleProperties {
    /**
     * Gradient Color stops
     */
    stops: ColorStop[];
    /**
     * Gradient angle in degrees
     */
    angle: number;
}
/**
 * Record contractor for LinearGradientFillStyleProperties.
 * @hidden
 */
declare const LinearGradientFillStyleRecord: Record.Factory<LinearGradientFillStyleProperties>;
/**
 * Linear Gradient fill style.
 *
 * Instances of LinearGradientFill are *immutable*, meaning that its setters don't modify the object,
 * but instead return a completely new modified object.
 */
export declare class LinearGradientFill extends LinearGradientFillStyleRecord implements Gradient, FillStyle {
    readonly type = "fillstyle";
    constructor(props?: Partial<LinearGradientFillStyleProperties>);
    /**
     * Get string description of the FillStyle.
     * @return  String based on all properties of the FillStyle.
     * @hidden
     */
    toString(): string;
    /**
     * Set color stops for the gradient.
     * @param stops Color Stops
     */
    setColorStops(stops: ColorStop[]): this;
    /**
     * Get current color stops from the gradient.
     */
    getColorStops(): ColorStop[];
    /**
     * Set the angle of the gradient line in degrees or radians.
     * @param angle Angle in degrees or radians. 0 degrees/radians is up. Clockwise rotation.
     * @param isRadians Pass `true` if the angle provided is in radians.
     */
    setAngle(angle: number, isRadians?: boolean): this;
    /**
     * Get the angle of the gradient line in degrees or radians.
     * @param isRadians Pass `true` if radians is wanted.
     */
    getAngle(isRadians?: boolean): number;
    /**
     * @return Newly created default highlight style of this one, with lighter fill color
     */
    protected createDefaultHighlightStyle(): this;
    /**
     * Get automatically computed highlight style.
     * @return  FillStyle object
     */
    getDefaultHighlightStyle(): this;
}
export {};
/**
 * Interface for all properties of a LineStyle.
 */
export interface LineStyleProperties<FillType extends FillStyle = FillStyle> {
    /**
     * Line fill style.
     */
    fillStyle: FillType;
    /**
     * Line thickness.
     *
     * -1 can be used to signify smallest available thickness.
     * With most features, this will result in slightly better GPU performance, but less detailed line.
     *
     * Default value: 1.
     */
    thickness: number;
    /**
     * Value to multiply the default thickness with when the Line is highlighted.
     *
     * This will only effect the highlighted line if no other style has been set for the Line's Highlighted style.
     * Values less or equal to 0 can cause unexpected behavior.
     *
     * Default value: 2
     */
    highlightThicknessMultiplier: number;
}
/**
 * Base interface for *line styles*.
 *
 * For implementations with more detailed documentation, see:
 * - [[SolidLine]]
 * - [[emptyLine]]
 * @noInheritDoc
 */
export declare abstract class LineStyle implements HighlightableType {
    readonly type = "linestyle";
    /**
     * Get automatically computed highlight style.
     * @return  LineStyle object
     */
    getDefaultHighlightStyle(): this;
    /**
     * @return Newly created default highlight style of this one, with lighter fill color and bigger thickness
     */
    protected abstract createDefaultHighlightStyle(): LineStyle;
}
/**
 * Singleton object which specifies that a *line* should not be rendered.
 *
 * When *emptyLine* is used, the configured line does **NOT** trigger mouse / touch -events (if this is desired, use a transparent [[SolidLine]] instead).
 *
 * **emptyLine Usage:**
 *
 * Use emptyLine as argument of:
 * - `setStrokeStyle` methods:
 *      * [[LineSeries.setStrokeStyle]]
 *      * [[Axis.setStrokeStyle]]
 *      * [[CustomTick.setGridStrokeStyle]]
 *      * etc.
 *
 * ```typescript
 *  // Example
 *  LineSeries.setStrokeStyle(emptyLine)
 * ```
 *
 * **Related information:**
 *
 * For more *line styles*, see:
 * - [[SolidLine]]
 */
export declare const emptyLine: LineStyle;
/**
 * Abstract class that indicates some visible line.
 * Used only for instanceOf check at Engine
 * @hidden Internal class
 */
declare abstract class VisibleLine<FillType extends FillStyle = FillStyle> extends LineStyle {
    /**
     * Construct a new Visible line object based on this one, but with modified fill style.
     *
     * Example (SolidFill):
     * ```javascript
     * // specify new fillstyle
     * solidLineStyle.setFillStyle( new SolidFill({
     *  color: ColorHex('#F00')
     * }) )
     * // change fillstyle properties
     * solidLineStyle.setFillStyle(
     *  solidfill => solidfill.setA( 80 )
     * )
     * ```
     * @param   value   Either a SolidFill object or a function, which will be used to create a new VisibleFill based on current value.
     * @return          New SolidLine object
     */
    abstract setFillStyle<NewFillType extends FillStyle>(value: NewFillType | ImmutableMutator<FillType, NewFillType>): VisibleLine<NewFillType>;
    /**
     * Get fill style of SolidLine.
     * @return  SolidFill object
     */
    getFillStyle(): FillType;
    /**
     * Construct a new SolidLine object based on this one, but with modified thickness.
     *
     * -1 can be used to signify smallest available thickness.
     * With most features, this will result in slightly better GPU performance, but less detailed line.
     *
     * @param   thickness   Thickness as pixels.
     */
    setThickness(thickness: number): this;
    /**
     * Get thickness of SolidLine
     * @return  Thickness as pixels
     */
    getThickness(): number;
    /**
     * Construct a new SolidLine object based on this one, but with modified highlight thickness multiplier.
     *
     * Only works when the highlighted style has not been set separately.
     * @param   value   Amount to multiply the line thickness with when highlighted.
     */
    setHighlightThicknessMultiplier(value: number): this;
    /**
     * Get highlighted line thickness multiplier.
     * @return Line thickness multiplier.
     */
    getHighlightThicknessMultiplier(): number;
}
/**
 * Style class for describing a *solid line*.
 *
 * Instances of SolidLine, like all LCJS style classes, are *immutable*, meaning that its setters don't modify the actual object,
 * but instead return a completely new modified object.
 *
 * **Properties of SolidLine:**
 * - `thickness`: thickness of line as pixels.
 * - `fillStyle`: description of line fill color. Currently supported *fill styles*:
 *      * [[SolidFill]]
 *      * [[LinearGradientFill]]
 *      * [[RadialGradientFill]]
 *      * [[PalettedFill]]
 *
 * **SolidLine Usage:**
 *
 * Use SolidLine with:
 * - `setStrokeStyle` methods:
 *      * [[LineSeries.setStrokeStyle]]
 *      * [[Axis.setStrokeStyle]]
 *      * [[CustomTick.setGridStrokeStyle]]
 *      * etc.
 *
 * *Watch out!* A common misuse is to attempt styling strokes or borders directly using *fill style* or *color*.
 * Remember, when calling a `setStrokeStyle` method, a *line style* is expected! Carefully observe the order of wrapped styles: *line style <- fill style <- color*
 *
 * ```typescript
 *  // Example, set line series stroke style to 1px solid red.
 *  LineSeries.setStrokeStyle(new SolidLine({
 *      thickness: 1,
 *      fillStyle: new SolidFill({ color: ColorRGBA( 255, 0, 0 ) })
 *  }))
 * ```
 *
 * **Related information:**
 *
 * For more *line styles*, see:
 * - [[emptyLine]]
 */
export declare class SolidLine<FillType extends FillStyle = SolidFill | LinearGradientFill | RadialGradientFill | PalettedFill> extends VisibleLine<FillType> {
    /**
     * Construct a SolidLine object, specifying any amount of its properties.
     *
     * ```typescript
     *  // Example, 1px solid red line.
     *  const solidRed = new SolidLine({
     *      thickness: 1,
     *      fillStyle: new SolidFill({ color: ColorRGBA( 255, 0, 0 ) })
     *  })
     *
     *  LineSeries.setStrokeStyle(solidRed)
     * ```
     * @param   props   Object containing any amount of SolidLine properties.
     */
    constructor(props?: Partial<LineStyleProperties<FillType>>);
    /**
     * @returns the default highlight style of this lineStyle
     */
    protected createDefaultHighlightStyle(): SolidLine<FillType>;
    /**
     * Construct a new Visible line object based on this one, but with modified fill style.
     *
     * Example (SolidFill):
     * ```javascript
     * // specify new fillstyle
     * solidLineStyle.setFillStyle( new SolidFill({
     *  color: ColorHex('#F00')
     * }) )
     * // change fillstyle properties
     * solidLineStyle.setFillStyle(
     *  solidfill => solidfill.setA( 80 )
     * )
     * ```
     * @param   value   Either a SolidFill object or a function, which will be used to create a new VisibleFill based on current value.
     * @return          New SolidLine object
     */
    setFillStyle<NewFillType extends FillStyle>(value: NewFillType | ImmutableMutator<FillType, NewFillType>): SolidLine<NewFillType>;
}
export {};
/**
 * Interface to specify the color and its value.
 * Each represented as a pair object {value: number, color: Color}.
 */
export interface LUTStep {
    /**
     * Value associated with a color.
     */
    value: number;
    /**
     * Color at given step.
     */
    color: Color;
    /**
     * Optional label to show on given step.
     *
     * Can be specified to alter default labels when the component that uses the `LUT` is attached to a `LegendBox`.
     *
     * ```typescript
     *  // Example, map Uint8 data range to Decibels range [0, 140].
     *  const lut = new LUT({
     *      steps: [
     *          { value: 0, label: '0', color: ColorHSV(0) },
     *          { value: 127.5, label: '70', color: ColorHSV(120) },
     *          { value: 255.0, label: '140', color: ColorHSV(240) },
     *      ],
     *      units: 'dB',
     *      interpolate: true,
     *  })
     * ```
     */
    label?: string;
}
/**
 * Interface to a single subrange between two LUT steps.
 * This internal data-structure is used to optimize lookup.
 * @hidden
 */
interface SubRange {
    /**
     * The lowest border of the range.
     */
    min: LUTStep;
    /**
     * The highest border of the range.
     */
    max: LUTStep;
}
/**
 * Interface to define secondary miscellaneous properties of a LUT.
 */
interface ValuePaletteOptions {
    /**
     * Title of the LUT, which describes the visualization.
     *
     * Default value: Empty string.
     */
    title: string;
    /**
     * Units of the data-values in the LUT, which describes the data domain.
     *
     * Default value: Empty string.
     */
    units: string;
    /**
     * Interpolation behavior of the LUT, which describes the distribution of color for the data:
     * - True: LUT creates a ***gradient*** LUT using linear-interpolation (LERP) between colors,
     * which were defined in the collection of steps.
     * - False: LUT creates a ***uniform*** LUT using step-function for each color
     * to describe the range of values where this color is used.
     *
     * Default value: true.
     */
    interpolate: boolean;
    /**
     * Fallback color, which is used if LUT steps are defined as empty or defined incorrectly.
     *
     * Default value: Black.
     */
    color: Color;
    /**
     * Minimum value that needs to be interpretable when using the LUT.
     *
     * By default this is automatically assigned to a slightly lower value than `min`.
     *
     * In some rare cases, it might be useful to define explicitly if look up precision errors occur.
     */
    valueRangeMin: number | undefined;
    /**
     * Maximum value that needs to be interpretable when using the LUT.
     *
     * By default this is automatically assigned to a slightly higher value than `max`.
     *
     * In some rare cases, it might be useful to define explicitly if look up precision errors occur.
     */
    valueRangeMax: number | undefined;
}
/**
 * Interface to store the collection of LUTSteps.
 */
interface LUTStepsOptions {
    /**
     * The collection of LUTSteps, which specifies the colors and their corresponding values
     * to describe the location and color of a transition point in a gradient.
     * Each represented as a pair object {value: number, color: Color}.
     *
     * Default value: [].
     */
    steps: LUTStep[];
}
/**
 * Interface to define a LUT options which were recomputed after each LUT update.
 */
interface LUTStateOptions {
    /**
     * Amount of LUT steps.
     */
    length: number;
    /**
     * Minimal value of the entire LUT.
     */
    min: number;
    /**
     * Maximal value of the entire LUT.
     */
    max: number;
    /**
     * Collection of subranges.
     */
    subranges: SubRange[];
    /**
     * Validation flag which describes that the LUT is configured correctly.
     */
    isValid: boolean;
    /**
     * Minimum value that needs to be interpretable when using the LUT.
     *
     * By default this is automatically assigned to a slightly lower value than `min`.
     *
     * In some rare cases, it might be useful to define explicitly if look up precision errors occur.
     *
     * @deprecated      Will be removed in v.4.0, this no longer affects anything.
     */
    valueRangeMin: number;
    /**
     * Maximum value that needs to be interpretable when using the LUT.
     *
     * By default this is automatically assigned to a slightly higher value than `max`.
     *
     * In some rare cases, it might be useful to define explicitly if look up precision errors occur.
     *
     * @deprecated      Will be removed in v.4.0, this no longer affects anything.
     */
    valueRangeMax: number;
}
/**
 * Record property object.
 * @hidden
 */
declare type LUTRecordType = LUTStepsOptions & ValuePaletteOptions & LUTStateOptions;
/**
 * Record constructor for PaletteProperties.
 * @hidden
 */
declare const LUTRecord: Record.Factory<LUTRecordType>;
/**
 * Interface defines a *LUT* lookup table configurations.
 */
export declare type LUTOptions = LUTStepsOptions & Partial<ValuePaletteOptions>;
/**
 * Style class for describing a *table of colors* with associated lookup values (numbers).
 *
 * Instances of LUT, like all LCJS style classes, are *immutable*, meaning that its setters don't modify the actual object,
 * but instead return a completely new modified object.
 *
 * **Properties of LUT:**
 * - `steps`: List of color steps (color + number value pair).
 * - `interpolate`: `true` enables automatic linear interpolation between color steps.
 *
 * **LUT Behavior:**
 *
 * Example 1, LUT with *interpolation disabled*.
 *
 * ```typescript
 *  const lut = new LUT({
 *      steps: [
 *          { value: 0, color: ColorRGBA( 0, 0, 0 ) },
 *          { value: 10, color: ColorRGBA( 255, 0, 0 ) },
 *          { value: 100, color: ColorRGBA( 0, 255, 0 ) }
 *      ],
 *      interpolate: false
 *  })
 * ```
 *
 * | Lookup Value | Color |
 * |--------------|-------|
 * | value < 10         | black |
 * | 10 <= value < 100  | red   |
 * | 100 <= value       | green |
 *
 *
 * Example 2, LUT with *interpolation enabled*.
 *
 * ```typescript
 *  const lut = new LUT({
 *      steps: [
 *          { value: 0, color: ColorRGBA( 0, 0, 0 ) },
 *          { value: 10, color: ColorRGBA( 255, 0, 0 ) },
 *          { value: 100, color: ColorRGBA( 0, 255, 0 ) }
 *      ],
 *      interpolate: true
 *  })
 * ```
 *
 * | Lookup Value | Color |
 * |--------------|-------|
 * | value <= 0         | black |
 * | 0 < value < 10     | interpolated between black and red |
 * | 10 < value < 100   | interpolated between red and green |
 *
 *
 * **LUT Usage:**
 *
 * Use *LUT* with:
 * - [[PalettedFill]] for styling *series* based on different lookup values (user supplied data, x/y/z coordinates, ...)
 * - Sliced charts for styling slices dynamically based on their value
 *      * [[PieChart.setLUT]]
 *      * [[GaugeChart.setLUT]]
 *      * [[PyramidChart.setLUT]]
 *      * [[FunnelChart.setLUT]]
 *
 * @noInheritDoc
 */
export declare class LUT extends LUTRecord {
    /**
     * Construct a LUT object, specifying any amount of its properties.
     *
     * Example 1, LUT with *interpolation disabled*.
     *
     * ```typescript
     *  const lut = new LUT({
     *      steps: [
     *          { value: 0, color: ColorRGBA( 0, 0, 0 ) },
     *          { value: 10, color: ColorRGBA( 255, 0, 0 ) },
     *          { value: 100, color: ColorRGBA( 0, 255, 0 ) }
     *      ],
     *      interpolate: false
     *  })
     * ```
     *
     * Example 2, LUT with *interpolation enabled*.
     *
     * ```typescript
     *  const lut = new LUT({
     *      steps: [
     *          { value: 0, color: ColorRGBA( 0, 0, 0 ) },
     *          { value: 10, color: ColorRGBA( 255, 0, 0 ) },
     *          { value: 100, color: ColorRGBA( 0, 255, 0 ) }
     *      ],
     *      interpolate: true
     *  })
     * ```
     *
     * @param   props   Object containing any amount of LUT properties.
     */
    constructor(options: LUTOptions);
    /**
     * Get string description of the Style object.
     * @return  String based on all properties of the Style object.
     * @hidden
     */
    toString(): string;
    /**
     * Set new collection of LUT steps.
     * @param steps Collection of color-value pairs.
     */
    setSteps(steps: LUTStep[]): this;
    /**
     * Get collection of LUT steps.
     * @returns Collection of steps.
     */
    getSteps(): LUTStep[];
    /**
     * Set title of the LUT, which describes the data.
     * @param title Title of the LUT.
     */
    setTitle(title: string): this;
    /**
     * Get title of the LUT.
     * @returns Title of the LUT as string.
     */
    getTitle(): string;
    /**
     * Set units of the data-values in the LUT, which describes the data domain.
     * @param units Units of the LUT.
     */
    setUnits(units: string): this;
    /**
     * Get units of the LUT.
     * @returns Units of the LUT as string.
     */
    getUnits(): string;
    /**
     * Set interpolation behavior of the LUT, which describes the distribution of color for the data:
     * - True: creates a ***gradient*** LUT using linear-interpolation (LERP) between colors,
     * which were defined in the collection of steps.
     * - False: creates a ***uniform*** LUT using step-function for each color
     * to describe the range of values where this color is used.
     * @param interpolate Interpolation behavior: True - gradient, False - uniform.
     */
    setInterpolation(interpolate: boolean): this;
    /**
     * Get interpolation behavior of the LUT.
     * @returns Intepolation behaviour state. True - gradient, False - uniform.
     */
    getInterpolation(): boolean;
    /**
     * Set fallback color.
     * The following color would be used as a backup.
     * Meaning, the LUT might be configured incorrectly or the data is incorrect.
     * @param color Color object.
     */
    setFallbackColor(color: Color): this;
    /**
     * Get fallback color of value the LUT.
     * @returns Color object.
     */
    getFallbackColor(): Color;
    /**
     * Get the color associated with the given value.
     *
     * Example:
     * ```javascript
     * const color = lut.getColors( 5 )
     * ```
     * @param values Single value.
     * @returns Associated color if the LUT is valid, otherwise fallback color.
     */
    getColors(values: number): Color;
    /**
     * Get the colors associated with the given collection of values.
     *
     * Example:
     * ```javascript
     * const colors = lut.getColors( [ 5, 10, 15 ] )
     * ```
     * @param values 1D collection of value.
     * @returns Collection of associated colors if the LUT is valid, otherwise fallback colors.
     */
    getColors(values: number[]): Color[];
    /**
     * Get the colors associated with the given collection Matrix2D of values.
     *
     * Example:
     * ```javascript
     * const colors = lut.getColors(
     *  [
     *    [ 3, 7, 9 ],
     *    [ 5, 10, 15 ]
     *  ]
     * )
     * ```
     * @param values 2D collection of values.
     * @returns Collection of associated colors if the LUT is valid, otherwise fallback colors.
     */
    getColors(values: number[][]): Color[][];
}
export {};
/**
 * Atm, for internal usage only.
 *
 * **IMPORTANT: Do not use *instanceof* to check for EmptyPoints3D**
 * **The class prototype is empty and as such the check would pass for any object**
 * **instead, check if object === emptyPoints3D (global singleton)**
 * @hidden
 */
export declare class EmptyPoints3D {
}
/**
 * Singleton object which indicates that points should not be rendered.
 *
 * When *emptyPoints3D* is used, the area that would be filled does **NOT** trigger mouse / touch -events, and
 * its rendering process is skipped, which results in saved performance.
 *
 * Atm, for internal usage only.
 * @hidden
 */
export declare const emptyPoints3D: EmptyPoints3D;
/**
 * Interface for all properties of a TriangulatedPoints3D.
 */
export interface TriangulatedPoints3DProperties {
    /**
     * Shape of rendered points.
     */
    shape: 'cube' | 'sphere';
    /**
     * Points size.
     *
     * Supports two types `number` or `Coord3D`:
     *
     * `number`:
     *
     * Symmetric size as _normalized World Units_ (roughly equal to pixels).
     *
     * [[Coord3D]]:
     *
     * User supplies size on each Axis, X, Y and Z individually, as Axis coordinates.
     *
     * ```js
     *  // Example syntax, 3D point size in Axis dimensions.
     *  pointSeries3D.setPointStyle(new TriangulatedPoints3D({
     *      size: { x: 10, y: 5, z: 200 },
     *      shape: 'sphere',
     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
     *  }))
     * ```
     */
    size: number | Coord3D;
    /**
     * *FillStyle* for rendering the points.
     */
    fillStyle: FillStyle;
    /**
     * *LineStyle* for rendering geometry wireframe.
     */
    wireframeStyle: LineStyle;
}
/**
 * A style class used to specify style of 3D points rendering as triangulated shapes.
 *
 * Supports specifying shape as a **cube** or a **sphere**.
 */
export declare class TriangulatedPoints3D implements HighlightableType {
    /**
     * When creating a new TriangulatedPoints3D object, any amount of its default parameters can be *overriden*, by supplying the
     * values to its constructor:
     * ```javascript
     *  new PointStyle3D.Triangulated({
     *      size: 10,
     *      fillStyle: new SolidFill({ color: ColorHex('#FFF') }),
     *  })
     * ```
     * @param   props   Optional object containing any amount of parameters of TriangulatedPoints3D
     */
    constructor(props?: Partial<TriangulatedPoints3DProperties>);
    /**
     * Construct a new TriangulatedPoints3D object based on this one, but with different size.
     *
     * Two size definitions are supported: `number` and `Coord3D`:
     *
     * `number`:
     *
     * Symmetric size as _normalized World Units_ (roughly equal to pixels).
     *
     * [[Coord3D]]:
     *
     * User supplies size on each Axis, X, Y and Z individually, as Axis coordinates.
     *
     * ```js
     *  // Example syntax, 3D point size in Axis dimensions.
     *  pointSeries3D.setPointStyle(new TriangulatedPoints3D({
     *      size: { x: 10, y: 5, z: 200 },
     *      shape: 'sphere',
     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
     *  }))
     * ```
     *
     * @param   size    Points size.
     * @return          New TriangulatedPoints3D object
     */
    setSize(size: number | Coord3D): this;
    /**
     * Get size of points rendered with this style object.
     * @return          Point size.
     */
    getSize(): number | Coord3D;
    /**
     * Construct a new TriangulatedPoints3D object based on this one, but with modified fill style.
     *
     * Example usage:
     *
     * | Desired result         | Argument                                      |
     * | :--------------------- | :-------------------------------------------- |
     * | Specified FillStyle    | new SolidFill({ color: ColorHex('#F00') })    |
     *
     * @param   value   Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @return          New TriangulatedPoints3D object
     */
    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of TriangulatedPoints3D.
     * @return  FillStyle object
     */
    getFillStyle(): FillStyle;
    /**
     * Construct a new TriangulatedPoints3D object based on this one, but with modified wireframe style.
     *
     * ```js
     *  // Example syntax,
     *  pointSeries3D.setPointStyle((style) => style
     *      .setWireframeStyle(new SolidLine({
     *          thickness: 1,
     *          fillStyle: new SolidFill({ color: ColorRGBA(255, 215, 0, 25) })
     *      }))
     *  )
     * ```
     *
     * @param   value   Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
     * @return          New TriangulatedPoints3D object
     */
    setWireframeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get wireframe style of TriangulatedPoints3D.
     * @return  LineStyle object
     */
    getWireframeStyle(): LineStyle;
    /**
     * Construct a new TriangulatedPoints3D object based on this one, but with different shape.
     *
     * @param   shape   Shape of the rendered points. Supports **'cube'** and **'sphere'**.
     * @return          New TriangulatedPoints3D object
     * @hidden
     */
    setShape(shape: 'cube' | 'sphere'): this;
    /**
     * Get size of points rendered with this style object.
     * @return          Size of the rendered points as *normalized World Units* (roughly equal to pixels).
     * @hidden
     */
    getShape(): 'cube' | 'sphere';
    /**
     * Get automatically computed highlight style.
     * @return  FillStyle object
     */
    getDefaultHighlightStyle(): this;
}
/**
 * Interface for all properties of a PixelatedPoints3DProperties.
 */
export interface PixelatedPoints3DProperties {
    /**
     * Size of the rendered points in **pixels**.
     *
     * Some devices / browser configurations always render with 1 pixel, regardless of this setting.
     */
    size: number;
    /**
     * *FillStyle* for rendering the points.
     */
    fillStyle: FillStyle;
}
/**
 * A style class used to specify style of 3D points rendering as pixelated squares.
 *
 * This rendering style is optimal for rendering large numbers of points that do not require great individual detail.
 */
export declare class PixelatedPoints3D implements HighlightableType {
    /**
     * When creating a new PixelatedPoints3D object, any amount of its default parameters can be *overriden*, by supplying the
     * values to its constructor:
     * ```javascript
     *  new PointStyle3D.Pixelated({
     *      size: 4,
     *      fillStyle: new SolidFill({ color: ColorHex('#FFF') }),
     *  })
     * ```
     * @param   props   Optional object containing any amount of parameters of PixelatedPoints3D
     */
    constructor(props?: Partial<PixelatedPoints3DProperties>);
    /**
     * Construct a new PixelatedPoints3D object based on this one, but with different size.
     *
     * @param   size    Size of the rendered points in **pixels**.
     * @return          New PixelatedPoints3D object
     */
    setSize(size: number): this;
    /**
     * Get size of points rendered with this style object.
     * @return          Size of the rendered points in **pixels**.
     */
    getSize(): number;
    /**
     * Construct a new PixelatedPoints3D object based on this one, but with modified fill style.
     *
     * Example usage:
     *
     * | Desired result         | Argument                                      |
     * | :--------------------- | :-------------------------------------------- |
     * | Specified SolidFill    | new SolidFill({ color: ColorHex('#F00') })    |
     *
     * @param   value   Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @return          New PixelatedPoints3D object
     */
    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of PixelatedPoints3D.
     * @return  FillStyle object
     */
    getFillStyle(): FillStyle;
    /**
     * Get automatically computed highlight style.
     * @return  FillStyle object
     */
    getDefaultHighlightStyle(): this;
}
/**
 * Collection of constructors for specifying style of 3D points rendering.
 *
 * Used with:
 * - **PointSeries3D**
 * - **PointCloudSeries3D**
 */
export declare const PointStyle3D: {
    /**
     * A style class used to specify style of 3D points rendering as triangulated Cubes.
     */
    Triangulated: typeof TriangulatedPoints3D;
    /**
     * A style class used to specify style of 3D points rendering as pixelated squares.
     *
     * This rendering style is optimal for rendering large numbers of points that do not require great individual detail.
     */
    Pixelated: typeof PixelatedPoints3D;
};
/**
 * @internal
 */
export declare const _solidForColorLogo: {
    _width: number;
    _height: number;
    _url: string;
};
/**
 * @internal
 */
export declare const _solidForGrayScaleLogo: {
    _width: number;
    _height: number;
    _url: string;
};

export declare abstract class GlInstanceGeometry {
    readonly _glUtils: GlUtils;
    constructor(_glUtils: GlUtils);
}
export interface GlInstanceGeometry3D {
}

export declare class GlInstanceGeometryList {
}

export interface GlEntity extends Entity {
}
export declare class GlEngine extends Engine {
    
    constructor(lcjsOptionsInput?: LightningChartOptions, options?: EngineOptions, GlUtilsConstructor?: typeof GlUtils);
}

export declare class GlUtils {
    readonly _lcjsOptions: InternalLightningChartOptions;
    
    readonly gl: WebGLRenderingContext;
    
    readonly gl2?: {
        ctx: WebGL2RenderingContext;
    };
    
    readonly gl1?: {
        ctx: WebGLRenderingContext;
        
        _ext: {
            ANGLE_instanced_arrays: ANGLE_instanced_arrays | null;
            EXT_blend_minmax: EXT_blend_minmax | null;
            OES_element_index_uint: OES_element_index_uint | null;
            OES_standard_derivatives: OES_standard_derivatives | null;
            OES_vertex_array_object: OES_vertex_array_object | null;
        };
        
        optional: {
            OES_texture_float: OES_texture_float | null;
        };
    };
    
    readonly IS_MACHINE_LITTLE_ENDIAN: boolean;
    constructor(_lcjsOptions: InternalLightningChartOptions, glCtx: {
        type: 'webgl2';
        ctx: WebGL2RenderingContext;
        antialias: boolean | undefined;
        lineAntialias: boolean;
    } | {
        type: 'webgl1';
        ctx: WebGLRenderingContext;
        antialias: boolean | undefined;
        lineAntialias: boolean;
    }, enableAlphaBlending?: boolean);
}
export declare type WebGLDrawMode = number;

export declare class Uniforms {
    MixedScaleXY: MixedScaleValuesXY;
}

export declare class Uniforms3D {
}

export declare class GLOffscreenHelper {
    private _glUtils;
    
    constructor(_glUtils: GlUtils);
}

export declare class RenderCall {
    protected readonly glUtils: GlUtils;
    protected readonly shader: Shader;
    constructor(glUtils: GlUtils, shader: Shader);
    
    uniform: (name: string) => WebGLUniformLocation;
    
    uniformOptional: (name: string) => WebGLUniformLocation | undefined;
    
    attribute: (name: string) => number;
    
    finish(): void;
}

export declare class GlImageTexture implements Disposable {
    
    constructor(glHelper: GlUtils, source: ImageFillSource);
    restore(): this;
    dispose(): this;
    isDisposed(): boolean;
}

export interface GlLayer {
}

export declare class GlLayer2D extends Layer2D implements GlLayer {
    protected readonly _glEngine: GlEngine;
    readonly gl: GlUtils;
    
    constructor(_glEngine: GlEngine, zIndex: number);
}

export declare class GlLayer3D extends Layer3D implements GlLayer {
    readonly _glEngine: GlEngine;
    readonly gl: GlUtils;
    
    constructor(_glEngine: GlEngine, zIndex: number, _scale: Vec3<UnitScale>);
}

export interface LUTRequest {
    readonly lut: LUT;
    readonly textureInfo?: LUTTextureInfo | null;
}

export interface LUTTextureInfo {
    texture: WebGLTexture;
    textureHeight: number;
}

export declare class SharedLUTs {
    private _gl;
    constructor(_gl: WebGLRenderingContext);
}

export declare const SharedLuts: (gl: WebGLRenderingContext) => SharedLUTs;

export interface Font {
    readonly font: string;
    readonly properties: FontProperties;
}

export declare const FontFactory: (font: string, properties: FontProperties) => Font;

export interface Glyph {
    
    origin: Point;
    
    size: Point;
    
    texCoords: [number, number, number, number, number, number, number, number, number, number, number, number];
    
    vertices: [number, number, number, number, number, number, number, number, number, number, number, number];
    
    texture: WebGLTexture;
    
    advanceX: number;
    
    baseline: number;
    
    packerId: number;
}

export interface GlyphInfo {
    
    glyph: string;
    
    size: Point;
    
    baseline: number;
    
    advance: number;
    
    offsetX: number;
}

export declare const Fonts: (settings: FontSettings) => Font;
export interface HeatmapGridScrollingOptions {
    
    heatmapDataType: 'intensity' | 'color';
    
    scrollDimension: 'columns' | 'rows';
    start: Point;
    step: Point;
    
    resolution: number;
}

export declare abstract class HeatmapGridScrolling extends FilledShape<LinearScaleXY | RadialScale> implements Region {
    readonly engine: Engine;
    
    constructor(engine: Engine, scale: LinearScaleXY | RadialScale, _remove: RemoveHandler<Entity>, _restore: RestoreHandler<Entity>, applicationFlags: InternalApplicationFlagPlusArgs[], _options: HeatmapGridScrollingOptions);
}

export declare type HeatmapGridStaticOptions = {
    columns: number;
    rows: number;
    
    heatmapDataType: 'intensity' | 'color';
    
    dataOrder: 'columns' | 'rows';
    start: Point;
    step: Point;
};

export declare type HeatmapGridInvalidationMatrix<T> = {
    
    type: 'intensity' | 'y';
    
    startPrimary: number;
    
    startSecondary: number;
    
    lengthPrimary: number;
    
    lengthSecondary: number;
    
    values: T[][];
};

export declare abstract class HeatmapGridStatic extends FilledShape<LinearScaleXY | RadialScale> implements Region {
    readonly engine: Engine;
    
    constructor(engine: Engine, scale: LinearScaleXY | RadialScale, _remove: RemoveHandler<Entity>, _restore: RestoreHandler<Entity>, applicationFlags: InternalApplicationFlagPlusArgs[], _options: HeatmapGridStaticOptions);
}

export declare type SurfaceGridScrollingOptions = {
    start: PointXZ;
    step: PointXZ;
    columns: number;
    rows: number;
    scrollDimension: 'columns' | 'rows';
    heatmapDataType: 'intensity';
};

export interface SurfaceGridScrolling extends Shape3D, Region3D {
}

export declare type SurfaceGridStaticOptions = {
    start: NonReadonly<PointXZ>;
    step: PointXZ;
    columns: number;
    rows: number;
    heatmapDataType: 'intensity';
    dataOrder: 'columns' | 'rows';
};

export interface SurfaceGridStatic extends Shape3D, Region3D {
}

export declare type reduceCallback<S, V, T, U> = (result: S, val: V, key: T, collection: U) => S;

export declare type orderedReduceCallback<S, V, T, U> = (result: S, left: V | undefined, cur: V, right: V | undefined, key: T, collection: U) => S;

export declare class Node<T> {
    value: T;
    left: Node<T> | null;
    right: Node<T> | null;
    length: number;
    constructor(value?: T);
}

export declare class Item<K, T> {
    key: K;
    value: T;
    constructor(key: K, value: T);
    equals(that: Item<K, T>): boolean;
    compare(that: Item<K, T>): number;
}
export declare class SortedMap<K, T> {
    contentEquals: (a: K | T, b: K | T) => boolean;
    contentCompare: (a: K | T, b: K | T) => number;
    store: SortedSet<Item<K, T>>;
    length: number;
    constructor(items?: Item<K, T> | Item<K, T>[], equals?: (a: K, b: K) => boolean, compare?: (a: K, b: K) => number);
}

export declare class SortedSet<T> {
    root: Node<T> | null;
    length: number;
    contentCompare: (a: T, b: T) => number;
    contentEquals: (a: T, b: T) => boolean;
    constructor(values?: T | T[], equals?: (a: T, b: T) => boolean, compare?: (a: T, b: T) => number);
}

export declare function defaultCompareFunction<T>(a: T, b: T): number;

export declare function defaultEqualsFunction<T>(a: T, b: T): boolean;

export declare function noop<T>(): undefined;

export declare class _PresetCurve {
    curve: any;
    g: any;
    n: any;
    constructor(options: any);
}
declare const curves: {
    [key: string]: any;
};
export { curves };

export declare class ColumnPackagingHelper extends ProgressiveHelperXY {
    protected readonly _refresh: () => unknown;
    
    constructor(_scale: ScaleXY, _applicationFlagsOwner: ApplicationFlagOwner, _refresh: () => unknown);
}

export declare class DataCleaningHelper<Segment extends DataPointsGroupXY> extends ProgressiveHelperXY {
}

export declare type InternalDataCleaningConfiguration = undefined | {
    
    maxDataPointCount: number | undefined;
} | {
    
    minDataPointCount: number | undefined;
} | {
    
    progressiveDataCleaningThreshold: number | undefined;
};

export interface DataPointsGroup {
    
    existingDataPointsCount: number;
    
    existingCoordinatesCount: number;
    
    allocatedCoordinatesCount: number;
}

export interface DataPointsGroupXY extends DataPointsGroup {
    
    boundaries: Interval<Point>;
}

export interface JointedDataPointsGroupXY extends DataPointsGroupXY {
    
    lastDataPoint: Point | undefined;
    
    jointPointsCount: number;
}

export interface DataPointsGroupXYZ extends DataPointsGroup {
    
    boundaries: Interval<Point3D>;
}

export interface JointedDataPointsGroupXYZ extends DataPointsGroupXYZ {
    
    lastDataPoint: Point3D | undefined;
    
    jointPointsCount: number;
}

export declare abstract class ProgressiveHelperXY {
    protected readonly _scale: ScaleXY;
    protected readonly _applicationFlagsOwner: ApplicationFlagOwner;
    
    constructor(_scale: ScaleXY, _applicationFlagsOwner: ApplicationFlagOwner);
    
    calculateUserDataPointsProgressiveRange(userDataPoints: Point[]): {
        start: number;
        end: number;
    };
    
    calculateUserDataPointsBoundaries(userDataPoints: Point[]): Interval<Point>;
    
    calculateAvgStepBetweenDataPoints(progressiveDataPointA: number, progressiveDataPointB: number, dataPointsInBetweenCount: number): number;
}

export declare class ProgressiveRenderHelperXY<Segment extends DataPointsGroupXY> extends ProgressiveHelperXY {
    
    renderVisibleOnly(segments: Segment[], clbk: (segment: Segment) => unknown): void;
}

export declare class SegmentationHelper<SegmentType extends DataPointsGroup, DataPoint> {
    protected readonly _destroySegment: (segment: SegmentType) => unknown;
    protected readonly _connectSegments: boolean;
    
    constructor(_activeSegments: SegmentType[], _destroySegment: (segment: SegmentType) => unknown, _connectSegments: boolean);
}

export declare abstract class Scale1D {
    
    getInnerStart(): number;
    
    getInnerEnd(): number;
    
    getInnerInterval(): number;
}

export declare abstract class ViewportScale1D extends Scale1D {
    _cellIndex: number;
    _cellSpan: number;
    _cellsAmount: number;
    
    constructor(_cellIndex: number, _cellSpan: number, _cellsAmount: number, _observedAmount?: ObservableValue<number[]>);
    
    getCellSize(): number;
}

export interface ScaleFactory {
    
    d1: <T extends Scale1D = Scale1D>(arg: {
        scale1DConstructor: Scale1DConstructor<T>;
        dimension: 'x' | 'y';
    }) => T;
    
    d2: <T extends ScaleXY & {
        _fromDashboardCellDefinition(cellIndex: Point, cellSpan: Point, cellsAmount: Point, observedAmount: Vec2<ObservableValue<number[]>> | undefined): T;
    }>(arg: {
        scaleXYConstructor: new () => T;
    }) => T;
}
declare type Scale1DConstructor<T> = new (cellIndex: number, cellSpan: number, cellsAmount: number, observedAmount?: ObservableValue<number[]>) => T;
export {};

export declare class LinearScale1D extends ViewportScale1D {
    
    getPixelSize(): number;
}

export declare class LogarithmicScale1D extends ViewportScale1D {
}

export declare type LogarithmicBaseInternal = 'e' | number;

export declare class RadialScale extends ScaleXY<LinearScale1D> {
}

export declare class UnitScale extends Validator implements Validatable, FormattingRange {
    
    getInnerStart(): number;
    
    getInnerEnd(): number;
    
    getInnerInterval(): number;
}

export declare const _createScaleFromAxesScalesXY: (scaleX: LinearScale1D | LogarithmicScale1D, scaleY: LinearScale1D | LogarithmicScale1D) => ScaleXY;

export declare abstract class ScaleXY<T extends ViewportScale1D = ViewportScale1D> {
    
    x: T;
    
    y: T;
    
    getInnerIntervalPixels(): Point;
}

export declare class LinearScaleXY extends ScaleXY<LinearScale1D> {
}

export declare type LinearScaleValuesXY = Vec2<{
    
    displacement: number;
    
    scaling: number;
    
    highPrecisionOffset: number;
}>;

export declare class MixedScaleXY extends ScaleXY<LinearScale1D | LogarithmicScale1D> {
}

export declare type MixedScaleValuesXY = {
    
    uScaleStart: [number, number];
    
    uScaleStartLog: [number, number];
    
    uScaleInterval: [number, number];
    
    uScaleIntervalLog: [number, number];
    
    uViewportStart: [number, number];
    
    uViewportSize: [number, number];
};

export interface MultiTexturePackInfo extends TexturePackInfo {
}

export declare class MultiTexturePacker {
    
    constructor(maxTextureSize: number);
}

export declare class TextureNode {
    constructor(origin: Point, size: Point);
}

export interface TexturePackInfo {
}

export declare class TexturePacker {
    
    constructor(maxTextureSize: number);
}
export {};

export interface IndicesGeneratorOptions {
    
    position: number;
    
    buffer: number[];
    
    next?: boolean;
}

interface Indices {
    
    first: number;
    
    second: number;
    
    third: number;
    
    fourth: number;
    
    fifth: number;
    
    sixth: number;
}

export declare class IndicesGenerator implements Indices {
    first: number;
    second: number;
    third: number;
    fourth: number;
    fifth: number;
    sixth: number;
}
export {};

export declare type Tiles = Array<Array<GridRangeOptions>>;

export interface IntensityTiles {
    tiles: Tiles;
    tilesCount: Point;
}
export interface PreRenderingTile<T> {
    range: GridRangeOptions;
    vbo: number[];
    ibo: Uint16Array;
    length: number;
    lengthWireframe: number;
    boundary: Interval<T>;
    intensities?: Float32Array;
    colors?: Float32Array;
}
export interface RenderingTile {
    
    vbo?: WebGLBuffer;
    
    ibo?: WebGLBuffer;
    
    intensities?: WebGLBuffer;
    
    colors?: WebGLBuffer;
    
    length?: number;
    
    lengthWireframe?: number;
}
export {};
export {};
export {};
/**
 * Type definition for a dynamic mouse style setting.
 * This allows for mouse styles that depend on situation.
 * @param   uiElement   UIElement to apply
 * @return              Mouse style as string or undefined
 */
export declare type DynamicUIMouseStyle<T extends UIElement> = (uiElement: T) => string | undefined;
/**
 * Type definition for a mouse style setting. This tells how mouse should look when hovering over an UIElement.
 *
 * For a collection of mouse styles, see [[MouseStyles]].
 */
export declare type UIMouseStyle = string | DynamicUIMouseStyle<UIElement>;
/**
 * Base class for Mouse-interactable ui-objects.
 * @hidden Internal class
 */
export declare abstract class UIObject implements Interactable {
    /**
     * Subscribe to Mouse Enter event
     * @param   listener    Function that will be called when mouse enters the bounds of UiObject.
     * @param   obj         Always object itself.
     * @param   event       MouseEvent that triggered the listener.
     * @return              Token-object that is a reference ID to the listener created.
     */
    onMouseEnter(listener: MouseEventHandler<this>): Token;
    /**
     * Subscribe to Mouse Leave event
     * @param   listener    Function that will be called when mouse leaves the bounds of UiObject.
     * @param   obj         Always object itself.
     * @param   event       MouseEvent that triggered the listener.
     * @return              Token-object that is a reference ID to the listener created.
     */
    onMouseLeave(listener: AbruptMouseEventHandler<this>): Token;
    /**
     * Subscribe to Mouse Click event
     * @param   listener    Function that will be called when mouse clicks the bounds of UiObject.
     * @param   obj         Always object itself.
     * @param   event       MouseEvent that triggered the listener.
     * @return              Token-object that is a reference ID to the listener created.
     */
    onMouseClick(listener: MouseEventHandler<this>): Token;
    /**
     * Subscribe to Mouse Double Click event
     */
    onMouseDoubleClick(listener: MouseEventHandler<this>): Token;
    /**
     * Subscribe to Mouse Down event
     */
    onMouseDown(listener: MouseEventHandler<this>): Token;
    /**
     * Subscribe to Mouse Up event
     */
    onMouseUp(listener: MouseEventHandler<this>): Token;
    /**
     * Subscribe to Mouse Move event
     * @param   listener    Event handler function
     * @returns             Token of subscription
     */
    onMouseMove(listener: MouseEventHandler<this>): Token;
    /**
     * Subscribe to Mouse Drag Start event
     */
    onMouseDragStart(listener: MouseDragStartEventHandler<this>): Token;
    /**
     * Subscribe to Mouse Drag event
     */
    onMouseDrag(listener: MouseDragEventHandler<this>): Token;
    /**
     * Subscribe to Mouse Drag Stop event
     */
    onMouseDragStop(listener: MouseDragStopEventHandler<this>): Token;
    /**
     * Subscribe to Mouse Wheel event
     * @param   listener    Event handler function
     * @returns             Token of subscription
     */
    onMouseWheel(listener: MouseWheelEventHandler<this>): Token;
    /**
     * Subscribe to Touch Start event
     * @param   listener    Event handler function
     * @returns             Token of subscription
     */
    onTouchStart(listener: TouchEventHandler<this>): Token;
    /**
     * Subscribe to Touch Move event
     * @param   listener    Event handler function
     * @returns             Token of subscription
     */
    onTouchMove(listener: TouchEventHandler<this>): Token;
    /**
     * Subscribe to Touch End event
     * @param   listener    Event handler function
     * @returns             Token of subscription
     */
    onTouchEnd(listener: TouchEventHandler<this>): Token;
    /**
     * Remove event listener from Mouse Enter Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseEnter(token: Token): boolean;
    /**
     * Remove event listener from Mouse Leave Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseLeave(token: Token): boolean;
    /**
     * Remove event listener from Mouse Click Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseClick(token: Token): boolean;
    /**
     * Remove event listener from Mouse Double Click Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseDoubleClick(token: Token): boolean;
    /**
     * Remove event listener from Mouse Down Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseDown(token: Token): boolean;
    /**
     * Remove event listener from Mouse Up Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseUp(token: Token): boolean;
    /**
     * Remove event listener from Mouse Move Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseMove(token: Token): boolean;
    /**
     * Remove event listener from Mouse Drag Start Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseDragStart(token: Token): boolean;
    /**
     * Remove event listener from Mouse Drag Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseDrag(token: Token): boolean;
    /**
     * Remove event listener from Mouse Drag Stop Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseDragStop(token: Token): boolean;
    /**
     * Remove event listener from Mouse Wheel Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offMouseWheel(token: Token): boolean;
    /**
     * Remove event listener from Touch Start Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offTouchStart(token: Token): boolean;
    /**
     * Remove event listener from Touch Move Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offTouchMove(token: Token): boolean;
    /**
     * Remove event listener from Touch End Event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offTouchEnd(token: Token): boolean;
    /**
     * Set mouse interactions enabled.
     * Implementations should update the mouse-interactions of any Shapes they may contain here.
     * @param   state
     */
    abstract setMouseInteractions(state: boolean): this;
    /**
     * @return Mouse interactions state
     */
    abstract getMouseInteractions(): boolean;
    /**
     * Get boolean flag for whether object is currently under mouse or not
     * @return  Boolean for is object under mouse currently
     */
    getIsUnderMouse(): boolean;
}
/**
 * Interface for abstract part of an *UIElement*, that does not manage its own location (for example, part of a *layout*).
 */
export interface UIPart extends Interactable, Marginable, Disposable {
    /**
     * Set mouse style when hovering over UI object.
     * @param   mouseStyle  Interface for defining how mouse should look when hovering over UI object
     * @return              Object itself
     */
    setMouseStyle(mouseStyle: UIMouseStyle): this;
    /**
     * Get mouse style.
     * @return              Interface for defining how mouse should look when hovering over UI object
     */
    getMouseStyle(): UIMouseStyle;
}
/**
 * Interface for a stand-alone *UIElement*.
 *
 * Adds ability for:
 * - Setting position
 * - Specifying draggability
 */
export interface UIElement extends UIObject, UIPart, Draggable, Plotable, Disposable {
    /**
     * Sets the position of this UiElement relative to its origin
     * @param position              Position
     */
    setPosition(position: Point): this;
    /**
     * Returns the position of this UiElement at given location relative to elements size.
     * @param relativePosition      Relative position vector (-1 to 1 which specifies position of origin, 0 is center of the object)
     * @param spaceOfInterest       Parameter to disregard parts of object when calculating the asked position. Defaults to Margin.
     * @return                      Object itself for fluent itself
     */
    getPosition(relativePosition?: Point, spaceOfInterest?: UISpace): Point;
    /**
     * Sets the position origin of this UiElement.
     * @param   origin  Relative position vector (-1 to 1, where 0 is center of the object).
     *                  UIOrigins, enum-like object can be used for easy selection of common values
     */
    setOrigin(origin: Point): this;
    /**
     * Returns the position origin of this UiElement.
     * @return  Relative position vector (-1 to 1, where 0 is center of the object).
     */
    getOrigin(): Point;
    /**
     * Returns the size of the UiElements in pixels including any Margins or Paddings
     * @param spaceOfInterest       Parameter to disregard parts of object when calculating the position. Defaults to Margin,
     *                              which includes everything. Should only ever be necessary for sub-classes
     * @return                      Object size in pixels
     */
    getSize(spaceOfInterest?: UISpace): Point;
    /**
     * Set auto dispose behavior for this UI element.
     *
     * Can be used to set a condition, where the UI element is automatically *disposed*, removing it from view.
     *
     * ```ts
     *  // Example, remove UI element when it is larger than 20% of viewport.
     *  UIElement.setAutoDisposeMode({
     *      type: 'max-width',
     *      maxWidth: 0.20,
     *  })
     * ```
     * @param   autoDisposeMode     Auto dispose mode.
     * @returns                     Object itself for fluent interface.
     */
    setAutoDispose(autoDisposeMode: AutoDisposeMode): this;
    /**
     * Get auto dispose behavior for this UI element.
     * @return                      Auto dispose mode.
     */
    getAutoDispose(): AutoDisposeMode;
}
/**
 * Base class for UI elements.
 * @hidden Internal class
 */
export declare abstract class InternalUIElement extends UIObject implements UIElement, Disposable {
    protected readonly _layer: Layer2D;
    protected readonly renderingScale: LinearScaleXY;
    readonly scale: ScaleXY;
    private readonly _remove;
    private readonly _restore;
    readonly theme: Theme;
    /**
     * Pixel location of UiElements origin. To get position use getPosition(relativePosition).
     *
     * Coordinate system = position scale (UIElement.scale)
     */
    protected position: any;
    protected origin: any;
    protected size: any;
    /**
     * @param   _layer                  Layer of drawing engine. Should be kept protected at all times
     * @param   renderingScale          Rendering scale
     * @param   scale                   Positioning scale
     * @param   _remove                 Injected remove method from parent.
     * @param   _restore                Injected restore method from parent.
     * @hidden
     */
    constructor(_layer: Layer2D, renderingScale: LinearScaleXY, scale: ScaleXY, _remove: RemoveHandler<UIElement>, _restore: RestoreHandler<UIElement>, theme: Theme);
    /**
     * Set auto dispose behavior for this UI element.
     *
     * Can be used to set a condition, where the UI element is automatically *disposed*, removing it from view.
     *
     * ```ts
     *  // Example, remove UI element when it is larger than 20% of viewport.
     *  UIElement.setAutoDisposeMode({
     *      type: 'max-width',
     *      maxWidth: 0.20,
     *  })
     * ```
     * @param   autoDisposeMode     Auto dispose mode.
     * @returns                     Object itself for fluent interface.
     */
    setAutoDispose(autoDisposeMode: AutoDisposeMode): this;
    /**
     * Get auto dispose behavior for this UI element.
     * @return                      Auto dispose mode.
     */
    getAutoDispose(): AutoDisposeMode;
    /**
     * Returns the size of the UiElements in pixels including any Margins or Paddings
     * @param spaceOfInterest       Parameter to disregard parts of object when calculating the position. Defaults to Margin,
     *                              which includes everything. Should only ever be necessary for sub-classes
     * @return                      Object size in pixels
     */
    getSize(spaceOfInterest?: UISpace): Point;
    /**
     * Member function that updates the size of the UI elements contents.
     * UiElements should apply this inside 'update'
     * @param   sizeInPixels    Size of element in pixels
     */
    protected setContentSize(sizeInPixels: Point): void;
    /**
     * Set margin around object in pixels.
     * @param   margin      Number with pixel margins for all sides or datastructure with individual pixel margins
     *                      for each side. Any side can be omitted, only passed values will be overridden.
     * @return              Object itself
     */
    setMargin(margin: Partial<MMargin> | number): this;
    /**
     * Get margin around object in pixels.
     * @return  Margin datastructure
     */
    getMargin(): Margin;
    /**
     * Dispose object, ceasing its operation while keeping the object intact until call of 'restore'.
     * @return Object itself for fluent interface
     */
    dispose(): this;
    /**
     * Restore object if it was previously disposed.
     * @returns Object itself itself for fluent interface
     */
    restore(): this;
    /**
     * Return the current state of Disposable object.
     * @return True if object is disposed, false if not.
     */
    isDisposed(): boolean;
    /**
     * Sets the position of this UiElement relative to its origin.
     *
     * NOTE: UIElements scale can't be changed apart from when it is created.
     * @param position  Location on the UIElements scale, where its origin should be positioned
     * @return          Object itself
     */
    setPosition(position: Point): this;
    /**
     * Returns the position of this UiElement at given location relative to elements size.
     * @param relativePosition      Relative position vector (-1 to 1 which specifies position of origin, 0 is center of the object)
     * @param spaceOfInterest       Parameter to disregard parts of object when calculating the asked position. Defaults to Margin,
     *                              which includes everything. Should only ever be necessary for other UiElements
     * @return                      Object itself for fluent itself
     */
    getPosition(relativePosition?: Point, spaceOfInterest?: UISpace): Point;
    /**
     * Sets the position origin of this UiElement. Affects how the "position" of UIElement is interpreted.
     *
     * See [[UIOrigins]] for a collection of common arguments in an easy-to-read format.
     * @param   Vec2 with each plane in range [-1, 1], where 0 is middle
     * @return  Object itself
     */
    setOrigin(origin: Point): this;
    /**
     * Get the position origin of this UiElement. Affects how the "position" of UIElement is interpreted.
     *
     * @return  Vec2 with each plane in range [-1, 1], where 0 is middle
     */
    getOrigin(): Point;
    /**
     * Set dragging mode of object. Defines how the object can be dragged by mouse.
     *
     * See [[UIDraggingModes]]collection for options.
     * @param       draggingMode    DraggingMode or undefined to disable dragging
     * @returns                     Object itself
     */
    setDraggingMode(draggingMode?: UIDraggingModes): this;
    /**
     * Get dragging mode of object.
     * Defines how the object can be dragged by mouse.
     * @returns                     Object itself
     */
    getDraggingMode(): UIDraggingModes;
    /**
     * Set mouse style when hovering over UI object.
     * @param   mouseStyle  Interface for defining how mouse should look when hovering over UI object
     * @return              Object itself
     */
    setMouseStyle(mouseStyle: UIMouseStyle): this;
    /**
     * Get mouse style.
     * @return              Interface for defining how mouse should look when hovering over UI object
     */
    getMouseStyle(): UIMouseStyle;
}
/**
 * Public interface for a UiElement that has background, but is not responsible for its own positioning.
 * @hidden
 */
export interface UIPartWithBackground<BackgroundType extends UIBackground> extends UIPart, StylableBackground<BackgroundType> {
}
/**
 * Public interface for a UiElement with background.
 * @hidden Internal class
 */
export declare abstract class UIElementWithBackground<BackgroundType extends UIBackground = UIBackground> extends InternalUIElement implements UIPartWithBackground<UIBackground> {
    protected readonly _layer: Layer2D;
    private _BackgroundClass;
    /**
     * Background object.
     * Can't be changed at runtime
     */
    protected readonly backgroundElement: InternalBackground & BackgroundType;
    /**
     * @param   _layer                  Rendering layer
     * @param   renderingScale          Rendering scale
     * @param   scale                   Positioning scale
     * @param   _BackgroundClass        Constructor for Background of UiElementLine
     * @hidden
     */
    constructor(_layer: Layer2D, renderingScale: LinearScaleXY, scale: ScaleXY, _BackgroundClass: BackgroundConstructor<InternalBackground & BackgroundType>, remove: RemoveHandler<UIElement>, restore: RestoreHandler<UIElement>, theme: Theme);
    /**
     * Subscribe to highlight object event. This is called whenever an object is highlighted.
     * @param   handler         Function that is called when event is triggered.
     * @param   isHighlighted   The Highlight state.
     * @return                  Token that can be used to unsubscribe from the event.
     */
    onHighlight(handler: (isHighlighted: boolean) => void): Token;
    /**
     * Unsubscribe from Highlight object event. This is called whenever an object is highlighted
     * @param   token       Token that was received when subscribing to the event.
     * @return              True if the unsubscription was successful.
     */
    offHighlight(token: Token): boolean;
    /**
     * Method for mutating Background of object.
     *
     * Type of Background is generic, see [[UIBackground]] for minimum interface.
     * @param   mutator Mutator function for Background
     * @return          Object itself for fluent interface
     */
    setBackground(mutator: Mutator<BackgroundType>): this;
    /**
     * Get Background of object.
     *
     * Type of Background is generic, see [[UIBackground]] for minimum interface.
     * @returns     Background object
     */
    getBackground(): BackgroundType;
    /**
     * Dispose object, ceasing its operation while keeping the object intact until call of 'restore'.
     * @return Object itself for fluent interface
     */
    dispose(): this;
    /**
     * Restore object if it was previously disposed.
     * @returns Object itself itself for fluent interface
     */
    restore(): this;
    /**
     * @return True if all sub-elements are disposed, false if not.
     */
    isDisposed(): boolean;
    /**
     * Set padding around object in pixels.
     * Padding is empty space between the UiElements content and Background
     * @param   padding     Number with pixel margins for all sides or datastructure with individual pixel paddings
     *                      for each side. Any side can be omitted, only passed values will be overridden.
     * @return              Object itself
     */
    setPadding(padding: Partial<Margin> | number): this;
    /**
     * Get padding around object in pixels.
     * Padding is empty space between the UiElements content and Background
     * @return  Margin datastructure
     */
    getPadding(): Margin;
    /**
     * Returns the size of the UiElements in pixels including any Margins or Paddings
     * @param spaceOfInterest       Parameter to disregard parts of object when calculating the position. Defaults to Margin,
     *                              which includes everything. Should only ever be necessary for sub-classes
     * @return                      Object size in pixels
     */
    getSize(spaceOfInterest?: UISpace): Point;
    /**
     * Returns the position of this UiElement at given location relative to elements size.
     * @param relativePosition      Relative position vector (-1 to 1 which specifies position of origin, 0 is center of the object)
     * @param spaceOfInterest       Parameter to disregard parts of object when calculating the asked position.
     * @return                      Object itself for fluent itself
     */
    getPosition(relativePosition?: Point, spaceOfInterest?: UISpace): Point;
    /**
     * Set mouse interactions enabled or disabled
     * @para state Specifies state of mouse interactions
     * @return     Object itself for fluent interface
     */
    setMouseInteractions(state: boolean): this;
    /**
     * @return Mouse interactions state
     */
    getMouseInteractions(): boolean;
    /**
     * @return True for highlighted state of object and false for basic
     */
    getHighlighted(): boolean;
    /**
     * Set highlighted state of the Object.
     * Implementations should also remember to highlight themselves here.
     * @param isHighlighted Highlight state of the object
     * @returns             Object itself for fluent interface
     */
    setHighlighted(isHighlighted: boolean): this;
}
/**
 * File contains interfaces for Backgrounds
 */
/**
 * Public interface of Background.
 * Type of UiElement that can be used as a Background of another element.
 */
export interface UIBackground {
    /**
     * Set FillStyle of Background.
     * @param value Fill style object or function which modifies it
     * @return      Object itself for fluent interface
     */
    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * @return      Current Background FillStyle
     */
    getFillStyle(): FillStyle;
    /**
     * Set stroke style of Background.
     * @param value LineStyle object or function which modifies it
     * @return      Object itself for fluent interface
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * @return      Current Background LineStyle
     */
    getStrokeStyle(): LineStyle;
    /**
     * Set highlighted FillStyle of Background
     * @param highlightStyle    FillStyle for highlighted object or mutator to modify existing one or undefined for auto assignment
     * @returns                 Object itself for fluent interface
     */
    setFillStyleHighlight(setter: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * @return      Highlighted FillStyle of Background or undefined for auto assignment
     */
    getFillStyleHighlight(): FillStyle | undefined;
}
/**
 * Internal interface of Background.
 * Type of UiElement that can be used as a Background of another element.
 * The main requirement for a background is to be fitted to a rectangle of any size.
 * @hidden
 */
export interface InternalBackground extends UIElement, UIBackground, Highlightable {
}
/**
 * Type of Background constructor
 * @param   layer   Rendering layer
 * @param   scale   Rendering scale
 * @hidden
 */
export declare type BackgroundConstructor<T extends UIBackground = UIBackground> = new (layer: Layer2D, renderingScale: LinearScaleXY, scale: ScaleXY, remove: RemoveHandler<UIElement>, restore: RestoreHandler<UIElement>, theme: Theme) => T;
/**
 * Background that can be pointed at a direction (left,right,up or down)
 */
export interface PointableBackground extends Pointable, UIBackground {
}
/**
 * Type of Pointable Background constructor
 * @param   layer   Rendering layer
 * @param   scale   Rendering scale
 * @hidden
 */
export declare type PointableBackgroundConstructor<T extends InternalBackground & PointableBackground = InternalBackground & PointableBackground> = new (layer: Layer2D, renderingScale: LinearScaleXY, scale: ScaleXY, remove: RemoveHandler<UIElement>, restore: RestoreHandler<UIElement>, theme: Theme) => T;
/**
 * Type of function for styling a generic UIElement.
 */
export declare type UIElementStyler<T = UIElement> = (object: T, theme: Theme) => unknown;
/**
 * Interface for abstract UiElement builder
 */
export interface UIElementBuilder<UIElementType extends UIPart = UIPart> {
    /**
     * Make new Builder with an additional styler.
     * @param   styler  UiElementStyler for specific type
     * @returns         New Builder
     */
    addStyler(styler: UIElementStyler<UIElementType>): this;
}
/**
 * File contains enums and layout-classes for positioning uiElements relatively.
 * Also their builders.
 */
/**
 * UiElement class that marks a 'gap' in line-layouts.
 * Positioning logic will make it so these gaps occupy all extra space.
 */
export declare class UILayoutGap extends EmptyUIElement {
    /**
     * Set size of gap.
     * @param   size    Size of gap as Vec2 of pixels
     * @return          Object itself
     */
    setSize(size: Point): this;
}
/**
 * Base class for positioning of UiElements in a line
 * @hidden Internal class
 */
export declare abstract class UIElementLine<BackgroundType extends UIBackground = UIBackground> extends UIElementWithBackground<BackgroundType> {
    /**
     * Returns list of UiElements inside Line
     */
    getMembers(): Array<UIPart>;
    /**
     * Get amount of members in group.
     * @return  Number
     */
    getMemberCount(): number;
    /**
     * Set minimum size Layout should occupy (in direction of layout).
     * If set, Layout will distribute any extra space to UiLayoutGaps among its members.
     * @param   minSize     Min size Layout should occupy (in direction of layout) or undefined to disable feature
     * @return              Object itself
     */
    setMinimumSize(minSize: pixel | undefined): this;
    /**
     * Get minimum size Layout should occupy (in direction of layout).
     * If set, Layout will distribute any extra space to UiLayoutGaps among its members.
     * @return              Min size Layout should occupy (in direction of layout) or undefined to disable feature
     */
    getMinimumSize(): pixel | undefined;
    /**
     * Add any UiElement using a builder
     * @param   builder Builder for any UiElement
     * @param   index   Index position or < 0 to push
     * @returns         Created UiElement
     */
    addElement<UiElementType extends UIPart>(builder: UIElementBuilder<UiElementType>, index?: number): UiElementType;
    /**
     * Add gap to line.
     * Gap can have fixed size and it also has custom logic which makes it occupy any extra space
     * caused by setting the minimum size for Line.
     * @param   fixedSize   Optional fixed size to set gap
     * @param   index       Index position or < 0 to push
     * @return              Object itself
     */
    abstract addGap(fixedSize?: pixel, index?: number): UILayoutGap;
    /**
     * Disposes objects inside the element.
     * UiElement will still be usable, but will not update itself nor render.
     * Disposed elements can be restored using 'restore()'
     * Implementations should use setEnabled on any other elements/Shapes they contain!
     * @return Object itself for fluent interface
     */
    dispose(): this;
    /**
     * Restore whatever resources this object has from rendering engine.
     * Implementations should use setEnabled on any other elements/Shapes they contain!
     * @returns Object itself itself for fluent interface
     */
    restore(): this;
    /**
     * @return True if all sub-elements have been disposed, false if not.
     */
    isDisposed(): boolean;
    /**
     * Set mouse interactions enabled.
     * This will set the states of all members inside the Layout, overriding any previous settings.
     * @param state     Mouse interactions enabled
     */
    setMouseInteractions(state: boolean): this;
    /**
     * Get mouse interactions enabled.
     * @return  True if any member of Layout has mouse interactions enabled.
     */
    getMouseInteractions(): boolean;
    /**
     * Set highlighted state of the Lines Background and all of its members
     * @param isHighlighted Highlight state of the object
     * @returns             Object itself for fluent interface
     */
    setHighlighted(isHighlighted: boolean): this;
}
/**
 * UI Layout for positioning UIElements in a row.
 */
export declare class UIElementRow<BackgroundClass extends UIBackground = UIBackground> extends UIElementLine<BackgroundClass> {
    /**
     * Add gap to Row.
     * Gap can have fixed width and it also has custom logic which makes it occupy any extra space
     * caused by setting the minimum size for Line.
     * @param   fixedSize   Optional fixed size to set gap
     * @return              Object itself
     */
    addGap(fixedSize?: pixel, index?: number): UILayoutGap;
}
/**
 * UI Layout for positioning UIElements in a column.
 */
export declare class UIElementColumn<BackgroundClass extends UIBackground = UIBackground> extends UIElementLine<BackgroundClass> {
    /**
     * Add gap to Column.
     * Gap can have fixed height and it also has custom logic which makes it occupy any extra space
     * caused by setting the minimum size for Line.
     * @param   fixedSize   Optional fixed size to set gap
     * @return              Gap object
     */
    addGap(fixedSize?: pixel, index?: number): UILayoutGap;
}
/**
 * Class which represents a grid of abstract UiElements.
 * Grid is formed from vertical lines, 'columns', that can have individual member anchoring.
 * @hidden  Internal class. HIDDEN FOR NOW, AS THE IMPLEMENTATION IS NOT TESTED OR USED (on public side)
 */
export declare class UIColumnGrid<BackgroundClass extends UIBackground = UIBackground> extends UIElementRow<BackgroundClass> {
    /**
     * Add new column to grid
     */
    addColumn(): UIElementColumn;
    /**
     * Get column at specified index
     * @param   index   Index to look for
     * @param   ensure? If true, grid adds the column and any missing ones if it doesn't exist
     * @return          UiElementColumn at given index
     */
    getColumn(index: number, ensure?: boolean): UIElementColumn;
}
/**
 * Class which represents a grid of abstract UiElements.
 * Grid is formed from horizontal lines, 'rows', that can have individual member anchoring.
 * @hidden  Internal class. HIDDEN FOR NOW, AS THE IMPLEMENTATION IS NOT TESTED OR USED (on public side)
 */
export declare class UIRowGrid<BackgroundClass extends UIBackground = UIBackground> extends UIElementColumn<BackgroundClass> {
    /**
     * Add new row to grid
     */
    addRow(): UIElementRow;
    /**
     * Get row at specified index
     * @param   index   Index to look for
     * @param   ensure? If true, grid adds the row and any missing ones if it doesn't exist
     * @return          UiElementRow at given index
     */
    getRow(index: number, ensure?: boolean): UIElementRow;
}
/**
 * Interface for builder of UiColumn layout
 */
export interface UIColumnBuilder<BackgroundType extends UIBackground = UIBackground> extends UIElementBuilder<UIElementColumn<BackgroundType>> {
    /**
     * Make new ColumnBuilder with different background
     */
    setBackground<NewBackgroundType extends BackgroundType>(newBackground: BackgroundConstructor<NewBackgroundType>): UIColumnBuilder<NewBackgroundType>;
}
/**
 * Interface for builder of UiRow layout
 */
export interface UIRowBuilder<BackgroundType extends UIBackground = UIBackground> extends UIElementBuilder<UIElementRow<BackgroundType>> {
    /**
     * Make new RowBuilder with different background
     */
    setBackground<NewBackgroundType extends BackgroundType>(newBackground: BackgroundConstructor<NewBackgroundType>): UIRowBuilder<NewBackgroundType>;
}
/**
 * Main implementation for OnScreenMenu.
 * This class handles the DOM creation, initialization and event wiring of the core OSM container.
 *
 * @beta This feature is considered experimental and might be changed in minor release.
 */
export declare class OnScreenMenu {
    protected containerObj: HTMLContainer;
    protected chart: ChartXY;
    protected _osmButtonShape?: OnScreenMenuButtonShape | undefined;
    /**
     * Creates an instance of the on-screen-menu base class
     * @param lcjsOptions       LCJS options object.
     * @param controlArray      A 2d array that describes the type of control to be added and its position (row, column).
     * @param containerObj      Main div element that contains the on-screen menu.
     * @param chart             Chart to which the on-screen menu is added.
     * @param osmButtonShape    The shape of the on-screen menu buttons.
     * @internal
     */
    constructor(_lcjsOptions: InternalLightningChartOptions, controlArray: (OnScreenMenuButtonType | OnScreenMenuCustomButtonParams)[][], containerObj: HTMLContainer, chart: ChartXY, _osmButtonShape?: OnScreenMenuButtonShape | undefined);
    /**
     * Remove the position properties for the div containing osm menu button.
     */
    removePositionProperty(): void;
    /**
     * Set the position property for the div containing the OSM menu.
     * @param position The [[OSMPosition]] where one wants to place the OnScreenMenu on the screen.
     */
    setPositionProperty(position: OSMPosition): void;
    /**
     * Adds a custom button to the On-Screen Menu.
     * @param buttonParams
     * @internal
     */
    private addCustomButton;
    /**
     * Removes the On-Screen-menu elements.
     */
    dispose(): void;
}
/**
 * Interface to describe parameters that are used to construct a custom button for the On-Screen Menu.
 */
export interface OnScreenMenuCustomButtonParams {
    /**
     * Path to an icon that this button will display.
     */
    icon?: string;
    /**
     * Optional label to be displayed on the button.
     */
    label?: string;
    dimensions?: OnScreenMenuDimensions;
    /**
     * Optional opacity for the button. Accepts a value between 0 and 1, were 0 is transparent and 1 is opaque.
     */
    opacity?: string;
    /**
     * Optional color value for this button. If no value is specified, the color will be chosen from the theme.
     */
    color?: string;
    /**
     * Optional value for the shape of the button.
     */
    shape?: OnScreenMenuButtonShape;
    /**
     * Function that represents the action to be performed on the click of the button.
     */
    action: (chart: ChartXY) => void;
}
/**
 * Lists the various types of pre-defined buttons that can be added to the On-Screen Menu.
 */
export declare enum OnScreenMenuButtonType {
    ZoomIn = 0,
    ZoomInX = 1,
    ZoomInY = 2,
    ZoomOut = 3,
    ZoomOutX = 4,
    ZoomOutY = 5,
    ZoomToFit = 6,
    ToggleAnimations = 7
}
/**
 * Type to describe the icon position on sprite image.
 * @internal
 */
export declare type SpriteImagePosition = {
    x: number;
    y: number;
};
/**
 * On-Screen Menu button shapes.
 */
export declare enum OnScreenMenuButtonShape {
    Circle = 0,
    Rectangle = 1,
    RoundedRectangle = 2
}
/**
 * Abstract base class that defines common instantiation and interaction logic for
 * all [[OnScreenMenu]] button type controls. All button classes deriving from this base
 * needs to specify an implementation for the onClick() method, which is the action that
 * will be executed on clicking the button.
 *
 * @internal Internal class.
 */
export declare abstract class OnScreenMenuButton extends OnScreenMenuControlBase {
    protected _buttonShape: OnScreenMenuButtonShape;
    protected _chart: ChartXY;
    /**
     * Creates an instance of on screen menu button.
     * @param _resourceBaseUrl  The base resource path.
     * @param _buttonShape      The shape of the button.
     * @param dimensions        ColSpan and RowSpan dimensions for this button.
     * @param _chart            The local chart instance. The is required to access chart specific APIs.
     * @internal
     */
    constructor(_resourceBaseUrl: string, _buttonShape: OnScreenMenuButtonShape, dimensions: OnScreenMenuDimensions, _chart: ChartXY);
    /**
     * Applies the background style and position for sprite icons.
     * @param icon The icon position.
     * @internal
     */
    protected applyStyleForSprite(icon: SpriteImagePosition): void;
    /**
     * Abstract function that determines the action to be performed on button click.
     * Must be defined in all child types.
     * @internal
     */
    abstract onClick(): void;
}
/**
 * Class describing a toggle button to be used for the [[OnScreenMenu]].
 * @internal Internal class
 */
export declare abstract class OnScreenMenuToggleButton extends OnScreenMenuButton {
    protected _chart: ChartXY;
    /**
     * Creates an instance of the [[OnScreenMenuToggleButton]] class.
     * @param resourceBaseUrl   The resource URL.
     * @param buttonShape       The shape of the button.
     * @param dimensions        ColSpan and RowSpan dimensions for this button.
     * @param _chart            The local chart instance. The is required to access chart specific APIs.
     */
    constructor(resourceBaseUrl: string, buttonShape: OnScreenMenuButtonShape, dimensions: OnScreenMenuDimensions, _chart: ChartXY);
    /**
     * Abstract method that determines what action is to be performed when the button is toggled.
     * @internal
     */
    abstract onToggledStateAction(): void;
    /**
     * Abstract method that determines what action is to be performed when the button is reset.
     * @internal
     */
    abstract onInitialStateAction(): void;
    /**
     * Determines the action to be performed on the button click.
     * @internal
     */
    onClick(): void;
}
/**
 * Class to describe a zoom in button for the [[OnScreenMenu]].
 * @internal Internal class.
 */
export declare class OnScreenMenuZoomInButton extends OnScreenMenuButton {
    protected _chart: ChartXY;
    /**
     * Creates an instance of on screen menu zoom in button.
     * @param resourceBaseUrl   The resource URL.
     * @param _chart            The local chart instance.
     * @param buttonShape       The shape of the button.
     */
    constructor(_resourceBaseUrl: string, _chart: ChartXY, buttonShape: OnScreenMenuButtonShape);
    /**
     * Does a zoom-in action towards the center of the chart.
     * @internal
     */
    onClick(): void;
}
/**
 * Class to describe a X axis zoom in button for the [[OnScreenMenu]].
 * @internal Internal class.
 */
export declare class OnScreenMenuZoomInXButton extends OnScreenMenuButton {
    protected _chart: ChartXY;
    /**
     * Creates an instance of on screen menu zoom in button.
     * @param resourceBaseUrl   The resource URL.
     * @param _chart            The local chart instance.
     * @param buttonShape       The shape of the button.
     */
    constructor(_resourceBaseUrl: string, _chart: ChartXY, buttonShape: OnScreenMenuButtonShape);
    /**
     * Does a zoom-in action towards the center of the chart.
     * @internal
     */
    onClick(): void;
}
/**
 * Class to describe a Y axis zoom in button for the [[OnScreenMenu]].
 * @internal Internal class.
 */
export declare class OnScreenMenuZoomInYButton extends OnScreenMenuButton {
    protected _chart: ChartXY;
    /**
     * Creates an instance of on screen menu zoom in button.
     * @param resourceBaseUrl   The resource URL.
     * @param _chart            The local chart instance.
     * @param buttonShape       The shape of the button.
     */
    constructor(_resourceBaseUrl: string, _chart: ChartXY, buttonShape: OnScreenMenuButtonShape);
    /**
     * Does a zoom-in action towards the center of the chart.
     * @internal
     */
    onClick(): void;
}
/**
 * Class to describe a zoom out button for the [[OnScreenMenu]].
 * @internal Internal class.
 */
export declare class OnScreenMenuZoomOutButton extends OnScreenMenuButton {
    protected _chart: ChartXY;
    /**
     * Creates an instance of on screen menu zoom out button.
     * @param resourceBaseUrl   The resource URL.
     * @param _chart            The local chart instance.
     * @param buttonShape       The shape of the button.
     */
    constructor(_resourceBaseUrl: string, _chart: ChartXY, buttonShape: OnScreenMenuButtonShape);
    /**
     * Does a zoom-out action from the center of the chart.
     */
    onClick(): void;
}
/**
 * Class to describe a X axes zoom out button for the [[OnScreenMenu]].
 * @internal Internal class.
 */
export declare class OnScreenMenuZoomOutXButton extends OnScreenMenuButton {
    protected _chart: ChartXY;
    /**
     * Creates an instance of on screen menu zoom out button.
     * @param resourceBaseUrl   The resource URL.
     * @param _chart            The local chart instance.
     * @param buttonShape       The shape of the button.
     */
    constructor(_resourceBaseUrl: string, _chart: ChartXY, buttonShape: OnScreenMenuButtonShape);
    /**
     * Does a zoom-out action from the center of the chart.
     */
    onClick(): void;
}
/**
 * Class to describe a Y axes zoom out button for the [[OnScreenMenu]].
 * @internal Internal class.
 */
export declare class OnScreenMenuZoomOutYButton extends OnScreenMenuButton {
    protected _chart: ChartXY;
    /**
     * Creates an instance of on screen menu zoom out button.
     * @param resourceBaseUrl   The resource URL.
     * @param _chart            The local chart instance.
     * @param buttonShape       The shape of the button.
     */
    constructor(_resourceBaseUrl: string, _chart: ChartXY, buttonShape: OnScreenMenuButtonShape);
    /**
     * Does a zoom-out action from the center of the chart.
     */
    onClick(): void;
}
/**
 * Class that describes a toggle animation button for the [[OnScreenMenu]].
 * @internal
 */
export declare class OnScreenMenuAnimationsButton extends OnScreenMenuToggleButton {
    protected _chart: ChartXY;
    /**
     * Creates an instance of on screen menu zoom out button.
     * @param resourceBaseUrl   The resource URL.
     * @param _chart            The local chart instance.
     * @param buttonShape       The shape of the button.
     * @internal
     */
    constructor(_resourceBaseUrl: string, _chart: ChartXY, buttonShape: OnScreenMenuButtonShape);
    /**
     * Disables the chart animations.
     * @internal
     */
    onToggledStateAction(): void;
    /**
     * Enables the chart animations.
     * @internal
     */
    onInitialStateAction(): void;
}
/**
 * Class that describes a zoom to fit button for the [[OnScreenMenu]].
 * @internal Internal class.
 */
export declare class OnScreenMenuZoomToFitButton extends OnScreenMenuButton {
    protected _chart: ChartXY;
    /**
     * Creates an instance of on screen menu zoom out button.
     * @param resourceBaseUrl   The resource URL.
     * @param _chart            The local chart instance.
     * @param buttonShape       The shape of the button.
     */
    constructor(_resourceBaseUrl: string, _chart: ChartXY, buttonShape: OnScreenMenuButtonShape);
    /**
     * Does a Zoom-to-fit action.
     * @internal
     */
    onClick(): void;
}
/**
 * Class that describes a custom button for the [[OnScreenMenu]].
 * @internal
 */
export declare class OnScreenMenuCustomButton extends OnScreenMenuButton {
    /**
     * Creates an instance of on screen menu custom button.
     * @param resourceBaseUrl   The resource URL.
     * @param params            The [[OnScreenMenuCustomButtonParams]] object containing the parameters to construct this button.
     * @param chart             The local chart instance.
     */
    constructor(_resourceBaseUrl: string, params: OnScreenMenuCustomButtonParams, chart: ChartXY);
    /**
     * Determines the action to be performed on the button click.
     * @internal
     */
    onClick(): void;
}
/**
 * Class that describes the show/hide toggle button for the [[OnScreenMenu]].
 * @internal Internal class.
 */
export declare class OnScreenMenuOsmToggleButton extends OnScreenMenuToggleButton {
    protected _chart: ChartXY;
    protected _controlContainerElement: HTMLDivElement;
    /**
     * Creates an instance of the [[OnScreenMenuOsmToggleButton]] class.
     * @param resourceBaseUrl   The resource URL.
     * @param buttonShape       The shape of the button.
     * @param _chart            The local chart instance. The is required to access chart specific APIs.
     */
    constructor(_resourceBaseUrl: string, buttonShape: OnScreenMenuButtonShape, _chart: ChartXY, _controlContainerElement: HTMLDivElement);
    /**
     * Makes the OnScreen Menu control grid visible.
     *
     * @internal
     */
    onToggledStateAction(): void;
    /**
     * Makes the OnScreen Menu control grid invisible.
     *
     * @internal
     */
    onInitialStateAction(): void;
}
/**
 * Interface that describes an abstract dimensions for [[OnScreenMenu]] controls.
 * We use this to determine sizing based on a grid layout in HTML.
 * @internal
 */
export interface OnScreenMenuDimensions {
    /**
     * The number of rows in the grid the control will take up.
     */
    rows: number;
    /**
     * The number of columns in the grid the control will take up.
     */
    columns: number;
}
/**
 * Interface that describes common properties for all [[OnScreenMenu]] controls.
 * @internal Internal interface.
 */
export interface OnScreenMenuControl {
}
/**
 * Abstract base class that describes all [[OnScreenMenu]] controls.
 * @internal Internal class
 */
export declare abstract class OnScreenMenuControlBase implements OnScreenMenuControl {
    /**
     * Creates an instance of on screen menu control base.
     * @param dimensions    The dimensions for the control.
     * @internal
     */
    constructor(_resourceBaseUrl: string, dimensions: OnScreenMenuDimensions);
}
/** @internal */
export declare const OnScreenMenuButtonIconsLight: OnScreenMenuIconSet;
/** @internal */
export declare const OnScreenMenuButtonIconsDark: OnScreenMenuIconSet;
/**
 * File contains builders and interfaces for end-user backgrounds.
 */
/**
 * Collection of available [[UIBackgrounds]] Can be used to customize the *background* of an *UIElement*.
 *
 * *Background* must be specified when the *UIElement* is created by method of its *builder*.
 *
 * Example usage:
 *```javascript
 * // Create TextBox with specified Background
 * Chart.addUIElement(UIElementBuilders.TextBox.setBackground(UIBackgrounds.Circle))
 * ```
 */
export declare const UIBackgrounds: {
    /**
     * No background.
     */
    None: typeof UIEmptyBackground;
    /**
     * Rectangular background.
     */
    Rectangle: typeof UIRectangle;
    /**
     * Circular background.
     */
    Circle: typeof UICircle;
    /**
     * 45 degree rotated rectangle background.
     */
    Diamond: typeof UIDiamond;
    /**
     * Arrow-like background.
     *
     * The *Pointers* direction can be modified by, for example:
     *
     * *UIElement*.setBackground((pointer) => pointer.setDirection(**UIDirections.Up**))
     *
     * This will throw an *error* if used on an *UIElement* with any other *Background*!
     */
    Pointer: typeof UIPointer;
};
/**
 * File contains builders and interfaces for end-user button pictures.
 */
/**
 * Collection of available *UIButtonPicture*s. Can be used to customize the shape of buttons and checkboxes of *UIElements*.
 *
 * *ButtonPicture* must be specified when the *UIElement* is created by method of its *builder*.
 *
 * Example usage:
 *```javascript
 * // Create ButtonBox with specified ButtonPicture
 * Chart.addUIElement(UIElementBuilders.ButtonBox.setPictureOff(UIButtonPictures.Circle))
 * // Create LegendBox with specified ButtonPicture
 * Chart.addUIElement(UIElementBuilders.HorizontalLegendBox.setEntry(
 * UIElementBuilders.TextBox.setPictureOff(UIButtonPictures.Circle)))
 * ```
 */
export declare const UIButtonPictures: {
    /**
     * Rectangular picture.
     */
    Rectangle: typeof UIRectangle;
    /**
     * Circular picture.
     */
    Circle: typeof UICircle;
    /**
     * 45 degree rotated rectangle picture.
     */
    Diamond: typeof UIDiamond;
};
/**
 * File contains user reference for cursor and marker builders.
 */
/**
 * Collection of *StaticCursorBuilders*.
 *
 * *StaticCursorBuilder*s are used to modify structure of *Markers*, by passing one when the *Marker* is created.
 *
 * Each item is associated with a specific *Chart*-type, that it can only be used with.
 */
export declare const MarkerBuilders: {
    /**
     * *StaticCursorBuilder* for creation of *MarkerXY*.
     *
     * Used to modify structure of *MarkerXY* when it is created. There are two versions of *MarkerXY*:
     * - [[ChartMarkerXY]] created with [[ChartXY.addChartMarkerXY]]
     * - [[SeriesMarkerXY]] created with *SeriesXY*.*addMarker*
     */
    XY: StaticCursorXYBuilder;
};
/**
 * Collection of *AutoCursorBuilders*.
 *
 * *AutoCursorBuilder*s are used to modify structure of *AutoCursor*s of *Chart*s, by passing one when the *Chart* is created.
 *
 * Each item is associated with a specific *Chart*-type, that it can only be used with.
 */
export declare const AutoCursorBuilders: {
    /**
     * *AutoCursorBuilder* for [[ChartXY]].
     *
     * Used to modify structure of *AutoCursor*, by passing one when creating a [[ChartXY]].
     */
    XY: AutoCursorXYBuilder;
    /**
     * *AutoCursorBuilder* for [[SpiderChart]].
     *
     * Used to modify structure of *AutoCursor*, by passing one when creating a [[SpiderChart]].
     */
    Spider: AutoCursor2DBuilder;
    /**
     * *AutoCursorBuilder* for [[MapChart]].
     *
     * Used to modify structure of *AutoCursor*, by passing one when creating a [[MapChart]].
     */
    Map: StaticCursor2DBuilder;
    /**
     * *AutoCursorBuilder* for [[PolarChart]].
     *
     * Used to modify structure of *AutoCursor*, by passing one when creating a [[PolarChart]].
     */
    Polar: AutoCursor2DBuilder;
};
/**
 * File contains builders and interfaces for end-user uiElements.
 */
/**
 * Collection of available *UIElement* *builders*. To build *UIElements* you must pass one of these to method: **addUIElement()**.
 * This method can be accessed through *Charts*, [[Dashboard]], Etc.
 *
 * Example usage:
 *```javascript
 * // Create a TextBox on a ChartXY
 * ChartXY.addUIElement(UIElementBuilders.TextBox)
 * // Create a CheckBox on a Dashboard
 * Dashboard.addUIElement(UIElementBuilders.CheckBox)
 * ```
 */
export declare const UIElementBuilders: {
    /**
     * *UIElement* that displays text over a *Background*.
     *
     * Example usage:
     *```javascript
     * // Create a TextBox
     * Chart.addUIElement(UIElementBuilders.TextBox)
     * ```
     */
    TextBox: UITextBoxBuilder;
    /**
     * *UIElement* that displays a toggleable checkbox and text over a *Background*.
     *
     * By default, *Background* is empty. To show it you must specify it using method of the *builder*, **setBackground**
     *
     * Example usage:
     *```javascript
     * // Create a CheckBox
     * Chart.addUIElement(UIElementBuilders.CheckBox)
     * // Create a CheckBox with specified Background
     * Chart.addUIElement(UIElementBuilders.CheckBox.setBackground(UIBackgrounds.Circle))
     * // Create a CheckBox with specified ButtonPicture
     * Chart.addUIElement(UIElementBuilders.CheckBox.setPictureOff(UIButtonPictures.Diamond))
     * ```
     */
    CheckBox: UICheckBoxBuilder;
    /**
     * *UIElement* that displays a button and text over a *Background*.
     *
     * By default, *Background* is empty. To show it you must specify it using method of the *builder*, **setBackground**
     *
     * Example usage:
     *```javascript
     * // Create a ButtonBox
     * Chart.addUIElement(UIElementBuilders.ButtonBox)
     * // Create a ButtonBox with specified Background
     * Chart.addUIElement(UIElementBuilders.ButtonBox.setBackground(UIBackgrounds.Circle))
     * // Create a ButtonBox with specified ButtonPicture
     * Chart.addUIElement(UIElementBuilders.ButtonBox.setPictureOff(UIButtonPictures.Diamond))
     * ```
     */
    ButtonBox: UICheckBoxBuilder;
    /**
     * *UIElement builder* that is intended to be used with *custom axis ticks*.
     * See [[Axis.addCustomTick]] for example usage, and more information.
     *
     * *PointableTextBox* is a text label enclosed within a background shaped in the form of an *arrow*.
     */
    PointableTextBox: UIPointableTextBoxBuilder;
    /**
     * *UIElement builder* that is intended to be used with *custom axis ticks*.
     * See [[Axis.addCustomTick]] for example usage, and more information.
     *
     * *AxisTick* is a text label connected to a *tick line* - fundamentally equal to a *default axis tick* shape.
     */
    AxisTick: UITickBuilder;
    /**
     * *UIElement builder* that can be used to build a [[UILUTRange]] component.
     * which displays a color lookup table range with labels.
     *
     * ```js
     *  // Example usage,
     *  const lutRange = chart.addUIElement(UIElementBuilders.LUTRange)
     *      .setLUT(myLut)
     * ```
     */
    LUTRange: UILUTRangeBuilder;
};
/**
 * Collection of available *LegendBox* *builders*. To build *LegendBox*es you must pass one of these to method: **addLegendBox()**.
 * This method can be accessed through *Charts*, *Dashboard*, Etc.
 *
 * Example usage:
 *```javascript
 * // Create a HorizontalLegendBox on a ChartXY
 * ChartXY.addLegendBox(LegendBoxBuilders.HorizontalLegendBox)
 * // Create a HorizontalLegendBox on a Dashboard
 * Dashboard.addLegendBox(LegendBoxBuilders.HorizontalLegendBox)
 * ```
 */
export declare const LegendBoxBuilders: {
    /**
     * Horizontal implementation of *LegendBox*.
     *
     * Example usage:
     *```javascript
     * // Create a Horizontal LegendBox
     * Chart.addUIElement(UIElementBuilders.HorizontalLegendBox)
     * ```
     */
    HorizontalLegendBox: UILegendBoxBuilder;
    /**
     * Vertical implementation of *LegendBox*.
     *
     * Example usage:
     *```javascript
     * // Create a Vertical LegendBox
     * Chart.addUIElement(UIElementBuilders.VerticalLegendBox)
     * ```
     */
    VerticalLegendBox: UILegendBoxBuilder;
};
/**
 * File contains builders and interfaces for end-user layouts.
 */
/**
 * Collection of *UIElementBuilder*s for *Layout*s. These allow positioning multiple *UIElements* relative to each other.
 */
export declare const UILayoutBuilders: {
    /**
     * *UIElement* for column layout, added *UIElements* will be layed out after one another **vertically**. Has a *Background*.
     *
     * By default, *Background* is hidden (style = [[emptyFill]]). To show it you must give it a style with: **UIColumn.setFillStyle**
     *
     * Example usage:
     *```javascript
     * // Create a Column
     * Chart.addUIElement(UILayouts.Column)
     * // Create a Column with specified Background
     * Chart.addUIElement(UILayouts.Column.setBackground(UIBackgrounds.Circle))
     * ```
     */
    Column: UIColumnBuilder;
    /**
     * *UIElement* for row layout, added *UIElements* will be layed out after one another **horizontally**. Has a *Background*.
     *
     * By default, *Background* is hidden (style = [[emptyFill]]). To show it you must give it a style with: **UIRow.setFillStyle**
     *
     * Example usage:
     *```javascript
     * // Create a Row
     * Chart.addUIElement(UILayouts.Row)
     * // Create a Row with specified Background
     * Chart.addUIElement(*UILayouts.Row.setBackground(UIBackgrounds.Circle))
     * ```
     */
    Row: UIRowBuilder;
};
/**
 * File contains builders and interfaces for end-user cursor pointMarkers.
 */
/**
 * Collection of available *PointMarker* implementations.
 *
 * *PointMarker*s are interactable *UIElement*s that belong to *AutoCursor*s and *Marker*s, indicating their location.
 *
 * *PointMarker* can be specified when creating an *AutoCursor* or *Marker*, by method of their *builder*.
 *
 * Example usage:
 *```javascript
 * // Create SeriesMarkerXY with specified PointMarker
 * SeriesXY.addMarker(MarkerBuilders.XY.setPointMarker(PointMarkers.UICircle))
 * // Specify PointMarker of AutoCursor
 * LightningChart.ChartXY({ autoCursorBuilder: AutoCursorBuilders.XY.setPointMarker(PointMarkers.UIDiamond) })
 * ```
 */
export declare const PointMarkers: {
    /**
     * No pointMarker.
     */
    None: typeof EmptyPointMarker;
    /**
     * Rectangular pointMarker.
     */
    UIRectangle: typeof UIRectangle;
    /**
     * Circular pointMarker.
     */
    UICircle: typeof UICircle;
    /**
     * 45 degree rotated rectangle pointMarker.
     */
    UIDiamond: typeof UIDiamond;
};
/**
 * Interface for all properties of a *library color theme*.
 *
 * A collection of default implementations can be accessed by [[Themes]].
 *
 * Color theme of components must be specified when it is created, and can't be changed afterwards (without destroying and recreating the component).
 * See [[ChartXY]] for example usage on specifying a *color theme* - the syntax is the same for every other component.
 */
export interface Theme {
    /**
     * FillStyle for LCJS container background.
     *
     * This background wraps over the entire LCJS chart or dashboard area.
     *
     * **Optional**.
     */
    lcjsBackgroundFillStyle?: FillStyle;
    /**
     * StrokeStyle for LCJS container background.
     *
     * This background wraps over the entire LCJS chart or dashboard area.
     *
     * **Optional**.
    // TODO: Docs on fallback when `undefined`?
     */
    lcjsBackgroundStrokeStyle?: LineStyle;
    /**
     * FillStyle for Dashboard background.
     *
     * @deprecated  Will be removed in v.4.0, use `lcjsBackgroundFillStyle` instead.
     *              Using `dashboardBackgroundFillStyle` works same as `lcjsBackgroundFillStyle` since v.3.1
     */
    dashboardBackgroundFillStyle?: FillStyle;
    /**
     * StrokeStyle for Dashboard background.
     *
     * @deprecated  Will be removed in v.4.0, use `lcjsBackgroundStrokeStyle` instead.
     *              Using `dashboardBackgroundFillStyle` works same as `lcjsBackgroundStrokeStyle` since v.3.1
     */
    dashboardBackgroundStrokeStyle?: LineStyle;
    /**
     * FillStyle for Dashboard splitter lines
     */
    dashboardSplitterStyle: LineStyle;
    /**
     * FillStyle for Panel background.
     *
     * This background exists over each individual *chart* or *panel*.
     */
    panelBackgroundFillStyle: FillStyle;
    /**
     * StrokeStyle for Panel background.
     *
     * This background exists over each individual *chart* or *panel*.
     */
    panelBackgroundStrokeStyle: LineStyle;
    /**
     * FontSettings for Chart title
     */
    chartTitleFont: FontSettings;
    /**
     * FillStyle for Chart title
     */
    chartTitleFillStyle: FillStyle;
    /**
     * FillStyle for series background fill.
     *
     * This background exists in all chart types that have *axes*, and is contained in the area enclosed by the charts axes.
     */
    seriesBackgroundFillStyle: FillStyle;
    /**
     * StrokeStyle for series background stroke.
     *
     * This background exists in all chart types that have *axes*, and is contained in the area enclosed by the charts axes.
     */
    seriesBackgroundStrokeStyle: LineStyle;
    /**
     * FillStyle for Spider Chart Series.
     */
    spiderSeriesFillStyle: FillStyle | Palette<FillStyle>;
    /**
     * StrokeStyle for Web line of Spider Chart.
     */
    spiderWebStyle: LineStyle;
    /**
     * StrokeStyle for Axis of Spider Chart.
     */
    spiderAxisStyle: SolidLine;
    /**
     * StrokeStyle for Axis Nib of Spider Chart.
     */
    spiderAxisNibStyle: SolidLine;
    /**
     * StrokeStyle for Spider Chart Series.
     */
    spiderSeriesStrokeStyle: LineStyle | Palette<LineStyle>;
    /**
     * FillStyle for Spider scale labels.
     */
    spiderScaleLabelFillStyle: FillStyle;
    /**
     * FontSettings for Spider scale labels.
     */
    spiderScaleLabelFont: FontSettings;
    /**
     * FillStyle for Spider axis labels.
     */
    spiderAxisLabelFillStyle: FillStyle;
    /**
     * FontSettings for Spider axis labels.
     */
    spiderAxisLabelFont: FontSettings;
    /**
     * Style for Polar Radial Axis Ticks.
     */
    polarRadialAxisTickStyle: VisibleTicks;
    /**
     * Style for Polar Radial Axis line.
     */
    polarRadialAxisStyle: SolidLine;
    /**
     * Style for Polar Radial Axis Title.
     */
    polarRadialAxisTitleStyle: FillStyle;
    /**
     * Style for Polar Amplitude Axis line.
     */
    polarAmplitudeAxisStyle: SolidLine;
    /**
     * Style for Polar Amplitude Axis Title.
     */
    polarAmplitudeAxisTitleStyle: FillStyle;
    /**
     * Fill Style for Polar Area Series.
     *
     * If `undefined`, will fallback to `mountainsFillStyle`.
     */
    polarAreaSeriesFillStyle?: FillStyle | Palette<FillStyle>;
    /**
     * Stroke Style for Polar Area Series.
     *
     * If `undefined`, will fallback to `mountainsStrokeStyle`.
     */
    polarAreaSeriesStrokeStyle?: LineStyle | Palette<LineStyle>;
    /**
     * FillStyle Palette for Sliced Charts (Pie, Donut) Slices.
     */
    sliceChartRadialFillStylePalette: Palette<FillStyle>;
    /**
     * FillStyle Palette for Sliced Charts (Funnel, Pyramid) Slices.
     */
    sliceChartStackedFillStylePalette: Palette<FillStyle>;
    /**
     * StrokeStyle for Sliced Chart (Pie, Funnel, Pyramid) Slices.
     */
    sliceChartStrokeStyle: LineStyle;
    /**
     * FillStyle for Sliced Chart (Pie, Funnel, Pyramid) Labels.
     */
    sliceLabelFillStyle: FillStyle;
    /**
     * FontSettings for Sliced Chart (Pie, Funnel, Pyramid) Labels.
     */
    sliceLabelFont: FontSettings;
    /**
     * LineStyle for Sliced Chart (Pie, Funnel, Pyramid) Label connectors.
     */
    sliceLabelConnectorStyle: LineStyle;
    /**
     * FillStyle for GaugeChart Slice
     */
    gaugeSliceFillStyle: FillStyle;
    /**
     * FillStyle for Gauge Chart area background
     */
    gaugeBackgroundFillStyle: FillStyle;
    /**
     * StrokeStyle for Gauge Chart area background
     */
    gaugeBackgroundStrokeStyle: LineStyle;
    /**
     * FillStyle for Chart XY zooming rectangle
     */
    chartXYZoomingRectangleFillStyle: FillStyle;
    /**
     * Style for Chart XY zooming rectangle stroke
     */
    chartXYZoomingRectangleStrokeStyle: LineStyle;
    /**
     * FillStyle for Chart XY fitting rectangle
     */
    chartXYFittingRectangleFillStyle: FillStyle;
    /**
     * Style for Chart XY fitting rectangle stroke
     */
    chartXYFittingRectangleStrokeStyle: LineStyle;
    /**
     * Default fill style for Map Chart (region fill).
     */
    mapChartFillStyle: FillStyle;
    /**
     * Default stroke style for Map Chart (region borders).
     */
    mapChartStrokeStyle: LineStyle;
    /**
     * Default fill style for Map Chart outlier regions.
     */
    mapChartOutlierRegionFillStyle: FillStyle;
    /**
     * Default stroke style for Map Chart outlier regions.
     */
    mapChartOutlierRegionStrokeStyle: LineStyle;
    /**
     * Default fill style for Map Chart separate regions.
     */
    mapChartSeparateRegionFillStyle: FillStyle;
    /**
     * Default stroke style for Map Chart separate regions.
     */
    mapChartSeparateRegionStrokeStyle: LineStyle;
    /**
     * FillStyle for Axis title
     */
    axisTitleFillStyle: FillStyle;
    /**
     * FontSettings for Axis title
     */
    axisTitleFont: FontSettings;
    /**
     * FillStyle for Axis labels
     *
     * @deprecated  `axisLabelFillStyle` has no effect on any property of LightningChart JS. It will be permanently removed in v.4.0.
     *              To style default Axis tick labels using `Theme` API, refer to `numericTickStrategy` or other _tick strategy_ properties.
     */
    axisLabelFillStyle?: FillStyle;
    /**
     * FontSettings for Axis title
     *
     * @deprecated  `axisLabelFont` has no effect on any property of LightningChart JS. It will be permanently removed in v.4.0.
     *              To style default Axis tick labels using `Theme` API, refer to `numericTickStrategy` or other _tick strategy_ properties.
     */
    axisLabelFont?: FontSettings;
    /**
     * FillStyle for Axis
     */
    axisStyle: LineStyle;
    /**
     * FillStyle for highlighted Axes (mouse-picking area)
     */
    axisOverlayStyle: FillStyle;
    /**
     * Style for Axis Nibs
     */
    axisNibStyle: LineStyle;
    /**
     * FillStyle for highlighted Axis Nibs (mouse-picking area)
     */
    axisNibOverlayStyle: FillStyle;
    /**
     * Default Numeric tick strategy configuration.
     */
    numericTickStrategy: NumericTickStrategy;
    /**
     * Default DateTime tick strategy configuration.
     */
    dateTimeTickStrategy: DateTimeTickStrategy;
    /**
     * Default Time tick strategy configuration.
     */
    timeTickStrategy: TimeTickStrategy;
    /**
     * Style for Custom Tick Grid line.
     */
    customTickGridStrokeStyle: LineStyle;
    /**
     * Length for CustomTick pointer.
     */
    customTickPointerLength: number;
    /**
     * FillStyle for CustomTick Marker.
     *
     * @deprecated  Use `uiPointableTextBoxFillStyle` instead.
     */
    customTickMarkerFillStyle?: FillStyle;
    /**
     * FillStyle for Custom Tick Marker Text
     *
     * @deprecated  Custom Tick marker theme style has been split into two separate properties based on type of Custom Tick.
     *              Use either `customTickMarkerTextFillStyle` or `uiTickTextFillStyle`
     */
    customTickMarkerTextFillStyle?: FillStyle;
    /**
     * StrokeStyle for CustomTick Marker.
     *
     * @deprecated  Custom Tick marker theme style has been split into two separate properties based on type of Custom Tick.
     *              Use either `uiPointableTextBoxStrokeStyle` or `uiTickStrokeStyle`
     */
    customTickMarkerStrokeStyle?: LineStyle;
    /**
     * Font Settings for CustomTick Marker.
     *
     * @deprecated  Custom Tick marker theme style has been split into two separate properties based on type of Custom Tick.
     *              Use either `uiPointableTextBoxFont` or `uiTickFont`
     */
    customTickMarkerFont?: FontSettings;
    /**
     * FillStyle for `UIPointableTextBox` Background.
     *
     * This is used with default Auto Cursor (X, Y ticks) as well as with default Custom Ticks [[Axis.addCustomTick]].
     *
     * Added in v.3.1, if omitted or `undefined` will fallback to `customTickMarkerFillStyle`.
     *
     * `customTickMarkerFillStyle` has priority over this, but it will be removed in next major release.
     */
    uiPointableTextBoxFillStyle?: FillStyle;
    /**
     * FillStyle for `UIPointableTextBox` Text.
     *
     * This is used with default Auto Cursor (X, Y ticks) as well as with default Custom Ticks [[Axis.addCustomTick]].
     *
     * Added in v.3.1, if omitted or `undefined` will fallback to `customTickMarkerTextFillStyle`.
     *
     * `customTickMarkerTextFillStyle` has priority over this, but it will be removed in next major release.
     */
    uiPointableTextBoxTextFillStyle?: FillStyle;
    /**
     * StrokeStyle for `UIPointableTextBox` Background Border.
     *
     * This is used with default Auto Cursor (X, Y ticks) as well as with default Custom Ticks [[Axis.addCustomTick]].
     *
     * Added in v.3.1, if omitted or `undefined` will fallback to `customTickMarkerTextFillStyle`.
     *
     * `customTickMarkerTextFillStyle` has priority over this, but it will be removed in next major release.
     */
    uiPointableTextBoxStrokeStyle?: LineStyle;
    /**
     * FontSettings for `UIPointableTextBox` Text.
     *
     * This is used with default Auto Cursor (X, Y ticks) as well as with default Custom Ticks [[Axis.addCustomTick]].
     *
     * Added in v.3.1, if omitted or `undefined` will fallback to `customTickMarkerFont`.
     *
     * `customTickMarkerFont` has priority over this, but it will be removed in next major release.
     */
    uiPointableTextBoxFont?: FontSettings;
    /**
     * FillStyle for `UITick` Text.
     *
     * This is used with Custom Ticks, when `UIElementBuilders.AxisTick` is used:
     *
     * ```js
     *  // Example, creation of UI tick.
     *  const tick = Axis.addCustomTick(UIElementBuilders.AxisTick)
     * ```
     *
     * Added in v.3.1, if omitted or `undefined` will fallback to `customTickMarkerTextFillStyle`.
     *
     * `customTickMarkerTextFillStyle` has priority over this, but it will be removed in next major release.
     */
    uiTickTextFillStyle?: FillStyle;
    /**
     * StrokeStyle for `UITick` Tick line.
     *
     * This is used with Custom Ticks, when `UIElementBuilders.AxisTick` is used:
     *
     * ```js
     *  // Example, creation of UI tick.
     *  const tick = Axis.addCustomTick(UIElementBuilders.AxisTick)
     * ```
     *
     * Added in v.3.1, if omitted or `undefined` will fallback to `customTickMarkerTextFillStyle`.
     *
     * `customTickMarkerTextFillStyle` has priority over this, but it will be removed in next major release.
     */
    uiTickStrokeStyle?: LineStyle;
    /**
     * FontSettings for `UITick` Text.
     *
     * This is used with Custom Ticks, when `UIElementBuilders.AxisTick` is used:
     *
     * ```js
     *  // Example, creation of UI tick.
     *  const tick = Axis.addCustomTick(UIElementBuilders.AxisTick)
     * ```
     *
     * Added in v.3.1, if omitted or `undefined` will fallback to `customTickMarkerFont`.
     *
     * `customTickMarkerFont` has priority over this, but it will be removed in next major release.
     */
    uiTickFont?: FontSettings;
    /**
     * Default fill style for UI Band
     */
    bandFillStyle: FillStyle;
    /**
     * Default stroke style for UI Band
     */
    bandStrokeStyle: LineStyle;
    /**
     * Default stroke style for Axis ConstantLine
     */
    constantLineStrokeStyle: SolidLine;
    /**
     * FillStyle for a Chart XY Series
     */
    seriesFillStyle: FillStyle | Palette<FillStyle>;
    /**
     * StrokeStyle for a Chart XY Series
     */
    seriesStrokeStyle: SolidLine | Palette<SolidLine>;
    /**
     * FillStyle for a Chart XY Series Point.
     */
    seriesPointFillStyle: FillStyle | Palette<FillStyle>;
    /**
     * StrokeStyle for a Chart XYZ Series.
     *
     * @deprecated Will be removed in v.4.0. Use `lineSeries3DStrokeStyle` instead.
     */
    seriesStrokeStyle3D: SolidLine<SolidFill> | Palette<SolidLine<SolidFill>>;
    /**
     * LineStyle for Line Series 3D.
     *
     * If `undefined`, will default to `seriesStrokeStyle3D`.
     */
    lineSeries3DStrokeStyle?: SolidLine<SolidFill> | Palette<SolidLine<SolidFill>>;
    /**
     * LineStyle for Point Line Series 3D.
     *
     * If `undefined`, will default to `seriesStrokeStyle3D`.
     */
    pointLineSeries3DStrokeStyle?: SolidLine<SolidFill> | Palette<SolidLine<SolidFill>>;
    /**
     * PointStyle for 3D Series with triangulated Points.
     *
     * @deprecated Will be removed in v.4.0. Use `pointSeries3DPointStyle` instead.
     */
    seriesTriangulatedPointStyle3D: TriangulatedPoints3D | Palette<TriangulatedPoints3D>;
    /**
     * PointStyle for Point Series 3D.
     *
     * If `undefined`, will default to `seriesTriangulatedPointStyle3D`.
     */
    pointSeries3DPointStyle?: TriangulatedPoints3D | Palette<TriangulatedPoints3D>;
    /**
     * PointStyle for Point Line Series 3D.
     *
     * If `undefined`, will default to `seriesTriangulatedPointStyle3D`.
     */
    pointLineSeries3DPointStyle?: TriangulatedPoints3D | Palette<TriangulatedPoints3D>;
    /**
     * PointStyle for 3D series with non-triangulated Points.
     *
     * @deprecated Will be removed in v.4.0. Use `pointCloudSeries3DPointStyle` instead.
     */
    seriesNonTriangulatedPointStyle3D: PixelatedPoints3D | Palette<PixelatedPoints3D>;
    /**
     * PointStyle for Point Line Series 3D.
     *
     * If `undefined`, will default to `seriesNonTriangulatedPointStyle3D`.
     */
    pointCloudSeries3DPointStyle?: PixelatedPoints3D | Palette<PixelatedPoints3D>;
    /**
     * FillStyle for Rectangle Series.
     *
     * If `undefined`, will default to `seriesFillStyle`.
     */
    rectangleSeriesFillStyle?: FillStyle | Palette<FillStyle>;
    /**
     * LineStyle for Rectangle Series.
     *
     * If `undefined`, will default to `emptyLine`.
     */
    rectangleSeriesStrokeStyle?: LineStyle | Palette<LineStyle>;
    /**
     * FillStyle for Polygon Series.
     *
     * If `undefined`, will default to `seriesFillStyle`.
     */
    polygonSeriesFillStyle?: FillStyle | Palette<FillStyle>;
    /**
     * LineStyle for Polygon Series.
     *
     * If `undefined`, will default to `emptyLine`.
     */
    polygonSeriesStrokeStyle?: LineStyle | Palette<LineStyle>;
    /**
     * StrokeStyle for mountain-series (Area, AreaRange).
     */
    mountainsStrokeStyle: SolidLine | Palette<SolidLine>;
    /**
     * FillStyle for mountain-series (Area, AreaRange).
     */
    mountainsFillStyle: FillStyle | Palette<FillStyle>;
    /**
     * StrokeStyle for inverted part of mountain-series (Area, AreaRange).
     */
    mountainsInvertedStrokeStyle: SolidLine | Palette<SolidLine>;
    /**
     * FillStyle for inverted part of mountain-series (Area, AreaRange).
     */
    mountainsInvertedFillStyle: FillStyle | Palette<FillStyle>;
    /**
     * StrokeStyle for segment series
     */
    segmentSeriesStyle: LineStyle | Palette<LineStyle>;
    /**
     * StrokeStyle for positive OHLC Bars
     */
    OHLCBarPositiveStyle: LineStyle;
    /**
     * Highlighted StrokeStyle for positive OHLC Bars
     *
     * @deprecated  Theme **highlighted** style properties will be removed in v.4.0.
     */
    OHLCBarPositiveHighlightStyle?: LineStyle;
    /**
     * StrokeStyle for negative OHLC Bars
     */
    OHLCBarNegativeStyle: LineStyle;
    /**
     * Highlighted StrokeStyle for negative OHLC Bars
     *
     * @deprecated  Theme **highlighted** style properties will be removed in v.4.0.
     */
    OHLCBarNegativeHighlightStyle?: LineStyle;
    /**
     * StrokeStyle for OHLC candle sticks
     */
    candleStickStyle: LineStyle;
    /**
     * StrokeStyle for OHLC candle sticks when highlighted
     *
     * @deprecated  Theme **highlighted** style properties will be removed in v.4.0.
     */
    candleStickStyleHighlight?: LineStyle;
    /**
     * FillStyle for Positive OHLC candle sticks
     */
    candleStickPositiveStyle: FillStyle;
    /**
     * FillStyle for Positive OHLC candle sticks when highlighted
     *
     * @deprecated  Theme **highlighted** style properties will be removed in v.4.0.
     */
    candleStickPositiveStyleHighlight?: FillStyle;
    /**
     * StrokeStyle for Positive OHLC candle sticks
     */
    candleStickPositiveStrokeStyle: LineStyle;
    /**
     * StrokeStyle for Positive OHLC candle sticks when highlighted
     *
     * @deprecated  Theme **highlighted** style properties will be removed in v.4.0.
     */
    candleStickPositiveStrokeStyleHighlight?: LineStyle;
    /**
     * FillStyle for Negative OHLC candle sticks
     */
    candleStickNegativeStyle: FillStyle;
    /**
     * FillStyle for Negative OHLC candle sticks when highlighted
     *
     * @deprecated  Theme **highlighted** style properties will be removed in v.4.0.
     */
    candleStickNegativeStyleHighlight?: FillStyle;
    /**
     * StrokeStyle for Negative OHLC candle sticks
     */
    candleStickNegativeStrokeStyle: LineStyle;
    /**
     * StrokeStyle for Negative OHLC candle sticks when highlighted
     *
     * @deprecated  Theme **highlighted** style properties will be removed in v.4.0.
     */
    candleStickNegativeStrokeStyleHighlight?: LineStyle;
    /**
     * FillStyle for Box Figures
     */
    boxFigureStyle: FillStyle;
    /**
     * StrokeStyle for Box Figures
     */
    boxFigureStrokeStyle: LineStyle;
    /**
     * StrokeStyle for Box Figures Line
     */
    boxFigureLineStyle: LineStyle;
    /**
     * StrokeStyle for Box Figures Median Line
     */
    boxFigureMedianLineStyle: LineStyle;
    /**
     * Default style for old deprecated 2D heatmap series fill.
     *
     * If `undefined`, defaults to `seriesFillStyle`.
     */
    heatmapFillStyle?: FillStyle | Palette<FillStyle>;
    /**
     * Default style for old deprecated 2D heatmap series wireframe.
     *
     * If `undefined`, defaults to `emptyFill`.
     */
    heatmapWireframeStyle?: FillStyle | Palette<FillStyle>;
    /**
     * Default style for 2D heatmap grid series fill.
     *
     * If `undefined`, defaults to `seriesFillStyle`.
     */
    heatmapGridSeriesFillStyle?: FillStyle | Palette<FillStyle>;
    /**
     * Default style for 2D heatmap grid series wireframe.
     *
     * If `undefined`, defaults to `emptyLine`.
     */
    heatmapGridSeriesWireframeStyle?: LineStyle | Palette<LineStyle>;
    /**
     * FillStyle for Surface series.
     */
    surfaceSeriesFillStyle: FillStyle | Palette<FillStyle>;
    /**
     * LineStyle for Surface series Wireframe.
     *
     * If `undefined`, defaults to `emptyLine`.
     */
    surfaceSeriesWireframeStyle?: LineStyle | Palette<LineStyle>;
    /**
     * FillStyle for Box series.
     */
    boxSeriesFillStyle: FillStyle | Palette<FillStyle>;
    /**
     * FillStyle for Cursor PointMarker
     */
    pointMarkerFillStyle: FillStyle;
    /**
     * StrokeStyle for Cursor PointMarker
     */
    pointMarkerStrokeStyle: LineStyle;
    /**
     * StrokeStyle for Horizontal Grid originating from Cursor PointMarker.
     *
     * @deprecated  Use `customTickGridStrokeStyle` instead.
     */
    pointMarkerHorizontalGridStrokeStyle?: LineStyle;
    /**
     * StrokeStyle for Vertical Grid originating from Cursor PointMarker
     *
     * @deprecated  Use `customTickGridStrokeStyle` instead.
     */
    pointMarkerVerticalGridStrokeStyle?: LineStyle;
    /**
     * FillStyle for Cursor PointMarker Text
     *
     * @deprecated  Use `uiPointableTextBoxTextFillStyle` or `uiTickTextFillStyle` instead.
     */
    pointMarkerTextFillStyle?: FillStyle;
    /**
     * FillStyle for Cursor ResultTable
     */
    resultTableFillStyle: FillStyle;
    /**
     * StrokeStyle for Cursor ResultTable
     */
    resultTableStrokeStyle: LineStyle;
    /**
     * FillStyle for Cursor ResultTable text
     */
    resultTableTextFillStyle: FillStyle;
    /**
     * FontSettings for Cursor ResultTable text
     *
     * **Optional**, if `undefined`, will fallback to default LCJS font (same as `new FontSettings()`).
     */
    resultTableTextFont?: FontSettings;
    /**
     * FillStyle for UI Element Background
     */
    uiBackgroundFillStyle: FillStyle;
    /**
     * StrokeStyle for UI Element Background
     */
    uiBackgroundStrokeStyle: LineStyle;
    /**
     * FillStyle for UI Text
     */
    uiTextFillStyle: FillStyle;
    /**
     * FillStyle for UI Button
     */
    uiButtonFillStyle: FillStyle;
    /**
     * Size for UI Button
     */
    uiButtonSize: number;
    /**
     * Common UI font
     */
    uiFont: FontSettings;
    /**
     * Default styles for 3D Charts Axes.
     */
    axesStyles3D: Vec3<LineStyle | SolidLine<SolidFill>>;
    /**
     * Default style for 3D Charts bounding box.
     */
    boundingBoxStyle3D: LineStyle | SolidLine<SolidFill>;
    /**
     * On-screen menu button background color.
     */
    onScreenMenuButtonBackgroundColor: Color;
    /**
     * Icon set for on-screen menu buttons.
     */
    onScreenMenuButtonIconSet: OnScreenMenuIconSet;
}
/**
 * Interface for FillStyle styling options.
 * Used with creating custom themes.
 */
export interface CustomFillStyle {
    color: Color | Array<Color>;
    fillType?: 'solid' | 'linearGradient' | 'radialGradient';
    angle?: number;
}
/**
 * Interface for StrokeStyle styling options.
 * Used with creating custom themes.
 */
export interface CustomLineStyle {
    color: Color | Array<Color>;
    fillType?: 'solid' | 'linearGradient' | 'radialGradient';
    lineType?: 'solid';
}
/**
 * Interface for Custom Styles.
 */
export interface CustomStyle {
    font: string;
    dashboard: {
        splitter?: CustomLineStyle;
        fill: CustomFillStyle;
    };
    chart: {
        title?: CustomFillStyle;
        backGroundFill?: CustomFillStyle;
        panelFill: CustomFillStyle;
    };
    spider: {
        fill?: CustomFillStyle;
        web?: CustomLineStyle;
        axis?: CustomLineStyle;
        axisNib?: CustomLineStyle;
        stroke?: CustomLineStyle;
        axisLabel?: CustomFillStyle;
        seriesLabel?: CustomFillStyle;
    };
    sliceChart: {
        connector?: CustomLineStyle;
        label?: CustomFillStyle;
    };
    gauge: {
        sliceFill?: CustomFillStyle;
        backgroundFill?: CustomFillStyle;
        stroke?: CustomLineStyle;
    };
    axis: {
        title?: CustomFillStyle;
        label?: CustomFillStyle;
        overlay?: CustomFillStyle;
        grid?: CustomLineStyle;
        tick?: CustomLineStyle;
        nib?: CustomLineStyle;
        nibOverlay?: CustomFillStyle;
        axes?: CustomLineStyle;
    };
    band: {
        fill?: CustomFillStyle;
    };
    constantline: {
        stroke?: CustomLineStyle;
    };
    series: {
        fill?: CustomFillStyle;
        stroke?: CustomLineStyle;
        pointFill?: CustomFillStyle;
    };
    mountains: {
        stroke?: CustomLineStyle;
        fill?: CustomFillStyle;
        invertedStroke?: CustomLineStyle;
        invertedFill?: CustomFillStyle;
    };
    candlestick: {
        fill?: CustomLineStyle;
        highlight?: CustomLineStyle;
        positive?: CustomFillStyle;
        positiveHighlight?: CustomFillStyle;
        positiveStroke?: CustomLineStyle;
        negative?: CustomFillStyle;
        negativeHighlight?: CustomFillStyle;
        negativeStroke?: CustomLineStyle;
    };
    box: {
        fill?: CustomFillStyle;
        stroke?: CustomLineStyle;
        line?: CustomLineStyle;
        median?: CustomLineStyle;
    };
    point: {
        fill?: CustomFillStyle;
        stroke?: CustomLineStyle;
        horizontalGrid?: CustomLineStyle;
        verticalGrid?: CustomLineStyle;
        text?: CustomFillStyle;
    };
    result: {
        fill?: CustomFillStyle;
        stroke?: CustomLineStyle;
        text?: CustomFillStyle;
    };
    ui: {
        fill?: CustomFillStyle;
        stroke?: CustomLineStyle;
        text?: CustomFillStyle;
        button?: CustomFillStyle;
    };
    customTick: {
        fill?: CustomFillStyle;
        stroke?: CustomLineStyle;
        grid?: CustomLineStyle;
    };
}
/**
 * Create a custom theme to use. New theme uses an existing theme as basis,
 * so users can customize only the parts they want from a preset theme.
 * This gives more control over each stylable object than customSimpleTheme and customComplexTheme.
 * See [[Theme]] for each customizable object available.
 *
 * Usage example:
 * ```javascript
 * // Modify the dashboard background color for the dark theme:
 * const customTheme = customTheme(Themes.dark, { dashboardBackGroundFillStyle: new SolidFill({color: ColorHEX('#f121')}) } )
 * ```
 * @param   baseTheme   Theme to use as basis for the new theme.
 * @param   newTheme    New theme or part of new theme to apply over the base theme.
 * @return              New theme.
 */
export declare const customTheme: (baseTheme: Theme, newTheme: Partial<Theme>) => Theme;
/**
 * Function for defining a new custom theme with only few parameters.
 * @param primaryColor Only required variable. Is used in headers and labels.
 * @param secondaryColor If not provided, will use primary color instead. Used in graphs, labels and subheaders.
 * @param base Theme to use as a base. Will be used for background, grid and constantlines.
 * @param fontFamily Custom font for all elements. IMPORTANT! Font must be used and loaded on the page where this variable is
 * used before rendering chart. You can ensure that font has been loaded by using function 'document.fonts.ready'.
 * @return new Theme
 *
 * ```javascript
 * // Define new theme with one color
 * const myTheme = customSimpleTheme(ColorHEX('#C90'), , Themes.light, 'Comic Sans')
 * const chart = lightningChart().ChartXY( { theme: myTheme } )
 * ```
 */
export declare const customSimpleTheme: (primaryColor: Color, secondaryColor?: Color | undefined, base?: Theme, fontFamily?: string | undefined) => Theme;
/**
 * Method for creating a custom theme by modifying individual settings. Can be used with customSimpleTheme.
 * @param base Theme to base the modifications on
 * @param options Modifications to the base theme
 * ```javascript
 * // Define a new theme with different colored background
 * const myTheme = customComplexTheme(Themes.light, {chart: {fill: {color: ColorHex('#FF7')}}})
 * const chart = lightningChart().ChartXY( { theme: myTheme } )
 * ```
 */
export declare const customComplexTheme: (base: Theme, options: Partial<CustomStyle>) => Theme;
/**
 * Class for visualization of large sets of individually configurable 3D *Boxes*.
 *
 * Add data with [[BoxSeries3D.invalidateData]].
 *
 * Style *boxes* with [[BoxSeries3D.setFillStyle]].
 *
 * **Example usage:**
 *
 * ```ts
 *  // Construct a grid of vertical boxes.
 *  const data = [
 *      { x: 0, z: 0 },
 *      { x: 1, z: 0 },
 *      { x: 0, z: 1 },
 *      { x: 1, z: 1 }
 *  ]
 *      // Map coords into **BoxData**.
 *      .map( coords => {
 *      const height = Math.random() * 100
 *      return {
 *          xCenter: coords.x,
 *          yCenter: height / 2,
 *          zCenter: coords.z,
 *          xSize: 1,
 *          ySize: height,
 *          zSize: 1
 *      }
 *  })
 *  const chart = lightningChart().Chart3D()
 *  const boxSeries = chart.addBoxSeries()
 *      .invalidateData( data )
 * ```
 *
 * **Color shading style**.
 *
 * By default, `BoxSeries3D` uses _Phong_ shading style.
 *
 * This can be changed with `BoxSeries3D.setColorShadingStyle(new ColorShadingStyles.Simple())`
 */
export declare class BoxSeries3D extends Series3D<BoxSet3D> implements AttachableWithLUT {
    /**
     * Method for invalidating *Box* data. Accepts an *Array* of [[BoxDataCentered]] objects.
     *
     * **Properties that must be defined for each NEW Box**:
     * - **"xCenter", "yCenter", "zCenter"**  | coordinates of Box in Axis values.
     * - **"xSize", "ySize", "zSize"**        | size of Box in Axis values.
     *
     * ( if altering a previously created Box, these are not necessary )
     *
     * **Optional properties:**
     * - **"id"**:
     *  If supplied, the *Box* can be altered afterwards by supplying different data with the same **"id"**
     * - **"color"**:
     *  If supplied, the *Box* will be coloured with that *color*,
     *  **but only when the *BoxSeries* is styled as [[IndividualPointFill]]**
     * - **"value"**
     *  *Look-up value* to be used when the *BoxSeries* is styled as [[PalettedFill]].
     *
     * **Example usage:**
     *
     * - Add an unidentified Box - in this case the Box can not be altered afterwards.
     *
     * ```ts
     *  BoxSeries3D.invalidateData([
     *      { xCenter: 0, yCenter: 0, zCenter: 0, xSize: 1, ySize: 1, zSize: 1 }
     *  ])
     * ```
     *
     * - Add an identified Box and alter its 'color' property afterwards.
     *
     * ```ts
     *  const id = "anything-unique"
     *  BoxSeries3D
     *      .setFillStyle( new IndividualPointFill() )
     *      .invalidateData([
     *          { id, xCenter: 0, yCenter: 0, zCenter: 0, xSize: 1, ySize: 1, zSize: 1 }
     *      ])
     *  setTimeout(() => {
     *      BoxSeries3D.invalidateData([ { id, color: ColorRGBA( 0, 255, 0 ) } ])
     *  }, 2000)
     * ```
     */
    invalidateData(data: Partial<BoxDataCentered>[]): this;
    /**
     * Method for invalidating *Box* data. Accepts an *Array* of [[BoxDataBounds]] objects.
     *
     * NOTE: Internally transforms all data into [[BoxDataCentered]] format, meaning that this method is slightly
     * slower than the alternative.
     *
     * **Properties that must be defined for each NEW Box**:
     * - **"xMin", "xMax"**   | bounds of Box on X Axis.
     * - **"yMin", "yMax"**   | bounds of Box on X Axis.
     * - **"zMin", "zMax"**   | bounds of Box on X Axis.
     *
     * ( if altering a previously created Box, these are not necessary )
     *
     * **Optional properties:**
     * - **"id"**:
     *  If supplied, the *Box* can be altered afterwards by supplying different data with the same **"id"**
     * - **"color"**:
     *  If supplied, the *Box* will be coloured with that *color*,
     *  **but only when the *BoxSeries* is styled as [[IndividualPointFill]]**
     * - **"value"**
     *  *Look-up value* to be used when the *BoxSeries* is styled as [[PalettedFill]].
     *
     * **Example usage:**
     *
     * - Add an unidentified Box - in this case the Box can not be altered afterwards.
     *
     * ```ts
     *  BoxSeries3D.invalidateData([
     *      { xMin: 0, yMin: 0, zMin: 0, xMax: 1, yMax: 1, zMax: 1 }
     *  ])
     * ```
     *
     * - Add an identified Box and alter its 'color' property afterwards.
     *
     * ```ts
     *  const id = "anything-unique"
     *  BoxSeries3D
     *      .setFillStyle( new IndividualPointFill() )
     *      .invalidateData([
     *          { id, xMin: 0, yMin: 0, zMin: 0, xMax: 1, yMax: 1, zMax: 1 }
     *      ])
     *  setTimeout(() => {
     *      BoxSeries3D.invalidateData([ { id, color: ColorRGBA( 0, 255, 0 ) } ])
     *  }, 2000)
     * ```
     */
    invalidateData(data: Partial<BoxDataBounds>[]): this;
    /**
     * Set *FillStyle* of *BoxSeries*.
     *
     * Supports following FillStyles:
     * - **[[SolidFill]]**:
     *  Single solid color for all *boxes*.
     * - **[[IndividualPointFill]]**:
     *  Each *box* is colored according to its **"color"** property.
     *  If the property is not present, the *box* is colored with the *IndividualPointFill* objects' fall-back color.
     * - **[[PalettedFill]]**:
     *  Each *box* is colored according to its **"value"** property and the *PalettedFill* objects'
     *  *look up table*.
     * @param   value   FillStyle or function which creates a FillStyle based on previous value.
     * @return          Object itself.
     */
    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get *FillStyle* of *BoxSeries*.
     *
     * Supports following FillStyles:
     * - **[[SolidFill]]**:
     *  Single solid color for all *boxes*.
     * - **[[IndividualPointFill]]**:
     *  Each *box* is colored according to its **"color"** property.
     *  If the property is not present, the *box* is colored with the *IndividualPointFill* objects' fall-back color.
     * - **[[PalettedFill]]**:
     *  Each *box* is colored according to its **"value"** property and the *PalettedFill* objects'
     *  *look up table*.
     * @return  FillStyle object.
     */
    getFillStyle(): FillStyle;
    /**
     * Set rounded edges of Boxes.
     *
     * NOTE: Rounded edges result in increased geometry precision, which in turn uses more rendering resources.
     * @param   roundness   Either a **number in range [0, 1]** describing the amount of rounding
     *                      or **undefined** to disable rounded edges.
     * @return              Object itself for fluent interface.
     */
    setRoundedEdges(roundness: number | undefined): this;
    /**
     * Get rounded edges of Boxes.
     *
     * NOTE: Rounded edges result in increased geometry precision, which in turn uses more rendering resources.
     * @return              Either a **number in range [0, 1]** describing the amount of rounding
     *                      or **undefined** for disabled rounded edges.
     */
    getRoundedEdges(): number | undefined;
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Series itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick?: boolean): this;
}
/**
 * Interface for non-geometric properties of a *box*.
 *
 * Box geometry can be specified in a variety of ways, namely:
 * - [[BoxDataCentered]].
 * - [[BoxDataBounds]].
 */
export interface BoxData {
    /**
     * Color of this box, when the *series* is styled as [[IndividualPointFill]].
     */
    color?: Color;
    /**
     * Look-up value for this box, when the *series* is styled as [[PalettedFill]].
     *
     * Determines the color of the box.
     */
    value?: number;
    /**
     * Identifier of this box.
     *
     * Can be used to alter the boxes' properties afterwards.
     */
    id?: string | number;
}
/**
 * Interface for specifying properties of a *box*.
 *
 * Non-geometry properties are explained in [[BoxData]] interface.
 *
 * This interface defines the box using a *center coordinate* and *size*. For another geometry definitions, see:
 * - [[BoxDataBounds]].
 */
export interface BoxDataCentered extends BoxData {
    /**
     * Center X coordinate of Box.
     */
    xCenter: number;
    /**
     * Center Y coordinate of Box.
     */
    yCenter: number;
    /**
     * Center Z coordinate of Box.
     */
    zCenter: number;
    /**
     * X size of Box. Applied both ways from 'xCenter' divided by 2.
     */
    xSize: number;
    /**
     * Y size of Box. Applied both ways from 'yCenter' divided by 2.
     */
    ySize: number;
    /**
     * Z size of Box. Applied both ways from 'zCenter' divided by 2.
     */
    zSize: number;
}
/**
 * Interface for specifying properties of a *box*.
 *
 * Non-geometry properties are explained in [[BoxData]] interface.
 *
 * This interface defines the box using *coordinate boundaries*. For another geometry definitions, see:
 * - [[BoxDataCentered]].
 */
export interface BoxDataBounds extends BoxData {
    /**
     * Minimum X coordinate.
     */
    xMin: number;
    /**
     * Minimum Y coordinate.
     */
    yMin: number;
    /**
     * Minimum Z coordinate.
     */
    zMin: number;
    /**
     * Maximum X coordinate.
     */
    xMax: number;
    /**
     * Maximum Y coordinate.
     */
    yMax: number;
    /**
     * Maximum Z coordinate.
     */
    zMax: number;
}
/**
 * Implementation of Chart3D camera control logic.
 * @hidden
 */
export declare class DefaultCameraStrategy implements CameraStrategy {
    protected readonly _engineScale: ScaleXY;
    protected readonly _viewportScalePixels: ScaleXY;
    protected readonly _boundingBoxScale: Vec3<UnitScale>;
    protected readonly _projectTo2D: (point: Point3D, cameraConfiguration?: CameraConfiguration) => Point | undefined;
    protected readonly _projectTo3D: (point: Point, cameraConfiguration?: CameraConfiguration) => Ray<Point3D> | undefined;
    /**
     * @param _engineScale          Scale object for whole engine.
     * @param _viewportScalePixels  Scale object for viewport in pixels (area limited by Dashboard or chart margins).
     * @param _boundingBoxScale     Scale object for 3D chart.
     * @param _projectTo2D          Injected function for projecting 3D point to 2D.
     *                              If camera config is supplied, that should be used for projecting.
     * @param _projectTo3D          Injected function for projecting 2D point to 3D.
     *                              If camera config is supplied, that should be used for projecting.
     */
    constructor(_engineScale: ScaleXY, _viewportScalePixels: ScaleXY, _boundingBoxScale: Vec3<UnitScale>, _projectTo2D: (point: Point3D, cameraConfiguration?: CameraConfiguration) => Point | undefined, _projectTo3D: (point: Point, cameraConfiguration?: CameraConfiguration) => Ray<Point3D> | undefined);
    getDefaultCameraConfiguration(boundingBox: Point3D): CameraConfiguration;
    /**
     * Apply list of camera interactions to camera state to get new camera configuration.
     */
    applyCameraInteractions(state: CameraStrategyInput, interactions: CameraInteraction[]): CameraConfiguration | undefined;
    boundingBoxChanged(state: CameraStrategyInput): CameraConfiguration | undefined;
    cameraLocationChanged(state: CameraStrategyInput): CameraConfiguration | undefined;
    viewportChanged(state: CameraStrategyInput): CameraConfiguration | undefined;
}
/**
 * Interface for abstract 3D camera interactions logic.
 * @hidden
 */
export interface CameraStrategy {
    /**
     * Initialize Camera configuration based on bounding box dimensions.
     * @param   boundingBox     Bounding box dimensions.
     * @return                  Initial CameraConfiguration.
     */
    getDefaultCameraConfiguration(boundingBox: Point3D): CameraConfiguration;
    /**
     * Apply list of camera interactions to camera state to get new camera configuration.
     */
    applyCameraInteractions(state: CameraStrategyInput, interactions: CameraInteraction[]): CameraConfiguration | undefined;
    /**
     * Method which is called when Chart3D's bounding box dimensions are changed.
     * Can return a new CameraConfiguration to reactively change the Camera location/direction.
     * @param   state       Current state of Chart3D.
     * @return              Optional CameraConfiguration to be applied.
     */
    boundingBoxChanged(state: CameraStrategyInput): CameraConfiguration | undefined;
    /**
     * Method which is called when camera location is changed by user calling [[Chart3D.setCameraLocation]].
     * Can return a new CameraConfiguration to reactively change the Camera location/direction.
     * @param   state       Current state of Chart3D.
     * @return              Optional CameraConfiguration to be applied.
     */
    cameraLocationChanged(state: CameraStrategyInput): CameraConfiguration | undefined;
    /**
     * Method which is called when viewport dimensions are changed (e.g. document is resized or Dashboard cell is resized).
     * Can return a new CameraConfiguration to reactively change the Camera location/direction.
     * @param   state       Current state of Chart3D.
     * @return              Optional CameraConfiguration to be applied.
     */
    viewportChanged(state: CameraStrategyInput): CameraConfiguration | undefined;
}
/**
 * Interface describing necessary information for CameraStrategy's decisions.
 * @hidden
 */
export interface CameraStrategyInput {
    /**
     * Current Chart3D bounding box dimensions centered at (0,0,0).
     */
    boundingBox: Point3D;
    /**
     * Location of Camera in World.
     */
    cameraLocation: Point3D;
    /**
     * Direction of Camera.
     */
    cameraDirection: Point3D;
}
/**
 * Interface describing full configuration of Chart3D camera.
 * @hidden
 */
export interface CameraConfiguration {
    /**
     * Location of Camera in World.
     */
    location: Point3D;
    /**
     * Direction of Camera.
     */
    direction: Point3D;
}
/**
 * @hidden
 */
export declare type MouseZoom = {
    /**
     * Set Zoom level as distance from scene origin.
     */
    distance: number;
} | {
    /**
     * Zoom by mouse wheel event.
     */
    mouseWheel: number;
};
/**
 * @hidden
 */
export declare type CameraRotationAndZoom = {
    type: 'rotate+zoom';
    rotation: Point;
    cameraDistance: number;
};
/**
 * @hidden
 */
export declare type CameraRotation = {
    type: 'rotate';
    rotation: Point;
};
/**
 * @hidden
 */
export declare type CameraWheelZoom = {
    type: 'wheel-zoom';
    deltaY: number;
};
/**
 * **NOTE: Only usable for internal debugging purposes**
 *
 * Excluded from production build.
 *
 * Rotates camera direction, without affecting location.
 *
 * @hidden
 */
export declare type CameraRotationFixed = {
    type: 'fixed-rotate';
    rotation: Point;
};
/**
 * **NOTE: Only usable for internal debugging purposes**
 *
 * Excluded from production build.
 *
 * Moves Camera in relative Forward/Backwards/Left/Right axes.
 *
 * @hidden
 */
export declare type CameraMove = {
    type: 'move';
    amountForward: number;
    amountRight: number;
};
/**
 * Internal type for describing different camera interaction events.
 * @hidden
 */
export declare type CameraInteraction = CameraRotationAndZoom | CameraRotation | CameraWheelZoom | CameraRotationFixed | CameraMove;
/**
 * Type definition for a generic type that is reliant on date-offset.
 * @hidden
 */
declare type NeedsDateOffset<T> = (dateOffset: number) => T;
/**
 * Interface for an internal data structure representing a displayable Date Time Unit.
 * @hidden
 */
export declare type DateTimeUnit = {
    /**
     * Identifier of date time unit.
     */
    readonly label: 'MilliSecond100' | 'Second' | 'Minute' | 'Hour' | 'Day' | 'Week' | 'Month' | 'Year' | 'Decade' | 'Century' | 'Millennium';
    /**
     * Size of unit as milliseconds.
     *
     * For irregular DateTimeUnits this should be the minimal interval (eq. Month: 28 days).
     */
    readonly unit: number;
} & ({
    readonly irregular: false;
    /**
     *
     */
    readonly greatTicks: undefined | {
        /**
         * Function that is used to synchronize tick positioning when it is the greatest time unit present.
         * @param   ref     Reference date time.
         */
        readonly getReferenceKeyValue: NeedsDateOffset<(ref: number) => number>;
    };
    /**
     *
     */
    readonly majorTicks: {
        /**
         * Fitting function for **minor** ticks of this time unit.
         *
         * Defines logic of fitting minor ticks when all don't fit.
         */
        readonly fitFunction: KeyValuesFittingFunction | undefined;
    };
    /**
     * Minor ticks configuration for this time unit.
     *
     * If undefined, minor ticks will not be displayed.
     */
    readonly minorTicks: undefined | {
        /**
         * Fitting function for **minor** ticks of this time unit.
         *
         * Defines logic of fitting minor ticks when all don't fit.
         */
        readonly fitFunction: KeyValuesFittingFunction | undefined;
        /**
         * Amount of **regular** minor ticks + 1.
         *
         * Eq. amount = 4 for second minor ticks results in:
         * 0:15, 0:30, 0:45
         */
        readonly amount: number;
    };
} | {
    readonly irregular: true;
    /**
     * Logic that finds previous key value from a reference key value for an irregular time unit.
     */
    readonly getPrevKeyValue: NeedsDateOffset<(ref: number) => number>;
    /**
     * Logic that finds next key value from a reference key value (including that ref value) for an irregular time unit.
     */
    readonly getNextKeyValueIncludingRef: NeedsDateOffset<(ref: number) => number>;
    /**
     * Logic that finds next key value from a reference key value for an irregular time unit.
     */
    readonly getNextKeyValue: NeedsDateOffset<(ref: number) => number>;
    /**
     *
     */
    readonly greatTicks: undefined | true;
    /**
     *
     */
    readonly majorTicks: {
        /**
         * Fitting function for **minor** ticks of this time unit.
         *
         * Defines logic of fitting minor ticks when all don't fit.
         */
        readonly fitFunction: KeyValuesFittingFunction | undefined;
    };
    /**
     * Minor ticks configuration for this time unit.
     *
     * If undefined, minor ticks will not be displayed.
     */
    readonly minorTicks: undefined | {
        /**
         * Fitting function for **minor** ticks of this time unit.
         *
         * Defines logic of fitting minor ticks when all don't fit.
         */
        readonly fitFunction: KeyValuesFittingFunction | undefined;
    };
});
/**
 * List of date-time units in increasing order.
 * @hidden
 */
export declare const DateTimeUnits: DateTimeUnit[];
/**
 * Type union of supported methods of defining a formatting behavior for *DateTime TickStrategy*.
 *
 * **1. Intl.DateTimeFormatOptions:**
 *
 *  Use JavaScript API for formatting logic by supplying a *Intl.DateTimeFormatOptions* object. Example usage:
 *
 * ```javascript
 *  // 'January 2015'
 *  { year: 'numeric', month: 'long' }
 * ```
 *
 * For complete documentation of valid keys and values, refer to
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
 *
 * **2. Custom formatting function:**
 *
 * Specify custom formatting logic by supplying a *function* that returns a *string*. Example usage:
 *
 * ```javascript
 *  ( value, range ) => {
 *      // 'value' = number position of tick along the *Axis*.
 *      // 'range' = *FormattingRange* object that can be used to find the total range of the *Axis*, if needed.
 *
 *      // Return *string*.
 *      return "any string"
 *  }
 *
 *  ( value ) => {
 *      // JS *Date* API can be used to interpret numeric *Axis* positions as *UTC Date/Time*, exposing a multitude of handy methods.
 *      const date = new Date( value )
 *      return date.toLocaleTimeString()
 *  }
 * ```
 *
 * JS *Date* documentation: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date
 */
export declare type DateTimeFormatter = Intl.DateTimeFormatOptions | FormattingFunction;
/**
 * Modifiable properties of a DateTime *TickStrategy*.
 *
 * Hidden because DateTimeTickStrategy intentionally has no constructor.
 * @hidden
 */
export interface DateTimeTickStrategyProperties {
    /**
     * Cursor formatter.
     *
     * This controls the date time formatting used by:
     * - Default cursor result table formatters.
     * - Default cursor tick formatters along Axis which uses this `TickStrategy`.
     * - `Axis.formatValue` method of the Axis which uses this `TickStrategy`.
     *
     * `undefined` means to use default date time cursor formatting.
     *
     * ```ts
     *  // Example value, cursor formatter to display week day, year, month, day, hour and minute.
     *  cursorFormatter: (value, range, locale) =>
     *      new Date(value).toLocaleDateString(locale, {
     *          weekday: 'long',
     *          year: 'numeric',
     *          month: 'numeric',
     *          day: 'numeric',
     *          minute: '2-digit',
     *          hour: '2-digit',
     *      })
     * ```
     */
    readonly cursorFormatter: FormattingFunction | undefined;
    /**
     * Style of Great ticks.
     *
     * To disable great ticks, set to **emptyTick**.
     *
     * **NOTE: Label alignment is overridden, and has no effect on this property.**
     */
    readonly greatTickStyle: TickStyle;
    /**
     * Style of Major ticks.
     *
     * Major ticks can't be disabled (via emptyTicks), because TickLevel style doesn't support emptyTicks,
     * and Major tick level must exist for Minor tick positioning.
     */
    readonly majorTickStyle: VisibleTicks;
    /**
     * Style of Minor ticks.
     *
     * To disable minor ticks, set to **emptyTick**.
     */
    readonly minorTickStyle: TickStyle;
    /**
     * Valid javascript Date locale string, that specifies a geographical, political or cultural region.
     *
     * *undefined* passes the decision making to the browser.
     *
     * For example values, refer to https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     */
    readonly locale: string | undefined;
    /**
     * Optional "origin date" value.
     *
     * By default data-points are interpreted as *UTC dates* (milliseconds since January 1st 1970 GMT+0).
     * If a **dateOrigin** is defined, data-points will instead be interpreted as milliseconds since **dateOrigin**.
     */
    readonly dateOrigin: Date | undefined;
    /**
     * Formatter options for **major** ticks that are placed on relevant **century** intervals.
     */
    readonly formatOptionsMajorCentury: DateTimeFormatter;
    /**
     * Formatter options for **minor** ticks that are placed on relevant **decade** intervals.
     */
    readonly formatOptionsMinorDecade: DateTimeFormatter;
    /**
     * Formatter options for **major** ticks that are placed on relevant **decade** intervals.
     */
    readonly formatOptionsMajorDecade: DateTimeFormatter;
    /**
     * Formatter options for **minor** ticks that are placed on relevant **year** intervals.
     */
    readonly formatOptionsMinorYear: DateTimeFormatter;
    /**
     * Formatter options for **major** ticks that are placed on relevant **year** intervals.
     */
    readonly formatOptionsMajorYear: DateTimeFormatter;
    /**
     * Formatter options for **minor** ticks that are placed on relevant **month** intervals.
     */
    readonly formatOptionsMinorMonth: DateTimeFormatter;
    /**
     * Formatter options for **great** ticks that are placed on relevant **year** intervals.
     */
    readonly formatOptionsGreatYear: DateTimeFormatter;
    /**
     * Formatter options for **major** ticks that are placed on relevant **month** intervals.
     */
    readonly formatOptionsMajorMonth: DateTimeFormatter;
    /**
     * Formatter options for **minor** ticks that are placed on relevant **week** intervals.
     */
    readonly formatOptionsMinorWeek: DateTimeFormatter;
    /**
     * Formatter options for **great** ticks that are placed on relevant **month** intervals.
     */
    readonly formatOptionsGreatMonth: DateTimeFormatter;
    /**
     * Formatter options for **major** ticks that are placed on relevant **week** intervals.
     */
    readonly formatOptionsMajorWeek: DateTimeFormatter;
    /**
     * Formatter options for **minor** ticks that are placed on relevant **day** intervals.
     */
    readonly formatOptionsMinorDay: DateTimeFormatter;
    /**
     * Formatter options for **great** ticks that are placed on relevant **week** intervals.
     */
    readonly formatOptionsGreatWeek: DateTimeFormatter;
    /**
     * Formatter options for **major** ticks that are placed on relevant **day** intervals.
     */
    readonly formatOptionsMajorDay: DateTimeFormatter;
    /**
     * Formatter options for **minor** ticks that are placed on relevant **hour** intervals.
     */
    readonly formatOptionsMinorHour: DateTimeFormatter;
    /**
     * Formatter options for **great** ticks that are placed on relevant **day** intervals.
     */
    readonly formatOptionsGreatDay: DateTimeFormatter;
    /**
     * Formatter options for **major** ticks that are placed on relevant **hour** intervals.
     */
    readonly formatOptionsMajorHour: DateTimeFormatter;
    /**
     * Formatter options for **minor** ticks that are placed on relevant **minute** intervals.
     */
    readonly formatOptionsMinorMinute: DateTimeFormatter;
    /**
     * Formatter options for **great** ticks that are placed on relevant **hour** intervals.
     */
    readonly formatOptionsGreatHour: DateTimeFormatter;
    /**
     * Formatter options for **major** ticks that are placed on relevant **minute** intervals.
     */
    readonly formatOptionsMajorMinute: DateTimeFormatter;
    /**
     * Formatter options for **minor** ticks that are placed on relevant **second** intervals.
     */
    readonly formatOptionsMinorSecond: DateTimeFormatter;
    /**
     * Formatter options for **great** ticks that are placed on relevant **minute** intervals.
     */
    readonly formatOptionsGreatMinute: DateTimeFormatter;
    /**
     * Formatter options for **major** ticks that are placed on relevant **second** intervals.
     */
    readonly formatOptionsMajorSecond: DateTimeFormatter;
    /**
     * Formatter options for **minor** ticks that are placed on relevant **millisecond** intervals.
     */
    readonly formatOptionsMinorMillisecond: DateTimeFormatter;
    /**
     * Formatter options for **great** ticks that are placed on relevant **second** intervals.
     */
    readonly formatOptionsGreatSecond: DateTimeFormatter;
    /**
     * Formatter options for **major** ticks that are placed on relevant **millisecond** intervals.
     */
    readonly formatOptionsMajorMilliSecond: DateTimeFormatter;
}
/**
 * *Axis Tick Strategy* that is designed for depicting date and time.
 *
 * Axis values are interpreted as UNIX timestamps similarly as with JavaScript Date API.
 *
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date
 *
 * Axis interval ranges supported by `DateTImeTickStrategy`:
 * - Minimum: 1 second (`1000`).
 * - Maximum: 1000 years (*really big number*).
 *
 * For reaching Axis ranges smaller than 1 second, [[TimeTickStrategy]] is recommended.
 *
 * **Note, that available axis interval ranges can be also limited by the type of Axis**, refer to [[Axis]] documentation for more information.
 *
 * Axis tick strategy is selected with [[Axis.setTickStrategy]] method:
 *
 * ```js
 *  Axis.setTickStrategy(AxisTickStrategies.DateTime, (dateTimeTicks) => dateTimeTicks)
 * ```
 *
 * All configuration of automatically created ticks is done using the callback from `setTickStrategy`,
 * see example below for the idea:
 *
 * ```js
 *  // Specify TickStrategy and use callback to style automatic ticks.
 *  Axis.setTickStrategy(AxisTickStrategies.DateTime, (dateTimeTicks) => dateTimeTicks
 *      // All methods of `DateTimeTickStrategy` can be used here for styling ticks.
 *      .setMajorTickStyle((majorTicks) => majorTicks
 *          .setLabelFont((font) => font
 *              .setWeight('bold')
 *          )
 *      )
 *  )
 * ```
 *
 * All available strategies for automatic Axis ticks creation can be referenced via [[AxisTickStrategies]].
 */
export declare class DateTimeTickStrategy implements MutableAxisTickStrategy {
    /**
     * Set cursor formatter for this `DateTimeTickStrategy` object.
     *
     * This will override the date time formatting used by:
     * - Default cursor result table formatters.
     * - Default cursor tick formatters along Axis which uses this `TickStrategy`.
     * - `Axis.formatValue` method of the Axis which uses this `TickStrategy`.
     *
     * ```ts
     *  // Example syntax, specify cursor formatting to display week day, year, month, day, hour and minute.
     *  Axis.setTickStrategy(AxisTickStrategies.DateTime, (ticks) => ticks
     *      .setCursorFormatter((value, range, locale) =>
     *          new Date(value).toLocaleDateString(locale, {
     *              weekday: 'long',
     *              year: 'numeric',
     *              month: 'numeric',
     *              day: 'numeric',
     *              minute: '2-digit',
     *              hour: '2-digit',
     *          })
     *      )
     *  )
     * ```
     * @param   formatter   `FormattingFunction` or `undefined` to use default date time cursor formatting.
     * @return              New *DateTimeTickStrategy* object.
     */
    setCursorFormatter(formatter: FormattingFunction | undefined): any;
    /**
     * Get cursor formatter of this `DateTimeTickStrategy` object.
     *
     * @return              `FormattingFunction` as set by user, or `undefined` to indicate that the default date time cursor formatting is configured.
     */
    getCursorFormatter(): FormattingFunction | undefined;
    /**
     * Construct a new *DateTimeTickStrategy* object based on this one, but with modified great tick style.
     *
     * *Great ticks* display the largest Date/Time information for the active time range.
     * There is always exactly one *great tick* in view.
     *
     * Example usage:
     *
     * **Disable great ticks**:
     *  ```javascript
     *  Axis.setTickStrategy(
     *      AxisTickStrategies.DateTime,
     *      ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
     *          .setGreatTickStyle( emptyTick )
     *  )
     * ```
     *
     * **Set font of great ticks**:
     * ```javascript
     *  Axis.setTickStrategy(
     *      AxisTickStrategies.DateTime,
     *      ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
     *          .setGreatTickStyle(( tickStyle: VisibleTicks ) => tickStyle
     *              .setLabelFont(( font ) => font
     *                  .setWeight( 'bold' )
     *              )
     *          )
     *  )
     *  ```
     * @param   value               Either a *TickStyle* object or a function, which creates a new one based on the existing style.
     * @return                      New *DateTimeTickStrategy* object.
     */
    setGreatTickStyle(value: TickStyle | ImmutableMutator<TickStyle>): this;
    /**
     * Get great tick style of this *DateTimeTickStrategy* object.
     *
     * *Great ticks* display the largest Date/Time information for the active time range.
     * There is always exactly one *great tick* in view.
     * @return                      Great tick style.
     */
    getGreatTickStyle(): TickStyle;
    /**
     * Construct a new *DateTimeTickStrategy* object based on this one, but with modified major tick style.
     *
     * *Major ticks* display the next smaller Date/Time information after *Great ticks*.
     * Often times, they represent the most 
     *
     * Example usage:
     *
     * **Set font of major ticks**:
     * ```javascript
     *  Axis.setTickStrategy(
     *      AxisTickStrategies.DateTime,
     *      ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
     *          .setMajorTickStyle(( tickStyle ) => tickStyle
     *              .setLabelFont(( font ) => font
     *                  .setWeight( 'bold' )
     *              )
     *          )
     *  )
     *  ```
     * @param   value               Either a *VisibleTicks* object or a function, which creates a new one based on the existing style.
     * @return                      New *DateTimeTickStrategy* object.
     */
    setMajorTickStyle(value: VisibleTicks | ImmutableMutator<VisibleTicks>): this;
    /**
     * Get major tick style of this *DateTimeTickStrategy* object.
     *
     * *Major ticks* display the next smaller Date/Time information after *Great ticks*.
     * Often times, they represent the most 
     * @return                      Major tick style.
     */
    getMajorTickStyle(): TickStyle;
    /**
     * Construct a new *DateTimeTickStrategy* object based on this one, but with modified minor tick style.
     *
     * *Minor ticks* display the next smaller Date/Time information after *Major ticks*.
     *
     * Example usage:
     *
     * **Disable minor ticks**:
     *  ```javascript
     *  Axis.setTickStrategy(
     *      AxisTickStrategies.DateTime,
     *      ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
     *          .setMinorTickStyle( emptyTick )
     *  )
     * ```
     *
     * **Set font of minor ticks**:
     *  ```javascript
     *  Axis.setTickStrategy(
     *      AxisTickStrategies.DateTime,
     *      ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
     *          .setMinorTickStyle(( tickStyle ) => tickStyle
     *              .setLabelFont(( font ) => font
     *                  .setWeight( 'bold' )
     *              )
     *          )
     *  )
     *  ```
     * @param   value               Either a *TickStyle* object or a function, which creates a new one based on the existing style.
     *                              Passing a function only works if the existing style is **not** *emptyTick*.
     * @return                      New *DateTimeTickStrategy* object.
     */
    setMinorTickStyle(value: TickStyle | ImmutableMutator<VisibleTicks>): this;
    /**
     * Get minor tick style of this *DateTimeTickStrategy* object.
     *
     * *Minor ticks* display the next smaller Date/Time information after *Major ticks*.
     * @return                      Minor tick style.
     */
    getMinorTickStyle(): TickStyle;
    /**
     * Construct a new *DateTimeTickStrategy* object based on this one, but with modified locale.
     *
     * The *locale* specifies a geographical, political or cultural region, affecting all formatting of *Tick labels*.
     *
     * All valid values can be found from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     *
     * Example usage:
     *
     * **Use locale of browser**:
     *  ```javascript
     *  Axis.setTickStrategy(
     *      AxisTickStrategies.DateTime,
     *      ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
     *          .setLocale( undefined )
     *  )
     * ```
     *
     * **Use specific locale**:
     *  ```javascript
     *  Axis.setTickStrategy(
     *      AxisTickStrategies.DateTime,
     *      ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
     *          .setLocale('en-US')
     *  )
     *  ```
     * @param   locale              Valid JavaScript Date locale string, that specifies a geographical, political or cultural region.
     *                              All valid values can be found from
     *                              https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @return                      New *DateTimeTickStrategy* object.
     */
    setLocale(locale: string | undefined): this;
    /**
     * Get locale of this *DateTimeTickStrategy* object.
     *
     * The *locale* specifies a geographical, political or cultural region, affecting all formatting of *Tick labels*.
     * @return                      JavaScript Date locale string, that specifies a geographical, political or cultural region.
     */
    getLocale(): string | undefined;
    /**
     * Construct a new *DateTimeTickStrategy* object based on this one, but with modified dateOrigin.
     *
     * By default data-points are interpreted as *UTC dates* (milliseconds since January 1st 1970 GMT+0).
     * If a **dateOrigin** is defined, data-points will instead be interpreted as milliseconds since **dateOrigin**.
     *
     * Specifying a *dateOrigin* can be necessary in applications where there is a long range of date-time data,
     * and high resolution zooming is desired.
     *
     * Example usage:
     *
     * **Application with one day of high-density data starting in year 2020**:
     *  ```javascript
     *  // Without specifying a dateOrigin, zooming will be limited to minutes with this range.
     *  // Milliseconds resolution can be reached by setting the dateOrigin to a Date
     *  // that is closer to the actual data (instead of the default 1.1.1970).
     *  Axis.setTickStrategy(
     *      AxisTickStrategies.DateTime,
     *      ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
     *          .setDateOrigin( new Date( 2020, 0, 1 ) )
     *  )
     * ```
     *
     * Check our DateTime Axis Interactive Example for a more thorough example on DateTime TickStrategy usage:
     * https://www.arction.com/lightningchart-js-interactive-examples/examples/lcjs-example-0020-dateTimeAxis.html
     *
     * @param   dateOrigin          A *JavaScript Date* object or *undefined*.
     * @return                      New *DateTimeTickStrategy* object.
     */
    setDateOrigin(dateOrigin: Date | undefined): this;
    /**
     * Get the *dateOrigin* of this *DateTimeTickStrategy* object.
     *
     * By default data-points are interpreted as *UTC dates* (milliseconds since January 1st 1970 GMT+0).
     * If a **dateOrigin** is defined, data-points will instead be interpreted as milliseconds since **dateOrigin**.
     * @return                      A *JavaScript Date* object or *undefined*.
     */
    getDateOrigin(): Date | undefined;
    /**
     * Construct a new *DateTimeTickStrategy* object based on this one, but with modified formatting options
     * for DateTime ranges where ticks are positioned as follows:
     *
     * - **Major: Decades**
     * - **Minor: Years**
     *
     * Example usage:
     *
     *  ```javascript
     *  Axis.setTickStrategy(
     *      AxisTickStrategies.DateTime,
     *      ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
     *          .setFormattingDecade(
     *              { year: 'numeric' },
     *              { year: 'numeric' }
     *          )
     *  )
     *  ```
     *
     * The used formatting options are dynamically chosen depending on the range of *Axis*, so depending
     * on the application this formatting customization method might not have a visible effect.
     *
     * For more detailed example usage, refer to [[DateTimeFormatter]].
     *
     * @param   majorTickFormattingOptions  Formatting options for *major ticks*
     * @param   minorTickFormattingOptions  Formatting options for *minor ticks*.
     * @return                              New *DateTimeTickStrategy* object.
     */
    setFormattingDecade(majorTickFormattingOptions: DateTimeFormatter | undefined, minorTickFormattingOptions: DateTimeFormatter | undefined): this;
    /**
     * Construct a new *DateTimeTickStrategy* object based on this one, but with modified formatting options
     * for DateTime ranges where ticks are positioned as follows:
     *
     * - **Major: Years**
     * - **Minor: Months**
     *
     * Example usage:
     *
     *  ```javascript
     *  Axis.setTickStrategy(
     *      AxisTickStrategies.DateTime,
     *      ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
     *          .setFormattingYear(
     *              { year: 'numeric' },
     *              { month: 'short' }
     *          )
     *  )
     *  ```
     *
     * The used formatting options are dynamically chosen depending on the range of *Axis*, so depending
     * on the application this formatting customization method might not have a visible effect.
     *
     * For more detailed example usage, refer to [[DateTimeFormatter]].
     * @param   majorTickFormattingOptions  Formatting options for *major ticks*
     * @param   minorTickFormattingOptions  Formatting options for *minor ticks*.
     * @return                              New *DateTimeTickStrategy* object.
     */
    setFormattingYear(majorTickFormattingOptions: DateTimeFormatter | undefined, minorTickFormattingOptions: DateTimeFormatter | undefined): this;
    /**
     * Construct a new *DateTimeTickStrategy* object based on this one, but with modified formatting options
     * for DateTime ranges where ticks are positioned as follows:
     *
     * - **Great: Years**
     * - **Major: Months**
     * - **Minor: Weeks**
     *
     * Example usage:
     *
     *  ```javascript
     *  Axis.setTickStrategy(
     *      AxisTickStrategies.DateTime,
     *      ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
     *          .setFormattingMonth(
     *              { year: 'numeric' },
     *              { month: 'long' },
     *              { day: '2-digit' }
     *          )
     *  )
     *  ```
     *
     * The used formatting options are dynamically chosen depending on the range of *Axis*, so depending
     * on the application this formatting customization method might not have a visible effect.
     *
     * For more detailed example usage, refer to [[DateTimeFormatter]].
     * @param   greatTickFormattingOptions  Formatting options for *great ticks*.
     * @param   majorTickFormattingOptions  Formatting options for *major ticks*
     * @param   minorTickFormattingOptions  Formatting options for *minor ticks*.
     * @return                              New *DateTimeTickStrategy* object.
     */
    setFormattingMonth(greatTickFormattingOptions: DateTimeFormatter | undefined, majorTickFormattingOptions: DateTimeFormatter | undefined, minorTickFormattingOptions: DateTimeFormatter | undefined): this;
    /**
     * Construct a new *DateTimeTickStrategy* object based on this one, but with modified formatting options
     * for DateTime ranges where ticks are positioned as follows:
     *
     * - **Great: Months**
     * - **Major: Weeks**
     * - **Minor: Days**
     *
     * Example usage:
     *
     *  ```javascript
     *  Axis.setTickStrategy(
     *      AxisTickStrategies.DateTime,
     *      ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
     *          .setFormattingWeek(
     *              { year: 'numeric', month: 'long' },
     *              { day: '2-digit' },
     *              { day: '2-digit' }
     *          )
     *  )
     *  ```
     *
     * The used formatting options are dynamically chosen depending on the range of *Axis*, so depending
     * on the application this formatting customization method might not have a visible effect.
     *
     * For more detailed example usage, refer to [[DateTimeFormatter]].
     * @param   greatTickFormattingOptions  Formatting options for *great ticks*.
     * @param   majorTickFormattingOptions  Formatting options for *major ticks*
     * @param   minorTickFormattingOptions  Formatting options for *minor ticks*.
     * @return                              New *DateTimeTickStrategy* object.
     */
    setFormattingWeek(greatTickFormattingOptions: DateTimeFormatter | undefined, majorTickFormattingOptions: DateTimeFormatter | undefined, minorTickFormattingOptions: DateTimeFormatter | undefined): this;
    /**
     * Construct a new *DateTimeTickStrategy* object based on this one, but with modified formatting options
     * for DateTime ranges where ticks are positioned as follows:
     *
     * - **Great: Weeks**
     * - **Major: Days**
     * - **Minor: Hours**
     *
     * Example usage:
     *
     *  ```javascript
     *  Axis.setTickStrategy(
     *      AxisTickStrategies.DateTime,
     *      ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
     *          .setFormattingDay(
     *              { year: 'numeric', month: 'long' },
     *              { day: '2-digit' },
     *              { hour: '2-digit', minute: '2-digit' }
     *          )
     *  )
     *  ```
     *
     * The used formatting options are dynamically chosen depending on the range of *Axis*, so depending
     * on the application this formatting customization method might not have a visible effect.
     *
     * For more detailed example usage, refer to [[DateTimeFormatter]].
     * @param   greatTickFormattingOptions  Formatting options for *great ticks*.
     * @param   majorTickFormattingOptions  Formatting options for *major ticks*
     * @param   minorTickFormattingOptions  Formatting options for *minor ticks*.
     * @return                              New *DateTimeTickStrategy* object.
     */
    setFormattingDay(greatTickFormattingOptions: DateTimeFormatter | undefined, majorTickFormattingOptions: DateTimeFormatter | undefined, minorTickFormattingOptions: DateTimeFormatter | undefined): this;
    /**
     * Construct a new *DateTimeTickStrategy* object based on this one, but with modified formatting options
     * for DateTime ranges where ticks are positioned as follows:
     *
     * - **Great: Days**
     * - **Major: Hours**
     * - **Minor: Minutes**
     *
     * Example usage:
     *
     *  ```javascript
     *  Axis.setTickStrategy(
     *      AxisTickStrategies.DateTime,
     *      ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
     *          .setFormattingHour(
     *              { year: 'numeric', month: 'long', day: '2-digit' },
     *              { hour: '2-digit', minute: '2-digit' },
     *              { hour: '2-digit', minute: '2-digit' }
     *          )
     *  )
     *  ```
     *
     * The used formatting options are dynamically chosen depending on the range of *Axis*, so depending
     * on the application this formatting customization method might not have a visible effect.
     *
     * For more detailed example usage, refer to [[DateTimeFormatter]].
     * @param   greatTickFormattingOptions  Formatting options for *great ticks*.
     * @param   majorTickFormattingOptions  Formatting options for *major ticks*
     * @param   minorTickFormattingOptions  Formatting options for *minor ticks*.
     * @return                              New *DateTimeTickStrategy* object.
     */
    setFormattingHour(greatTickFormattingOptions: DateTimeFormatter | undefined, majorTickFormattingOptions: DateTimeFormatter | undefined, minorTickFormattingOptions: DateTimeFormatter | undefined): this;
    /**
     * Construct a new *DateTimeTickStrategy* object based on this one, but with modified formatting options
     * for DateTime ranges where ticks are positioned as follows:
     *
     * - **Great: Hours**
     * - **Major: Minutes**
     * - **Minor: Seconds**
     *
     * Example usage:
     *
     *  ```javascript
     *  Axis.setTickStrategy(
     *      AxisTickStrategies.DateTime,
     *      ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
     *          .setFormattingMinute(
     *              { year: 'numeric', month: 'long', day: '2-digit' },
     *              { hour: '2-digit', minute: '2-digit' },
     *              { hour: '2-digit', minute: '2-digit', second: '2-digit' }
     *          )
     *  )
     *  ```
     *
     * The used formatting options are dynamically chosen depending on the range of *Axis*, so depending
     * on the application this formatting customization method might not have a visible effect.
     *
     * For more detailed example usage, refer to [[DateTimeFormatter]].
     * @param   greatTickFormattingOptions  Formatting options for *great ticks*.
     * @param   majorTickFormattingOptions  Formatting options for *major ticks*
     * @param   minorTickFormattingOptions  Formatting options for *minor ticks*.
     * @return                              New *DateTimeTickStrategy* object.
     */
    setFormattingMinute(greatTickFormattingOptions: DateTimeFormatter | undefined, majorTickFormattingOptions: DateTimeFormatter | undefined, minorTickFormattingOptions: DateTimeFormatter | undefined): this;
    /**
     * Construct a new *DateTimeTickStrategy* object based on this one, but with modified formatting options
     * for DateTime ranges where ticks are positioned as follows:
     *
     * - **Great: Minutes**
     * - **Major: Seconds**
     * - **Minor: Milliseconds**
     *
     * Example usage:
     *
     *  ```javascript
     *  Axis.setTickStrategy(
     *      AxisTickStrategies.DateTime,
     *      ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
     *          .setFormattingSecond(
     *              { year: 'numeric', month: 'long', day: '2-digit', hour: '2-digit', minute: '2-digit' },
     *              { hour: '2-digit', minute: '2-digit', second: '2-digit' },
     *              ( value ) => new Date( value ).getUTCMilliseconds(),
     *          )
     *  )
     *  ```
     *
     * The used formatting options are dynamically chosen depending on the range of *Axis*, so depending
     * on the application this formatting customization method might not have a visible effect.
     *
     * For more detailed example usage, refer to [[DateTimeFormatter]].
     * @param   greatTickFormattingOptions  Formatting options for *great ticks*.
     * @param   majorTickFormattingOptions  Formatting options for *major ticks*
     * @param   minorTickFormattingOptions  Formatting options for *minor ticks*
     * @return                              New *DateTimeTickStrategy* object.
     */
    setFormattingSecond(greatTickFormattingOptions: DateTimeFormatter | undefined, majorTickFormattingOptions: DateTimeFormatter | undefined, minorTickFormattingOptions?: DateTimeFormatter | undefined): this;
    /**
     * Construct a new *DateTimeTickStrategy* object based on this one, but with modified formatting options
     * for DateTime ranges where ticks are positioned as follows:
     *
     * - **Great: Seconds**
     * - **Major: Every tenth MilliSecond**
     *
     * Example usage:
     *
     *  ```javascript
     *  Axis.setTickStrategy(
     *      AxisTickStrategies.DateTime,
     *      ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
     *          .setFormattingMilliSecond(
     *              { year: 'numeric', month: 'long', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' },
     *              ( value ) => new Date( value ).getUTCMilliseconds()
     *          )
     *  )
     *  ```
     *
     * The used formatting options are dynamically chosen depending on the range of *Axis*, so depending
     * on the application this formatting customization method might not have a visible effect.
     *
     * For more detailed example usage, refer to [[DateTimeFormatter]].
     * @param   greatTickFormattingOptions  Formatting options for *great ticks*.
     * @param   majorTickFormattingOptions  Formatting options for *major ticks*
     * @return                              New *DateTimeTickStrategy* object.
     */
    setFormattingMilliSecond(greatTickFormattingOptions: DateTimeFormatter | undefined, majorTickFormattingOptions: DateTimeFormatter | undefined): this;
}
export {};
/**
 * Modifiable properties of a Numeric *TickStrategy*.
 *
 * Hidden because NumericTickStrategy intentionally has no constructor.
 * @hidden
 */
export interface NumericTickStrategyProperties {
    /**
     * Style of Extreme ticks (start & end of Axis).
     *
     * To disable extreme ticks, set to **emptyTick**.
     */
    readonly extremeTickStyle: TickStyle;
    /**
     * Style of Major ticks.
     *
     * Major ticks can't be disabled (via emptyTicks), because TickLevel style doesn't support emptyTicks,
     * and Major tick level must exist for minor tick positioning.
     */
    readonly majorTickStyle: VisibleTicks;
    /**
     * Style of Minor ticks.
     *
     * To disable minor ticks, set to **emptyTick**.
     */
    readonly minorTickStyle: TickStyle;
    /**
     * Optional coordinate to offset from tick coordinates when formatting tick labels and default cursor labels.
     *
     * If supplied, the value of `formattingOffset` will be added to every coordinate before formatting.
     * This can be useful for offsetting displayed data ranges in cases where actual data can't be practically rendered due to extremely large numbers for example.
     *
     * ```
     *  // Example, specify formatting offset.
     *  Axis.setTickStrategy(AxisTickStrategies.Numeric, (ticks) => ticks
     *      // Will result in `0` being formatted as `1000000`
     *      .setFormattingOffset(1000000)
     *  )
     * ```
     */
    readonly formattingOffset: number | undefined;
    /**
     * Cursor formatter.
     *
     * This controls the formatting used by:
     * - Default cursor result table formatters.
     * - Default cursor tick formatters along Axis which uses this `TickStrategy`.
     * - `Axis.formatValue` method of the Axis which uses this `TickStrategy`.
     *
     * `undefined` means to use default Numeric cursor formatting.
     *
     * ```ts
     *  // Example value, custom cursor formatter
     *  cursorFormatter: (value, range, locale) => value.toFixed(3)
     * ```
     */
    readonly cursorFormatter: FormattingFunction | undefined;
    /**
     * Formatting function used for extreme ticks.
     *
     * Use FormattingFunctions to select available ones or define custom function.
     *
     * **undefined** will result in default selection.
     */
    readonly extremeFormattingFunction?: FormattingFunction;
    /**
     * Formatting function used for major ticks.
     *
     * Use FormattingFunctions to select available ones or define custom function.
     *
     * **undefined** will result in default selection.
     */
    readonly majorFormattingFunction?: FormattingFunction;
    /**
     * Formatting function used for minor ticks.
     *
     * Use FormattingFunctions to select available ones or define custom function.
     *
     * **undefined** will result in default selection.
     */
    readonly minorFormattingFunction?: FormattingFunction;
}
/**
 * *Axis Tick Strategy* that is designed for depicting numeric values of all magnitudes.
 *
 * **`NumericTickStrategy` is the default selection for all Axes**.
 *
 * Axis interval ranges supported by `NumericTickStrategy`:
 * - Minimum: `10e-9`
 * - Maximum: Unlimited.
 *
 * **Note, that available axis interval ranges can be also limited by the type of Axis**, refer to [[Axis]] documentation for more information.
 *
 * Axis tick strategy is selected with [[Axis.setTickStrategy]] method:
 *
 * ```js
 *  Axis.setTickStrategy(AxisTickStrategies.Numeric, (numericTicks) => numericTicks)
 * ```
 *
 * All configuration of automatically created ticks is done using the callback from `setTickStrategy`,
 * see example below for the idea:
 *
 * ```js
 *  // Specify TickStrategy and use callback to style automatic ticks.
 *  Axis.setTickStrategy(AxisTickStrategies.Numeric, (numericTicks) => numericTicks
 *      // All methods of `NumericTickStrategy` can be used here for styling ticks.
 *      .setMajorTickStyle((majorTicks) => majorTicks
 *          .setLabelFont((font) => font
 *              .setWeight('bold')
 *          )
 *      )
 *  )
 * ```
 *
 * All available strategies for automatic Axis ticks creation can be referenced via [[AxisTickStrategies]].
 */
export declare class NumericTickStrategy implements MutableAxisTickStrategy {
    /**
     * Set cursor formatter for this `TickStrategy` object.
     *
     * This will override the date time formatting used by:
     * - Default cursor result table formatters.
     * - Default cursor tick formatters along Axis which uses this `TickStrategy`.
     * - `Axis.formatValue` method of the Axis which uses this `TickStrategy`.
     *
     * ```ts
     *  // Example syntax, custom cursor formatting.
     *  Axis.setTickStrategy(AxisTickStrategies.Numeric, (ticks) => ticks
     *      .setCursorFormatter((value, range, locale) =>
     *          value.toFixed(3)
     *      )
     *  )
     * ```
     * @param   formatter   `FormattingFunction` or `undefined` to use default numeric cursor formatting.
     * @return              New *NumericTickStrategy* object.
     */
    setCursorFormatter(formatter: FormattingFunction | undefined): any;
    /**
     * Get cursor formatter of this `NumericTickStrategy` object.
     *
     * @return              `FormattingFunction` as set by user, or `undefined` to indicate that the default numeric cursor formatting is configured.
     */
    getCursorFormatter(): FormattingFunction | undefined;
    /**
     * Construct a new *NumericTickStrategy* object based on this one, but with modified extreme tick style.
     *
     * Example usage:
     *
     * **Disable extreme ticks**:
     *  ```javascript
     *  Axis.setTickStrategy(
     *      AxisTickStrategies.Numeric,
     *      ( tickStrategy: NumericTickStrategy ) => tickStrategy
     *          .setExtremeTickStyle( emptyTick )
     *  )
     * ```
     *
     * **Set font of extreme ticks**:
     *  ```javascript
     *  Axis.setTickStrategy(
     *      AxisTickStrategies.Numeric,
     *      ( tickStrategy: NumericTickStrategy ) => tickStrategy
     *          .setExtremeTickStyle(( tickStyle: VisibleTicks ) => tickStyle
     *              .setLabelFont(( font ) => font
     *                  .setWeight( 'bold' )
     *              )
     *          )
     *  )
     *  ```
     * @param   value               Either a *TickStyle* object or a function, which creates a new one based on the existing style.
     *                              Passing a function only works if the existing style is **not** *emptyTick*.
     * @return                      New *NumericTickStrategy* object.
     */
    setExtremeTickStyle(value: TickStyle | ImmutableMutator<VisibleTicks>): this;
    /**
     * Get extreme tick style of this *NumericTickStrategy* object.
     * @return                      Extreme tick style.
     */
    getExtremeTickStyle(): TickStyle;
    /**
     * Construct a new *NumericTickStrategy* object based on this one, but with modified formatting offset.
     *
     * `formattingOffset` is an optional coordinate to offset from tick coordinates when formatting tick labels and default cursor labels.
     *
     * If supplied, the value of `formattingOffset` will be added to every coordinate before formatting.
     * This can be useful for offsetting displayed data ranges in cases where actual data can't be practically rendered due to extremely large numbers for example.
     *
     * ```
     *  // Example, specify formatting offset.
     *  Axis.setTickStrategy(AxisTickStrategies.Numeric, (ticks) => ticks
     *      // Will result in `0` being formatted as `1000000`
     *      .setFormattingOffset(1000000)
     *  )
     * ```
     *
     * @param
     */
    setFormattingOffset(formattingOffset: number | undefined): this;
    /**
     * Get `formattingOffset` of Tick strategy.
     *
     * `formattingOffset` is an optional coordinate to offset from tick coordinates when formatting tick labels and default cursor labels.
     *
     * If supplied, the value of `formattingOffset` will be added to every coordinate before formatting.
     * This can be useful for offsetting displayed data ranges in cases where actual data can't be practically rendered due to extremely large numbers for example.
     *
     * ```
     *  // Example, specify formatting offset.
     *  Axis.setTickStrategy(AxisTickStrategies.Numeric, (ticks) => ticks
     *      // Will result in `0` being formatted as `1000000`
     *      .setFormattingOffset(1000000)
     *  )
     * ```
     */
    getFormattingOffset(): number | undefined;
    /**
     * Construct a new *NumericTickStrategy* object based on this one, but with modified major tick style.
     *
     * Example usage:
     *
     * **Set font of major ticks**:
     *  ```javascript
     *  Axis.setTickStrategy(
     *      AxisTickStrategies.Numeric,
     *      ( tickStrategy: NumericTickStrategy ) => tickStrategy
     *          .setMajorTickStyle(( tickStyle ) => tickStyle
     *              .setLabelFont(( font ) => font
     *                  .setWeight( 'bold' )
     *              )
     *          )
     *  )
     *  ```
     * @param   value               Either a *VisibleTicks* object or a function, which creates a new one based on the existing style.
     * @return                      New *NumericTickStrategy* object.
     */
    setMajorTickStyle(value: VisibleTicks | ImmutableMutator<VisibleTicks>): this;
    /**
     * Get major tick style of this *NumericTickStrategy* object.
     * @return                      Major tick style.
     */
    getMajorTickStyle(): VisibleTicks;
    /**
     * Construct a new *NumericTickStrategy* object based on this one, but with modified minor tick style.
     *
     * Example usage:
     *
     * **Disable minor ticks**:
     *  ```javascript
     *  Axis.setTickStrategy(
     *      AxisTickStrategies.Numeric,
     *      ( tickStrategy: NumericTickStrategy ) => tickStrategy
     *          .setMinorTickStyle( emptyTick )
     *  )
     * ```
     *
     * **Set font of minor ticks**:
     *  ```javascript
     *  Axis.setTickStrategy(
     *      AxisTickStrategies.Numeric,
     *      ( tickStrategy: NumericTickStrategy ) => tickStrategy
     *          .setMinorTickStyle(( tickStyle: VisibleTicks ) => tickStyle
     *              .setLabelFont(( font ) => font
     *                  .setWeight( 'bold' )
     *              )
     *          )
     *  )
     *  ```
     * @param   value               Either a *TickStyle* object or a function, which creates a new one based on the existing style.
     *                              Passing a function only works if the existing style is **not** *emptyTick*.
     * @return                      New *NumericTickStrategy* object.
     */
    setMinorTickStyle(value: TickStyle | ImmutableMutator<TickStyle>): this;
    /**
     * Get minor tick style of this *NumericTickStrategy* object.
     * @return                      Minor tick style.
     */
    getMinorTickStyle(): TickStyle;
    /**
     * Utility method for setting *formatting function* of all numeric tick levels (extreme, major, minor) as well as cursor.
     *
     * Each formatting target can be individually overridden with following methods:
     * - [[setExtremeFormattingFunction]] | extreme ticks
     * - [[setMajorFormattingFunction]] | major ticks
     * - [[setMinorFormattingFunction]] | minor ticks
     * - [[setCursorFormatter]] | cursor result table and ticks
     * @param   formattingFunction  Function that formats a tick value to text.
     * @return                      New *NumericTickStrategy* object.
     */
    setFormattingFunction(formattingFunction: FormattingFunction): this;
    /**
     * Get extreme ticks formatting function of this *NumericTickStrategy* object.
     * @return          Formatting Function.
     */
    getExtremeFormattingFunction(): FormattingFunction | undefined;
    /**
     * Set extreme ticks formatting function of this *NumericTickStrategy* object.
     * @param formattingFunction    Formatting function to use with this *NumericTickStrategy* object.
     * @return                      New *NumericTickStrategy* object.
     */
    setExtremeFormattingFunction(formattingFunction: FormattingFunction): this;
    /**
     * Get major ticks formatting function of this *NumericTickStrategy* object.
     * @return          Formatting Function.
     */
    getMajorFormattingFunction(): FormattingFunction | undefined;
    /**
     * Set major ticks formatting function of this *NumericTickStrategy* object.
     * @param formattingFunction    Formatting function to use with this *NumericTickStrategy* object.
     * @return                      New *NumericTickStrategy* object.
     */
    setMajorFormattingFunction(formattingFunction: FormattingFunction): this;
    /**
     * Get minor ticks formatting function of this *NumericTickStrategy* object.
     * @return          Formatting Function.
     */
    getMinorFormattingFunction(): FormattingFunction | undefined;
    /**
     * Set minor ticks formatting function of this *NumericTickStrategy* object.
     * @param formattingFunction    Formatting function to use with this *NumericTickStrategy* object.
     * @return                      New *NumericTickStrategy* object.
     */
    setMinorFormattingFunction(formattingFunction: FormattingFunction): this;
}
/**
 * Type map of valid parameter combinations for Axis.setTickStrategy().
 * @hidden
 */
export declare type TickStrategyParameters = {
    type: 'Empty';
} | {
    type: 'Numeric';
    styler: ImmutableMutator<NumericTickStrategy>;
} | {
    type: 'DateTime';
    styler: ImmutableMutator<DateTimeTickStrategy>;
} | {
    type: 'Time';
    styler: ImmutableMutator<TimeTickStrategy>;
};
/**
 * @hidden
 */
export declare type TickStrategyType = TickStrategyParameters['type'];
/**
 * @hidden
 */
export declare type TickStrategyStyler<A, T> = A extends {
    type: T;
    styler: any;
} ? A['styler'] : never;
/**
 * Collection of available *AxisTickStrategies*.
 *
 * *AxisTickStrategies* modify logic of drawing *Axis Ticks* and formatting to better suit different user applications.
 * For example, a *DateTime Axis* is created by selecting *AxisTickStrategies.DateTime*.
 */
export declare const AxisTickStrategies: {
    /**
     * Disables all automatic creation of Axis ticks.
     *
     * *CustomTicks* can still be created manually.
     *
     * Example usage:
     *
     *  ```typescript
     *  Axis.setTickStrategy( AxisTickStrategies.Empty )
     *  ```
     */
    Empty: "Empty";
    /**
     * *Axis Tick Strategy* that is designed for depicting numeric values of all magnitudes.
     *
     * **`NumericTickStrategy` is the default selection for all Axes**.
     *
     * Axis interval ranges supported by `NumericTickStrategy`:
     * - Minimum: `10e-9`
     * - Maximum: Unlimited.
     *
     * **Note, that available axis interval ranges can be also limited by the type of Axis**, refer to [[Axis]] documentation for more information.
     *
     * Axis tick strategy is selected with [[Axis.setTickStrategy]] method:
     *
     * ```js
     *  Axis.setTickStrategy(AxisTickStrategies.Numeric, (numericTicks) => numericTicks)
     * ```
     *
     * All configuration of automatically created ticks is done using the callback from `setTickStrategy`,
     * see example below for the idea:
     *
     * ```js
     *  // Specify TickStrategy and use callback to style automatic ticks.
     *  Axis.setTickStrategy(AxisTickStrategies.Numeric, (numericTicks) => numericTicks
     *      // All methods of `NumericTickStrategy` can be used here for styling ticks.
     *      .setMajorTickStyle((majorTicks) => majorTicks
     *          .setLabelFont((font) => font
     *              .setWeight('bold')
     *          )
     *      )
     *  )
     * ```
     *
     * All available strategies for automatic Axis ticks creation can be referenced via [[AxisTickStrategies]].
     */
    Numeric: "Numeric";
    /**
     * *Axis Tick Strategy* that is designed for depicting date and time.
     *
     * Axis values are interpreted as UNIX timestamps similarly as with JavaScript Date API.
     *
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date
     *
     * Axis interval ranges supported by `DateTImeTickStrategy`:
     * - Minimum: 1 second (`1000`).
     * - Maximum: 1000 years (*really big number*).
     *
     * **Note, that available axis interval ranges can be also limited by the type of Axis**, refer to [[Axis]] documentation for more information.
     *
     * Axis tick strategy is selected with [[Axis.setTickStrategy]] method:
     *
     * ```js
     *  Axis.setTickStrategy(AxisTickStrategies.DateTime, (dateTimeTicks) => dateTimeTicks)
     * ```
     *
     * All configuration of automatically created ticks is done using the callback from `setTickStrategy`,
     * see example below for the idea:
     *
     * ```js
     *  // Specify TickStrategy and use callback to style automatic ticks.
     *  Axis.setTickStrategy(AxisTickStrategies.DateTime, (dateTimeTicks) => dateTimeTicks
     *      // All methods of `DateTimeTickStrategy` can be used here for styling ticks.
     *      .setMajorTickStyle((majorTicks) => majorTicks
     *          .setLabelFont((font) => font
     *              .setWeight('bold')
     *          )
     *      )
     *  )
     * ```
     *
     * All available strategies for automatic Axis ticks creation can be referenced via [[AxisTickStrategies]].
     */
    DateTime: "DateTime";
    /**
     * *Axis Tick Strategy* that is designed for depicting time ranges between hundreds of hours to individual nanoseconds.
     *
     * Axis values are interpreted as milliseconds, for example:
     * - `0` -> `00:00:00`
     * - `1 000` -> `00:00:01`
     * - `3 600 000` -> `01:00:00`
     * - `1` -> `00:00:00.001`
     * - `0.001` -> `00:00:00.000001`
     *
     * **When `TimeTickStrategy` is active, Axis interval will be always restricted to max. 100 hours interval and min. 100 nanoseconds interval.**
     *
     * Axis tick strategy is selected with [[Axis.setTickStrategy]] method:
     *
     * ```js
     *  Axis.setTickStrategy(AxisTickStrategies.Time, (timeTicks) => timeTicks)
     * ```
     *
     * All configuration of automatically created ticks is done using the callback from `setTickStrategy`,
     * see example below for the idea:
     *
     * ```js
     *  // Specify TickStrategy and use callback to style automatic ticks.
     *  Axis.setTickStrategy(AxisTickStrategies.Time, (timeTicks) => timeTicks
     *      // All methods of `TimeTickStrategy` can be used here for styling ticks.
     *      .setMajorTickStyle((majorTicks) => majorTicks
     *          .setLabelFont((font) => font
     *              .setWeight('bold')
     *          )
     *      )
     *  )
     * ```
     *
     * All available strategies for automatic Axis ticks creation can be referenced via [[AxisTickStrategies]].
     */
    Time: "Time";
};
/**
 * Interface for *AxisTickStrategy*.
 *
 * Defines the positioning and formatting logic of *Axis* ticks.
 *
 * TODO: This is intended to be published to users, but not quite yet.
 * @hidden
 */
export interface AxisTickStrategy {
}
/**
 * @hidden
 */
export declare type IndependentTickLevels = IndependentAxisTickLevel[];
/**
 * @hidden
 */
export declare type LayeredTickLevels = (PhysicalLayeredAxisTickLevel | DirectiveLayeredAxisTickLevel)[];
/**
 * Shared interface all *TickLevels*.
 * @hidden
 */
interface AxisTickLevel {
}
/**
 * Shared interface for *TickLevels* that can be styled.
 * @hidden
 */
interface StylableAxisTickLevel {
}
/**
 * Type of *AxisTickLevel* that is not related to any other *AxisTickLevel*.
 *
 * Has priority over any layered ticks, if collides, layered tick will always be hidden.
 *
 * If independent tick collides with another, the first key value has priority and will be shown.
 * @hidden
 */
export interface IndependentAxisTickLevel extends AxisTickLevel, StylableAxisTickLevel {
}
/**
 * Type of *AxisTickLevel* that works inside a layered hierarchy of multiple *LayeredAxisTickLevels*.
 *
 * Each consequent *LayeredAxisTickLevel* is positioned using the key values of the upper *LayeredAxisTickLevel*.
 * @hidden
 */
export interface LayeredAxisTickLevel extends AxisTickLevel {
}
/**
 * Type of *LayeredAxisTickLevel* that has physical ticks.
 *
 * Can be configured with *automatic fitting* functionalities.
 * @hidden
 */
export interface PhysicalLayeredAxisTickLevel extends LayeredAxisTickLevel, StylableAxisTickLevel {
}
/**
 * Type of *LayeredAxisTickLevel* that doesn't have any physical ticks.
 *
 * This is only used for positioning ticks in *PhysicalLayeredAxisTickLevels* below itself.
 * @hidden
 */
export interface DirectiveLayeredAxisTickLevel extends LayeredAxisTickLevel {
}
/**
 * Function that finds tick positions.
 * @param   axisMin     Min coordinate of whole Axis.
 * @param   axisMax     Max coordinate of whole Axis.
 * @param   axisStart   Start coordinate of whole Axis (either min or max, depending if Axis is inverted or not).
 * @param   axisEnd     End coordinate of whole Axis (either min or max, depending if Axis is inverted or not).
 * @return              List of axis key values.
 *                      Ticks will be positioned on these positions.
 * @hidden
 */
export declare type IndependentKeyValuesGenerator = (axisMin: number, axisMax: number, axisStart: number, axisEnd: number) => number[];
/**
 * Function that finds tick positions for an interval of layered ticks.
 * @param   min         Min location for tick creation.
 * @param   max         Max location for tick creation.
 * @param   axisMin     Min coordinate of whole Axis.
 * @param   axisMax     Max coordinate of whole Axis.
 * @return              List of axis key values.
 *                      Ticks will be positioned on these positions (minus ticks that are removed because of collisions).
 * @hidden
 */
export declare type LayeredKeyValuesGenerator = (min: number, max: number, axisMin: number, axisMax: number) => number[];
/**
 * Type of AxisTick fitting function.
 *
 * @param   nonFittingKeyValues Key values (from _getKeyValues) that resulted in collisions.
 * @param   attempt             The amount of attempts that fitting has been attempted, starting with 0.
 * @param   min                 Min location for tick creation.
 * @param   max                 Max location for tick creation.
 * @param   axisMin             Min coordinate of whole Axis.
 * @param   axisMax             Max coordinate of whole Axis.
 * @return                      New key values that will be attempted again and checked for collisions.
 *                              If these also don't fit, _fitKeyValues will be called again.
 *                              Returning *undefined* will stop the process, resulting in no displayed ticks.
 * @hidden
 */
export declare type KeyValuesFittingFunction = (nonFittingKeyValues: number[], attempt: number, min: number, max: number, axisMin: number, axisMax: number) => number[] | undefined;
/**
 * Singleton object which indicates that Axis ticks shouldn't be created.
 *
 * The type information is not necessary for users, so it is hidden. Users refer to it with string constants ('Empty').
 * @hidden
 */
export declare const EmptyAxisTickStrategy: AxisTickStrategy;
/**
 * Internal interface for default implementations of Axis TickStrategies.
 *
 * Default implementations are immutable settings objects that users can modify with convenient setters.
 * This interface defines a method that is internally used to convert the settings object into an actual TickStrategy.
 * @hidden
 */
export interface MutableAxisTickStrategy {
}
export {};
/**
 * TODO
 * @hidden
 */
export interface TimeTickStrategyProperties {
    /**
     * Style of Major ticks.
     *
     * Major ticks can't be disabled (via emptyTicks), because TickLevel style doesn't support emptyTicks,
     * and Major tick level must exist for minor tick positioning.
     */
    readonly majorTickStyle: VisibleTicks;
    /**
     * Style of Minor ticks.
     *
     * To disable minor ticks, set to **emptyTick**.
     */
    readonly minorTickStyle: TickStyle;
    /**
     * Formatting function used for major ticks.
     *
     * Use FormattingFunctions to select available ones or define custom function.
     *
     * **undefined** will result in default selection.
     */
    readonly majorFormattingFunction?: FormattingFunction;
    /**
     * Formatting function used for minor ticks.
     *
     * Use FormattingFunctions to select available ones or define custom function.
     *
     * **undefined** will result in default selection.
     */
    readonly minorFormattingFunction?: FormattingFunction;
    /**
     * Cursor formatter.
     *
     * This controls the formatting used by:
     * - Default cursor result table formatters.
     * - Default cursor tick formatters along Axis which uses this `TickStrategy`.
     * - `Axis.formatValue` method of the Axis which uses this `TickStrategy`.
     *
     * `undefined` means to use default Time cursor formatting.
     *
     * ```ts
     *  // Example value, custom cursor formatter
     *  cursorFormatter: (value, range, locale) => value.toFixed(3)
     * ```
     */
    readonly cursorFormatter: FormattingFunction | undefined;
    /**
     * optional "Time origin"  value.
     * If a **timeOrigin** is defined, data-points will instead be interpreted as milliseconds since **timeOrigin**.
     */
    readonly timeOrigin: number | undefined;
}
/**
 * Collection of formatting functions used with [[TimeTickStrategy]].
 *
 * Can be referenced in user applications for convenience.
 */
export declare const TimeFormattingFunctions: {
    /**
     * Display hours, minutes and seconds.
     *
     * `'00:00:00'`
     */
    hhmmss: (value: number) => string;
    /**
     * Display hours, minutes, seconds and milliseconds.
     *
     * `'00:00:00.000'`
     */
    hhmmssmmm: (value: number) => string;
    /**
     * Display hours, minutes, seconds, milliseconds and microseconds.
     *
     * `'00:00:00.000000'`
     */
    hhmmssmmmuuu: (value: number) => string;
    /**
     * Display hours, minutes, seconds, milliseconds, microseconds and nanoseconds.
     *
     * `'00:00:00.000000000'`
     */
    hhmmssmmmuuunnn: (value: number) => string;
};
/**
 * *Axis Tick Strategy* that is designed for depicting time ranges between hundreds of hours to individual nanoseconds.
 *
 * Axis values are interpreted as milliseconds, for example:
 * - `0` -> `00:00:00`
 * - `1 000` -> `00:00:01`
 * - `3 600 000` -> `01:00:00`
 * - `1` -> `00:00:00.001`
 * - `0.001` -> `00:00:00.000001`
 *
 * Axis interval ranges supported by `TimeTickStrategy`:
 * - Minimum: 100 nanoseconds (`0.0001`).
 * - Maximum: 100 hours (`8 640 000 000`)
 *
 * **Note, that available axis interval ranges can be also limited by the type of Axis**, refer to [[Axis]] documentation for more information.
 *
 * Axis tick strategy is selected with [[Axis.setTickStrategy]] method:
 *
 * ```js
 *  Axis.setTickStrategy(AxisTickStrategies.Time, (timeTicks) => timeTicks)
 * ```
 *
 * All configuration of automatically created ticks is done using the callback from `setTickStrategy`,
 * see example below for the idea:
 *
 * ```js
 *  // Specify TickStrategy and use callback to style automatic ticks.
 *  Axis.setTickStrategy(AxisTickStrategies.Time, (timeTicks) => timeTicks
 *      // All methods of `TimeTickStrategy` can be used here for styling ticks.
 *      .setMajorTickStyle((majorTicks) => majorTicks
 *          .setLabelFont((font) => font
 *              .setWeight('bold')
 *          )
 *      )
 *  )
 * ```
 *
 * All available strategies for automatic Axis ticks creation can be referenced via [[AxisTickStrategies]].
 */
export declare class TimeTickStrategy implements MutableAxisTickStrategy {
    /**
     * Construct a new *TimeTickStrategy* object based on this one, but with modified major tick style.
     *
     * Example usage:
     *
     * **Set font of major ticks**:
     *  ```javascript
     *  Axis.setTickStrategy(
     *      AxisTickStrategies.Time,
     *      ( tickStrategy: TimeTickStrategy ) => tickStrategy
     *          .setMajorTickStyle(( tickStyle ) => tickStyle
     *              .setLabelFont(( font ) => font
     *                  .setWeight( 'bold' )
     *              )
     *          )
     *  )
     *  ```
     * @param   value               Either a *VisibleTicks* object or a function, which creates a new one based on the existing style.
     * @return                      New *TimeTickStrategy* object.
     */
    setMajorTickStyle(value: VisibleTicks | ImmutableMutator<VisibleTicks>): this;
    /**
     * Get major tick style of this *TimeTickStrategy* object.
     * @return                      Major tick style.
     */
    getMajorTickStyle(): VisibleTicks;
    /**
     * Construct a new *TimeTickStrategy* object based on this one, but with modified minor tick style.
     *
     * Example usage:
     *
     * **Disable minor ticks**:
     *  ```javascript
     *  Axis.setTickStrategy(
     *      AxisTickStrategies.Time,
     *      ( tickStrategy: TimeTickStrategy ) => tickStrategy
     *          .setMinorTickStyle( emptyTick )
     *  )
     * ```
     *
     * **Set font of minor ticks**:
     *  ```javascript
     *  Axis.setTickStrategy(
     *      AxisTickStrategies.Time,
     *      ( tickStrategy: TimeTickStrategy ) => tickStrategy
     *          .setMinorTickStyle(( tickStyle: VisibleTicks ) => tickStyle
     *              .setLabelFont(( font ) => font
     *                  .setWeight( 'bold' )
     *              )
     *          )
     *  )
     *  ```
     * @param   value               Either a *TickStyle* object or a function, which creates a new one based on the existing style.
     *                              Passing a function only works if the existing style is **not** *emptyTick*.
     * @return                      New *TimeTickStrategy* object.
     */
    setMinorTickStyle(value: TickStyle | ImmutableMutator<TickStyle>): this;
    /**
     * Get minor tick style of this *TimeTickStrategy* object.
     * @return                      Minor tick style.
     */
    getMinorTickStyle(): TickStyle;
    /**
     * Set cursor formatter for this `TimeTickStrategy` object.
     *
     * This will override the date time formatting used by:
     * - Default cursor result table formatters.
     * - Default cursor tick formatters along Axis which uses this `TickStrategy`.
     * - `Axis.formatValue` method of the Axis which uses this `TickStrategy`.
     *
     * ```ts
     *  // Example syntax, custom cursor formatting.
     *  Axis.setTickStrategy(AxisTickStrategies.Time, (ticks) => ticks
     *      .setCursorFormatter((value, range, locale) =>
     *          value.toFixed(3)
     *      )
     *  )
     * ```
     * @param   formatter   `FormattingFunction` or `undefined` to use default time cursor formatting.
     * @return              New *TimeTickStrategy* object.
     */
    setCursorFormatter(formatter: FormattingFunction | undefined): any;
    /**
     * Get cursor formatter of this `TimeTickStrategy` object.
     *
     * @return              `FormattingFunction` as set by user, or `undefined` to indicate that the default time cursor formatting is configured.
     */
    getCursorFormatter(): FormattingFunction | undefined;
    /**
     * Construct a new *TimeTickStrategy* object based on this one, but with modified timeOrigin.
     *
     * If a **timeOrigin** is defined, data-points will instead be interpreted as **milliseconds** since **timeOrigin**.
     *
     * Example usage:
     *
     * **Application with 24 hour time origin offset**:
     * ```javascript
     * Axis.setTickStrategy(AxisTickStrategies.Time,
     *     (tickStrategy) => tickStrategy.setTimeOrigin(24 * 60 * 60 * 1000)
     * )
     * ```
     *
     * @param   timeOrigin   Millisecond offset or `undefined` to disable time origin offsetting.
     * @return               New *TimeTickStrategy* object.
     */
    setTimeOrigin(timeOrigin: number | undefined): this;
    /**
     *  Get the *timeOrigin* of this *TimeTickStrategy* object.
     * @return          Current time origin milliseconds or *undefined*.
     */
    getTimeOrigin(): number | undefined;
}
/**
 * List of MapRegions included in [[MapTypes.Africa]].
 *
 * Can be referenced like so:
 *
 * ```ts
 * const countries = MapRegions[ MapTypes.Africa ]
 * ```
 *
 * Each item is an enum-like object, that can be used with [[MapChart]] API to specify any region.
 *
 * **Example usage**:
 *
 * - Invalidate selected region value.
 *
 * ``` ts
 *  MapChart.invalidateRegionValues([
 *      { ...MapRegions[ MapTypes.Africa ].Egypt, value: 0 }
 *  ])
 * ```
 *
 * - List all region names (can be useful when developing a js application without intellisense).
 *
 * ``` ts
 *  Object.keys( MapRegions[ MapTypes.Africa ] ).forEach( key => console.log( key ) )
 * ```
 *
 * Note, that the list includes all countries that are visible on the MapChart, some of which are outside the continent of Africa.
 */
export declare const MapRegionsAfrica: {
    Angola: Country;
    Burundi: Country;
    Benin: Country;
    'Burkina Faso': Country;
    Botswana: Country;
    'Central African Republic': Country;
    'Ivory Coast': Country;
    Cameroon: Country;
    'Democratic Republic of the Congo': Country;
    'Republic of Congo': Country;
    Comoros: Country;
    'Cape Verde': Country;
    Djibouti: Country;
    Algeria: Country;
    Egypt: Country;
    Eritrea: Country;
    Ethiopia: Country;
    Gabon: Country;
    Ghana: Country;
    Guinea: Country;
    Gambia: Country;
    'Guinea Bissau': Country;
    'Equatorial Guinea': Country;
    Israel: Country;
    Jordan: Country;
    Kenya: Country;
    Lebanon: Country;
    Liberia: Country;
    Libya: Country;
    Lesotho: Country;
    Morocco: Country;
    Madagascar: Country;
    Mali: Country;
    Malta: Country;
    Mozambique: Country;
    Mauritania: Country;
    Mauritius: Country;
    Malawi: Country;
    Namibia: Country;
    Niger: Country;
    Nigeria: Country;
    Oman: Country;
    Rwanda: Country;
    'Western Sahara': Country;
    'Saudi Arabia': Country;
    Sudan: Country;
    'South Sudan': Country;
    Senegal: Country;
    'Saint Helena': Country;
    'Sierra Leone': Country;
    Somalia: Country;
    Swaziland: Country;
    Seychelles: Country;
    Syria: Country;
    Chad: Country;
    Togo: Country;
    Tunisia: Country;
    'United Republic of Tanzania': Country;
    Uganda: Country;
    Yemen: Country;
    'South Africa': Country;
    Zambia: Country;
    Zimbabwe: Country;
};
/**
 * List of MapRegions included in [[MapTypes.Asia]].
 *
 * Can be referenced like so:
 *
 * ```ts
 * const countries = MapRegions[ MapTypes.Asia ]
 * ```
 *
 * Each item is an enum-like object, that can be used with [[MapChart]] API to specify any region.
 *
 * **Example usage**:
 *
 * - Invalidate selected region value.
 *
 * ``` ts
 *  MapChart.invalidateRegionValues([
 *      { ...MapRegions[ MapTypes.Asia ].China, value: 0 }
 *  ])
 * ```
 *
 * - List all region names (can be useful when developing a js application without intellisense).
 *
 * ``` ts
 *  Object.keys( MapRegions[ MapTypes.Asia ] ).forEach( key => console.log( key ) )
 * ```
 *
 * Note, that the list includes all countries that are visible on the MapChart, some of which are outside the continent of Asia.
 */
export declare const MapRegionsAsia: {
    Afghanistan: Country;
    'United Arab Emirates': Country;
    Armenia: Country;
    Australia: Country;
    Azerbaijan: Country;
    Bangladesh: Country;
    Bahrain: Country;
    Brunei: Country;
    Bhutan: Country;
    China: Country;
    Georgia: Country;
    Indonesia: Country;
    India: Country;
    Iran: Country;
    Iraq: Country;
    Israel: Country;
    Jordan: Country;
    Japan: Country;
    Kazakhstan: Country;
    Kyrgyzstan: Country;
    Cambodia: Country;
    'South Korea': Country;
    Kuwait: Country;
    Laos: Country;
    Lebanon: Country;
    'Sri Lanka': Country;
    Maldives: Country;
    Myanmar: Country;
    Mongolia: Country;
    Malaysia: Country;
    Nepal: Country;
    Oman: Country;
    Pakistan: Country;
    Philippines: Country;
    'Papua New Guinea': Country;
    'North Korea': Country;
    Palestine: Country;
    Qatar: Country;
    Russia: Country;
    'Saudi Arabia': Country;
    Singapore: Country;
    Syria: Country;
    Thailand: Country;
    Tajikistan: Country;
    Turkmenistan: Country;
    Turkey: Country;
    Taiwan: Country;
    Uzbekistan: Country;
    Vietnam: Country;
    Yemen: Country;
};
/**
 * List of MapRegions included in [[MapTypes.Australia]].
 *
 * Can be referenced like so:
 *
 * ```ts
 * const territories = MapRegions[ MapTypes.Australia ]
 * ```
 *
 * Each item is an enum-like object, that can be used with [[MapChart]] API to specify any region.
 *
 * **Example usage**:
 *
 * - Invalidate selected region value.
 *
 * ``` ts
 *  MapChart.invalidateRegionValues([
 *      { ...MapRegions[ MapTypes.Australia ].Queensland, value: 0 }
 *  ])
 * ```
 *
 * - List all region names (can be useful when developing a js application without intellisense).
 *
 * ``` ts
 *  Object.keys( MapRegions[ MapTypes.Australia ] ).forEach( key => console.log( key ) )
 * ```
 */
export declare const MapRegionsAustralia: {
    'New South Wales': AustraliaTerritory;
    Victoria: AustraliaTerritory;
    Queensland: AustraliaTerritory;
    'South Australia': AustraliaTerritory;
    'Western Australia': AustraliaTerritory;
    Tasmania: AustraliaTerritory;
    'Northern Territory': AustraliaTerritory;
    'Australian Capital Territory': AustraliaTerritory;
    'Other Territories': AustraliaTerritory;
};
/**
 * List of MapRegions included in [[MapTypes.Canada]].
 *
 * Can be referenced like so:
 *
 * ```ts
 * const territories = MapRegions[ MapTypes.Canada ]
 * ```
 *
 * Each item is an enum-like object, that can be used with [[MapChart]] API to specify any region.
 *
 * **Example usage**:
 *
 * - Invalidate selected region value.
 *
 * ``` ts
 *  MapChart.invalidateRegionValues([
 *      { ...MapRegions[ MapTypes.Canada ].Ontario, value: 0 }
 *  ])
 * ```
 *
 * - List all region names (can be useful when developing a js application without intellisense).
 *
 * ``` ts
 *  Object.keys( MapRegions[ MapTypes.Canada ] ).forEach( key => console.log( key ) )
 * ```
 */
export declare const MapRegionsCanada: {
    'British Columbia': CanadaProvinceOrTerritory;
    Quebec: CanadaProvinceOrTerritory;
    Nunavut: CanadaProvinceOrTerritory;
    'Prince Edward Island': CanadaProvinceOrTerritory;
    Saskatchewan: CanadaProvinceOrTerritory;
    Yukon: CanadaProvinceOrTerritory;
    Manitoba: CanadaProvinceOrTerritory;
    Ontario: CanadaProvinceOrTerritory;
    'New Brunswick': CanadaProvinceOrTerritory;
    'Northwest Territories': CanadaProvinceOrTerritory;
    Alberta: CanadaProvinceOrTerritory;
    'Newfoundland and Labrador': CanadaProvinceOrTerritory;
    'Nova Scotia': CanadaProvinceOrTerritory;
};
/**
 * List of MapRegions included in [[MapTypes.Europe]].
 *
 * Can be referenced like so:
 *
 * ```ts
 * const countries = MapRegions[ MapTypes.Europe ]
 * ```
 *
 * Each item is an enum-like object, that can be used with [[MapChart]] API to specify any region.
 *
 * **Example usage**:
 *
 * - Invalidate selected region value.
 *
 * ``` ts
 *  MapChart.invalidateRegionValues([
 *      { ...MapRegions[ MapTypes.Europe ].Finland, value: 0 }
 *  ])
 * ```
 *
 * - List all region names (can be useful when developing a js application without intellisense).
 *
 * ``` ts
 *  Object.keys( MapRegions[ MapTypes.Europe ] ).forEach( key => console.log( key ) )
 * ```
 *
 * Note, that the list includes all countries that are visible on the MapChart, some of which are outside the continent of Europe.
 */
export declare const MapRegionsEurope: {
    Albania: Country;
    Austria: Country;
    Belarus: Country;
    Belgium: Country;
    Bulgaria: Country;
    'Bosnia and Herzegovina': Country;
    Switzerland: Country;
    Cyprus: Country;
    'Czech Republic': Country;
    Germany: Country;
    Denmark: Country;
    Spain: Country;
    Estonia: Country;
    Finland: Country;
    France: Country;
    'United Kingdom': Country;
    Greece: Country;
    Croatia: Country;
    Hungary: Country;
    Ireland: Country;
    Iceland: Country;
    Italy: Country;
    Kosovo: Country;
    Lithuania: Country;
    Luxembourg: Country;
    Latvia: Country;
    Macedonia: Country;
    Malta: Country;
    Montenegro: Country;
    Netherlands: Country;
    Norway: Country;
    Poland: Country;
    Portugal: Country;
    Romania: Country;
    'Republic of Serbia': Country;
    Slovakia: Country;
    Slovenia: Country;
    Sweden: Country;
    Ukraine: Country;
    Moldova: Country;
    Russia: Country;
    Turkey: Country;
};
/**
 * [[MapTypes]] pairing with a list of MapRegions the MapType includes.
 *
 * For example, when using **MapType.Europe**, the list of available *countries* can be referenced with:
 *
 * ```ts
 * const countries = MapRegions[ MapTypes.Europe ]
 * ```
 *
 * Each item is an enum-like object, that can be used with [[MapChart]] API to specify any region.
 *
 * **Example usage**:
 *
 * - Invalidate selected region value.
 *
 * ``` ts
 *  MapChart.invalidateRegionValues([
 *      { ...MapRegions[ MapTypes.Europe ].Finland, value: 0 }
 *  ])
 * ```
 *
 * - List all region names (can be useful when developing a js application without intellisense).
 *
 * ``` ts
 *  Object.keys( MapRegions[ MapTypes.Europe ] ).forEach( key => console.log( key ) )
 * ```
 */
export declare const MapRegions: {
    /**
     * [[MapRegionsWorld]]
     */
    World: {
        Aruba: Country;
        Afghanistan: Country;
        Angola: Country;
        Anguilla: Country;
        Albania: Country;
        Aland: Country;
        Andorra: Country;
        'United Arab Emirates': Country;
        Argentina: Country;
        Armenia: Country;
        'American Samoa': Country;
        Antarctica: Country;
        'French Southern and Antarctic Lands': Country;
        'Antigua and Barbuda': Country;
        Australia: Country;
        Austria: Country;
        Azerbaijan: Country;
        Burundi: Country;
        Belgium: Country;
        Benin: Country;
        'Burkina Faso': Country;
        Bangladesh: Country;
        Bulgaria: Country;
        Bahrain: Country;
        'The Bahamas': Country;
        'Bosnia and Herzegovina': Country;
        Belarus: Country;
        Belize: Country;
        Bermuda: Country;
        Bolivia: Country;
        Brazil: Country;
        Barbados: Country;
        Brunei: Country;
        Bhutan: Country;
        Botswana: Country;
        'Central African Republic': Country;
        Canada: Country;
        Switzerland: Country;
        Chile: Country;
        China: Country;
        'Ivory Coast': Country;
        Cameroon: Country;
        'Cyprus No Mans Area': Country;
        'Democratic Republic of the Congo': Country;
        'Republic of Congo': Country;
        'Cook Islands': Country;
        Colombia: Country;
        Comoros: Country;
        'Cape Verde': Country;
        'Costa Rica': Country;
        Cuba: Country;
        Curaçao: Country;
        'Cayman Islands': Country;
        'Northern Cyprus': Country;
        Cyprus: Country;
        'Czech Republic': Country;
        Germany: Country;
        Djibouti: Country;
        Dominica: Country;
        Denmark: Country;
        'Dominican Republic': Country;
        Algeria: Country;
        Ecuador: Country;
        Egypt: Country;
        Eritrea: Country;
        'Dhekelia Sovereign Base Area': Country;
        Spain: Country;
        Estonia: Country;
        Ethiopia: Country;
        Finland: Country;
        Fiji: Country;
        'Falkland Islands': Country;
        France: Country;
        'Faroe Islands': Country;
        'Federated States of Micronesia': Country;
        Gabon: Country;
        'United Kingdom': Country;
        Georgia: Country;
        Guernsey: Country;
        Ghana: Country;
        Guinea: Country;
        Gambia: Country;
        'Guinea Bissau': Country;
        'Equatorial Guinea': Country;
        Greece: Country;
        Grenada: Country;
        Greenland: Country;
        Guatemala: Country;
        Guam: Country;
        Guyana: Country;
        'Hong Kong S.A.R.': Country;
        'Heard Island and McDonald Islands': Country;
        Honduras: Country;
        Croatia: Country;
        Haiti: Country;
        Hungary: Country;
        Indonesia: Country;
        'Isle of Man': Country;
        India: Country;
        'Indian Ocean Territories': Country;
        'British Indian Ocean Territory': Country;
        Ireland: Country;
        Iran: Country;
        Iraq: Country;
        Iceland: Country;
        Israel: Country;
        Italy: Country;
        Jamaica: Country;
        Jersey: Country;
        Jordan: Country;
        Japan: Country;
        'Baykonur Cosmodrome': Country;
        'Siachen Glacier': Country;
        Kazakhstan: Country;
        Kenya: Country;
        Kyrgyzstan: Country;
        Cambodia: Country;
        Kiribati: Country;
        'Saint Kitts and Nevis': Country;
        'South Korea': Country;
        Kosovo: Country;
        Kuwait: Country;
        Laos: Country;
        Lebanon: Country;
        Liberia: Country;
        Libya: Country;
        'Saint Lucia': Country;
        Liechtenstein: Country;
        'Sri Lanka': Country;
        Lesotho: Country;
        Lithuania: Country;
        Luxembourg: Country;
        Latvia: Country;
        'Macao S.A.R': Country;
        'Saint Martin': Country;
        Morocco: Country;
        Moldova: Country;
        Madagascar: Country;
        Maldives: Country;
        Mexico: Country;
        'Marshall Islands': Country;
        Macedonia: Country;
        Mali: Country;
        Malta: Country;
        Myanmar: Country;
        Montenegro: Country;
        Mongolia: Country;
        'Northern Mariana Islands': Country;
        Mozambique: Country;
        Mauritania: Country;
        Montserrat: Country;
        Mauritius: Country;
        Malawi: Country;
        Malaysia: Country;
        Namibia: Country;
        'New Caledonia': Country;
        Niger: Country;
        Nigeria: Country;
        Nicaragua: Country;
        Niue: Country;
        Netherlands: Country;
        Norway: Country;
        Nepal: Country;
        'New Zealand': Country;
        Oman: Country;
        Pakistan: Country;
        Panama: Country;
        'Pitcairn Islands': Country;
        Peru: Country;
        'Spratly Islands': Country;
        Philippines: Country;
        Palau: Country;
        'Papua New Guinea': Country;
        Poland: Country;
        'Puerto Rico': Country;
        'North Korea': Country;
        Portugal: Country;
        Paraguay: Country;
        Palestine: Country;
        'French Polynesia': Country;
        Qatar: Country;
        Romania: Country;
        Russia: Country;
        Rwanda: Country;
        'Western Sahara': Country;
        'Saudi Arabia': Country;
        Sudan: Country;
        'South Sudan': Country;
        Senegal: Country;
        Singapore: Country;
        'South Georgia and South Sandwich Islands': Country;
        'Saint Helena': Country;
        'Solomon Islands': Country;
        'Sierra Leone': Country;
        'El Salvador': Country;
        Somalia: Country;
        'Saint Pierre and Miquelon': Country;
        'Republic of Serbia': Country;
        'Sao Tome and Principe': Country;
        Suriname: Country;
        Slovakia: Country;
        Slovenia: Country;
        Sweden: Country;
        Swaziland: Country;
        Seychelles: Country;
        Syria: Country;
        'Turks and Caicos Islands': Country;
        Chad: Country;
        Togo: Country;
        Thailand: Country;
        Tajikistan: Country;
        Turkmenistan: Country;
        'East Timor': Country;
        Tonga: Country;
        'Trinidad and Tobago': Country;
        Tunisia: Country;
        Turkey: Country;
        Tuvalu: Country;
        Taiwan: Country;
        'United Republic of Tanzania': Country;
        Uganda: Country;
        Ukraine: Country;
        'United States Minor Outlying Islands': Country;
        Uruguay: Country;
        'United States of America': Country;
        'US Naval Base Guantanamo Bay': Country;
        Uzbekistan: Country;
        'Saint Vincent and the Grenadines': Country;
        Venezuela: Country;
        'British Virgin Islands': Country;
        'United States Virgin Islands': Country;
        Vietnam: Country;
        Vanuatu: Country;
        'Wallis and Futuna': Country;
        'Akrotiri Sovereign Base Area': Country;
        Samoa: Country;
        Yemen: Country;
        'South Africa': Country;
        Zambia: Country;
        Zimbabwe: Country;
        'French Guyana': Country;
    };
    /**
     * [[MapRegionsUSA]]
     */
    USA: {
        Alabama: State;
        Alaska: State;
        Arizona: State;
        Arkansas: State;
        California: State;
        Colorado: State;
        Connecticut: State;
        Delaware: State;
        'District of Columbia': State;
        Florida: State;
        Georgia: State;
        Hawaii: State;
        Idaho: State; /**
         * [[MapRegionsWorld]]
         */
        Illinois: State;
        Indiana: State;
        Iowa: State;
        Kansas: State;
        Kentucky: State;
        Louisiana: State;
        Maine: State;
        Maryland: State;
        Massachusetts: State;
        Michigan: State;
        Minnesota: State;
        Mississippi: State;
        Missouri: State;
        Montana: State; /**
         * [[MapRegionsAustralia]]
         */
        Nebraska: State;
        Nevada: State;
        'New Hampshire': State;
        'New Jersey': State;
        'New Mexico': State;
        'New York': State;
        'North Carolina': State;
        'North Dakota': State;
        Ohio: State;
        Oklahoma: State;
        Oregon: State;
        Pennsylvania: State;
        'Rhode Island': State;
        'South Carolina': State;
        'South Dakota': State;
        Tennessee: State;
        Texas: State;
        Utah: State;
        Vermont: State;
        Virginia: State;
        Washington: State;
        'West Virginia': State;
        Wisconsin: State;
        Wyoming: State;
    };
    /**
     * [[MapRegionsNorthAmerica]]
     */
    NorthAmerica: {
        Anguilla: Country;
        'Antigua and Barbuda': Country;
        'The Bahamas': Country;
        Bermuda: Country;
        Barbados: Country;
        Canada: Country;
        Cuba: Country;
        'Cayman Islands': Country;
        Dominica: Country;
        'Dominican Republic': Country;
        Grenada: Country;
        Greenland: Country;
        Haiti: Country;
        Jamaica: Country;
        'Saint Kitts and Nevis': Country;
        'Saint Lucia': Country;
        'Saint Martin': Country;
        Mexico: Country;
        Montserrat: Country;
        'Puerto Rico': Country;
        'Saint Pierre and Miquelon': Country;
        'Turks and Caicos Islands': Country;
        'Trinidad and Tobago': Country;
        'United States of America': Country;
        'Saint Vincent and the Grenadines': Country;
        'British Virgin Islands': Country;
        'United States Virgin Islands': Country;
    };
    /**
     * [[MapRegionsSouthAmerica]]
     */
    SouthAmerica: {
        Argentina: Country;
        Bolivia: Country;
        Brazil: Country;
        Chile: Country;
        Colombia: Country;
        'Costa Rica': Country;
        Ecuador: Country;
        'Falkland Islands': Country;
        Guyana: Country;
        Nicaragua: Country;
        Panama: Country;
        Peru: Country;
        Paraguay: Country;
        Suriname: Country;
        Uruguay: Country;
        Venezuela: Country;
        'French Guyana': Country;
        Guatemala: Country;
        'El Salvador': Country;
        Honduras: Country;
    };
    /**
     * [[MapRegionsCanada]]
     */
    Canada: {
        'British Columbia': CanadaProvinceOrTerritory;
        Quebec: CanadaProvinceOrTerritory;
        Nunavut: CanadaProvinceOrTerritory;
        'Prince Edward Island': CanadaProvinceOrTerritory;
        Saskatchewan: CanadaProvinceOrTerritory;
        Yukon: CanadaProvinceOrTerritory;
        Manitoba: CanadaProvinceOrTerritory;
        Ontario: CanadaProvinceOrTerritory;
        /**
         * [[MapRegionsWorld]]
         */
        'New Brunswick': CanadaProvinceOrTerritory; /**
         * [[MapRegionsUSA]]
         */
        'Northwest Territories': CanadaProvinceOrTerritory;
        Alberta: CanadaProvinceOrTerritory;
        'Newfoundland and Labrador': CanadaProvinceOrTerritory; /**
         * [[MapRegionsCanada]]
         */
        'Nova Scotia': CanadaProvinceOrTerritory;
    };
    /**
     * [[MapRegionsEurope]]
     */
    Europe: {
        Albania: Country;
        Austria: Country;
        Belarus: Country;
        Belgium: Country;
        Bulgaria: Country;
        'Bosnia and Herzegovina': Country;
        Switzerland: Country;
        Cyprus: Country; /**
         * [[MapRegionsUSA]]
         */
        'Czech Republic': Country;
        Germany: Country;
        Denmark: Country;
        Spain: Country;
        Estonia: Country;
        Finland: Country;
        France: Country;
        'United Kingdom': Country;
        Greece: Country;
        Croatia: Country;
        Hungary: Country;
        Ireland: Country;
        Iceland: Country;
        Italy: Country;
        Kosovo: Country;
        Lithuania: Country;
        Luxembourg: Country;
        Latvia: Country;
        Macedonia: Country;
        Malta: Country;
        Montenegro: Country;
        Netherlands: Country;
        Norway: Country;
        Poland: Country;
        Portugal: Country;
        Romania: Country;
        'Republic of Serbia': Country;
        Slovakia: Country;
        Slovenia: Country;
        Sweden: Country;
        Ukraine: Country;
        Moldova: Country;
        Russia: Country;
        Turkey: Country;
    };
    /**
     * [[MapRegionsAsia]]
     */
    Asia: {
        Afghanistan: Country;
        'United Arab Emirates': Country;
        Armenia: Country;
        Australia: Country;
        Azerbaijan: Country;
        Bangladesh: Country;
        Bahrain: Country;
        Brunei: Country;
        Bhutan: Country;
        China: Country;
        Georgia: Country;
        Indonesia: Country;
        India: Country;
        Iran: Country;
        Iraq: Country;
        Israel: Country;
        Jordan: Country;
        Japan: Country;
        Kazakhstan: Country;
        Kyrgyzstan: Country;
        Cambodia: Country;
        'South Korea': Country;
        Kuwait: Country;
        Laos: Country;
        Lebanon: Country;
        'Sri Lanka': Country;
        Maldives: Country;
        Myanmar: Country;
        Mongolia: Country;
        Malaysia: Country;
        Nepal: Country;
        Oman: Country;
        Pakistan: Country;
        Philippines: Country;
        'Papua New Guinea': Country;
        'North Korea': Country;
        Palestine: Country;
        Qatar: Country;
        Russia: Country;
        'Saudi Arabia': Country;
        Singapore: Country;
        Syria: Country;
        Thailand: Country;
        Tajikistan: Country;
        Turkmenistan: Country;
        Turkey: Country;
        Taiwan: Country;
        Uzbekistan: Country;
        Vietnam: Country;
        Yemen: Country;
    };
    /**
     * [[MapRegionsAfrica]]
     */
    Africa: {
        Angola: Country;
        Burundi: Country;
        Benin: Country;
        'Burkina Faso': Country;
        Botswana: Country;
        'Central African Republic': Country;
        'Ivory Coast': Country;
        Cameroon: Country;
        'Democratic Republic of the Congo': Country;
        'Republic of Congo': Country;
        Comoros: Country;
        'Cape Verde': Country; /**
         * [[MapRegionsEurope]]
         */
        Djibouti: Country;
        Algeria: Country;
        Egypt: Country;
        Eritrea: Country;
        Ethiopia: Country;
        Gabon: Country;
        Ghana: Country;
        Guinea: Country;
        Gambia: Country;
        'Guinea Bissau': Country;
        'Equatorial Guinea': Country;
        Israel: Country;
        Jordan: Country;
        Kenya: Country;
        Lebanon: Country;
        Liberia: Country;
        Libya: Country;
        Lesotho: Country;
        Morocco: Country;
        Madagascar: Country;
        Mali: Country;
        Malta: Country;
        Mozambique: Country;
        Mauritania: Country;
        Mauritius: Country;
        Malawi: Country;
        Namibia: Country;
        Niger: Country;
        Nigeria: Country;
        Oman: Country;
        Rwanda: Country;
        'Western Sahara': Country;
        'Saudi Arabia': Country;
        Sudan: Country;
        'South Sudan': Country;
        Senegal: Country;
        'Saint Helena': Country;
        'Sierra Leone': Country;
        Somalia: Country;
        Swaziland: Country;
        Seychelles: Country;
        Syria: Country;
        Chad: Country;
        Togo: Country;
        Tunisia: Country;
        'United Republic of Tanzania': Country;
        Uganda: Country;
        Yemen: Country;
        'South Africa': Country;
        Zambia: Country;
        Zimbabwe: Country;
    };
    /**
     * [[MapRegionsAustralia]]
     */
    Australia: {
        'New South Wales': AustraliaTerritory;
        Victoria: AustraliaTerritory;
        Queensland: AustraliaTerritory;
        'South Australia': AustraliaTerritory;
        'Western Australia': AustraliaTerritory;
        Tasmania: AustraliaTerritory;
        'Northern Territory': AustraliaTerritory;
        'Australian Capital Territory': AustraliaTerritory;
        'Other Territories': AustraliaTerritory;
    };
};
/**
 * List of MapRegions included in [[MapTypes.NorthAmerica]].
 *
 * Can be referenced like so:
 *
 * ```ts
 * const countries = MapRegions[ MapTypes.NorthAmerica ]
 * ```
 *
 * Each item is an enum-like object, that can be used with [[MapChart]] API to specify any region.
 *
 * **Example usage**:
 *
 * - Invalidate selected region value.
 *
 * ``` ts
 *  MapChart.invalidateRegionValues([
 *      { ...MapRegions[ MapTypes.NorthAmerica ].Panama, value: 0 }
 *  ])
 * ```
 *
 * - List all region names (can be useful when developing a js application without intellisense).
 *
 * ``` ts
 *  Object.keys( MapRegions[ MapTypes.NorthAmerica ] ).forEach( key => console.log( key ) )
 * ```
 *
 * Note, that the list includes all countries that are visible on the MapChart, some of which are outside the continent of North America.
 */
export declare const MapRegionsNorthAmerica: {
    Anguilla: Country;
    'Antigua and Barbuda': Country;
    'The Bahamas': Country;
    Bermuda: Country;
    Barbados: Country;
    Canada: Country;
    Cuba: Country;
    'Cayman Islands': Country;
    Dominica: Country;
    'Dominican Republic': Country;
    Grenada: Country;
    Greenland: Country;
    Haiti: Country;
    Jamaica: Country;
    'Saint Kitts and Nevis': Country;
    'Saint Lucia': Country;
    'Saint Martin': Country;
    Mexico: Country;
    Montserrat: Country;
    'Puerto Rico': Country;
    'Saint Pierre and Miquelon': Country;
    'Turks and Caicos Islands': Country;
    'Trinidad and Tobago': Country;
    'United States of America': Country;
    'Saint Vincent and the Grenadines': Country;
    'British Virgin Islands': Country;
    'United States Virgin Islands': Country;
};
/**
 * List of MapRegions included in [[MapTypes.SouthAmerica]].
 *
 * Can be referenced like so:
 *
 * ```ts
 * const countries = MapRegions[ MapTypes.SouthAmerica ]
 * ```
 *
 * Each item is an enum-like object, that can be used with [[MapChart]] API to specify any region.
 *
 * **Example usage**:
 *
 * - Invalidate selected region value.
 *
 * ``` ts
 *  MapChart.invalidateRegionValues([
 *      { ...MapRegions[ MapTypes.SouthAmerica ].Colombia, value: 0 }
 *  ])
 * ```
 *
 * - List all region names (can be useful when developing a js application without intellisense).
 *
 * ``` ts
 *  Object.keys( MapRegions[ MapTypes.SouthAmerica ] ).forEach( key => console.log( key ) )
 * ```
 *
 * Note, that the list includes all countries that are visible on the MapChart, some of which are outside the continent of South America.
 */
export declare const MapRegionsSouthAmerica: {
    Argentina: Country;
    Bolivia: Country;
    Brazil: Country;
    Chile: Country;
    Colombia: Country;
    'Costa Rica': Country;
    Ecuador: Country;
    'Falkland Islands': Country;
    Guyana: Country;
    Nicaragua: Country;
    Panama: Country;
    Peru: Country;
    Paraguay: Country;
    Suriname: Country;
    Uruguay: Country;
    Venezuela: Country;
    'French Guyana': Country;
    Guatemala: Country;
    'El Salvador': Country;
    Honduras: Country;
};
/**
 * List of MapRegions included in [[MapTypes.USA]].
 *
 * Can be referenced like so:
 *
 * ```ts
 * const states = MapRegions[ MapTypes.USA ]
 * ```
 *
 * Each item is an enum-like object, that can be used with [[MapChart]] API to specify any region.
 *
 * **Example usage**:
 *
 * - Invalidate selected region value.
 *
 * ``` ts
 *  MapChart.invalidateRegionValues([
 *      { ...MapRegions[ MapTypes.USA ].Alabama, value: 0 }
 *  ])
 * ```
 *
 * - List all region names (can be useful when developing a js application without intellisense).
 *
 * ``` ts
 *  Object.keys( MapRegions[ MapTypes.USA ] ).forEach( key => console.log( key ) )
 * ```
 */
export declare const MapRegionsUSA: {
    Alabama: State;
    Alaska: State;
    Arizona: State;
    Arkansas: State;
    California: State;
    Colorado: State;
    Connecticut: State;
    Delaware: State;
    'District of Columbia': State;
    Florida: State;
    Georgia: State;
    Hawaii: State;
    Idaho: State;
    Illinois: State;
    Indiana: State;
    Iowa: State;
    Kansas: State;
    Kentucky: State;
    Louisiana: State;
    Maine: State;
    Maryland: State;
    Massachusetts: State;
    Michigan: State;
    Minnesota: State;
    Mississippi: State;
    Missouri: State;
    Montana: State;
    Nebraska: State;
    Nevada: State;
    'New Hampshire': State;
    'New Jersey': State;
    'New Mexico': State;
    'New York': State;
    'North Carolina': State;
    'North Dakota': State;
    Ohio: State;
    Oklahoma: State;
    Oregon: State;
    Pennsylvania: State;
    'Rhode Island': State;
    'South Carolina': State;
    'South Dakota': State;
    Tennessee: State;
    Texas: State;
    Utah: State;
    Vermont: State;
    Virginia: State;
    Washington: State;
    'West Virginia': State;
    Wisconsin: State;
    Wyoming: State;
};
/**
 * List of MapRegions included in [[MapTypes.World]].
 *
 * Can be referenced like so:
 *
 * ```ts
 * const countries = MapRegions[ MapTypes.World ]
 * ```
 *
 * Each item is an enum-like object, that can be used with [[MapChart]] API to specify any region.
 *
 * **Example usage**:
 *
 * - Invalidate selected region value.
 *
 * ``` ts
 *  MapChart.invalidateRegionValues([
 *      { ...MapRegions[ MapTypes.World ].Finland, value: 0 }
 *  ])
 * ```
 *
 * - List all region names (can be useful when developing a js application without intellisense).
 *
 * ``` ts
 *  Object.keys( MapRegions[ MapTypes.World ] ).forEach( key => console.log( key ) )
 * ```
 */
export declare const MapRegionsWorld: {
    Aruba: Country;
    Afghanistan: Country;
    Angola: Country;
    Anguilla: Country;
    Albania: Country;
    Aland: Country;
    Andorra: Country;
    'United Arab Emirates': Country;
    Argentina: Country;
    Armenia: Country;
    'American Samoa': Country;
    Antarctica: Country;
    'French Southern and Antarctic Lands': Country;
    'Antigua and Barbuda': Country;
    Australia: Country;
    Austria: Country;
    Azerbaijan: Country;
    Burundi: Country;
    Belgium: Country;
    Benin: Country;
    'Burkina Faso': Country;
    Bangladesh: Country;
    Bulgaria: Country;
    Bahrain: Country;
    'The Bahamas': Country;
    'Bosnia and Herzegovina': Country;
    Belarus: Country;
    Belize: Country;
    Bermuda: Country;
    Bolivia: Country;
    Brazil: Country;
    Barbados: Country;
    Brunei: Country;
    Bhutan: Country;
    Botswana: Country;
    'Central African Republic': Country;
    Canada: Country;
    Switzerland: Country;
    Chile: Country;
    China: Country;
    'Ivory Coast': Country;
    Cameroon: Country;
    'Cyprus No Mans Area': Country;
    'Democratic Republic of the Congo': Country;
    'Republic of Congo': Country;
    'Cook Islands': Country;
    Colombia: Country;
    Comoros: Country;
    'Cape Verde': Country;
    'Costa Rica': Country;
    Cuba: Country;
    Curaçao: Country;
    'Cayman Islands': Country;
    'Northern Cyprus': Country;
    Cyprus: Country;
    'Czech Republic': Country;
    Germany: Country;
    Djibouti: Country;
    Dominica: Country;
    Denmark: Country;
    'Dominican Republic': Country;
    Algeria: Country;
    Ecuador: Country;
    Egypt: Country;
    Eritrea: Country;
    'Dhekelia Sovereign Base Area': Country;
    Spain: Country;
    Estonia: Country;
    Ethiopia: Country;
    Finland: Country;
    Fiji: Country;
    'Falkland Islands': Country;
    France: Country;
    'Faroe Islands': Country;
    'Federated States of Micronesia': Country;
    Gabon: Country;
    'United Kingdom': Country;
    Georgia: Country;
    Guernsey: Country;
    Ghana: Country;
    Guinea: Country;
    Gambia: Country;
    'Guinea Bissau': Country;
    'Equatorial Guinea': Country;
    Greece: Country;
    Grenada: Country;
    Greenland: Country;
    Guatemala: Country;
    Guam: Country;
    Guyana: Country;
    'Hong Kong S.A.R.': Country;
    'Heard Island and McDonald Islands': Country;
    Honduras: Country;
    Croatia: Country;
    Haiti: Country;
    Hungary: Country;
    Indonesia: Country;
    'Isle of Man': Country;
    India: Country;
    'Indian Ocean Territories': Country;
    'British Indian Ocean Territory': Country;
    Ireland: Country;
    Iran: Country;
    Iraq: Country;
    Iceland: Country;
    Israel: Country;
    Italy: Country;
    Jamaica: Country;
    Jersey: Country;
    Jordan: Country;
    Japan: Country;
    'Baykonur Cosmodrome': Country;
    'Siachen Glacier': Country;
    Kazakhstan: Country;
    Kenya: Country;
    Kyrgyzstan: Country;
    Cambodia: Country;
    Kiribati: Country;
    'Saint Kitts and Nevis': Country;
    'South Korea': Country;
    Kosovo: Country;
    Kuwait: Country;
    Laos: Country;
    Lebanon: Country;
    Liberia: Country;
    Libya: Country;
    'Saint Lucia': Country;
    Liechtenstein: Country;
    'Sri Lanka': Country;
    Lesotho: Country;
    Lithuania: Country;
    Luxembourg: Country;
    Latvia: Country;
    'Macao S.A.R': Country;
    'Saint Martin': Country;
    Morocco: Country;
    Moldova: Country;
    Madagascar: Country;
    Maldives: Country;
    Mexico: Country;
    'Marshall Islands': Country;
    Macedonia: Country;
    Mali: Country;
    Malta: Country;
    Myanmar: Country;
    Montenegro: Country;
    Mongolia: Country;
    'Northern Mariana Islands': Country;
    Mozambique: Country;
    Mauritania: Country;
    Montserrat: Country;
    Mauritius: Country;
    Malawi: Country;
    Malaysia: Country;
    Namibia: Country;
    'New Caledonia': Country;
    Niger: Country;
    Nigeria: Country;
    Nicaragua: Country;
    Niue: Country;
    Netherlands: Country;
    Norway: Country;
    Nepal: Country;
    'New Zealand': Country;
    Oman: Country;
    Pakistan: Country;
    Panama: Country;
    'Pitcairn Islands': Country;
    Peru: Country;
    'Spratly Islands': Country;
    Philippines: Country;
    Palau: Country;
    'Papua New Guinea': Country;
    Poland: Country;
    'Puerto Rico': Country;
    'North Korea': Country;
    Portugal: Country;
    Paraguay: Country;
    Palestine: Country;
    'French Polynesia': Country;
    Qatar: Country;
    Romania: Country;
    Russia: Country;
    Rwanda: Country;
    'Western Sahara': Country;
    'Saudi Arabia': Country;
    Sudan: Country;
    'South Sudan': Country;
    Senegal: Country;
    Singapore: Country;
    'South Georgia and South Sandwich Islands': Country;
    'Saint Helena': Country;
    'Solomon Islands': Country;
    'Sierra Leone': Country;
    'El Salvador': Country;
    Somalia: Country;
    'Saint Pierre and Miquelon': Country;
    'Republic of Serbia': Country;
    'Sao Tome and Principe': Country;
    Suriname: Country;
    Slovakia: Country;
    Slovenia: Country;
    Sweden: Country;
    Swaziland: Country;
    Seychelles: Country;
    Syria: Country;
    'Turks and Caicos Islands': Country;
    Chad: Country;
    Togo: Country;
    Thailand: Country;
    Tajikistan: Country;
    Turkmenistan: Country;
    'East Timor': Country;
    Tonga: Country;
    'Trinidad and Tobago': Country;
    Tunisia: Country;
    Turkey: Country;
    Tuvalu: Country;
    Taiwan: Country;
    'United Republic of Tanzania': Country;
    Uganda: Country;
    Ukraine: Country;
    'United States Minor Outlying Islands': Country;
    Uruguay: Country;
    'United States of America': Country;
    'US Naval Base Guantanamo Bay': Country;
    Uzbekistan: Country;
    'Saint Vincent and the Grenadines': Country;
    Venezuela: Country;
    'British Virgin Islands': Country;
    'United States Virgin Islands': Country;
    Vietnam: Country;
    Vanuatu: Country;
    'Wallis and Futuna': Country;
    'Akrotiri Sovereign Base Area': Country;
    Samoa: Country;
    Yemen: Country;
    'South Africa': Country;
    Zambia: Country;
    Zimbabwe: Country;
    'French Guyana': Country;
};
/**
 * Generic super class for [[PolarAxisAmplitude]] and [[PolarAxisRadial]].
 * @hidden  Not exported for minimal API doc. End user applications can use union: PolarAxisAmplitude | PolarAxisRadial instead if needed.
 */
export declare abstract class PolarAxis extends GenericAxis<AxisScale, PolarChart, PolarSeries, PolarAxisStrategy, PolarAxisTick, AbstractTickPlottingVariables, undefined> implements StylableAxisLine {
    /**
     * Specifies axis stroke
     * @param  value        Axis stroke style
     * @returns             Axis itself for fluent interface
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * @returns Axis stroke as a LineStyle object
     */
    getStrokeStyle(): LineStyle;
    /**
     * Enable / disable all interactions of Axis.
     * @param   enabled Interactions enabled or not.
     * @return          Object itself for fluent interface.
     */
    setMouseInteractions(enabled: boolean): this;
}
/**
 * Implementation of Polar Axis Tick.
 */
export declare class PolarAxisTick extends Tick {
    readonly gridline: Arc | Line;
    readonly tickline: Line;
    /**
     * @param   tickLevel       AxisTickLevel tick belongs to.
     * @param   value           Position of Tick on Axis.
     * @param   _removeFromAxis Remove handler for Tick.
     * @param   _restoreToAxis  Restore handler for Tick.
     * @param   _scale          Scale for shapes.
     * @param   _labelLayer     Layer for rendering Label.
     * @param   gridline        Shape for rendering Tick gridline (type depends on PolarAxis).
     * @param   tickline        Shape for rendering Tick line. Not using LineCollection for simplicity.
     * @param   label           Optionally injectable Tick Label shape.
     *                          Injection can be useful to reuse Tick shapes for performance.
     */
    constructor(tickLevel: AxisTickLevel, value: number, _removeFromAxis: RemoveHandler<AbstractAxisTick>, _restoreToAxis: RestoreHandler<AbstractAxisTick>, _scale: RadialScale, _labelLayer: Layer2D, _gridlineLayer: Layer2D, gridline: Arc | Line, tickline: Line, label?: Text);
    /**
     * Restores all custom tick sub-elements
     * @returns This for fluid interface
     */
    restore(): this;
    /**
     * Disposes all tick sub-elements
     * @returns This for fluid interface
     */
    dispose(): this;
    /**
     * @return True if all sub-elements are disposed, false if not.
     */
    isDisposed(): boolean;
}
/**
 * Class that represents the **amplitude** value interval on a [[PolarChart]].
 *
 * The Amplitude Axis is depicted as a single line segment starting from the very center of the PolarChart and ending at its right side.
 *
 * The Amplitude Axes' tick grid lines travel all over the PolarCharts Series space, doing a full 360 degree until returning to the other end of the tick, along the Amplitude Axis.
 *
 * The Amplitude Axes' title is positioned just below the Axis line and centered horizontally.
 *
 * Here is a list of the most commonly useful methods of Polar Amplitude Axis:
 * - [[PolarAxisAmplitude.setTitle]]            | Set title label.
 * - [[PolarAxisAmplitude.setInterval]]         | Set amplitude interval (start, end).
 * - [[PolarAxisAmplitude.setScrollStrategy]]   | Specify basis of automatic scrolling based on attached Series.
 * - [[PolarAxisAmplitude.setStrokeStyle]]      | Set style of Axis line.
 * - [[PolarAxisAmplitude.setTickStrategy]]     | Set style and creation basis of Axis ticks.
 */
export declare class PolarAxisAmplitude extends PolarAxis {
}
/**
 * Internal class.
 * Implements functional logic of PolarCharts Radial Axis (the circular one).
 *
 * Users can have reference to it, but limited to a sub set of its API, by interface: [[PolarAxisRadial]].
 * Main difference being that Radial Polar Axis doesn't have scrolling logic.
 * @hidden
 */
export declare class InternalPolarAxisRadial extends PolarAxis implements PolarAxisRadial {
    /**
     * Set style of Axis *ticks*.
     *
     * **Example usage:**
     *
     * - Modify default style
     *
     * ```ts
     *  PolarAxisRadial.setTickStyle( ( ticks: VisibleTicks ) => ticks
     *      .setLabelFillStyle( new SolidFill({ color: ColorRGBA( 255, 0, 0 ) }) )
     *  )
     *
     * ```
     *
     * - Pass a completely custom created VisibleTicks object
     *
     * ```ts
     *  PolarAxisRadial.setTickStyle( new VisibleTicks({
     *      labelFillStyle: new SolidFill({ color: ColorRGBA( 255, 0, 0 ) })
     *  }) )
     * ```
     *
     * @param   value   Either a [[VisibleTicks]] object or a function, which will be used to modify previous style.
     * @return          Object itself for fluent interface.
     */
    setTickStyle(value: VisibleTicks | ImmutableMutator<VisibleTicks>): this;
    /**
     * Get style of Axis *ticks*.
     * @return      VisibleTicks object.
     */
    getTickStyle(): VisibleTicks;
    /**
     * Set Axis tick formatting function. This defines text displayed by each tick.
     * @param   formattingFunction  [[FormattingFunction]].
     * @return  Object itself for fluent interface.
     */
    setTickFormattingFunction(formattingFunction: FormattingFunction): this;
    /**
     * Get Axis tick formatting function. This defines text displayed by each tick.
     * @return  [[FormattingFunction]]
     */
    getTickFormattingFunction(): FormattingFunction;
    /**
     * Set whether PolarAxisRadial direction is clockwise or counterclockwise.
     * @param   clockwise   True for clockwise direction, False for counterclockwise.
     * @return              Object itself for fluent interface.
     */
    setClockwise(clockwise: boolean): this;
    /**
     * Get whether PolarAxisRadial is clockwise or counterclockwise.
     * @return              True for clockwise direction, False for counterclockwise.
     */
    getClockwise(): boolean;
    /**
     * Set rotation of Radial Axis by specifying degree angle that is depicted at *North* position (horizontally centered, vertically highest).
     *
     * Example usage:
     * ```typescript
     *  // Rotate Radial Axis so that 0 degrees is shown at North position.
     *  PolarAxisRadial.setNorth(0)
     * ```
     * @param   angle       Angle as *degrees* that will be depicted at *North* position. Defaults to 90.
     * @return              Object itself for fluent interface.
     */
    setNorth(angle: number): this;
    /**
     * Get rotation of Radial Axis as degree angle that is depicted at *North* position (horizontally centered, vertically highest).
     * @return              Angle as *degrees* that is depicted at *North* position. Defaults to 90.
     */
    getNorth(): number;
    /**
     * Set how many sections the Radial Axis is divided into by Ticks.
     * @param   sectionsCount   Amount of sections.
     * @return                  Object itself for fluent interface.
     */
    setDivision(sectionsCount: number): this;
    /**
     * Get how many sections the Radial Axis is divided into by Ticks.
     * @return                  Amount of sections.
     */
    getDivision(): number;
}
/**
 * Axis object that represents a [[PolarChart]]s *radial* dimension,
 * which is depicted as an angle on the Charts center.
 *
 *
 * Class that represents the **radial** value interval on a [[PolarChart]].
 *
 * The Radial Axis is depicted as a continuous line traversing all the way along the outer edge of the PolarChart.
 *
 * The Radial Axes' ticks are positioned along this line, with the gridlines slicing the PolarChart into equally sized slices.
 *
 * The Radial Axes' title is positioned next to the charts right side, next to where the [[PolarAmplitudeAxis]] ends.
 *
 * Here is a list of the most commonly useful methods of Polar Radial Axis:
 * - [[PolarAxisRadial.setTitle]]                   | Set title label.
 * - [[PolarAxisRadial.setStrokeStyle]]             | Set style of Axis line.
 * - [[PolarAxisRadial.setTickStyle]]               | Set style of Axis ticks.
 * - [[PolarAxisRadial.setDivision]]                | Set amount of sections of PolarChart (also amount of Radial ticks).
 * - [[PolarAxisRadial.setClockwise]]               | Set direction of radial progression. Default = Counter Clock-Wise.
 * - [[PolarAxisRadial.setNorth]]                   | Set rotation of Radial Axis.
 * - [[PolarAxisRadial.setTickFormattingFunction]]  | Set formatting of Axis ticks.
 */
export interface PolarAxisRadial extends StylableAxisLine, StylableAxisTitle {
    /**
     * Set style of Axis *ticks*.
     *
     * **Example usage:**
     *
     * - Modify default style (assuming its type as [[VisibleTicks]])
     *
     * ```ts
     *  PolarAxisRadial.setTickStyle( ( ticks: VisibleTicks ) => ticks
     *      .setLabelFillStyle( new SolidFill({ color: ColorRGBA( 255, 0, 0 ) }) )
     *  )
     *
     * ```
     *
     * - Pass a completely custom created VisibleTicks object
     *
     * ```ts
     *  PolarAxisRadial.setTickStyle( new VisibleTicks({
     *      labelFillStyle: new SolidFill({ color: ColorRGBA( 255, 0, 0 ) })
     *  }) )
     * ```
     *
     * @param   value   Either a [[VisibleTicks]] object or a function, which will be used to modify previous style.
     * @return          Object itself for fluent interface.
     */
    setTickStyle(value: VisibleTicks | ImmutableMutator<VisibleTicks>): this;
    /**
     * Get style of Axis *ticks*.
     * @return      VisibleTicks object.
     */
    getTickStyle(): VisibleTicks;
    /**
     * Set whether PolarAxisRadial direction is clockwise or counterclockwise.
     *
     * Defaults to counterclockwise (false).
     * @param   clockwise   True for clockwise direction, False for counterclockwise.
     * @return              Object itself for fluent interface.
     */
    setClockwise(clockwise: boolean): this;
    /**
     * Get whether PolarAxisRadial is clockwise or counterclockwise.
     * @return              True for clockwise direction, False for counterclockwise.
     */
    getClockwise(): boolean;
    /**
     * Set rotation of Radial Axis by specifying degree angle that is depicted at *North* position (horizontally centered, vertically highest).
     *
     * Example usage:
     * ```typescript
     *  // Rotate Radial Axis so that 0 degrees is shown at North position.
     *  PolarAxisRadial.setNorth(0)
     * ```
     * @param   angle       Angle as *degrees* that will be depicted at *North* position. Defaults to 90.
     * @return              Object itself for fluent interface.
     */
    setNorth(angle: number): this;
    /**
     * Get rotation of Radial Axis as degree angle that is depicted at *North* position (horizontally centered, vertically highest).
     * @return              Angle as *degrees* that is depicted at *North* position. Defaults to 90.
     */
    getNorth(angle: number): number;
    /**
     * Set Axis tick formatting function. This defines text displayed by each tick.
     * @param   formattingFunction  [[FormattingFunction]].
     * @return  Object itself for fluent interface.
     */
    setTickFormattingFunction(formattingFunction: FormattingFunction): this;
    /**
     * Get Axis tick formatting function. This defines text displayed by each tick.
     * @return  [[FormattingFunction]]
     */
    getTickFormattingFunction(): FormattingFunction;
    /**
     * Set how many sections the Radial Axis is divided into by Ticks.
     * @param   sectionsCount   Amount of sections.
     * @return                  Object itself for fluent interface.
     */
    setDivision(sectionsCount: number): this;
    /**
     * Get how many sections the Radial Axis is divided into by Ticks.
     * @return                  Amount of sections.
     */
    getDivision(): number;
}
/**
 * TODO
 * Hidden, as there is only one type of Polar Axis Strategy (no Numeric, DateTime, etc.).
 * @hidden
 */
export interface PolarAxisStrategy extends AbstractAxisStrategy<PolarSeries> {
    /**
     * Function which gets an AxisScale object from PolarScale based on type of Axis (amplitude or radial).
     * @param   polarScale      PolarScale.
     * @return                  AxisScale object.
     */
    _getScale1D: (polarScale: RadialScale) => AxisScale;
}
/**
 * Type of *PolarSeries* for visualizing a collection of [[PolarPoints]] by connecting them with a line.
 *
 * *PolarLineSeries* are created with [[PolarChart.addLineSeries]].
 *
 * Set data with [[PolarLineSeries.setData]]:
 *
 * ```ts
 *  PolarSeries.setData(
 *      new Array( 90 ).fill( 0 ).map(( _, i ) => ({
 *          angle: i,
 *          amplitude: 60 + 25 * Math.cos( 5 * i * Math.PI / 180 )
 *      }))
 *  )
 * ```
 */
export declare class PolarLineSeries extends PolarSeries<LineSet, CursorPoint<PolarLineSeries>> implements Lined {
    /**
     * Set data for PolarSeries to render as a list of [[PolarPoint]]s.
     * @param   points  List of [[PolarPoint]]s.
     * @return          Object itself for fluent interface.
     */
    setData(points: PolarPoint[]): this;
    /**
     * Set stroke style of Series.
     *
     * Example usage:
     *```javascript
     * // Specified LineStyle
     * PolarLineSeries.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * PolarLineSeries.setStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden must be done with dispose() method, emptyLine is not supported
     * ```
     * @param   value   Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
     * @returns         Chart itself
     */
    setStrokeStyle(value: SolidLine | ImmutableMutator<SolidLine>): this;
    /**
     * Get stroke style of Series.
     * @return  SolidLine object
     */
    getStrokeStyle(): SolidLine;
    /**
     * Set stroke style of Series when it is highlighted.
     * Highlighting is activated by placing mouse on top / touching Series (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     *
     * Example usage:
     *```javascript
     * // Specified LineStyle
     * PolarLineSeries.setStrokeStyleHighlight(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * PolarLineSeries.setStrokeStyleHighlight((solidLine) => solidLine.setThickness(5))
     * // Hidden must be done with transparentLine, emptyLine is not supported
     * PolarLineSeries.setStrokeStyleHighlight(transparentLine)
     * // Automatic
     * PolarLineSeries.setStrokeStyleHighlight(undefined)
     * ```
     * @param   value   Either a SolidLine object or a function, which will be used to modify current value or
     *                  undefined for automatic value based on normal style.
     * @returns         Chart itself
     */
    setStrokeStyleHighlight(value: SolidLine | ImmutableMutator<SolidLine> | undefined): this;
    /**
     * Get stroke style of Series when it is highlighted.
     * Highlighting is activated by placing mouse on top / touching Series (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     * @return  SolidLine object
     */
    getStrokeStyleHighlight(): SolidLine;
    /**
     * Set automatic connection of first and last data points enabled or not.
     *
     * **Disabled by default.**
     * @param   enabled     Boolean.
     * @return              Object itself for fluent interface.
     */
    setConnectDataAutomaticallyEnabled(enabled: boolean): this;
    /**
     * Get automatic connection of first and last data points enabled or not.
     * @return              Boolean.
     */
    getConnectDataAutomaticallyEnabled(): boolean;
    /**
     * Abstract method that solves the nearest datapoint to a given coordinate on screen.
     * @param   location    Location on screen
     * @return              Undefined or data-structure for positioning of cursors
     */
    solveNearestFromScreen(location: Point): CursorPoint<PolarLineSeries> | undefined;
    /**
     * Abstract method that solves the nearest datapoint to a given coordinate on a screen from a specific segment.
     * @param   location    Location on screen
     * @param   segment     Segment to solve from
     * @return              Undefined or data-structure for positioning of cursors
     */
    solveNearestFromSegment(location: Point, segment: LineSet): CursorPoint<PolarLineSeries> | undefined;
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Series itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick?: boolean): this;
}
/**
 * Type of *PolarSeries* for visualizing a collection of [[PolarPoints]] by filling them with a specifiable [[PointShape]],
 * as well as connecting them with a line.
 *
 * *PolarPointLineSeries* are created with [[PolarChart.addPointLineSeries]].
 *
 * Set data with [[PolarSeries.setData]]:
 *
 * ```ts
 *  PolarSeries.setData(
 *      new Array( 90 ).fill( 0 ).map(( _, i ) => ({
 *          angle: i,
 *          amplitude: 60 + 25 * Math.cos( 5 * i * Math.PI / 180 )
 *      }))
 *  )
 * ```
 */
export declare class PolarPointLineSeries extends PolarSeries<LineSet | PointSet, CursorPoint<PolarPointLineSeries>> implements Lined, Pointed {
    /**
     * Set data for `PolarPointSeries` to render as a list of [[PolarPoint]]s.
     * @param   points  List of [[PolarPoint]]s.
     * @return          Object itself for fluent interface.
     */
    setData(points: PolarPoint[]): this;
    /**
     * Set stroke style of Series.
     *
     * Example usage:
     *```javascript
     * // Specified LineStyle
     * PolarLineSeries.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * PolarLineSeries.setStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden must be done with dispose() method, emptyLine is not supported
     * ```
     * @param   value   Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
     * @returns         Chart itself
     */
    setStrokeStyle(value: SolidLine | ImmutableMutator<SolidLine>): this;
    /**
     * Get stroke style of Series.
     * @return  SolidLine object
     */
    getStrokeStyle(): SolidLine;
    /**
     * Set stroke style of Series when it is highlighted.
     * Highlighting is activated by placing mouse on top / touching Series (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     *
     * Example usage:
     *```javascript
     * // Specified LineStyle
     * PolarLineSeries.setStrokeStyleHighlight(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * PolarLineSeries.setStrokeStyleHighlight((solidLine) => solidLine.setThickness(5))
     * // Hidden must be done with transparentLine, emptyLine is not supported
     * PolarLineSeries.setStrokeStyleHighlight(transparentLine)
     * // Automatic
     * PolarLineSeries.setStrokeStyleHighlight(undefined)
     * ```
     * @param   value   Either a SolidLine object or a function, which will be used to modify current value or
     *                  undefined for automatic value based on normal style.
     * @returns         Chart itself
     */
    setStrokeStyleHighlight(value: SolidLine | ImmutableMutator<SolidLine> | undefined): this;
    /**
     * Get stroke style of Series when it is highlighted.
     * Highlighting is activated by placing mouse on top / touching Series (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     * @return  SolidLine object
     */
    getStrokeStyleHighlight(): SolidLine;
    /**
     * Set point fill style of Series.
     *
     * Example usage:
     *```javascript
     * // Create a new style
     * PolarPointSeries.setPointFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Change transparency
     * PolarPointSeries.setPointFillStyle((solidFill) => solidFill.setA(80))
     * // Set hidden
     * PolarPointSeries.setPointFillStyle(emptyFill)
     * // Individual point style (required for using 'color' properties in data points)
     * PolarPointSeries.setPointFillStyle(new IndividualPointFill())
     *
     * ```
     * @param fillStyle     Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns             Series itself for fluent interface.
     */
    setPointFillStyle(fillStyle: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get normal points fill style.
     * @return  Normal point fillStyle
     */
    getPointFillStyle(): FillStyle;
    /**
     * Set point fill style of Series when it is highlighted.
     *
     * Example usage:
     *```javascript
     * // Create a new style
     * PolarPointSeries.setPointFillStyleHighlight(new SolidFill({ color: ColorHEX('#F00') }))
     * // Change transparency
     * PolarPointSeries.setPointFillStyleHighlight((solidFill) => solidFill.setA(80))
     * // Set hidden
     * PolarPointSeries.setPointFillStyleHighlight(emptyFill)
     * // Automatic
     * PolarPointSeries.setPointFillStyleHighlight(undefined)
     * ```
     * @param value Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value or
     *              undefined for automatic value based on normal style.
     * @returns     Series itself for fluent interface.
     */
    setPointFillStyleHighlight(value: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * Get current highlight fill style of points.
     * @return  Current highlight point fill style
     */
    getPointFillStyleHighlight(): FillStyle;
    /**
     * Set size of point in pixels.
     * @param   size    Size of point in pixels.
     * @returns         Object itself for fluent interface.
     */
    setPointSize(size: number): this;
    /**
     * Get current size of points in pixels.
     * @returns Size of point in pixels.
     */
    getPointSize(): number;
    /**
     * Set shape of points.
     * @param   shape   One of [[PointShape]] options.
     * @return          Object itself for fluent interface.
     */
    setPointShape(shape: PointShape): this;
    /**
     * Get shape of points.
     * @returns PointShape
     */
    getPointShape(): PointShape;
    /**
     * Set the rotation of points in degrees.
     * @param angle Rotation angle in degrees
     */
    setPointRotation(angle: number): this;
    /**
     * Get the current rotation of points.
     */
    getPointRotation(): number;
    /**
     * Set automatic connection of first and last data points enabled or not.
     *
     * **Disabled by default.**
     * @param   enabled     Boolean.
     * @return              Object itself for fluent interface.
     */
    setConnectDataAutomaticallyEnabled(enabled: boolean): this;
    /**
     * Get automatic connection of first and last data points enabled or not.
     * @return              Boolean.
     */
    getConnectDataAutomaticallyEnabled(): boolean;
    /**
     * Abstract method that solves the nearest datapoint to a given coordinate on screen.
     * @param   location    Location on screen
     * @return              Undefined or data-structure for positioning of cursors
     */
    solveNearestFromScreen(location: Point): CursorPoint<PolarPointLineSeries> | undefined;
    /**
     * Abstract method that solves the nearest datapoint to a given coordinate on a screen from a specific segment.
     * @param   location    Location on screen
     * @param   segment     Segment to solve from
     * @return              Undefined or data-structure for positioning of cursors
     */
    solveNearestFromSegment(location: Point, segment: PointSet | LineSet): CursorPoint<PolarPointLineSeries> | undefined;
}
/**
 * Type of *PolarSeries* for visualizing a collection of [[PolarPoints]] by filling them with a specifiable [[PointShape]].
 *
 * *PointShape* can be configured with [[PolarPointSeries.setPointStyle]].
 *
 * *PolarPointSeries* are created with [[PolarChart.addPointSeries]].
 *
 * Set data with [[PolarSeries.setData]]:
 *
 * ```ts
 *  PolarSeries.setData(
 *      new Array( 90 ).fill( 0 ).map(( _, i ) => ({
 *          angle: i,
 *          amplitude: 60 + 25 * Math.cos( 5 * i * Math.PI / 180 )
 *      }))
 *  )
 * ```
 */
export declare class PolarPointSeries extends PolarSeries<PointSet, CursorPoint<PolarPointSeries>> implements Pointed {
    /**
     * Set data for PolarSeries to render as a list of [[PolarPoint]]s.
     * @param   points  List of [[PolarPoint]]s.
     * @return          Object itself for fluent interface.
     */
    setData(points: PolarPoint[]): this;
    /**
     * Set point fill style of Series.
     *
     * Example usage:
     *```javascript
     * // Create a new style
     * PolarPointSeries.setPointFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Change transparency
     * PolarPointSeries.setPointFillStyle((solidFill) => solidFill.setA(80))
     * // Set hidden
     * PolarPointSeries.setPointFillStyle(emptyFill)
     * // Individual point style (required for using 'color' properties in data points)
     * PolarPointSeries.setPointFillStyle(new IndividualPointFill())
     *
     * ```
     * @param fillStyle     Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns             Series itself for fluent interface.
     */
    setPointFillStyle(fillStyle: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get normal points fill style.
     * @return  Normal point fillStyle
     */
    getPointFillStyle(): FillStyle;
    /**
     * Set point fill style of Series when it is highlighted.
     *
     * Example usage:
     *```javascript
     * // Create a new style
     * PolarPointSeries.setPointFillStyleHighlight(new SolidFill({ color: ColorHEX('#F00') }))
     * // Change transparency
     * PolarPointSeries.setPointFillStyleHighlight((solidFill) => solidFill.setA(80))
     * // Set hidden
     * PolarPointSeries.setPointFillStyleHighlight(emptyFill)
     * // Automatic
     * PolarPointSeries.setPointFillStyleHighlight(undefined)
     * ```
     * @param value Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value or
     *              undefined for automatic value based on normal style.
     * @returns     Series itself for fluent interface.
     */
    setPointFillStyleHighlight(value: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * Get current highlight fill style of points.
     * @return  Current highlight point fill style
     */
    getPointFillStyleHighlight(): FillStyle;
    /**
     * Set size of point in pixels.
     * @param   size    Size of point in pixels.
     * @returns         Object itself for fluent interface.
     */
    setPointSize(size: number): this;
    /**
     * Get current size of points in pixels.
     * @returns Size of point in pixels.
     */
    getPointSize(): number;
    /**
     * Set shape of points.
     * @param   shape   One of [[PointShape]] options.
     * @return          Object itself for fluent interface.
     */
    setPointShape(shape: PointShape): this;
    /**
     * Get shape of points.
     * @returns PointShape
     */
    getPointShape(): PointShape;
    /**
     * Set the rotation of points in degrees.
     * @param angle Rotation angle in degrees
     */
    setPointRotation(angle: number): this;
    /**
     * Get the current rotation of points.
     */
    getPointRotation(): number;
    /**
     * Abstract method that solves the nearest datapoint to a given coordinate on screen.
     * @param   location    Location on screen
     * @return              Undefined or data-structure for positioning of cursors
     */
    solveNearestFromScreen(location: Point): CursorPoint<PolarPointSeries> | undefined;
    /**
     * Abstract method that solves the nearest datapoint to a given coordinate on a screen from a specific segment.
     * @param   location    Location on screen
     * @param   segment     Segment to solve from
     * @return              Undefined or data-structure for positioning of cursors
     */
    solveNearestFromSegment(location: Point, segment: PointSet): CursorPoint<PolarPointSeries> | undefined;
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Series itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick?: boolean): this;
}
/**
 * File contains the logic for an abstract Funnel Chart.
 * The rendering logic of a "Funnel" is abstract and defined in a sub-class of this.
 */
/**
 * Enum for selecting different drawing approaches for [[FunnelChart]].
 *
 * Use with [[FunnelChart.setSliceMode]]
 */
export declare enum FunnelSliceModes {
    /**
     * Slices **height** represents its relative value inside the Funnel Chart.
     */
    VariableHeight = 0,
    /**
     * Slices **width** represents its relative value inside the Funnel Chart.
     */
    VariableWidth = 1
}
/**
 * Type of a FunnelChart constructor.
 * @hidden
 */
export declare type FunnelChartConstructor<T extends FunnelChart> = new (layerSupplier: LayerSupplier, scaleFactory: ScaleFactory, removeChart: (chart: Panel) => void, logoFactory?: LogoFactory, resizeEventInterface?: DashboardResizeEventInterface, theme?: Theme, _disableAnimations?: boolean) => T;
/**
 * Abstract base class for *Funnel Charts*.
 * Visualizes proportions and percentages between categories, by dividing a funnel into proportional segments.
 *
 * Set data using *FunnelChart*.**addSlice( name: string, value: number )**
 *
 * There are multiple implementations of *FunnelChart*, each with their own visual design and *API* for customizing it.
 * List of selectable options can be found in: [[FunnelChartTypes]]
 */
export declare abstract class FunnelChart extends Chart implements SlicedCharts<FunnelSlice> {
    /**
     * This method is used for the adding slices in the funnel chart.
     * @param title Funnel slice title
     * @param value  funnel slice value
     */
    addSlice(title: string, value: number): FunnelSlice;
    /**
     * This method is used for the adding multiple slices in the funnel chart.
     * @param slices Array of slices
     */
    addSlices(slices: {
        name: string;
        value: number;
    }[]): Array<FunnelSlice>;
    /**
     * Get all Slices of Funnel Chart.
     * NOTE: Manual modifications to returned Array can have unforeseen side-effects.
     * Removing or adding Slices is intended to be done using other APIs (FunnelChart.addSlice, Slice.dispose, ...)
     * @return  Array of Slices
     */
    getSlices(): FunnelSlice[];
    /**
     * Set Funnel Head Width
     * @param  headWidth   Funnel Head Width range from 0 to 100
     * @return             Funnel Chart itself
     */
    setHeadWidth(headWidth: number): this;
    /**
     * Get Funnel Head Width
     * @return  number (0 - 100)
     */
    getHeadWidth(): number;
    /**
     * Set Funnel Neck Width
     * @param neckWidth Funnel Neck Width range from 0 to 100
     * @return          Funnel Chart itself
     */
    setNeckWidth(neckWidth: number): this;
    /**
     * Get Funnel Neck Width
     * @return  number (0 - 100)
     */
    getNeckWidth(): number;
    /**
     * Set gap between Slice / start of label connector, and end of label connector / Label.
     * @param   sliceGap   Gap as pixels. Clamped between [0, 20] !
     * @return             Funnel Chart itself
     */
    setSliceGap(sliceGap: pixel): this;
    /**
     * Set FunnelSliceMode. Can be used to select between different drawing approaches for Slices.
     *
     * See [[FunnelSliceModes]] for a collection of options.
     * @param   sliceMode   FunnelSliceMode
     * @return              Funnel Chart itself
     */
    setSliceMode(sliceMode: FunnelSliceModes): this;
    /**
     * Get FunnelSliceMode. Can be used to select between different drawing approaches for Slices.
     *
     * See [[FunnelSliceModes]] for a collection of options.
     * @return  FunnelSliceMode
     */
    getFunnelSliceMode(): FunnelSliceModes;
    /**
     * Attach lookup table (LUT) to fill the slices with Colors based on value.
     *
     * The color for the slice would be selected from a specified *LUT*, which contains the information about gradient steps.
     * After setting LUT to undefined all the slices stay colorized, but no further lookup.
     *
     * LUT class stores information about values and its associated colors,
     * * which provides efficient lookup of the color based on provided value
     * * as well as linear and step interpolation between colors.
     *
     * ``` javascript
     * const funnel = lightningChart()
     *  .Funnel( { type: FunnelChartTypes.LabelsOnSides } )
     *  .setLUT( new LUT (steps: [
     *          { value: 10, color: ColorRGBA( 0, 0, 0 ) },
     *          { value: 20, color: ColorRGBA( 30, 255, 0 ) },
     *          { value: 30, color: ColorRGBA( 60, 204, 0 ) },
     *          { value: 40, color: ColorRGBA( 90, 128, 0 ) },
     *          { value: 50, color: ColorRGBA( 255, 0, 0 ) } ) ],
     *      interpolate: true } )
     * ```
     *
     * @param lut   Lookup table
     * @returns     Pie itself for fluent interface
     */
    setLUT(value: LUT): this;
    /**
     * Set style of Funnel Slices fill.
     * This style is managed as a continuous Palette of FillStyle objects. Each Slice of Funnel will be assigned an incremental index,
     * which will be used to pick its fill style from this Palette.
     *
     * So, for example... We have a Funnel Chart with 5 Slices, and we give it a Palette with only 3 possible values
     * (0 = red, 1 = green, 2 = blue). The resulting Slice fill styles will be: red, green, blue, red, green.
     * Note that this means, that the supplied Palette will have to work in a continuous manner!
     *
     * @param   sliceFillStylePalette   Palette for FillStyle objects
     * @return                          Funnel Chart itself
     */
    setSliceFillStyle(sliceFillStylePalette: Palette<FillStyle>): this;
    /**
     * Get style of Funnel Slices fill.
     * This style is managed as a continuous Palette of FillStyle objects. Each Slice of Funnel will be assigned an incremental index,
     * which will be used to pick its fill style from this Palette.
     *
     * So, for example... We have a Funnel Chart with 5 Slices, and we give it a Palette with only 3 possible values
     * (0 = red, 1 = green, 2 = blue). The resulting Slice fill styles will be: red, green, blue, red, green.
     * Note that this means, that the supplied Palette will have to work in a continuous manner!
     *
     * @return  Palette<FillStyle>
     */
    getSliceFillStyle(): Palette<FillStyle>;
    /**
     * Set style of Funnel Slices Stroke.
     * @param   value   LineStyle object or function which creates a new style based on previous
     * @return          Funnel Chart itself
     */
    setSliceStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of Funnel Slices Stroke.
     * @return  LineStyle object
     */
    getSliceStrokeStyle(): LineStyle;
    /**
     * Set sorter of Funnels' Slices as a comparator-function.
     *
     * For some commonly needed default implementations, can refer to SliceSorters-collection.
     * @param   sliceSorter SliceSorter - function which sorts Slices of Funnel with JavaScript API: Array.sort.
     * @return              Funnel Chart itself
     */
    setSliceSorter(sliceSorter: SliceSorter<FunnelSlice>): this;
    /**
     * Get sorter of Funnels' Slices as a comparator-function.
     * @return  SliceSorter - function which sorts Slices of Funnel with JavaScript API: Array.sort.
     */
    getSliceSorter(): SliceSorter<FunnelSlice>;
    /**
     * Set fill style of Funnel Slices Labels.
     * @param   value   FillStyle object or function which creates a new style based on previous
     * @return          Funnel Chart itself
     */
    setLabelFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of Funnel Slice Labels.
     * @return  FillStyle object
     */
    getLabelFillStyle(): FillStyle;
    /**
     * Set font of Slice Labels.
     * @param   value   FontSettings or mutator function for existing settings
     * @return          Funnel Chart itself
     */
    setLabelFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
    /**
     * Get font of Slice Labels.
     * @return  FontSettings
     */
    getLabelFont(): FontSettings;
    /**
     * Set formatter of Slice Labels.
     *
     * See [[SliceLabelFormatters]] for a collection of default options.
     * @param   labelFormatter  SliceLabelFormatter - function which generates text of Labels per Slice.
     * @return                  Funnel Chart itself
     */
    setLabelFormatter(labelFormatter: SliceLabelFormatter<FunnelSlice>): this;
    /**
     * Get formatter of Slice Labels.
     * @return  SliceLabelFormatter - function which generates text of Labels per Slice.
     */
    getLabelFormatter(): SliceLabelFormatter<FunnelSlice>;
    /**
     * Sets if animations are enabled or not.
     * @param   animationsEnabled   Boolean state for animations enabled
     * @return                      Funnel Chart itself
     */
    setAnimationsEnabled(animationsEnabled: boolean): this;
    /**
     * Gets if animations are enabled or not.
     * @return  Boolean state for animations enabled
     */
    getAnimationsEnabled(): boolean;
    /**
     * Disable all animations for the chart.
     *
     * All animations have to be re-enabled individually if you wish to re-enable animations.
     * @return      Chart itself for fluent interface.
     * @deprecated  Deprecated in v3.1.0. Will be removed in v4.0.0. Use [[setAnimationsEnabled]] instead.
     */
    disableAnimations(): this;
    /**
     * Set if slices should be highlighted on mouse hover / touch. Applies to all Slices.
     * @param state True if Slices should be highlighted on hover, false if not. This applies to all existing Slices and new Slices added.
     */
    setSliceHighlightOnHover(state: boolean): this;
    /**
     * **Permanently** dispose the component.
     *
     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
     * **to the component and its children** in application code.
     * ```javascript
     * let chart = ...Funnel()
     * let slice = chart.addSlice({name: 'name', value: 50})
     * // Dispose Chart, and remove all references so that they can be garbage-collected.
     * chart.dispose()
     * chart = undefined
     * slice = undefined
     * ```
     * @return  Object itself for fluent interface
     */
    dispose(): this;
}
/**
 * File contains different implementations of Funnel Charts, each with their own rendering logic.
 */
/**
 * [[FunnelChart]] implementation that draws Slice Labels on its left and right sides.
 * Slices and Labels are connected by 'label connector lines'.
 */
export declare class FunnelChartWithLabelsOnSides extends FunnelChart {
    /**
     * Set style of Label connector lines.
     * @param   labelConnectorStyle LineStyle object
     * @return                      Funnel Chart itself
     */
    setLabelConnectorStyle(labelConnectorStyle: LineStyle): this;
    /**
     * Get style of Label connector lines.
     * @return  LineStyle object
     */
    getLabelConnectorStyle(): LineStyle;
    /**
     * Set gap between Slice / start of label connector, and end of label connector / Label.
     * @param   labelConnectorGap   Gap as pixels
     * @return                      Funnel Chart itself
     */
    setLabelConnectorGap(labelConnectorGap: pixel): this;
    /**
     * Get gap between Slice / start of label connector, and end of label connector / Label.
     * @return  Gap as pixels
     */
    getLabelConnectorGap(): number;
    /**
     * Set the side where label should display
     * @param   labelSide   Left /Right
     * @return              Funnel Chart itself
     */
    setLabelSide(labelSide: FunnelLabelSide): this;
    /**
     * Get the side where label shown
     * @return The label side
     */
    getLabelSide(): FunnelLabelSide;
    /**
     * Get minimum size of Panel.
     * Depending on the type of class this value might be automatically computed to fit different elements.
     * @return  Point minimum size or undefined if unimplemented
     */
    getMinimumSize(): Point | undefined;
}
/**
 * [[FunnelChart]] implementation that draws Slice Labels inside the Slices.
 * Works well when Label texts are short and there are not a lot of Slices, as the actual Funnel has more space.
 */
export declare class FunnelChartWithLabelsInsideSlices extends FunnelChart {
    /**
     * Get minimum size of Panel.
     * Depending on the type of class this value might be automatically computed to fit different elements.
     * @return      Point
     */
    getMinimumSize(): Point | undefined;
}
/**
 * Interface for readonly configuration of [FunnelChart](../classes/funnelchart.html).
 *
 * Some properties of `FunnelChart` can only be configured when it is created. These arguments are all optional, and are wrapped in a single object parameter:
 *
 * ```typescript
 *  // Example, create chart with specified color theme.
 *  const chart = LightningChart.Funnel({
 *      theme: Themes.light,
 *  })
 * ```
 *
 * *Watch out!* The full set of available readonly configuration parameters depends on if the chart is *standalone*, or inside a *dashboard*:
 *
 * For *standalone* `FunnelChart`, more parameters are documented in [[LightningChart.Funnel]].
 *
 * For *dashboard* `FunnelChart`, more parameters are documented in [[Dashboard.createFunnelChart]].
 *
 *
 * **Commonly used properties:**
 *
 * - [[FunnelChartOptions.type]]: Specify visual design of *funnel chart* from a collection of options.
 * - [[FunnelChartOptions.theme]]: Specify chart color *theme*.
 * - [[FunnelChartOptions.disableAnimations]]: Convenience flag to disable all animations from chart.
 *
 * **Example usage:**
 *
 * ```typescript
 *  // Example 1, create funnel chart with default configuration.
 *  const chart = LightningChart.Funnel({})
 * ```
 *
 * ```typescript
 *  // Example 2, create funnel chart with labels inside slices.
 *  const chart = LightningChart.Funnel({
 *      type: FunnelChartTypes.LabelsInsideSlices
 *  })
 * ```
 *
 * ```typescript
 *  // Example 3, create funnel chart with specified color theme.
 *  const chart = LightningChart.Funnel({
 *      theme: Themes.light,
 *  })
 * ```
 */
export interface FunnelChartOptions<FunnelChartType extends FunnelChartTypes> extends CommonChartOptions {
    /**
     * Interface for specifying desired "type" of Funnel Chart.
     * This can be used to select different rendering approaches, mainly reflecting how Slice Labels are positioned.
     *
     * Options are located in [[FunnelChartTypes]]-collection. If undefined, will default to [[FunnelChartWithLabelsOnSides]].
     */
    type?: FunnelChartType;
}
/**
 * Collection of [[FunnelChart]] implementations. Each option can have their own visual design, and *API* for customization of it.
 *
 * This must be specified when the *FunnelChart* is created (or default one will be used).
 *
 * Example usage:
 *```javascript
 * // Create a FunnelChart with default type
 * LightningChart.Funnel()
 * // Create a FunnelChart with specified type
 * LightningChart.Funnel({ type: FunnelChartTypes.LabelsInsideSlices })
 * ```
 */
export declare const FunnelChartTypes: {
    /**
     * Funnel Chart type, where Slice Labels are positioned on the either left or right sides of Chart.
     * The side can be set using setLabelSide
     * Labels are connected to their Slices with lines, which can be styled using unique API for this Funnel Chart type.
     */
    LabelsOnSides: typeof FunnelChartWithLabelsOnSides;
    /**
     * Funnel Chart type, where Slice Labels inside the Slices.
     */
    LabelsInsideSlices: typeof FunnelChartWithLabelsInsideSlices;
};
/**
 * Available Funnel Chart types
 * @hidden
 */
export declare type FunnelChartTypes = typeof FunnelChartTypes[keyof typeof FunnelChartTypes];
/**
 * Options for selecting side of labels in a [[FunnelChartWithLabelsOnSides]].
 *
 * Use with [[FunnelChartWithLabelsOnSides.setLabelSide]]
 */
export declare enum FunnelLabelSide {
    /**
     * Label Side  - Right
     */
    Right = 0,
    /**
     * Label Side  - Left
     */
    Left = 1
}
/**
 * Possible Shape types for parts of a Slice.
 */
declare type FunnelSliceVisual = Polygon | Text;
/**
 * Class that represents a single Slice of a Funnel Chart.
 * It is given to users when a Slice is added.
 */
export declare abstract class FunnelSlice extends Slice<FunnelSliceVisual> {
    /**
     * Set value of Slice.
     * @param   value   Numeric value
     * @return          Slice itself
     */
    abstract setValue(value: number): this;
    /**
     * Get value of Slice.
     * @return          Numeric value
     */
    abstract getValue(): number;
}
/**
 * Internal class that hides some internal interfaces of a Slice that are only needed for interactions with the owning Funnel Chart.
 * @hidden
 */
export declare class InternalFunnelSlice extends FunnelSlice {
    protected _chart: FunnelChart;
    readonly scale: LinearScaleXY;
    protected _removeFromChart: RemoveHandler<ChartComponent>;
    protected _restoreFromChart: RestoreHandler<ChartComponent>;
    /**
     * Index of Slice inside its owning Chart.
     * It tells how many Slices were created before this one.
     * It is not updated for disposed Slices, and so cannot be used for counting the amount of existing Slices.
     */
    readonly index: number;
    /**
     * @param   index               Index of Slice
     * @param    polygonLayer       Rendering layer for Polygon
     * @param    labelLayer         Rendering layer for Label
     * @param    _chart             Owning chart
     * @param    scale              Rendering scale
     * @param   _removeFromChart    Remove handler for Slice
     * @param    _restoreFromChart  Restore handler for Slice
     * @hidden
     */
    constructor(index: number, polygonLayer: Layer2D, labelLayer: Layer2D, _chart: FunnelChart, scale: LinearScaleXY, _removeFromChart: RemoveHandler<ChartComponent>, _restoreFromChart: RestoreHandler<ChartComponent>, _theme: Theme);
    /**
     * Set value of Slice.
     * @param   value   Numeric value
     * @return          Slice itself
     */
    setValue(value: number): this;
    /**
     * Get value of Slice.
     * @return          Numeric value
     */
    getValue(): number;
    /**
     * Tell the owning chart to remove this component.
     * @return  Slice itself.
     */
    dispose(): this;
    /**
     * Tell the owning chart to restore this series.
     * @return  Slice itself.
     */
    restore(): this;
    /**
     * Method that owning Funnel Chart uses to assign style of a Slice it owns.
     * @param   polygonFillStyle    FillStyle for Polygon
     * @param   polygonStrokeStyle  LineStyle for Polygon
     * @param   labelFillStyle  FillStyle for Label
     * @param   labelFont       FontSettings for Label
     */
    setStyle(polygonFillStyle: FillStyle, polygonStrokeStyle: LineStyle, labelFillStyle: FillStyle, labelFont: FontSettings): void;
    /**
     * Get animated value of Slice.
     * When value of Slice is changed, the animated value will not update immediately, but after an animation.
     * (if animations are not disabled).
     * @return  Animated value
     */
    getAnimatedValue(): number;
    /**
     * Attach series to an annotation.
     * @param entry Object which has to be attached
     * @return      Series itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick?: boolean): this;
    /**
     * Enable or disable forced highlighting of series
     * @param highLight True for enabled and false for disabled
     * @returns         Series itself for fluent interface
     */
    setHighlighted(highLight: boolean): this;
    /**
     * Method styles an attached entry according to Slice itself.
     */
    protected styleAttachedEntry(entry: LegendBoxEntry): void;
}
export {};
/**
 * Interval object defines the minimum and maximum slice interval.
 */
export interface SliceInterval {
    min: number;
    max: number;
}
/**
 * Abstract base class for *Gauge Charts*.
 * Gauge charts indicate where your data point(s) falls over a particular range.
 * This chart type is often used in executive dashboard reports to show key business indicators.
 *
 * There are multiple implementations of *GaugeChart*, each with their own visual design and *API* for customizing it.
 * List of selectable options can be found in: [[GaugeChartTypes]]
 */
export declare abstract class GaugeChart<PublicSlice extends GaugeSlice = GaugeSlice, InternalSlice extends GaugeSlice = GaugeSlice> extends Chart {
    /**
     * @param   layerSupplier           LayerSupplier. Must NOT be cached, because it contains reference to actual Engine instance.
     * @param   scaleFactory            Scale factory.
     * @param   removeChart             Injectable Panel/Chart remove method.
     * @param   logoFactory             Logo factory.
     * @param   resizeEventInterface    Injectable event interface for resizing Panel (used for dashboard)
     * @param   theme                   Theme used to style elements in the Chart.
     * @param   _disableAnimations      Disable animations by default
     * @hidden
     */
    constructor(_lcjsOptions: InternalLightningChartOptions, layerSupplier: LayerSupplier, scaleFactory: ScaleFactory, removeChart: (chart: Panel) => void, logoFactory?: LogoFactory, resizeEventInterface?: DashboardResizeEventInterface, theme?: Theme, _disableAnimations?: boolean);
    /**
     * Set lookup table.
     *
     * Example usage:
     *```javascript
     * // Gauge slice color depending on value
     * SolidGauge.setLUT(new LUT ( { steps: [ { value: 0, color: ColorRGBA( 0, 0, 0 ) },
     *  { value: 500, color: ColorRGBA( 12, 213, 87 ) } ],
     *  interpolate: true })
     * ```
     * @param lut   Lookup table |
     * @returns     Gauge itself for fluent interface
     */
    abstract setLUT(lut?: LUT): this;
    /**
     * Sets if animations are enabled or not.
     * @param   animationsEnabled   Boolean state for animations enabled
     * @returns                     Gauge itself for fluent interface.
     */
    setAnimationsEnabled(animationsEnabled: boolean): this;
    /**
     * Gets if animations are enabled or not.
     * @return  Boolean state for animations enabled
     */
    getAnimationsEnabled(): boolean;
    /**
     * Disable all animations for the chart.
     *
     * All animations have to be re-enabled individually if you wish to re-enable animations.
     * @return      Chart itself for fluent interface.
     * @deprecated  Deprecated in v3.1.0. Will be removed in v4.0.0. Use [[setAnimationsEnabled]] instead.
     */
    disableAnimations(): this;
    /**
     * **Permanently** dispose the component.
     *
     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
     * **to the component and its children** in application code.
     * ```javascript
     * let chart = ...Gauge()
     * let slice = chart.getDefaultSlice()
     * // Dispose Chart, and remove all references so that they can be garbage-collected.
     * chart.dispose()
     * chart = undefined
     * slice = undefined
     * ```
     * @return  Object itself for fluent interface
     */
    dispose(): this;
}
/**
 * Type of a GaugeChart constructor.
 * @hidden
 */
export declare type GaugeChartConstructor<T extends GaugeChart> = new (layerSupplier: LayerSupplier, scaleFactory: ScaleFactory, removeChart: (chart: Panel) => void, logoFactory?: LogoFactory, resizeEventInterface?: DashboardResizeEventInterface, theme?: Theme, _disableAnimations?: boolean) => T;
/**
 * Interface for readonly configuration of [GaugeChart](../classes/gaugechart.html).
 *
 * Some properties of `GaugeChart` can only be configured when it is created. These arguments are all optional, and are wrapped in a single object parameter:
 *
 * ```typescript
 *  // Example, create chart with specified color theme.
 *  const chart = LightningChart.Gauge({
 *      theme: Themes.light,
 *  })
 * ```
 *
 * *Watch out!* The full set of available readonly configuration parameters depends on if the chart is *standalone*, or inside a *dashboard*:
 *
 * For *standalone* `GaugeChart`, more parameters are documented in [[LightningChart.Gauge]].
 *
 * For *dashboard* `GaugeChart`, more parameters are documented in [[Dashboard.createGaugeChart]].
 *
 *
 * **Commonly used properties:**
 *
 * - [[GaugeChartOptions.type]]: Specify type of *gauge chart*.
 * - [[GaugeChartOptions.theme]]: Specify chart color *theme*.
 * - [[GaugeChartOptions.disableAnimations]]: Convenience flag to disable all animations from chart.
 *
 * **Example usage:**
 *
 * ```typescript
 *  // Example 1, create chart with default configuration.
 *  const chart = LightningChart.Gauge({})
 * ```
 *
 * ```typescript
 *  // Example 2, create chart with specified color theme.
 *  const chart = LightningChart.Gauge({
 *      theme: Themes.light,
 *  })
 * ```
 */
export interface GaugeChartOptions<GaugeChartType extends GaugeChartTypes> extends CommonChartOptions {
    /**
     * Interface for specifying desired "type" of Gauge Chart.
     * This can be used to select different gauge types.
     *
     * **Note, at this time, there is only a single type available, leaving this API effectively unusable.**
     *
     * Options are located in [[GaugeChartTypes]] collection. If undefined, will default to Solid.
     */
    type?: GaugeChartType;
}
/**
 * Collection of [[GaugeChart]] implementations. Each option can have their own visual design, and *API* for customization of it.
 *
 * **Note, at this time, there is only a single type available, leaving this API effectively unusable.**
 *
 * This must be specified when the [[GaugeChart]] is created (or default one will be used).
 *
 * Example usage:
 *```javascript
 * // Create a GaugeChart with specified type
 * LightningChart.Gauge({ type: GaugeChartTypes.Solid })
 * ```
 */
export declare const GaugeChartTypes: {
    /**
     * Solid Gauge Chart type, which contains a single slice represents a value within the interval.
     */
    Solid: typeof SolidGauge;
};
/**
 * @hidden
 */
export declare type GaugeChartTypes = typeof GaugeChartTypes[keyof typeof GaugeChartTypes];
/**
 * Value change event listener.
 * @param slice     Slice
 * @param previous  Previous slice value
 * @param next      Next slice value
 */
export declare type ValueChangeEventListener<S extends GaugeSlice> = (slice: S, previous: number, next: number) => void;
/**
 * Interval change event listener.
 * @param slice     Slice
 * @param previous  Previous slice interval
 * @param next      Next slice interval
 */
export declare type IntervalChangeEventListener<S extends GaugeSlice> = (slice: S, previous: SliceInterval, next: SliceInterval) => void;
/**
 * Abstract class of Gauge slice.
 * The slice can be represented as a single or multiples shapes.
 */
export declare abstract class GaugeSlice<GaugeSliceVisual extends ChartVisual = ChartVisual> extends Slice<GaugeSliceVisual> {
    /**
     * Set scale interval.
     * @param  start                Start scale value
     * @param  end                  End scale value
     * @returns Slice for fluent interface
     */
    abstract setInterval(start: number, end: number): this;
    /**
     * Set font of interval labels.
     *
     * Example usage:
     *```javascript
     * // Specified FontSettings
     * GaugeSlice.setIntervalLabelsFont(new FontSettings({ size: 24, style: 'italic' }))
     * // Set to bold
     * GaugeSlice.setIntervalLabelsFont((fontSettings) => fontSettings.setWeight('bold'))
     * ```
     *
     * @param   value   Either a FontSettings object or a function, which will be used to create a new FontSettings based on current value.
     * @returns         Chart itself
     */
    abstract setIntervalLabelsFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
    /**
     * Get font of gauge interval labels.
     * @returns         FontSettings object for gauge interval labels.
     */
    abstract getIntervalLabelsFont(): FontSettings;
    /**
     * Set interval labels visibility enabled or disabled.
     * @param state True - labels are enabled, otherwise - disabled.
     * @returns     Slice itself for fluent interface.
     */
    abstract setIntervalLabelsVisible(state: boolean): this;
    /**
     * Get interval labels visibility state.
     * @returns True - labels are enabled, otherwise - disabled.
     */
    abstract getIntervalLabelsVisible(): boolean;
    /**
     * Remove subscription from value change event
     * @param token Event listener
     * @returns True if the listener is successfully removed and false if it is not found
     */
    offValueChange(token: Token): boolean;
    /**
     * Remove subscription from interval change event
     * @param token Event listener
     * @returns True if the listener is successfully removed and false if it is not found
     */
    offIntervalChange(token: Token): boolean;
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Series itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick?: boolean): this;
    /**
     * Enable or disable forced highlighting of series
     * @param highLight True for enabled and false for disabled
     * @returns         Series itself for fluent interface
     */
    setHighlighted(highLight: boolean): this;
    /**
     * Method styles an attached entry according to Slice itself.
     */
    protected styleAttachedEntry(entry: LegendBoxEntry): void;
}
/**
 * File contains the logic for an abstract Pie Chart.
 * The rendering logic of a "Pie" is abstract and defined in a sub-class of this.
 */
/**
 * Abstract base class for *Pie Charts*.
 * Visualizes proportions and percentages between categories, by dividing a circle into proportional segments.
 *
 * Set data using *PieChart*.**addSlice( name: string, value: number )**
 *
 * There are multiple implementations of *PieChart*, each with their own visual design and *API* for customizing it.
 * List of selectable options can be found in: [[PieChartTypes]]
 */
export declare abstract class PieChart extends Chart implements SlicedCharts<PieSlice> {
    /**
     * Add new Slice to the Pie Chart.
     * The Slice will be automatically assigned an unique style (using SliceFillStylePalette),
     * that will not be affected by sorting of Slices.
     *
     * Currently there is no way to override the individual style of a Slice - style modifications must be done using the API of Pie Chart.
     *
     * @param   name    Initial name for Slice as string.
     * @param   value   Initial value for Slice as number.
     * @return          New Slice object.
     */
    addSlice(name: string, value: number): PieSlice;
    /**
     * This method is used for the adding multiple slices in the funnel chart.
     * @param multiSlice Array of slices
     */
    addSlices(multiSlice: {
        name: string;
        value: number;
    }[]): Array<PieSlice>;
    /**
     * Get all Slices of Pie Chart.
     * NOTE: Manual modifications to returned Array can have unforeseen side-effects.
     * Removing or adding Slices is intended to be done using other APIs (PieChart.addSlice, Slice.dispose, ...)
     * @return  Array of Slices
     */
    getSlices(): PieSlice[];
    /**
     * Set if it is allowed for multiple Slices to be 'exploded' at the same time or not.
     * When a Slice is exploded, it is drawn differently from non-exploded state
     * - usually slightly "pushed away" from the center of Pie Chart.
     *
     * Does not affect state of already exploded Slices!
     * @param   multipleSliceExplosionAllowed   Is behavior allowed as boolean flag
     * @return                                  Pie Chart itself
     */
    setMultipleSliceExplosion(multipleSliceExplosionAllowed: boolean): this;
    /**
     * Get a boolean flag which implies whether it is allowed for multiple Slices to be 'exploded' at the same time or not.
     * When a Slice is exploded, it is drawn differently from non-exploded state
     * - usually slightly "pushed away" from the center of Pie Chart.
     * @return  Is behavior allowed as boolean flag
     */
    getMultipleSliceExplosion(): boolean;
    /**
     * Set inner radius of Pie Chart.
     * This method can be used to style the Pie Chart as a "Donut Chart", with the center being hollow.
     * @param   innerRadius     Inner radius as a percentage of outer radius [0, 100]
     * @return                  Pie Chart itself
     */
    setInnerRadius(innerRadius: number): this;
    /**
     * Get inner radius of Pie Chart..
     * This property can be used to style the Pie Chart as a "Donut Chart", with the center being hollow.
     * @return  Inner radius as a percentage of outer radius [0, 100]
     */
    getInnerRadius(): number;
    /**
     * Set offset of exploded Slices in pixels.
     * @param   sliceExplosionOffset    Offset of exploded Slices in pixels
     * @return                          Pie Chart itself
     */
    setSliceExplosionOffset(sliceExplosionOffset: pixel): this;
    /**
     * Get offset of exploded Slices in pixels.
     * @return  Offset of exploded Slices in pixels
     */
    getSliceExplosionOffset(): pixel;
    /**
     * Attach lookup table (LUT) to fill the slices with Colors based on value.
     *
     * The color for the slice would be selected from a specified *LUT*, which contains the information about gradient steps.
     * After setting LUT to undefined all the slices stay colorized, but no further lookup.
     *
     * LUT class stores information about values and its associated colors,
     * * which provides efficient lookup of the color based on provided value
     * * as well as linear and step interpolation between colors.
     *
     * ``` javascript
     * const pie = lightningChart()
     *  .Pie( { type: PieChartTypes.LabelsOnSides } )
     *  .setLUT( new LUT (steps: [
     *          { value: 10, color: ColorRGBA( 0, 0, 0 ) },
     *          { value: 20, color: ColorRGBA( 30, 255, 0 ) },
     *          { value: 30, color: ColorRGBA( 60, 204, 0 ) },
     *          { value: 40, color: ColorRGBA( 90, 128, 0 ) },
     *          { value: 50, color: ColorRGBA( 255, 0, 0 ) } ) ],
     *      interpolate: true } )
     * ```
     *
     * @param lut   Lookup table
     * @returns     Pie itself for fluent interface
     */
    setLUT(lut?: LUT): this;
    /**
     * Set style of Pie Slices fill.
     * This style is managed as a continuous Palette of FillStyle objects. Each Slice of Pie will be assigned an incremental index,
     * which will be used to pick its fill style from this Palette.
     *
     * So, for example... We have a Pie Chart with 5 Slices, and we give it a Palette with only 3 possible values
     * (0 = red, 1 = green, 2 = blue). The resulting Slice fill styles will be: red, green, blue, red, green.
     * Note that this means, that the supplied Palette will have to work in a continuous manner!
     *
     * @param   sliceFillStylePalette   Palette for FillStyle objects
     * @return                          Pie Chart itself
     */
    setSliceFillStyle(sliceFillStylePalette: Palette<FillStyle>): this;
    /**
     * Get style of Pie Slices fill.
     * This style is managed as a continuous Palette of FillStyle objects. Each Slice of Pie will be assigned an incremental index,
     * which will be used to pick its fill style from this Palette.
     *
     * So, for example... We have a Pie Chart with 5 Slices, and we give it a Palette with only 3 possible values
     * (0 = red, 1 = green, 2 = blue). The resulting Slice fill styles will be: red, green, blue, red, green.
     * Note that this means, that the supplied Palette will have to work in a continuous manner!
     *
     * @return  Palette<FillStyle>
     */
    getSliceFillStyle(): Palette<FillStyle>;
    /**
     * Set stroke style of Pie Slices border.
     * @param   value   LineStyle object or function which creates a new style based on previous
     * @return          Pie Chart itself
     */
    setSliceStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stroke style of Pie Slices border.
     * @return  LineStyle object
     */
    getSliceStrokeStyle(): LineStyle;
    /**
     * Set sorter of Pies' Slices as a comparator-function.
     *
     * For some commonly needed default implementations, can refer to PieSliceSorters-collection.
     * @param   sliceSorter PieSliceSorter - function which sorts Slices of Pie with JavaScript API: Array.sort.
     * @return              Pie Chart itself
     */
    setSliceSorter(sliceSorter: SliceSorter<PieSlice>): this;
    /**
     * Get sorter of Pies' Slices as a comparator-function.
     * @return  PieSliceSorter - function which sorts Slices of Pie with JavaScript API: Array.sort.
     */
    getSliceSorter(): SliceSorter<PieSlice>;
    /**
     * Set fill style of Pie Slices Labels.
     * @param   value   FillStyle object or function which creates a new style based on previous
     * @return          Pie Chart itself
     */
    setLabelFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of Pie Slice Labels.
     * @return  FillStyle object
     */
    getLabelFillStyle(): FillStyle;
    /**
     * Set font of Slice Labels.
     * @param   value   FontSettings or mutator function for existing settings
     * @return          Pie Chart itself
     */
    setLabelFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
    /**
     * Get font of Slice Labels.
     * @return  FontSettings
     */
    getLabelFont(): FontSettings;
    /**
     * Set formatter of Slice Labels.
     *
     * See [[SliceLabelFormatters]] for a collection of default options.
     * @param   labelFormatter  SliceLabelFormatter - function which generates text of Labels per Slice.
     * @return                  Pie Chart itself
     */
    setLabelFormatter(labelFormatter: SliceLabelFormatter<PieSlice>): this;
    /**
     * Get formatter of Slice Labels.
     * @return  SliceLabelFormatter - function which generates text of Labels per Slice.
     */
    getLabelFormatter(): SliceLabelFormatter<PieSlice>;
    /**
     * Sets if animations are enabled or not.
     * @param   animationsEnabled   Boolean state for animations enabled
     * @return                      Pie Chart itself
     */
    setAnimationsEnabled(animationsEnabled: boolean): this;
    /**
     * Gets if animations are enabled or not.
     * @return  Boolean state for animations enabled
     */
    getAnimationsEnabled(): boolean;
    /**
     * Disable all animations for the chart.
     *
     * All animations have to be re-enabled individually if you wish to re-enable animations.
     * @return      Chart itself for fluent interface.
     * @deprecated  Deprecated in v3.1.0. Will be removed in v4.0.0. Use [[setAnimationsEnabled]] instead.
     */
    disableAnimations(): this;
    /**
     * Set if slices should be highlighted on mouse hover / touch. Applies to all Slices.
     * @param state True if Slices should be highlighted on hover, false if not. This applies to all existing Slices and new Slices added.
     */
    setSliceHighlightOnHover(state: boolean): this;
}
/**
 * File contains different implementations of Pie Charts, each with their own rendering logic.
 */
/**
 * [[PieChart]] implementation that draws Slice Labels on its left and right sides.
 * Slices and Labels are connected by 'label connector lines'.
 */
export declare class PieChartWithLabelsOnSides extends PieChart {
    /**
     * Set style of Label connector lines.
     * @param   labelConnectorStyle LineStyle object
     * @return                      Pie Chart itself
     */
    setLabelConnectorStyle(labelConnectorStyle: LineStyle): this;
    /**
     * Get style of Label connector lines.
     * @return  LineStyle object
     */
    getLabelConnectorStyle(): LineStyle;
    /**
     * Set length of label connector line for an exploded Slice. For non-exploded Slices, the length will be the sum of
     * this and explosion offset.
     * @param   labelConnectorLength    Length as pixels
     * @return                          Pie Chart itself
     */
    setLabelConnectorLength(labelConnectorLength: pixel): this;
    /**
     * Get length of label connector line for an exploded Slice. For non-exploded Slices, the length will be the sum of
     * this and explosion offset.
     * @return  Length as pixels
     */
    getLabelConnectorLength(): number;
    /**
     * Set gap between Slice / start of label connector, and end of label connector / Label.
     * @param   labelConnectorGap   Gap as pixels
     * @return                      Pie Chart itself
     */
    setLabelConnectorGap(labelConnectorGap: pixel): this;
    /**
     * Get gap between Slice / start of label connector, and end of label connector / Label.
     * @return  Gap as pixels
     */
    getLabelConnectorGap(): number;
    /**
     * Get minimum size of Panel.
     * Depending on the type of class this value might be automatically computed to fit different elements.
     * @return  Vec2 minimum size or undefined if unimplemented
     */
    getMinimumSize(): Point | undefined;
}
/**
 * [[PieChart]] implementation that draws Slice Labels inside the Slices.
 * Works well when Label texts are short and there are not a lot of Slices, as the actual Pie has more space.
 * Public class
 */
export declare class PieChartWithLabelsInsideSlices extends PieChart {
    /**
     * Get minimum size of Panel.
     * Depending on the type of class this value might be automatically computed to fit different elements.
     * @return  Vec2 minimum size or undefined if unimplemented
     */
    getMinimumSize(): Point | undefined;
    /**
     * Set position of Labels.
     * @param   labelPositionInsideSlice    Position of labels inside their respective Slices as a number between [0, 1]
     * @return                              Pie Chart itself
     */
    setLabelPosition(labelPositionInsideSlice: number): this;
    /**
     * Get position of Labels.
     * @return  Position of labels inside their respective Slices as a number between [0, 1]
     */
    getLabelPosition(): number;
}
/**
 * Interface for readonly configuration of [[PieChart]].
 *
 * Some properties of `PieChart` can only be configured when it is created. These arguments are all optional, and are wrapped in a single object parameter:
 *
 * ```typescript
 *  // Example, create chart with specified color theme.
 *  const chart = LightningChart.Pie({
 *      theme: Themes.light,
 *  })
 * ```
 *
 * *Watch out!* The full set of available readonly configuration parameters depends on if the chart is *standalone*, or inside a *dashboard*:
 *
 * For *standalone* `PieChart`, more parameters are documented in [[LightningChart.Pie]].
 *
 * For *dashboard* `PieChart`, more parameters are documented in [[Dashboard.createPieChart]].
 *
 *
 * **Commonly used properties:**
 *
 * - [[PieChartOptions.type]]: Specify pie chart visual design from a collection of options.
 * - [[PieChartOptions.theme]]: Specify chart color *theme*.
 * - [[PieChartOptions.disableAnimations]]: Convenience flag to disable all animations from chart.
 *
 * **Example usage:**
 *
 * ```typescript
 *  // Example 1, create chart with default configuration.
 *  const chart = LightningChart.Pie({})
 * ```
 *
 * ```typescript
 *  // Example 2, create pie chart with labels inside slices.
 *  const chart = LightningChart.Pie({
 *      type: PieChartTypes.LabelsInsideSlices
 *  })
 * ```
 *
 * ```typescript
 *  // Example 3, create chart with specified color theme.
 *  const chart = LightningChart.Pie({
 *      theme: Themes.light,
 *  })
 * ```
 */
export interface PieChartOptions<PieChartType extends PieChartTypes> extends CommonChartOptions {
    /**
     * Specify pie chart visual design from a collection of options.
     *
     * Options are located in [[PieChartTypes]] collection. If undefined, will default to `PieChartTypes.LabelsOnSides`.
     */
    type?: PieChartType;
}
/**
 * Collection of [[PieChart]] implementations. Each option can have their own visual design, and *API* for customization of it.
 *
 * This must be specified when the [[PieChart]] is created (or default one will be used).
 *
 * Example usage:
 *```javascript
 * // Create a PieChart with specified type
 * LightningChart.Pie({ type: PieChartTypes.LabelsInsideSlices })
 * ```
 */
export declare const PieChartTypes: {
    /**
     * Pie Chart type, where Slice Labels are positioned on the left and right sides of Chart.
     * Labels are connected to their Slices with lines, which can be styled using unique API for this Pie Chart type.
     */
    LabelsOnSides: typeof PieChartWithLabelsOnSides;
    /**
     * Pie Chart type, where Slice Labels inside the Slices.
     * Works well when Label texts are short and there are not a lot of Slices, as the actual Pie has more space.
     */
    LabelsInsideSlices: typeof PieChartWithLabelsInsideSlices;
};
/**
 * @hidden
 */
export declare type PieChartTypes = typeof PieChartTypes[keyof typeof PieChartTypes];
/**
 * Possible Shape types for parts of a Slice.
 */
declare type PieSliceVisual = Arc | Text;
/**
 * Abstract class represents a Pie & Donut specific slice API.
 */
export declare abstract class PieSlice extends Slice<PieSliceVisual> {
    /**
     * Set is Slice exploded.
     * When a Slice is exploded, it is drawn differently from non-exploded state
     * - usually slightly "pushed away" from the center of Pie Chart.
     * @param   exploded    State of explosion as boolean
     * @return              Slice itself
     */
    abstract setExploded(exploded: boolean): this;
    /**
     * Get is Slice exploded.
     * When a Slice is exploded, it is drawn differently from non-exploded state
     * - usually slightly "pushed away" from the center of Pie Chart.
     * @return  State of explosion as boolean
     */
    abstract getExploded(): boolean;
}
/**
 * Internal class that hides some internal interfaces of a Slice that are only needed for interactions with the owning Pie Chart.
 * @hidden Internal class
 */
export declare class InternalPieSlice extends PieSlice {
    protected _chart: PieChart;
    readonly scale: LinearScaleXY;
    protected _removeFromChart: RemoveHandler<ChartComponent>;
    protected _restoreFromChart: RestoreHandler<ChartComponent>;
    /**
     * Index of Slice inside its owning Chart.
     * It tells how many Slices were created before this one.
     * It is not updated for disposed Slices, and so cannot be used for counting the amount of existing Slices.
     */
    readonly index: number;
    /**
     * @param   index               Index of Slice
     * @param    arcLayer           Rendering layer for Arc
     * @param    labelLayer         Rendering layer for Label
     * @param    _chart             Owning chart
     * @param    scale              Rendering scale
     * @param   _removeFromChart    Remove handler for Slice
     * @param    _restoreFromChart  Restore handler for Slice
     * @hidden
     */
    constructor(index: number, arcLayer: Layer2D, labelLayer: Layer2D, _chart: PieChart, scale: LinearScaleXY, _removeFromChart: RemoveHandler<ChartComponent>, _restoreFromChart: RestoreHandler<ChartComponent>, _theme: Theme);
    /**
     * Set value of Slice.
     * @param   value   Numeric value
     * @return          Slice itself
     */
    setValue(value: number): this;
    /**
     * Get value of Slice.
     * @return          Numeric value
     */
    getValue(): number;
    /**
     * Set is Slice exploded.
     * When a Slice is exploded, it is drawn differently from non-exploded state
     * - usually slightly "pushed away" from the center of Pie Chart.
     * @param   exploded    State of explosion as boolean
     * @return              Slice itself
     * @sideEffect          If set to true and Pie Chart multiple slice explosion is disabled,
     *                      this will unexplode any previously exploded Slices
     */
    setExploded(exploded: boolean): this;
    /**
     * Get is Slice exploded.
     * When a Slice is exploded, it is drawn differently from non-exploded state
     * - usually slightly "pushed away" from the center of Pie Chart.
     * @return  State of explosion as boolean
     */
    getExploded(): boolean;
    /**
     * Tell the owning chart to remove this component.
     * @return  Slice itself.
     */
    dispose(): this;
    /**
     * Tell the owning chart to restore this series.
     * @return  Slice itself.
     */
    restore(): this;
    /**
     * Method that owning Pie Chart uses to assign style of a Slice it owns.
     * @param   arcFillStyle    FillStyle for Arc
     * @param   arcStrokeStyle  LineStyle for Arc
     * @param   labelFillStyle  FillStyle for Label
     * @param   labelFont       FontSettings for Label
     */
    setStyle(arcFillStyle: FillStyle, arcStrokeStyle: LineStyle, labelFillStyle: FillStyle, labelFont: FontSettings): void;
    /**
     * Get animated value of Slice.
     * When value of Slice is changed, the animated value will not update immediately, but after an animation.
     * (if animations are not disabled).
     * @return  Animated value
     */
    getAnimatedValue(): number;
    /**
     * Get animated explosion state of Slice.
     * When state of Slice explosion is changed, this animated explosion value will move between 0 and 1 respectively,
     * but with an animation.
     * (if animations are not disabled).
     * @return  Animated value [0, 1]
     */
    getAnimatedExplosion(): number;
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Series itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick?: boolean): this;
    /**
     * Enable or disable forced highlighting of series
     * @param highLight True for enabled and false for disabled
     * @returns         Series itself for fluent interface
     */
    setHighlighted(highLight: boolean): this;
    /**
     * Method styles an attached entry according to Slice itself.
     */
    protected styleAttachedEntry(entry: LegendBoxEntry): void;
}
export {};
/**
 * File contains the logic for an abstract Pyramid Chart.
 * The rendering logic of a "Pyramid" is abstract and defined in a sub-class of this.
 */
/**
 * Enum for selecting different drawing approaches for [[PyramidChart]].
 *
 * Use with [[PyramidChart.setSliceMode]]
 */
export declare enum PyramidSliceModes {
    /**
     * Slices **height** represents its relative value inside the Pyramid Chart.
     */
    VariableHeight = 0,
    /**
     * Slices **width** represents its relative value inside the Pyramid Chart.
     */
    VariableWidth = 1
}
/**
 * Type of a PyramidChart constructor.
 * @hidden
 */
export declare type PyramidChartConstructor<T extends PyramidChart> = new (layerSupplier: LayerSupplier, scaleFactory: ScaleFactory, removeChart: (chart: Panel) => void, logoFactory?: LogoFactory, resizeEventInterface?: DashboardResizeEventInterface, theme?: Theme, _disableAnimations?: boolean) => T;
/**
 * Abstract base class for *Pyramid Charts*.
 * Visualizes proportions and percentages between categories, by dividing a pyramid into proportional segments.
 *
 * Set data using *PyramidChart*.**addSlice( name: string, value: number )**
 *
 * There are multiple implementations of *PyramidChart*, each with their own visual design and *API* for customizing it.
 * List of selectable options can be found in: [[PyramidChartTypes]]
 */
export declare abstract class PyramidChart extends Chart implements SlicedCharts<PyramidSlice> {
    /**
     * This method is used for the adding slices in the pyramid chart.
     * @param title Pyramid slice title
     * @param value  pyramid slice value
     */
    addSlice(title: string, value: number): PyramidSlice;
    /**
     * This method is used for the adding multiple slices in the pyramid chart.
     * @param slices Array of slices
     */
    addSlices(slices: {
        name: string;
        value: number;
    }[]): Array<PyramidSlice>;
    /**
     * Get all Slices of Pyramid Chart.
     * NOTE: Manual modifications to returned Array can have unforeseen side-effects.
     * Removing or adding Slices is intended to be done using other APIs (PyramidChart.addSlice, Slice.dispose, ...)
     * @return  Array of Slices
     */
    getSlices(): PyramidSlice[];
    /**
     * Set Pyramid Neck Width
     * @param neckWidth Pyramid Neck Width range from 0 to 100
     * @return          Pyramid Chart itself
     */
    setNeckWidth(neckWidth: number): this;
    /**
     * Get Pyramid Neck Width
     * @return  number (0 - 100)
     */
    getNeckWidth(): number;
    /**
     * Set gap between Slice / start of label connector, and end of label connector / Label.
     * @param   sliceGap   Gap as pixels. Clamped between [0, 20] !
     * @return             Pyramid Chart itself
     */
    setSliceGap(sliceGap: pixel): this;
    /**
     * Set PyramidSliceMode. Can be used to select between different drawing approaches for Slices.
     *
     * See [[PyramidSliceModes]] for a collection of options.
     * @param   sliceMode   PyramidSliceMode
     * @return              Pyramid Chart itself
     */
    setSliceMode(sliceMode: PyramidSliceModes): this;
    /**
     * Get PyramidSliceMode. Can be used to select between different drawing approaches for Slices.
     *
     * See [[PyramidSliceModes]] for a collection of options.
     * @return  PyramidSliceMode
     */
    getPyramidSliceMode(): PyramidSliceModes;
    /**
     * Attach lookup table (LUT) to fill the slices with Colors based on value.
     *
     * The color for the slice would be selected from a specified *LUT*, which contains the information about gradient steps.
     * After setting LUT to undefined all the slices stay colorized, but no further lookup.
     *
     * LUT class stores information about values and its associated colors,
     * * which provides efficient lookup of the color based on provided value
     * * as well as linear and step interpolation between colors.
     *
     * ``` javascript
     * const pyramid = lightningChart()
     *  .Pyramid( { type: PyramidChartTypes.LabelsOnSides } )
     *  .setLUT( new LUT (steps: [
     *          { value: 10, color: ColorRGBA( 0, 0, 0 ) },
     *          { value: 20, color: ColorRGBA( 30, 255, 0 ) },
     *          { value: 30, color: ColorRGBA( 60, 204, 0 ) },
     *          { value: 40, color: ColorRGBA( 90, 128, 0 ) },
     *          { value: 50, color: ColorRGBA( 255, 0, 0 ) } ) ],
     *      interpolate: true } )
     * ```
     * @param value     Lookup table
     * @returns         Pyramid itself for fluent interface
     */
    setLUT(value: LUT): this;
    /**
     * Set style of Pyramid Slices fill.
     * This style is managed as a continuous Palette of FillStyle objects. Each Slice of Pyramid will be assigned an incremental index,
     * which will be used to pick its fill style from this Palette.
     *
     * So, for example... We have a Pyramid Chart with 5 Slices, and we give it a Palette with only 3 possible values
     * (0 = red, 1 = green, 2 = blue). The resulting Slice fill styles will be: red, green, blue, red, green.
     * Note that this means, that the supplied Palette will have to work in a continuous manner!
     *
     * @param   sliceFillStylePalette   Palette for FillStyle objects
     * @return                          Pyramid Chart itself
     */
    setSliceFillStyle(sliceFillStylePalette: Palette<FillStyle>): this;
    /**
     * Get style of Pyramid Slices fill.
     * This style is managed as a continuous Palette of FillStyle objects. Each Slice of Pyramid will be assigned an incremental index,
     * which will be used to pick its fill style from this Palette.
     *
     * So, for example... We have a Pyramid Chart with 5 Slices, and we give it a Palette with only 3 possible values
     * (0 = red, 1 = green, 2 = blue). The resulting Slice fill styles will be: red, green, blue, red, green.
     * Note that this means, that the supplied Palette will have to work in a continuous manner!
     *
     * @return  Palette<FillStyle>
     */
    getSliceFillStyle(): Palette<FillStyle>;
    /**
     * Set style of Pyramid Slices Stroke.
     * @param   value   LineStyle object or function which creates a new style based on previous
     * @return          Pyramid Chart itself
     */
    setSliceStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of Pyramid Slices Stroke.
     * @return  LineStyle object
     */
    getSliceStrokeStyle(): LineStyle;
    /**
     * Set sorter of Pyramids' Slices as a comparator-function.
     *
     * For some commonly needed default implementations, can refer to SliceSorters-collection.
     * @param   sliceSorter SliceSorter - function which sorts Slices of Pyramid with JavaScript API: Array.sort.
     * @return              Pyramid Chart itself
     */
    setSliceSorter(sliceSorter: SliceSorter<PyramidSlice>): this;
    /**
     * Get sorter of Pyramids' Slices as a comparator-function.
     * @return  SliceSorter - function which sorts Slices of Pyramid with JavaScript API: Array.sort.
     */
    getSliceSorter(): SliceSorter<PyramidSlice>;
    /**
     * Set fill style of Pyramid Slices Labels.
     * @param   value   FillStyle object or function which creates a new style based on previous
     * @return          Pyramid Chart itself
     */
    setLabelFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of Pyramid Slice Labels.
     * @return  FillStyle object
     */
    getLabelFillStyle(): FillStyle;
    /**
     * Set font of Slice Labels.
     * @param   value   FontSettings or mutator function for existing settings
     * @return          Pyramid Chart itself
     */
    setLabelFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
    /**
     * Get font of Slice Labels.
     * @return  FontSettings
     */
    getLabelFont(): FontSettings;
    /**
     * Set formatter of Slice Labels.
     *
     * See [[SliceLabelFormatters]] for a collection of default options.
     * @param   labelFormatter  SliceLabelFormatter - function which generates text of Labels per Slice.
     * @return                  Pyramid Chart itself
     */
    setLabelFormatter(labelFormatter: SliceLabelFormatter<PyramidSlice>): this;
    /**
     * Get formatter of Slice Labels.
     * @return  SliceLabelFormatter - function which generates text of Labels per Slice.
     */
    getLabelFormatter(): SliceLabelFormatter<PyramidSlice>;
    /**
     * Sets if animations are enabled or not.
     * @param   animationsEnabled   Boolean state for animations enabled
     * @return                      Pyramid Chart itself
     */
    setAnimationsEnabled(animationsEnabled: boolean): this;
    /**
     * Gets if animations are enabled or not.
     * @return  Boolean state for animations enabled
     */
    getAnimationsEnabled(): boolean;
    /**
     * Disable all animations for the chart.
     *
     * All animations have to be re-enabled individually if you wish to re-enable animations.
     * @return      Chart itself for fluent interface.
     * @deprecated  Deprecated in v3.1.0. Will be removed in v4.0.0. Use [[setAnimationsEnabled]] instead.
     */
    disableAnimations(): this;
    /**
     * Set if slices should be highlighted on mouse hover / touch. Applies to all Slices.
     * @param state True if Slices should be highlighted on hover, false if not. This applies to all existing Slices and new Slices added.
     */
    setSliceHighlightOnHover(state: boolean): this;
    /**
     * **Permanently** dispose the component.
     *
     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
     * **to the component and its children** in application code.
     * ```javascript
     * let chart = ...Pyramid()
     * let slice = chart.addSlice({name: 'name', value: 50})
     * // Dispose Chart, and remove all references so that they can be garbage-collected.
     * chart.dispose()
     * chart = undefined
     * slice = undefined
     * ```
     * @return  Object itself for fluent interface
     */
    dispose(): this;
}
/**
 * File contains different implementations of Pyramid Charts, each with their own rendering logic.
 */
/**
 * [[PyramidChart]] implementation that draws Slice Labels on its left and right sides.
 * Slices and Labels are connected by 'label connector lines'.
 */
export declare class PyramidChartWithLabelsOnSides extends PyramidChart {
    /**
     * Set style of Label connector lines.
     * @param   labelConnectorStyle LineStyle object
     * @return                      Pyramid Chart itself
     */
    setLabelConnectorStyle(labelConnectorStyle: LineStyle): this;
    /**
     * Get style of Label connector lines.
     * @return  LineStyle object
     */
    getLabelConnectorStyle(): LineStyle;
    /**
     * Set gap between Slice / start of label connector, and end of label connector / Label.
     * @param   labelConnectorGap   Gap as pixels
     * @return                      Pyramid Chart itself
     */
    setLabelConnectorGap(labelConnectorGap: pixel): this;
    /**
     * Get gap between Slice / start of label connector, and end of label connector / Label.
     * @return  Gap as pixels
     */
    getLabelConnectorGap(): number;
    /**
     * Set the side where label should display
     * @param   labelSide   Left / Right
     * @return              Pyramid Chart itself
     */
    setLabelSide(labelSide: PyramidLabelSide): this;
    /**
     * Get the side where label shown
     * @return The label side
     */
    getLabelSide(): PyramidLabelSide;
    /**
     * Get minimum size of Panel.
     * Depending on the type of class this value might be automatically computed to fit different elements.
     * @return  Point minimum size or undefined if unimplemented
     */
    getMinimumSize(): Point | undefined;
}
/**
 * [[PyramidChart]] implementation that draws Slice Labels inside the Slices.
 * Works well when Label texts are short and there are not a lot of Slices, as the actual Pyramid has more space.
 */
export declare class PyramidChartWithLabelsInsideSlices extends PyramidChart {
    /**
     * Get minimum size of Panel.
     * Depending on the type of class this value might be automatically computed to fit different elements.
     * @return      Point
     */
    getMinimumSize(): Point | undefined;
}
/**
 * Interface for readonly configuration of [PyramidChart](../classes/pyramidchart.html).
 *
 * Some properties of `PyramidChart` can only be configured when it is created. These arguments are all optional, and are wrapped in a single object parameter:
 *
 * ```typescript
 *  // Example, create chart with specified color theme.
 *  const chart = LightningChart.Pyramid({
 *      theme: Themes.light,
 *  })
 * ```
 *
 * *Watch out!* The full set of available readonly configuration parameters depends on if the chart is *standalone*, or inside a *dashboard*:
 *
 * For *standalone* `PyramidChart`, more parameters are documented in [[LightningChart.Pyramid]].
 *
 * For *dashboard* `PyramidChart`, more parameters are documented in [[Dashboard.createPyramidChart]].
 *
 *
 * **Commonly used properties:**
 *
 * - [[PyramidChartOptions.type]]: Specify visual design of *pyramid chart* from a collection of options.
 * - [[PyramidChartOptions.theme]]: Specify chart color *theme*.
 * - [[PyramidChartOptions.disableAnimations]]: Convenience flag to disable all animations from chart.
 *
 * **Example usage:**
 *
 * ```typescript
 *  // Example 1, create pyramid chart with default configuration.
 *  const chart = LightningChart.Pyramid({})
 * ```
 *
 * ```typescript
 *  // Example 2, create pyramid chart with labels inside slices.
 *  const chart = LightningChart.Pyramid({
 *      type: PyramidChartTypes.LabelsInsideSlices
 *  })
 * ```
 *
 * ```typescript
 *  // Example 3, create pyramid chart with specified color theme.
 *  const chart = LightningChart.Pyramid({
 *      theme: Themes.light,
 *  })
 * ```
 */
export interface PyramidChartOptions<PyramidChartType extends PyramidChartTypes> extends CommonChartOptions {
    /**
     * Interface for specifying desired "type" of Pyramid Chart.
     * This can be used to select different rendering approaches, mainly reflecting how Slice Labels are positioned.
     *
     * Options are located in [[PyramidChartTypes]] collection. If undefined, will default to [[PyramidChartWithLabelsOnSides]].
     */
    type?: PyramidChartType;
}
/**
 * Collection of [[PyramidChart]] implementations. Each option can have their own visual type, and *API* for customization of it.
 *
 * This must be specified when the [[PyramidChart]] is created (or default one will be used).
 *
 * Example usage:
 *```javascript
 * // Create a PyramidChart with default type
 * LightningChart.Pyramid()
 * // Create a PyramidChart with specified type
 * LightningChart.Pyramid({ type: PyramidChartTypes.LabelsInsideSlices })
 * ```
 */
export declare const PyramidChartTypes: {
    /**
     * Pyramid Chart type, where Slice Labels are positioned on the either left or right sides of Chart.
     * The side can be set using setLabelSide
     * Labels are connected to their Slices with lines, which can be styled using unique API for this Pyramid Chart type.
     */
    LabelsOnSides: typeof PyramidChartWithLabelsOnSides;
    /**
     * Pyramid Chart type, where Slice Labels inside the Slices.
     */
    LabelsInsideSlices: typeof PyramidChartWithLabelsInsideSlices;
};
/**
 * Available Pyramid Chart types
 * @hidden
 */
export declare type PyramidChartTypes = typeof PyramidChartTypes[keyof typeof PyramidChartTypes];
/**
 * Options for selecting side of labels in a [[PyramidChartWithLabelsOnSides]].
 *
 * Use with [[PyramidChartWithLabelsOnSides.setLabelSide]]
 */
export declare enum PyramidLabelSide {
    /**
     * Label Side  - Right
     */
    Right = 0,
    /**
     * Label Side  - Left
     */
    Left = 1
}
/**
 * Possible Shape types for parts of a Slice.
 */
declare type PyramidSliceVisual = Polygon | Text;
/**
 * Class that represents a single Slice of a Pyramid Chart.
 * It is given to users when a Slice is added.
 */
export declare abstract class PyramidSlice extends Slice<PyramidSliceVisual> {
    /**
     * Set value of Slice.
     * @param   value   Numeric value
     * @return          Slice itself
     */
    abstract setValue(value: number): this;
    /**
     * Get value of Slice.
     * @return          Numeric value
     */
    abstract getValue(): number;
}
/**
 * Internal class that hides some internal interfaces of a Slice that are only needed for interactions with the owning Pyramid Chart.
 * @hidden
 */
export declare class InternalPyramidSlice extends PyramidSlice {
    protected _chart: PyramidChart;
    readonly scale: LinearScaleXY;
    protected _removeFromChart: RemoveHandler<ChartComponent>;
    protected _restoreFromChart: RestoreHandler<ChartComponent>;
    /**
     * Index of Slice inside its owning Chart.
     * It tells how many Slices were created before this one.
     * It is not updated for disposed Slices, and so cannot be used for counting the amount of existing Slices.
     */
    readonly index: number;
    /**
     * @param   index               Index of Slice
     * @param    polygonLayer       Rendering layer for Polygon
     * @param    labelLayer         Rendering layer for Label
     * @param    _chart             Owning chart
     * @param    scale              Rendering scale
     * @param   _removeFromChart    Remove handler for Slice
     * @param    _restoreFromChart  Restore handler for Slice
     * @hidden
     */
    constructor(index: number, polygonLayer: Layer2D, labelLayer: Layer2D, _chart: PyramidChart, scale: LinearScaleXY, _removeFromChart: RemoveHandler<ChartComponent>, _restoreFromChart: RestoreHandler<ChartComponent>, _theme: Theme);
    /**
     * Set value of Slice.
     * @param   value   Numeric value
     * @return          Slice itself
     */
    setValue(value: number): this;
    /**
     * Get value of Slice.
     * @return          Numeric value
     */
    getValue(): number;
    /**
     * Tell the owning chart to remove this component.
     * @return  Slice itself.
     */
    dispose(): this;
    /**
     * Tell the owning chart to restore this series.
     * @return  Slice itself.
     */
    restore(): this;
    /**
     * Method that owning Pyramid Chart uses to assign style of a Slice it owns.
     * @param   polygonFillStyle    FillStyle for Polygon
     * @param   polygonStrokeStyle  LineStyle for Polygon
     * @param   labelFillStyle  FillStyle for Label
     * @param   labelFont       FontSettings for Label
     */
    setStyle(polygonFillStyle: FillStyle, polygonStrokeStyle: LineStyle, labelFillStyle: FillStyle, labelFont: FontSettings): void;
    /**
     * Get animated value of Slice.
     * When value of Slice is changed, the animated value will not update immediately, but after an animation.
     * (if animations are not disabled).
     * @return  Animated value
     */
    getAnimatedValue(): number;
    /**
     * Attach series to an annotation.
     * @param entry Object which has to be attached
     * @return      Series itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick?: boolean): this;
    /**
     * Enable or disable forced highlighting of series
     * @param highLight True for enabled and false for disabled
     * @returns         Series itself for fluent interface
     */
    setHighlighted(highLight: boolean): this;
    /**
     * Method styles an attached entry according to Slice itself.
     */
    protected styleAttachedEntry(entry: LegendBoxEntry): void;
}
export {};
/**
 * Implementation specific values necessary for tick plotting.
 * @hidden
 */
interface TickPlottingVariables extends AbstractTickPlottingVariables {
    /**
     *
     */
    startPosition: number;
    /**
     *
     */
    gridStrokeLen: number;
    /**
     * Height level of Grid Stroke Start
     */
    gridStrokeStart: pixel;
    /**
     * Height level of Tick Stroke Start
     */
    tickStart: number;
}
/**
 * Implementation of 2D Axis Tick.
 * @hidden
 */
export declare class Tick extends AbstractAxisTick {
    protected readonly _gridlineLayer: Layer2D;
    protected readonly _gridlineScale: ScaleXY;
    /**
     * @param   tickLevel       AxisTickLevel tick belongs to.
     * @param   value           Position of Tick on Axis.
     * @param   _removeFromAxis Remove handler for Tick.
     * @param   _restoreToAxis  Restore handler for Tick.
     * @param   _labelLayer     Layer for rendering Tick Label.
     * @param   _labelScale     Scale for rendering Tick label.
     * @param   _gridlineLayer  Layer for rendering Gridline shape.
     * @param   _gridlineScale  Scale for rendering Gridline shape.
     * @param   label           Optionally injectable Tick Label shape.
     *                          Injection can be useful to reuse Tick shapes for performance.
     */
    constructor(tickLevel: AxisTickLevel, value: number, _removeFromAxis: RemoveHandler<AbstractAxisTick>, _restoreToAxis: RestoreHandler<AbstractAxisTick>, _labelLayer: Layer2D, _labelScale: LinearScaleXY | RadialScale | MixedScaleXY, _gridlineLayer: Layer2D, _gridlineScale: ScaleXY, label?: Text);
}
/**
 * *Axis* is a child component of *ChartXY*. It defines a numeric range on a single plane (*X* or *Y*),
 * that will be used to scale attached *Series* to the *ChartXY*s viewport.
 *
 * The default `Axis` can be referenced with [[ChartXY.getDefaultAxisX]] and [[ChartXY.getDefaultAxisY]].
 *
 * `ChartXY` doesn't have a limit on number of *axes*. Additional *axes* can be created with [[ChartXY.addAxisX]] and [[ChartXY.addAxisY]].
 * Multiple *Axes* can be stacked on top of another, and *axes* can be positioned on either side of the *chart* (left, right, top, bottom, see [[AxisOptions]]).
 *
 * The visual components of *axis* are:
 * - Title. By default *axis* has no title. It can be enabled with [[Axis.setTitle]].
 * - Axis line. A single horizontal line for *X axes*, and vertical line for *Y axes*. It can be styled with [[Axis.setStrokeStyle]].
 * - [Ticks](#axis-ticks). Labels that help understand the data visualized along an axis.
 *   - [Numeric ticks](#numeric-ticks)
 *   - [Datetime ticks](#datetime-ticks)
 *   - [Custom ticks](#custom-ticks)
 *
 * - [Highlighters](#axis-highlighters). Can be used to highlight positions or areas on an *axis*.
 *
 * See [Scrolling and interval configuration](#axis-automatic-scrolling-and-axis-intervals-configuration) for detailed information about management of *axis interval*.
 *
 * #### Axis Ticks
 *
 * Ticks are labels attached to the *axis line* that visualize the progression of values along the *axis*. A tick consists of three individually stylable parts:
 * - Label (text)
 * - Tick line.
 * - Grid line.
 *
 * There are currently three different ways of managing axis ticks:
 * 1. Automatic numeric ticks (default).
 * 3. Automatic time ticks.
 * 2. Automatic datetime ticks.
 * 4. Custom ticks.
 *
 * ##### Numeric ticks
 *
 * Numeric ticks are enabled by default for all *axes*.
 * They are designed for depicting numeric values of all magnitudes.
 *
 * Configuring the ticks is done with [[Axis.setTickStrategy]].
 *
 * ```typescript
 * Axis.setTickStrategy(AxisTickStrategies.Numeric, (strategy) => strategy
 *   // Configure NumericTickStrategy
 *   .setMinorFormattingFunction((tickPosition) => `X: ${tickPosition}`)
 *   .setMinorTickStyle((tickStyle: VisibleTicks) => tickStyle
 *     .setTickLength(12)
 *     .setTickPadding(2)
 *   )
 * )
 * ```
 *
 * Frequently used API:
 *
 * - [[NumericTickStrategy.setMajorFormattingFunction]] | set formatting of major ticks labels text.
 * - [[NumericTickStrategy.setMinorFormattingFunction]] | set formatting of minor ticks labels text.
 * - [[NumericTickStrategy.setMajorTickStyle]] | set style of major ticks.
 * - [[NumericTickStrategy.setMinorTickStyle]] | set style of minor ticks.
 *
 * For full list of configuration API, see [[NumericTickStrategy]].
 *
 * Examples showcasing *numeric axes*:
 * - [Shared Axis example](https://www.arction.com/lightningchart-js-interactive-examples/examples/lcjs-example-0007-sharedAxis.html)
 *
 * ##### Time ticks
 *
 * Time ticks are designed for depicting time ranges between hundreds of hours to individual nanoseconds.
 *
 * They are enabled, as well as configured, with [[Axis.setTickStrategy]].
 *
 * ```typescript
 * Axis.setTickStrategy(AxisTickStrategies.Time, (strategy) => strategy
 *   // Configure TimeTickStrategy
 *   .setMinorFormattingFunction((tickPosition) => `X: ${tickPosition}`)
 *   .setMinorTickStyle((tickStyle: VisibleTicks) => tickStyle
 *     .setTickLength(12)
 *     .setTickPadding(2)
 *   )
 * )
 * ```
 *
 * Frequently used API:
 *
 * - [[TimeTickStrategy.setMajorFormattingFunction]] | set formatting of major ticks labels text.
 * - [[TimeTickStrategy.setMinorFormattingFunction]] | set formatting of minor ticks labels text.
 * - [[TimeTickStrategy.setMajorTickStyle]] | set style of major ticks.
 * - [[TimeTickStrategy.setMinorTickStyle]] | set style of minor ticks.
 *
 * For full list of configuration API, see [[TimeTickStrategy]].
 *
 * Examples showcasing `TimeTickStrategy`:
 * - No listed examples as of yet.
 *
 * ##### Datetime ticks
 *
 * DateTime ticks are enabled, as well as configured, with [[Axis.setTickStrategy]].
 *
 * ```typescript
 * Axis.setTickStrategy(AxisTickStrategies.DateTime, (strategy) => strategy
 *   // Configure DateTimeTickStrategy
 *   .setMinorTickStyle((tickStyle: VisibleTicks) => tickStyle
 *     .setTickLength(12)
 *     .setTickPadding(2)
 *   )
 * )
 * ```
 *
 * Frequently used API:
 * - [[DateTimeTickStrategy.setMajorTickStyle]] | set style of major ticks.
 * - [[DateTimeTickStrategy.setMinorTickStyle]] | set style of minor ticks.
 * - [[DateTimeTickStrategy.setDateOrigin]] | set date origin (required for most applications with zooming enabled).
 *
 * For full list of configuration API, see [[DateTimeTickStrategy]].
 *
 * Examples showcasing *datetime axes*:
 * - [Datetime Axis example](https://www.arction.com/lightningchart-js-interactive-examples/examples/lcjs-example-0020-dateTimeAxis.html)
 *
 * ##### Custom ticks
 *
 * Automatic creation of ticks can be disabled with [[Axis.setTickStrategy]]:
 *
 * ```typescript
 * // Disable automatic axis ticks.
 * Axis.setTickStrategy(AxisTickStrategies.Empty)
 * ```
 *
 * *Custom ticks* can be created with [[Axis.addCustomTick]]:
 *
 * ```typescript
 * // Create custom ticks.
 * for (let x = 0; x < 100; x += 10) {
 *   const tick = Axis.addCustomTick(UIElementBuilders.AxisTick)
 * }
 * ```
 *
 * Frequently used `CustomTick` API:
 * - [[CustomTick.setValue]] | configure position of tick on *axis*.
 * - [[CustomTick.setTextFormatter]] | configure text displayed by tick label using a callback function.
 * - [[CustomTick.setTickLength]] | configure length of tick line.
 * - [[CustomTick.setGridStrokeStyle]] | style tick grid line.
 * - [[CustomTick.setMarker]] | style tick label and/or tick line.
 * - [[CustomTick.dispose]] | remove tick, either permanently or momentarily.
 * - [[CustomTick.restore]] | restore tick after `dispose()`.
 *
 * Examples showcasing *custom axis ticks*:
 * - [Custom Axis Ticks example](https://www.arction.com/lightningchart-js-interactive-examples/examples/lcjs-example-0011-customTicksScrolling.html)
 *
 * #### Axis automatic scrolling and Axis intervals configuration
 *
 * *Axis interval* is the range of data values that are visible on the *Axis*, they are referred to as *start* and *end*.
 *
 * By default, all *axes* fit the interval automatically to reveal all attached *series*. This behavior is called *fitting scroll strategy*.
 *
 * Automatic scrolling behavior can be controlled by selecting the *scroll strategy*, with [[Axis.setScrollStrategy]]:
 *
 * ```typescript
 * // Select progressive scroll strategy.
 * Axis.setScrollStrategy(AxisScrollStrategies.progressive)
 * ```
 *
 * Following *scroll strategies* are supported:
 * - [[AxisScrollStrategies.fitting]] (default) | axis will automatically scroll to contain the boundaries of all attached *series*.
 * - [[AxisScrollStrategies.expansion]] | same as 'fitting', but will never decrease axis interval.
 * - [[AxisScrollStrategies.progressive]] | axis will keep distance between *start* and *end* constant, and scroll to reveal series boundaries that go higher than active axis interval.
 * - [[AxisScrollStrategies.regressive]] | axis will keep distance between *start* and *end* constant, and scroll to reveal series boundaries that go lower than active axis interval.
 * - `undefined` | automatic scrolling is disabled.
 *
 * Axis interval can be manually set with [[Axis.setInterval]]:
 *
 * ```typescript
 * // Axis start = 0, end = 100.
 * Axis.setInterval(0, 100)
 * ```
 *
 * However, if automatic scrolling is either 'fitting' or 'expansion' the configured axis interval might immediately be overridden.
 *
 * Frequently used methods:
 * - [[Axis.setScrollStrategy]] | configure automatic scrolling behavior.
 * - [[Axis.setInterval]] | configure active axis interval.
 * - [[Axis.getInterval]] | get active axis interval.
 * - [[Axis.fit]] | fit axis interval to contain all attached series boundaries.
 * - [[Axis.stop]] | stop automatic scrolling momentarily.
 * - [[Axis.onScaleChange]] | trigger a custom action whenever axis scale changes.
 * - [[Axis.setAnimationScroll]] | Enable/disable automatic scrolling animation.
 *
 * ##### Axis interval limitations
 *
 * *LightningChart JS* is easily the market leader in zooming interactions and visualization resolution, and contrary to most chart libraries, we are open about axis zooming limits;
 *
 * "Axis zooming limits" refer to constraints on the magnitude of Axis interval, which is calculated as `Math.abs(end - start)`.
 * When the limit is reached, the Axis will not be able to zoom in and out further by programmatic calls ([[Axis.setInterval]]) or user interactions.
 *
 * The constraints are primarily affected by two factors:
 * - Active *Tick Strategy*.
 * - Axis type.
 *
 * Both of these factors have their own definition of support minimum and maximum Axis interval, and when combined the lesser values are used.
 * For example, if *Tick Strategy* would allow min interval of `0.001` and *Axis type* `0.005`, effectively the min interval would be `0.001`.
 *
 * The Axis interval limits imposed by each available *Tick Strategy* are documented at [[AxisTickStrategies]].
 *
 * The Axis interval limits imposed by *Axis Type* are documented at [[AxisOptions]].
 *
 * #### Axis highlighters
 *
 * Two kinds of *highlighters* are supported:
 * - [[ConstantLine]] | highlights a position on the Axis.
 * - [[Band]] | highlights a range on the Axis.
 *
 * Examples showcasing *axis highlighters*:
 * - [Bands and ConstantLines example](https://www.arction.com/lightningchart-js-interactive-examples/examples/lcjs-example-0701-bandsConstantlines.html)
 */
export declare class Axis extends GenericAxis<LinearScale1D | LogarithmicScale1D, ChartXY, SeriesXY, DimensionalAxisStrategy, Tick, TickPlottingVariables, undefined> implements Validatable, Disposable, StylableAxisLine {
    protected readonly _gridlineLayer: Layer2D;
    protected readonly _layeredGridlineLayers: Layer2D[];
    protected readonly _fg: Layer2D;
    protected readonly _ui: Layer2D;
    protected readonly _layerHighlightersBelow: Layer2D;
    protected readonly _layerHighlightersAbove: Layer2D;
    readonly chart: ChartXY;
    protected _removeAxis: (axis: Axis) => void;
    protected _restoreAxis: (axis: Axis) => void;
    /**
     * @param _gridlineLayer            Rendering Layer for non-layered Grid lines.
     * @param  _layeredGridlineLayers   List of rendering layers for layered tick level grid lines. ChartXY is responsible for creating enough layers for all tick strategies' needs.
     * @param _fg                       Rendering Layer for Axis, Ticks and Title.
     * @param _ui                       Rendering Layer for user interaction Shapes.
     * @param _layerHighlightersBelow   Rendering layer for Highlighters with "below" setting.
     * @param _layerHighlightersAbove   Rendering layer for Highlighters with "above" setting.
     * @param scale                     Scale of the Axis value
     * @param _heightScale              Height Scale or the Axis
     * @param _axisStrategy             Axis strategy, defines X or Y positing
     * @param chart                     Chart that owns the Axis.
     * @param _uiPosition               UI position in percents. 0 means bottom/right, 100 means top/left,
     *                                  anything in between places the axis in the custom position along the chart's space
     * @param _removeAxis               Injected remove method from owner.
     * @param _restoreAxis              Injected restore method from owner.
     * @param setSeriesAttachHandler    Function that axis calls to inject series attach handler to its owning chart.
     * @param _theme                    Theme from owning chart, used to apply styling to Axis.
     *                                  Cached for sub components of Axis (custom tick, highlighters, etc.)
     * @param _disableAnimations        Disable animations by default
     * @param
     * @hidden
     */
    constructor(_gridlineLayer: Layer2D, _layeredGridlineLayers: Layer2D[], _fg: Layer2D, _ui: Layer2D, _layerHighlightersBelow: Layer2D, _layerHighlightersAbove: Layer2D, scale: LinearScale1D | LogarithmicScale1D, heightScale: LinearScale1D, _axisStrategy: DimensionalAxisStrategy, chart: ChartXY, _uiPosition: number, _removeAxis: (axis: Axis) => void, _restoreAxis: (axis: Axis) => void, setSeriesAttachHandler: (axis: Axis, handler: AxisAttachHandler) => void, _theme: Theme, _animationsDefaultDisable: boolean, _axisType: InternalAxisType);
    /**
     * Add a highlighter Band to the Axis.
     * A Band can be used to highlight an interval on the Axis.
     *
     * @param   onTop   Is Band rendered above Series, or below. Default to above.
     * @return          Band object.
     */
    addBand(onTop?: boolean): Band;
    /**
     * Add a highlighter ConstantLine to the Axis.
     * A ConstantLine can be used to highlight a specific value on the Axis.
     *
     * @param   onTop   Is ConstantLine rendered above Series, or below. Default to above.
     * @return          ConstantLine object.
     */
    addConstantLine(onTop?: boolean): ConstantLine;
    /**
     * Get all Highlighters of Axis.
     * @return  array of highlighters
     */
    getHighlighters(): Highlighter[];
    /**
     * Add event listener to Mouse Click on Axis
     * @param clbk      Event listener for Mouse Click Event
     * @returns         Token of subscription
     */
    onAxisInteractionAreaMouseClick: (clbk: MouseEventHandler<this>) => Token;
    /**
     * Add event listener to Mouse Double Click on Axis
     * @param clbk      Event listener for Mouse Double Click Event
     * @returns         Token of subscription
     */
    onAxisInteractionAreaMouseDoubleClick: (clbk: MouseEventHandler<this>) => Token;
    /**
     * Add event listener to Mouse Down on Axis
     * @param clbk      Event listener for Mouse Down Event
     * @returns         Token of subscription
     */
    onAxisInteractionAreaMouseDown: (clbk: MouseEventHandler<this>) => Token;
    /**
     * Add event listener to Mouse Up on Axis
     * @param clbk      Event listener for Mouse Up Event
     * @returns         Token of subscription
     */
    onAxisInteractionAreaMouseUp: (clbk: MouseEventHandler<this>) => Token;
    /**
     * Add event listener to Mouse Enter Event on Axis
     * @param clbk      Event listener function for Mouse Enter Event
     * @returns         Token of subscription
     */
    onAxisInteractionAreaMouseEnter: (clbk: MouseEventHandler<this>) => Token;
    /**
     *  Add event listener to Mouse Leave Event on Axis
     * @param clbk      Event listener function for Mouse Leave Event
     * @returns         Token of subscription
     */
    onAxisInteractionAreaMouseLeave: (clbk: MouseEventHandler<this>) => Token;
    /**
     *  Add event listener to Mouse Move on Axis
     * @param clbk      Event listener function for Mouse Move
     * @returns         Token of subscription
     */
    onAxisInteractionAreaMouseMove: (clbk: MouseEventHandler<this>) => Token;
    /**
     *  Add event listener to Mouse Wheel event on Axis
     * @param clbk      Event listener function for Mouse Wheel
     * @returns         Token of subscription
     */
    onAxisInteractionAreaMouseWheel: (clbk: MouseWheelEventHandler<this>) => Token;
    /**
     *  Add event listener to Mouse Drag Start event on Axis
     * @param clbk      Event listener function for Mouse Drag Start
     * @returns         Token of subscription
     */
    onAxisInteractionAreaMouseDragStart: (clbk: MouseDragStartEventHandler<this>) => Token;
    /**
     *  Add event listener to Mouse Drag event on Axis
     * @param clbk      Event listener function for Mouse Drag
     * @returns         Token of subscription
     */
    onAxisInteractionAreaMouseDrag: (clbk: MouseDragEventHandler<this>) => Token;
    /**
     *  Add event listener to Mouse Drag Stop event on Axis
     * @param clbk      Event listener function for Mouse Drag Stop
     * @returns         Token of subscription
     */
    onAxisInteractionAreaMouseDragStop: (clbk: MouseDragStopEventHandler<this>) => Token;
    /**
     *  Add event listener to Touch Start event on Axis
     * @param clbk      Event listener function for Touch Start
     * @returns         Token of subscription
     */
    onAxisInteractionAreaTouchStart: (clbk: TouchEventHandler<this>) => Token;
    /**
     *  Add event listener to Mouse Touch event on Axis
     * @param clbk      Event listener function for Mouse Touch
     * @returns         Token of subscription
     */
    onAxisInteractionAreaTouch: (clbk: TouchEventHandler<this>) => Token;
    /**
     *  Add event listener to Mouse Touch Stop event on Axis
     * @param clbk      Event listener function for Mouse Touch Stop
     * @returns         Token of subscription
     */
    onAxisInteractionAreaTouchStop: (clbk: TouchEventHandler<this>) => Token;
    /**
     *  Add event listener to Mouse Drag Start event on Axis
     * @param clbk      Event listener function for Mouse Drag Start
     * @returns         Token of subscription
     * @deprecated      Deprecated in v3.3.0. Will be removed in v4.0.0. Use [[onAxisInteractionAreaMouseDragStart]] instead.
     */
    onAxisAreaMouseDragStart: (clbk: MouseDragStartEventHandler<this>) => Token;
    /**
     *  Add event listener to Mouse Drag event on Axis
     * @param clbk      Event listener function for Mouse Drag
     * @returns         Token of subscription
     * @deprecated      Deprecated in v3.3.0. Will be removed in v4.0.0. Use [[onAxisInteractionAreaMouseDrag]] instead.
     */
    onAxisAreaMouseDrag: (clbk: MouseDragEventHandler<this>) => Token;
    /**
     *  Add event listener to Mouse Drag Stop event on Axis
     * @param clbk      Event listener function for Mouse Drag Stop
     * @returns         Token of subscription
     * @deprecated      Deprecated in v3.3.0. Will be removed in v4.0.0. Use [[onAxisInteractionAreaMouseDragStop]] instead.
     */
    onAxisAreaMouseDragStop: (clbk: MouseDragStopEventHandler<this>) => Token;
    /**
     *  Add event listener to Touch Start event on Axis
     * @param clbk      Event listener function for Touch Start
     * @returns         Token of subscription
     * @deprecated      Deprecated in v3.3.0. Will be removed in v4.0.0. Use [[onAxisInteractionAreaTouchStart]] instead.
     */
    onAxisInteractionAreaMouseTouchStart: (clbk: TouchEventHandler<this>) => Token;
    /**
     *  Add event listener to Touch Start event on Axis
     * @param clbk      Event listener function for Touch
     * @returns         Token of subscription
     * @deprecated      Deprecated in v3.3.0. Will be removed in v4.0.0. Use [[onAxisInteractionAreaTouch]] instead.
     */
    onAxisInteractionAreaMouseTouch: (clbk: TouchEventHandler<this>) => Token;
    /**
     *  Add event listener to Touch Stop event on Axis
     * @param clbk      Event listener function for Touch Start Stop
     * @returns         Token of subscription
     * @deprecated      Deprecated in v3.3.0. Will be removed in v4.0.0. Use [[onAxisInteractionAreaTouchStop]] instead.
     */
    onAxisInteractionAreaMouseTouchStop: (clbk: TouchEventHandler<this>) => Token;
    /**
     * Remove event listener from  Mouse Click event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offAxisInteractionAreaMouseClick: (token: Token) => boolean;
    /**
     * Remove event listener from  Mouse Double Click event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offAxisInteractionAreaMouseDoubleClick: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Down event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offAxisInteractionAreaMouseDown: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Up event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offAxisInteractionAreaMouseUp: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Enter event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offAxisInteractionAreaMouseEnter: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Leave event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offAxisInteractionAreaMouseLeave: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Move event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offAxisInteractionAreaMouseMove: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Wheel event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offAxisInteractionAreaMouseWheel: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Drag Start event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offAxisInteractionAreaMouseDragStart: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Drag event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offAxisInteractionAreaMouseDrag: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Drag Stop event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offAxisInteractionAreaMouseDragStop: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Touch Start event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offAxisInteractionAreaTouchStart: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Touch event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offAxisInteractionAreaTouch: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Touch Stop event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     */
    offAxisInteractionAreaTouchStop: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Touch Start event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     * @deprecated      Deprecated in v3.3.0. Will be removed in v4.0.0. Use [[offAxisInteractionAreaTouchStart]] instead.
     */
    offAxisInteractionAreaMouseTouchStart: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Touch event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     * @deprecated      Deprecated in v3.3.0. Will be removed in v4.0.0. Use [[offAxisInteractionAreaTouch]] instead.
     */
    offAxisInteractionAreaMouseTouch: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Touch Stop event
     * @param   token   Token of event listener which has to be removed
     * @return          True if the listener is successfully removed and false if it is not found
     * @deprecated      Deprecated in v3.3.0. Will be removed in v4.0.0. Use [[offAxisInteractionAreaTouchStop]] instead.
     */
    offAxisInteractionAreaMouseTouchStop: (token: Token) => boolean;
    /**
     * Set Axis *thickness* as pixels.
     *
     * For X Axis, this means Axis height.
     *
     * For Y Axis, this means Axis width.
     *
     * ```
     *  // Example syntax,
     *  Axis.setThickness( 60 )
     * ```
     *
     * @param   thickness   Explicit thickness of Axis as pixels.
     * @return              Object itself for fluent interface.
     */
    setThickness(thickness: number): this;
    /**
     * Configure Axis *thickness* min/max limits as pixels.
     *
     * The thickness of Axis is calculated based on ticks, title, axis line, etc.
     * By setting `min` and/or `max` thickness, the size allocated for Axis can be restricted to desired limits.
     *
     * For X Axis, this means Axis height.
     *
     * For Y Axis, this means Axis width.
     *
     * ```
     *  // Example syntax, set axis to at least 100 px thick, but allow larger axis thickness if labels are large, or other such scenario.
     *  Axis.setThickness({ min: 100, max: undefined })
     * ```
     *
     * @param   thickness   Explicit thickness of Axis as pixels.
     * @return              Object itself for fluent interface.
     */
    setThickness(thickness: {
        min?: number;
        max?: number;
    }): this;
    /**
     * Get Axis *thickness* min/max limits as pixels.
     *
     * For X Axis, this means Axis height.
     *
     * For Y Axis, this means Axis width.
     *
     * By default, Axis has no thickness restrictions, so `getThickness` should return `{ min: undefined, max: undefined }`.
     *
     * @return  Actively configured Axis thickness limits as pixels.
     */
    getThickness(): {
        min: number | undefined;
        max: number | undefined;
    };
    /**
     * Set enabled flags for all mouse-interactions on axis directly.
     * Does not affect chart mouse-interactions.
     * @param   enabled     Boolean: are mouse-interactions enabled
     * @return              Axis itself for fluent interface
     */
    setMouseInteractions(enabled: boolean): this;
    /**
     * Get height of axis in pixels
     * @return      Number
     */
    getHeight(): number;
    /**
     * Pan scale by pixel value delta.
     *
     * Used by ChartXY as well as Axis itself.
     * @param   amount  Amount to shift scale of axis in pixels
     */
    pan(amount: pixel): void;
    /**
     * Zoom scale from/to a position.
     *
     * Used by ChartXY as well as Axis itself.
     * @param   referencePosition   Position to zoom towards or from on axis
     * @param   zoomDirection       Amount and direction of zoom [-1, 1] as a guideline
     */
    zoom(referencePosition: number, zoomDirection: number): void;
    /**
     * Add custom tick to Axis.
     * *Custom ticks* can be used to expand on default tick placement, or completely override Axis ticks placement with custom logic.
     *
     * Example usage:
     *
     * **Create custom tick, specify position on Axis and label text.**
     *
     * ```typescript
     *  const customTick = Axis.addCustomTick()
     *      .setValue(5)
     *      // Label text is specified with a callback function.
     *      // This example formats Axis positions with one fraction, like this: "5.0"
     *      .setTextFormatter((value) => value.toFixed(1))
     * ```
     *
     * **Select CustomTick Marker type.**
     *
     * ```typescript
     *  // CustomTick shape can be changed by supplying a tick marker builder.
     *  // The only supported values are 'AxisTick' and 'PointableTextBox'
     *  const customTick1 = Axis.addCustomTick(UIElementBuilders.AxisTick)
     *  const customTick2 = Axis.addCustomTick(UIElementBuilders.PointableTextBox)
     * ```
     *
     * **Disable default ticks, and create custom positioned ticks.**
     *
     * ```typescript
     *  // Disable default Axis ticks.
     *  Axis.setTickStrategy(AxisTickStrategies.Empty)
     *
     *  // Create a bunch of custom positioned ticks.
     *  for (let x = 0; x <= 100; x += 10) {
     *      Axis.addCustomTick(UIElementBuilders.AxisTick)
     *          .setValue(x)
     *  }
     * ```
     *
     * For more information, like styling *custom ticks*, see [[CustomTick]].
     *
     * @param markerBuilder     Optional builder for *TickMarker* of CustomTick (tick line, label, possible background).
     *                          Possible values are: [[UIElementBuilders.AxisTick]], [[UIElementBuilders.PointableTextBox]].
     *                          Default is `PointableTextBox`
     * @returns                 CustomTick.
     */
    addCustomTick(markerBuilder?: UIElementBuilder<InternalTickMarker>): CustomTick;
    /**
     * Get position of axis on its chart as a %
     */
    getUiPosition(): number;
    /**
     * Set style of Axis line stroke.
     *
     * ```ts
     *  // Example syntax, specify LineStyle
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorHEX('#F00') })
     *  }))
     * ```
     *
     * ```ts
     *  // Example syntax, change thickness only
     *  Axis.setStrokeStyle((stroke) => new SolidLine({ ...stroke, thickness: 5 }))
     * ```
     *
     * **Supported fill styles:**
     *
     * [[SolidFill]]:
     *
     * Solid fill color.
     *
     * ```ts
     *  // Example, solid colored line.
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
     *  }))
     * ```
     *
     * To learn more about available *Color* factories, see [[ColorRGBA]]
     *
     * [[PalettedFill]]:
     *
     * Color line stroke dynamically based on `x` or `y` coordinate.
     *
     * ```ts
     *  // Example, dynamic color by Y coordinates
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new PalettedFill({
     *          lookUpProperty: 'y',
     *          lut: new LUT({
     *              interpolate: true,
     *              steps: [
     *                  { value: 0, color: ColorRGBA(255, 0, 0) },
     *                  { value: 10, color: ColorRGBA(0, 255, 0) },
     *              ]
     *          })
     *      })
     *  }))
     * ```
     *
     * To learn more about Color lookup tables, see [[LUT]].
     *
     * [[LinearGradientFill]]:
     *
     * Color line stroke with a linear configurable gradient palette.
     *
     * ```ts
     *  // Example, linear gradient line color
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new LinearGradientFill()
     *  }))
     * ```
     *
     * To learn more about linear gradient configurations, see [[LinearGradientFill]].
     *
     * [[RadialGradientFill]]:
     *
     * Color line stroke with a radial configurable gradient palette.
     *
     * ```ts
     *  // Example, radial gradient line color
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new RadialGradientFill()
     *  }))
     * ```
     *
     * To learn more about radial gradient configurations, see [[RadialGradientFill]].
     *
     * @param   value   Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
     * @returns         Object itself for fluent interface.
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * @returns Axis stroke as a LineStyle object
     */
    getStrokeStyle(): LineStyle;
    /**
     * Get style of axis overlay (shown only when interacting with mouse / touch).
     * @return  FillStyle object
     */
    getOverlayStyle(): FillStyle;
    /**
     * Set style of axis overlay (shown only when interacting with mouse / touch).
     * @param   style   FillStyle object or mutator to modify existing one
     */
    setOverlayStyle(style: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Set is mouse-interaction enabled:
     * Zooming by dragging on axis. (LMB)
     * @param   enabled     Boolean flag
     */
    setAxisInteractionZoomByDragging(enabled: boolean): this;
    /**
     * Get is mouse-interaction enabled:
     * Zooming by dragging on axis. (LMB)
     * @return  Boolean flag
     */
    getAxisInteractionZoomByDragging(): boolean;
    /**
     * Set is mouse-interaction enabled:
     * Panning by dragging on axis. (RMB)
     * @param   enabled     Boolean flag
     */
    setAxisInteractionPanByDragging(enabled: boolean): this;
    /**
     * Get is mouse-interaction enabled:
     * Panning by dragging on axis. (RMB)
     * @return  Boolean flag
     */
    getAxisInteractionPanByDragging(): boolean;
    /**
     * Set is mouse-interaction enabled:
     * Zooming by mouse-wheeling on axis.
     * @param   enabled     Boolean flag
     */
    setAxisInteractionZoomByWheeling(enabled: boolean): this;
    /**
     * Get is mouse-interaction enabled:
     * Zooming by mouse-wheeling on axis.
     * @return  Boolean flag
     */
    getAxisInteractionZoomByWheeling(): boolean;
    /**
     * Set is mouse-interaction enabled:
     * Release axis by double-clicking on axis.
     * @param   enabled     Boolean flag
     */
    setAxisInteractionReleaseByDoubleClicking(enabled: boolean): this;
    /**
     * Get is mouse-interaction enabled:
     * Release axis by double-clicking on axis.
     * @return  Boolean flag
     */
    getAxisInteractionReleaseByDoubleClicking(): boolean;
    /**
     * Set mouse style when hovering over axis area.
     * @param   mouseStyle  Mouse-style preset name (see [[MouseStyles]])
     * @return              Object itself
     */
    setAxisMouseHoverStyle(mouseStyle?: string): this;
    /**
     * Get mouse style when hovering over axis area.
     * @return  Mouse-style preset name
     */
    getAxisMouseHoverStyle(): string;
    /**
     * Set mouse style when panning axis.
     * @param   mouseStyle  Mouse-style preset name (see [[MouseStyles]])
     * @return              Object itself
     */
    setAxisMousePanStyle(mouseStyle?: string): this;
    /**
     * Get mouse style when panning axis.
     * @return  Mouse-style preset name
     */
    getAxisMousePanStyle(): string;
    /**
     * Set mouse style when zooming axis.
     * @param   mouseStyle  Mouse-style preset name (see [[MouseStyles]])
     * @return              Object itself
     */
    setAxisMouseZoomStyle(mouseStyle?: string): this;
    /**
     * Get mouse style when zooming axis.
     * @return  Mouse-style preset name
     */
    getAxisMouseZoomStyle(): string;
    /**
     * @returns Padding after Axis title
     */
    getTitleMargin(): number;
    /**
     * Specifies padding after Axis title.
     * This is only accounted when title is visible.
     * @param  margin   Gap between the title and the next axis in pixels. Can also affect chart margins
     * @returns         Axis itself for fluent interface
     */
    setTitleMargin(margin: pixel): this;
    /**
     * @returns Axis nib stroke length in pixels
     */
    getNibLength(): number;
    /**
     * Specifies Axis nib stroke length in pixels
     * @param  length  Axis nib stroke length in pixels
     * @returns        Axis itself for fluent interface
     */
    setNibLength(length: pixel): this;
    /**
     * @returns nib stroke fillstyle as a Fillstyle object
     */
    getNibStyle(): LineStyle;
    /**
     * Specifies Axis nibs StrokeStyle
     * @param   style       LineStyle object or mutator to modify existing one
     * @returns             Axis itself for fluent interface
     */
    setNibStyle(style: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of nib overlay (shown only when interacting with mouse / touch).
     * @return  FillStyle object
     */
    getNibOverlayStyle(): FillStyle;
    /**
     * Set style of nib overlay (shown only when interacting with mouse / touch).
     * @param   style   FillStyle object or mutator to modify existing one
     */
    setNibOverlayStyle(style: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Set ideal size of nib mouse-picking area in pixels.
     * @param   size   Size in pixels
     * @returns Object itself
     */
    setNibMousePickingAreaSize(size: pixel): this;
    /**
     * Get size of nib mouse-picking area in pixels.
     * @returns Size in pixels
     */
    getNibMousePickingAreaSize(): number;
    /**
     * Set is mouse-interaction enabled:
     * Scaling by dragging on nib.
     * @param   enabled     Boolean flag
     */
    setNibInteractionScaleByDragging(enabled: boolean): this;
    /**
     * Get is mouse-interaction enabled:
     * Scaling by dragging on nib.
     * @return  Boolean flag
     */
    getNibInteractionScaleByDragging(): boolean;
    /**
     * Set is mouse-interaction enabled:
     * Scaling by mouse-wheeling on nib.
     * @param   enabled     Boolean flag
     */
    setNibInteractionScaleByWheeling(enabled: boolean): this;
    /**
     * Get is mouse-interaction enabled:
     * Scaling by mouse-wheeling on nib.
     * @return  Boolean flag
     */
    getNibInteractionScaleByWheeling(): boolean;
    /**
     * Set mouse style when hovering over nib area.
     * @param   mouseStyle  Mouse-style preset name (see [[MouseStyles]])
     * @return              Object itself
     */
    setNibMouseHoverStyle(mouseStyle?: string): this;
    /**
     * Get mouse style when hovering over nib area.
     * @return  Mouse-style preset name
     */
    getNibMouseHoverStyle(): string;
    /**
     * Set mouse style when scaling nib.
     * @param   mouseStyle  Mouse-style preset name (see [[MouseStyles]])
     * @return              Object itself
     */
    setNibMouseScaleStyle(mouseStyle?: string): this;
    /**
     * Get mouse style when hovering over nib area.
     * @return  Mouse-style preset name
     */
    getNibMouseScaleStyle(): string;
    /**
     * Set all states of chart mouse interactions on axis at once.
     * @param   enabled Boolean flag
     */
    setChartInteractions(enabled: boolean): this;
    /**
     * Set is mouse-interaction enabled:
     * Panning by dragging on chart.
     * @param   enabled     Boolean flag
     */
    setChartInteractionPanByDrag(enabled: boolean): this;
    /**
     * Get is mouse-interaction enabled:
     * Panning by dragging on chart.
     * @return  Boolean flag
     */
    getChartInteractionPanByDrag(): boolean;
    /**
     * Set is mouse-interaction enabled:
     * Zooming by mouse-wheeling on chart.
     * @param   enabled     Boolean flag
     */
    setChartInteractionZoomByWheel(enabled: boolean): this;
    /**
     * Get is mouse-interaction enabled:
     * Zooming by mouse-wheeling on chart.
     * @return  Boolean flag
     */
    getChartInteractionZoomByWheel(): boolean;
    /**
     * Set is mouse-interaction enabled:
     * Zooming by capturing rectangle on chart.
     * @param   enabled     Boolean flag
     */
    setChartInteractionZoomByDrag(enabled: boolean): this;
    /**
     * Get is mouse-interaction enabled:
     * Zooming by capturing rectangle on chart.
     * @return  Boolean flag
     */
    getChartInteractionZoomByDrag(): boolean;
    /**
     * Set is mouse-interaction enabled:
     * Fitting by capturing rectangle on chart.
     * @param   enabled     Boolean flag
     */
    setChartInteractionFitByDrag(enabled: boolean): this;
    /**
     * Get is mouse-interaction enabled:
     * Fitting by capturing rectangle on chart.
     * @return  Boolean flag
     */
    getChartInteractionFitByDrag(): boolean;
    /**
     * Dispose all Axis sub-elements and remove this Axis from collection it's in.
     * @returns this for fluent interface
     */
    dispose(): this;
    /**
     * @return True if all Axis sub-elements are disposed, false if not.
     */
    isDisposed(): boolean;
    /**
     * Restore all Axis sub-elements and restore this Axis to the collection it was in.
     * @returns this for fluent interface
     */
    restore(): this;
}
export {};
/**
 * Interface for a strategy which defines Axis dimension
 */
interface AxisStrategy extends AbstractAxisStrategy<SeriesXY> {
    /**
     * Mouse style when dragging over axis
     */
    readonly defaultDragMouseStyle: string;
    /**
     * Used internally for rendering the axis title text at a specified angle
     * @param   direction Axis direction factor
     * @returns           Configured title text rotation in degrees
     */
    readonly getTitleTextRotation: (direction: 1 | -1) => number;
}
/**
 * Union of Dimensional and Axis Strategies
 * @hidden
 */
export declare type DimensionalAxisStrategy = MultidimensionalStrategy & AxisStrategy;
export {};
/**
 * Interface for *TickMarker*, a part of [[CustomTick]] that represents the label and pointer attached to the Axis.
 *
 * Most styling of CustomTicks can be managed directly via [[CustomTick]] API, but for some rare cases
 * its *TickMarker* has to be mutated. TickMarker is accessed via [[CustomTick.setMarker]] method, using a callback function:
 *
 * ```typescript
 *  CustomTick.setMarker((tickMarker) =>
 *      // ... mutate TickMarker.
 *  )
 *
 *  //
 * ```
 */
export interface TickMarker extends UIPart, GettableText, StyleTextAPI, Pointable {
}
/**
 * Internal interface for CustomTicks TickMarkers.
 * @hidden
 */
export interface InternalTickMarker extends TickMarker, CustomizableText {
}
/**
 * Interface for function which specifies CustomTick text.
 */
export declare type CustomTickTextFormatter = (value: number, customTick: CustomTick) => string;
/**
 * Class that represents a single *Axis tick* that can be managed by the user.
 *
 * *Custom ticks* are created with [[Axis.addCustomTick]].
 *
 * **Frequently used methods:**
 *
 * | Method | Purpose |
 * |------------ | ------------------------------ |
 * | [[setValue]] | Set tick position along Axis. |
 * | [[setTextFormatter]] | Set tick label text using a callback function. |
 * | [[dispose]] | Destroy tick temporarily, or permanently |
 * | [[restore]] | Restore tick after `dispose` |
 * | [[setGridStrokeStyle]] | Set tick gridline style |
 * | [[setTickLength]] | Set tick line length as pixels |
 * | [[setTickLabelPadding]] | Set padding between tick line and label |
 *
 * **Styling CustomTicks:**
 *
 * Tick gridline can be styled with [[CustomTick.setGridStrokeStyle]]
 *
 * *TickMarker* (label, tick, possible background) are styled via [[CustomTick.setMarker]] as a callback function, like this:
 *
 * ```typescript
 *  CustomTick.setMarker((tickMarker) => tickMarker
 *      // Style TickMarker.
 *      .setTextFillStyle(new SolidFill({ color: ColorRGBA( 255, 0, 0 ) }))
 *      .setFont((font) => font.setStyle( 'italic' ))
 *  )
 * ```
 *
 * See [[TickMarker]] for available customization API.
 *
 * **Styling specific TickMarkers:**
 *
 * When a *custom tick* is created, a *tick marker builder* can be specified.
 * This specifies the shape, and general visual look of the *custom tick*, and can also
 * expose a larger set of customization API for the *tick marker*.
 * To use the specific API, it is required to cast the *tick marker* object to the correct type (*TypeScript* users only):
 *
 * ```typescript
 *  const customTick = Axis.addCustomTick(UIElementBuilders.PointableTextBox)
 *  customTick.setMarker((tickMarker: UIPointableTextBox) => tickMarker
 *      // ^ Above type cast is necessary to access full configuration API of UIPointableTextBox
 *      // Style TickMarker background fill color.
 *      .setBackground((background) => background
 *          .setFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0, 100) }))
 *      )
 *  )
 * ```
 *
 * For reference,
 * - CustomTick created with `UIElementBuilders.AxisTick` will support API as described by [[UITick]]
 * - CustomTick created with `UIElementBuilders.PointableTextBox` will support API as described by [[UIPointableTextBox]]
 */
export declare abstract class CustomTick extends UIObject {
    /**
     * Axis that CustomTick belongs to.
     */
    readonly axis: Axis;
    /**
     * Sets the position of this custom tick on its Axis
     * @param value Value in the units of main scale
     * @returns     This for fluid interface
     * @sideEffect  Overrides text of CustomTicks Marker with formated value.
     */
    setValue(value: number): this;
    /**
     * Value of CustomTick
     */
    getValue(): number;
    /**
     * Set text of CustomTicks' Marker with a formatting function.
     *
     * Example usage:
     *```javascript
     * // Marker shows formatted position of CustomTick on its Axis
     * CustomTick.setTextFormatter((position, customTick) => customTick.axis.formatValue(position))
     * // Marker shows 'Hello world'
     * CustomTick.setTextFormatter((position, customTick) => 'Hello world')
     * ```
     * @param   textFormatter   A function of type: *CustomTickTextFormatter*, that defines text of CustomTicks' Marker.
     * @return                  Object itself
     */
    setTextFormatter(textFormatter: CustomTickTextFormatter): this;
    /**
     * Set tick length as pixels.
     * @param   length  Tick length as pixels.
     * @return          Object itself for fluent interface.
     */
    setTickLength(length: pixel): this;
    /**
     * Get tick length as pixels.
     * @returns        Tick length as pixels.
     */
    getTickLength(): pixel;
    /**
     * Set pixel padding between tick line and label.
     */
    setTickLabelPadding(padding: pixel): this;
    /**
     * Set rotation of tick label.
     * @param value Rotation in degrees
     * @returns Object itself
     */
    setTickLabelRotation(value: number): this;
    /**
     * Get rotation of tick label.
     * @returns Rotation in degrees
     */
    getTickLabelRotation(): number;
    /**
     * Get pixel padding between tick line and label.
     */
    getTickLabelPadding(): pixel;
    /**
     * Set length of grid stroke in percents
     * @param length     Grid line length as a % of viewport size
     * @returns          This for fluent interface
     */
    setGridStrokeLength(length: number): this;
    /**
     * @returns Grid stroke length as a % of the viewport size
     */
    getGridStrokeLength(): number;
    /**
     * @param value Grid stroke style
     * @returns This for fluent interface
     */
    setGridStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * @returns Grid stroke style as a LineStyle object
     */
    getGridStrokeStyle(): LineStyle;
    /**
     * Restore all sub-elements of custom tick
     * @return This for fluent interface
     */
    restore(): this;
    /**
     * Disposes all custom tick sub-elements
     * @returns This for fluid interface
     */
    dispose(): this;
    /**
     * @return True if all customTick child elements are disposed, false if not.
     */
    isDisposed(): boolean;
    /**
     * Remove Marker from rendering collection, so it can be safely trashed by GC
     * @returns Object itself for fluent interface
     */
    disposeMarker(): this;
    /**
     * Place Marker back to rendering collection, so it became visible again
     * @returns Object itself for fluent interface
     */
    restoreMarker(): this;
    /**
     * @returns True if visible and False for invisible
     */
    isDisposedMarker(): boolean;
    /**
     * Configure *custom ticks* *TickMarker* (label, tick, possible background) via a callback function.
     *
     * **Example usage:**
     *
     * ```typescript
     *  CustomTick.setMarker((tickMarker) => tickMarker
     *      // Style TickMarker.
     *      .setTextFillStyle(new SolidFill({ color: ColorRGBA( 255, 0, 0 ) }))
     *      .setFont((font) => font.setStyle( 'italic' ))
     *  )
     * ```
     *
     * See [[TickMarker]] for available customization API.
     *
     * **Styling specific TickMarkers:**
     *
     * When a *custom tick* is created, a *tick marker builder* can be specified.
     * This specifies the shape, and general visual look of the *custom tick*, and can also
     * expose a larger set of customization API for the *tick marker*.
     * To use the specific API, it is required to cast the *tick marker* object to the correct type (*TypeScript* users only):
     *
     * ```typescript
     *  const customTick = Axis.addCustomTick(UIElementBuilders.PointableTextBox)
     *  customTick.setMarker((tickMarker: UIPointableTextBox) => tickMarker
     *      // ^ Above type cast is necessary to access full configuration API of UIPointableTextBox
     *      // Style TickMarker background fill color.
     *      .setBackground((background) => background
     *          .setFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0, 100) }))
     *      )
     *  )
     * ```
     *
     * For reference,
     * - CustomTick created with `UIElementBuilders.AxisTick` will support API as described by [[UITick]]
     * - CustomTick created with `UIElementBuilders.PointableTextBox` will support API as described by [[UIPointableTextBox]]
     */
    setMarker(mutator: Mutator<TickMarker>): this;
    /**
     * Get *custom ticks* *TickMarker* (label, tick, possible background).
     * @returns TickMarker object
     */
    getMarker(): TickMarker;
    /**
     * Set mouse interactions enabled or disabled
     * @param state Specifies state of mouse interactions
     * @return      Object itself for fluent interface
     */
    setMouseInteractions(state: boolean): this;
    /**
     * @return Mouse interactions state
     */
    getMouseInteractions(): boolean;
    /**
     * Set whether `CustomTick` should allocate space on its `Axis`.
     *
     * By default, this is `true`, which means that `Axis` will always make sure it is big enough to fit the tick.
     *
     * By setting to `false`, this particular `CustomTick` can be removed from this behaviour, which can be useful in applications
     * where some custom ticks are only enabled temporarily. Disabling this functionality can prevent the size of the Axis from changing in unwanted ways.
     *
     * ```ts
     *  // Example syntax, disable custom tick space allocation.
     *  CustomTick.setAllocatesAxisSpace(false)
     * ```
     * @param   shouldAxisAllocateSpace     Boolean flag.
     * @return                              Object itself for fluent interface.
     */
    setAllocatesAxisSpace(shouldAxisAllocateSpace: boolean): this;
    /**
     * Get whether `CustomTick` should allocate space on its `Axis`.
     *
     * By default, this is `true`, which means that `Axis` will always make sure it is big enough to fit the tick.
     *
     * By setting to `false`, this particular `CustomTick` can be removed from this behaviour, which can be useful in applications
     * where some custom ticks are only enabled temporarily. Disabling this functionality can prevent the size of the Axis from changing in unwanted ways.
     *
     * @return  Boolean flag.
     */
    getAllocatesAxisSpace(): boolean;
    /**
     * Check that customTick fit the main scale
     * @returns         Boolean with the result
     */
    isInScale(): boolean;
    /**
     * Subscribe to value change event.
     * This event is triggered when [[setValue]] is called.
     *
     * **Example usage:**
     *
     *```javascript
     * // Set onValueChange event
     * CustomTick.onValueChange((num) => {
     *  console.log(num)
     * })
     *
     * // Set customTick value
     * CustomTick.setValue(20)
     *
     * ```
     * @param   handler     Function that is called when event is triggered.
     * @param   value       Position of CustomTick.
     * @return              Token that can be used to unsubscribe from the event.
     */
    onValueChange(handler: (value: number) => unknown): Token;
    /**
     * Unsubscribe from value change event.
     *
     * This event is called whenever the position of the *CustomTick* is changed via  **CustomTick.setValue**.
     * @param   token       Token that was received when the subscription was created.
     * @return              True if unsubscription was successful.
     */
    offValueChange(token: Token): boolean;
}
/**
 * Custom tick marker extended by some internal APIs
 * @hidden Internal class
 */
export declare class InternalCustomTick extends CustomTick {
    /**
     * @return True if all customTick child elements are disposed, false if not.
     */
    isDisposed(): boolean;
    /**
     * Disposes all custom tick sub-elements
     * @returns This for fluid interface
     */
    dispose(): this;
    /**
     * Update sub-elements of custom tick
     * @returns Object itself for fluent interface
     */
    update(): this;
    /**
     * Similarly to Axis.plot(), plots all the relevant shapes of this customTick
     * and shoves them into the passed engine.
     * @param  axisScale     Scale object of the axis this customTick is contained in.
     * @param  startHeight   Start height in pixels of the axis this customTick is contained in
     * @param  axisThickness Thickness in pixels of the axis this customTick is contained in
     * @param  margins       Vec2 of owning axis' margins in percents (0 to 1)
     */
    plot(gridStrokeStart: number, gridStrokeLen: number, gridStrokeOffset: number, tickStart: number): this;
}
/**
 * Interface for a strategy which defines dimension
 */
export interface MultidimensionalStrategy {
    /**
     * @param size Two dimensional value width of which has to be extracted
     * @returns    Width of Vec2
     */
    readonly getWidth: <T>(sizes: Vec2<T>) => T;
    /**
     * @param size Two dimensional value height of which has to be extracted
     * @returns    Height of Vec2
     */
    readonly getHeight: <T>(size: Vec2<T>) => T;
    /**
     * Combine argument with the tick value to create relevant Vec2
     * @param   height Value on height Scale units
     * @return         Vec2 which represents relevant for custom tick position
     */
    readonly toVec2: <T>(value: T, height: T) => Vec2<T>;
    /**
     * Combine argument with the tick value to create relevant Point
     * @param   height Value on height Scale units
     * @return         Point
     */
    readonly toPoint: (value: number, height: number) => Point;
}
/**
 * MultidimensionalStrategy for X Dimension
 */
export declare const xDimensionStrategy: MultidimensionalStrategy;
/**
 * MultidimensionalStrategy for X Dimension
 */
export declare const yDimensionStrategy: MultidimensionalStrategy;
/**
 * EllipseSeries, implementation of FigureSeries that simply plots individual ellipses (using Arcs).
 */
/**
 * Data type that defines a ellipse shape
 */
export interface EllipseDimensions {
    /**
     * X coordinate of ellipses center.
     */
    readonly x: number;
    /**
     * Y coordinate of ellipses center.
     */
    readonly y: number;
    /**
     * X radius of ellipse.
     */
    readonly radiusX: number;
    /**
     * Y radius of ellipse
     */
    readonly radiusY: number;
}
/**
 * Class for series visual that is an Ellipse.
 */
export declare class EllipseFigure extends CustomizableFigure {
    protected readonly _layer: Layer2D;
    readonly scale: LinearScaleXY;
    protected readonly _figureBoundsChanged: () => void;
    protected dimensions: EllipseDimensions;
    /**
     * @param   _layer                  Rendering layer
     * @param   scale                   Rendering scale
     * @param   _remove                 Callback that is called when Figure.dispose() is called.
     * @param   _restore                Callback that is called when Figure.restore() is called.
     * @param   _figureBoundsChanged    Callback that is called when Figure boundaries are changed
     * @hidden
     */
    constructor(_layer: Layer2D, scale: LinearScaleXY, _remove: RemoveHandler<Figure>, _restore: RestoreHandler<Figure>, _figureBoundsChanged: () => void, _theme: Theme, iSeries: number);
    /**
     * Get boundaries that contain figure.
     * @return  Interval<Point>
     */
    getBoundaries(): Interval<Point>;
    /**
     * Set new dimensions for figure.
     * @param   dimensions  Dimensions
     * @return              Object itself
     * @sideEffect          Owning series will be informed of change in size, possible initiating scrolling.
     */
    setDimensions(dimensions: EllipseDimensions): this;
    /**
     * Get current dimensions of figure.
     * @return  Dimensions
     */
    getDimensions(): EllipseDimensions;
    /**
     * Set fill style of Ellipse.
     * @param   fillStyle   FillStyle object or mutator to modify existing one
     * @return              Object itself
     */
    setFillStyle(fillStyle: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of Ellipse.
     * @return              FillStyle object
     */
    getFillStyle(): FillStyle;
    /**
     * Set fill style of Ellipse when highlighted.
     * @param   fillStyle   FillStyle object or mutator to modify existing one or undefined for auto assignment
     * @return              Object itself
     */
    setFillStyleHighlight(fillStyle: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * Get fill style of Ellipse when highlighted.
     * @return              FillStyle object or undefined for auto assignment
     */
    getFillStyleHighlight(): FillStyle | undefined;
    /**
     * Set stroke style of Ellipse.
     * @param   value   LineStyle object or mutator to modify existing one
     * @return              Object itself
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stroke style of Ellipse.
     * @return              LineStyle object
     */
    getStrokeStyle(): LineStyle;
    /**
     * Set stroke style of Ellipse when highlighted.
     * @param   value   LineStyle object or mutator to modify existing one or undefined for auto assignment
     * @return              Object itself
     */
    setStrokeStyleHighlight(value: LineStyle | ImmutableMutator<LineStyle> | undefined): this;
    /**
     * Get stroke style of Ellipse when highlighted.
     * @return              LineStyle object or undefined for auto assignment
     */
    getStrokeStyleHighlight(): LineStyle | undefined;
    /**
     * Set highlighted state of the Object
     * @param isHighlighted Highlight state of the object
     * @returns             Object itself for fluent interface
     */
    setHighlighted(isHighlighted: boolean): this;
    /**
     * Return some dominant fill style of the figure
     * @returns     FillStyle object
     */
    getDominantStyle(): FillStyle;
}
/**
 * Implementation of EllipseSeries
 */
export declare class EllipseSeries extends SimpleFigureSeries<EllipseFigure, FigureSeriesFormatter<EllipseFigure, EllipseSeries>, EllipseDimensions, LinearScaleXY> {
    /**
     * @param _chart                Parent Chart
     * @param _removeFromChart      Handler for removing reference to series from owning chart
     * @param _restoreFromChart     Handler for restoring reference to series from owning chart
     * @param _layer                Rendering layer
     * @param axisX                 Axis X
     * @param axisY                 Axis Y
     * @param axisXAttachHandler    Attach handler for Axis X
     * @param axisYAttachHandler    Attach handler for Axis Y
     * @param _newUILayer           Factory for creating new UI layers for drawing SeriesMarkers
     * @param _theme                Theme from owning Chart.
     * @hidden
     */
    constructor(chart: ChartXY, _removeFromChart: RemoveHandler<ChartComponent>, _restoreFromChart: RestoreHandler<ChartComponent>, _layer: Layer2D, axisX: Axis, axisY: Axis, axisXAttachHandler: AxisAttachHandler, axisYAttachHandler: AxisAttachHandler, _newUILayer: () => Layer2D, _theme: Theme, automaticColorIndex: number);
    /**
     * Add new figure to the series.
     * @param   dimensions  Dimensions that figure must represent
     * @return  Created figure
     */
    add(dimensions: EllipseDimensions): EllipseFigure;
}
/**
 * Interface for supplying readonly configurations to a [[EllipseSeries]].
 */
export interface EllipseSeriesOptions extends SeriesOptions {
}
/**
 * Abstract figure class for series visuals that are formed of multiple primitive shapes.
 * @hidden Internal class
 */
export declare abstract class Figure extends UIObject implements Disposable, Highlightable {
    protected readonly _layer: Layer2D;
    readonly scale: ScaleXY;
    private readonly _removeFigure;
    private readonly _restoreFigure;
    /**
     * Figure implementations should add primitive shapes in their constructors using
     * this.addShape( layer.addX( ... ) ) for proper functionality!
     *
     * @param   _layer   Rendering layer. Used to create primitive shapes
     * @param   scale   Rendering scale
     * @param   _removeFigure  Callback that is called when Figure.dispose() is called
     * @hidden
     */
    constructor(_layer: Layer2D, scale: ScaleXY, _removeFigure: RemoveHandler<Figure>, _restoreFigure: RestoreHandler<Figure>, _theme: Theme);
    /**
     * Subscribe to highlight object event. This is called whenever an object is highlighted.
     * @param   handler         Function that is called when event is triggered.
     * @param   isHighlighted   The Highlight state.
     * @return                  Token that can be used to unsubscribe from the event.
     */
    onHighlight(handler: (isHighlighted: boolean) => void): Token;
    /**
     * Unsubscribe from Highlight object event. This is called whenever an object is highlighted
     * @param   token       Token that was received when subscribing to the event.
     * @return              True if the unsubscription was successful.
     */
    offHighlight(token: Token): boolean;
    /**
     * Return some dominant fill style of the figure
     * @returns     FillStyle object
     */
    abstract getDominantStyle(): FillStyle;
    /**
     * Dispose shapes from rendering layer
     */
    dispose(): this;
    /**
     * @return True if all shapes are disposed, false if not.
     */
    isDisposed(): boolean;
    /**
     * Restore shapes to the rendering layer.
     */
    restore(): this;
    /**
     * Set highlighted state of the Object
     * @param isHighlighted Highlight state of the object
     * @returns             Object itself for fluent interface
     */
    setHighlighted(isHighlighted: boolean): this;
    /**
     * @return True for highlighted state of object and false for basic
     */
    getHighlighted: () => boolean;
    /**
     * Set mouse interactions enabled or disabled
     * @param state Specifies state of mouse interactions
     * @return     Object itself for fluent interface
     */
    setMouseInteractions(state: boolean): this;
    /**
     * @return Mouse interactions state
     */
    getMouseInteractions(): boolean;
}
/**
 * Implementation of SeriesXY that uses abstract 'Figures' to display segments
 *
 */
/**
 * Type for styler function for Figure
 * @param   figure  Figure
 */
export declare type FigureStyler<T extends Figure> = (figure: T) => void;
/**
 * Abstract base class for series based on figures.
 * @hidden Internal class
 */
export declare abstract class FigureSeries<FigureType extends Figure, CursorPointInterface extends CursorPoint<SeriesXY>, ScaleType extends ScaleXY> extends SeriesXY<FigureType, CursorPointInterface, ScaleType> {
    /**
     * Clear all previously pushed data points from the *series*.
     *
     * ```ts
     *  // Example usage
     *  LineSeries.clear()
     * ```
     *
     * @return      Object itself for fluent interface.
     */
    clear(): this;
}
/**
 * Extension of Figure to allow changing of individual figure boundaries from user triggered customizations.
 * @hidden Internal class
 */
export declare abstract class CustomizableFigure extends Figure {
    /**
     * Get boundaries that contain figure.
     * @return  Interval<Point>
     */
    abstract getBoundaries(): Interval<Point>;
}
/**
 * Base class for simple figure series that are designed for low amounts of figures.
 * Adds unified API for adding segments and always returns created figures, which allows users
 * to apply individual style upon each figure. Also gives user direct access to any created figures for full customizability.
 * @hidden Internal class
 */
export declare abstract class SimpleFigureSeries<FigureType extends CustomizableFigure, FormatterType extends FigureSeriesFormatter<FigureType, any>, InputType, ScaleType extends ScaleXY> extends FigureSeries<FigureType, SimpleFigureSeriesCursorPoint<FigureType>, ScaleType> {
    /**
     * Add new figure to the series.
     * @param   dimensions  Dimensions that figure must represent
     * @return              Created figure
     */
    abstract add(dimensions: InputType): FigureType;
    /**
     * Set style for all figures of series.
     * NOTE: Because the function is applied for each figure added, it is not advised to create any objects inside the function.
     * Instead they should be previously cached and later referred to.
     *
     * Example usage:
     *```javascript
     * // Explicit style
     * // The type of 'figure' is equal to type parameter: FigureType
     * SimpleFigureSeries.setDefaultStyle((figure) => ...)
     * ```
     * @param   styler  Styler function that is applied to all existing and newly added segments
     * @return          Object itself
     */
    setDefaultStyle(styler: FigureStyler<FigureType>): this;
    /**
     * Set highlight mode of series.
     * Defines how mouse affects highlighting of figures.
     * @param   highlightMode   HighlightMode
     * @return                  Object itself
     */
    setHighlightMode(highlightMode: HighlightModes): this;
    /**
     * Get highlight mode of series.
     * Defines how mouse affects highlighting of figures.
     * @return                  HighlightMode
     */
    getHighlightMode(): HighlightModes;
    /**
     * Configure formatting of *Cursor ResultTable* when pointing at this *series*.
     *
     * ```typescript
     *  // Example usage
     *  RectangleSeries.setCursorResultTableFormatter((tableBuilder, series, figure) => {
     *      const rectangleDimensions = figure.getDimensionsTwoPoints()
     *      return tableBuilder
     *          .addRow(`Pointing at`, '', series.getName())
     *          .addRow(`X1:`, '', rectangleDimensions.x1)
     *          .addRow(`X2:`, '', rectangleDimensions.x2)
     *          .addRow(`Y1:`, '', rectangleDimensions.y1)
     *          .addRow(`Y2:`, '', rectangleDimensions.y2)
     *  })
     * ```
     *
     * The general syntax of configuring *ResultTable* formatting is shared between all *series* types;
     * You specify a callback function, which receives a [[TableContentBuilder]]. The contents of the table are then set using methods of the *table builder*:
     *
     * ```typescript
     *  // Using TableContentBuilder.
     *  RectangleSeries.setCursorResultTableFormatter((tableBuilder, series, figure) => {
     *      // addRow adds a list of strings to a new row in the table. Empty strings ('') will allocate any extra horizontal space within the row.
     *      tableBuilder
     *          .addRow('Item 0:', '', 'Value 0')
     *          .addRow('Item 1:', '', 'Value 1')
     *          .addRow('Long row that highlights the idea of empty strings')
     *
     *      // After configuration, the table builder must be returned!
     *      return tableBuilder
     *  })
     * ````
     *
     * Default Axis formatting can be referenced by using [[Axis.formatValue]] method.
     *
     * The additional values that are supplied to the callback function vary between different chart types,
     * refer to the *series* documentation of `setCursorResultTableFormatter` to learn the exact available information.
     * `Figure Series` receive two extra parameters:
     * 1. `series` | reference to the series itself.
     * 2. `figure` | reference to the pointed *figure*.
     * This type is **generic** - for example, for `RectangleSeries` it is of type `RectangleFigure`.
     *
     * **Related API:**
     *
     * - [[setCursorEnabled]] | configure whether *cursors* should pick on this particular *series* or not.
     * - [[ChartXY.setAutoCursorMode]] | configure behavior when auto cursor is visible.
     *
     * @param   formatter   Function which builds *ResultTable* content.
     * @return              Object itself
     */
    setCursorResultTableFormatter(formatter: FormatterType): this;
    /**
     * Get ResultTable Formatter.
     * @return  Function which builds ResultTable content for the Series.
     */
    getCursorResultTableFormatter(): FormatterType;
    /**
     * Solves the nearest datapoint to a given coordinate on screen.
     * @param   location    Location on screen
     * @return              Undefined or data-structure for positioning of cursors
     */
    solveNearestFromScreen(location: Point): undefined | SimpleFigureSeriesCursorPoint<FigureType>;
    /**
     * Solves the nearest datapoint to a given coordinate on a screen from a specific segment.
     * @param   location    Location on screen
     * @param   segment     Segment to solve from
     * @return              Undefined or data-structure for positioning of cursors
     */
    solveNearestFromSegment(location: Point, segment: FigureType): undefined | SimpleFigureSeriesCursorPoint<FigureType>;
    /**
     * Clear all previously pushed data points from the *series*.
     *
     * ```ts
     *  // Example usage
     *  LineSeries.clear()
     * ```
     *
     * @return      Object itself for fluent interface.
     */
    clear(): this;
    /**
     * @return Max X value of the series
     */
    getXMax(): number;
    /**
     * @return Min X value of the series
     */
    getXMin(): number;
    /**
     * @return Max Y value of the series
     */
    getYMax(): number;
    /**
     * @return Min Y value of the series
     */
    getYMin(): number;
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Series itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick?: boolean): this;
    setHighlightOnHover(state: boolean): this;
}
/**
 * Interface for CursorPoints that point to a Figure of SimpleFigureSeries.
 * Used to pack information about pointed segment to users.
 */
export interface SimpleFigureSeriesCursorPoint<FigureType extends Figure> extends CursorPoint<SimpleFigureSeries<any, any, any, any>> {
    /**
     * Pointed figure.
     */
    figure: FigureType;
}
/**
 * Interface for a function which builds ResultTable content when pointing at a FigureSeries.
 * @param   tableContentBuilder     Builder that is used to build contents of ResultTable.
 *                                  Use addRow() method for adding content.
 * @param   series                  Series
 * @param   segment                 Figure that is pointed at. This type is abstract and depends on the type of Series in question.
 *                                  For example, if you are using a BoxSeries this 'figure' will be of type: "BoxFigure".
 * @return                          TableContentBuilder that was supplied
 */
export declare type FigureSeriesFormatter<FigureType extends CustomizableFigure, P extends SimpleFigureSeries<FigureType, any, any, any>> = <T extends TableContentBuilder>(tableContentBuilder: T, series: P, figure: FigureType) => T;
/**
 * Class for series visual that is a Polygon.
 */
export declare class PolygonFigure extends CustomizableFigure {
    protected readonly _layer: Layer2D;
    readonly scale: LinearScaleXY;
    protected readonly _figureBoundsChanged: () => void;
    /**
     * @param   _layer                  Rendering layer
     * @param   scale                   Rendering scale
     * @param   _remove                 Callback that is called when Figure.dispose() is called
     * @param   _restore                Callback that is called when Figure.restore() is called
     * @param   _figureBoundsChanged    Callback that is called when Figure boundaries are changed
     * @param _theme                Theme from owning Chart, used for styling
     * @hidden
     */
    constructor(_layer: Layer2D, scale: LinearScaleXY, _remove: RemoveHandler<Figure>, _restore: RestoreHandler<Figure>, _figureBoundsChanged: () => void, _theme: Theme, iSeries: number);
    /**
     * Get boundaries that contain figure.
     * @return  Interval<Point>
     */
    getBoundaries(): Interval<Point>;
    /**
     * Set new dimensions for figure.
     * @param   polygonCoordinates  List of polygon coordinates
     * @return                      Object itself
     * @sideEffect                  Owning series will be informed of change in size, possibly initiating scrolling.
     */
    setDimensions(polygonCoordinates: Point[]): this;
    /**
     * Get current dimensions of figure as list of polygon coordinates.
     * @return  List of Polygon coordinates.
     */
    getDimensions(): Point[];
    /**
     * Set fill style of Polygon.
     * @param   fillStyle   FillStyle object or mutator to modify existing one
     * @return              Object itself
     */
    setFillStyle(fillStyle: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of Polygon.
     * @return              FillStyle object
     */
    getFillStyle(): FillStyle;
    /**
     * Set fill style of Polygon when highlighted.
     * @param   fillStyle   FillStyle object or mutator to modify existing one or undefined for auto assignment
     * @return              Object itself
     */
    setFillStyleHighlight(fillStyle: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * Get fill style of Polygon when highlighted.
     * @return              FillStyle object or undefined for auto assignment
     */
    getFillStyleHighlight(): FillStyle | undefined;
    /**
     * Set stroke style of Polygon.
     * @param   value       LineStyle object or mutator to modify existing one
     * @return              Object itself
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stroke style of Polygon.
     * @return              LineStyle object
     */
    getStrokeStyle(): LineStyle;
    /**
     * Set stroke style of Polygon when highlighted.
     * @param   value   LineStyle object or mutator to modify existing one or undefined for auto assignment
     * @return              Object itself
     */
    setStrokeStyleHighlight(value: LineStyle | ImmutableMutator<LineStyle> | undefined): this;
    /**
     * Get stroke style of Polygon when highlighted.
     * @return              LineStyle object or undefined for auto assignment
     */
    getStrokeStyleHighlight(): LineStyle | undefined;
    /**
     * Set highlighted state of the Object
     * @param isHighlighted Highlight state of the object
     * @returns             Object itself for fluent interface
     */
    setHighlighted(isHighlighted: boolean): this;
    /**
     * Return some dominant fill style of the figure
     * @returns     FillStyle object
     */
    getDominantStyle(): FillStyle;
}
/**
 * Series that lets user draw Polygon with independent figures.
 */
export declare class PolygonSeries extends SimpleFigureSeries<PolygonFigure, FigureSeriesFormatter<PolygonFigure, PolygonSeries>, Point[], LinearScaleXY> {
    /**
     * @param _chart                Parent Chart
     * @param _removeFromChart      Handler for removing reference to series from owning chart
     * @param _restoreFromChart     Handler for restoring reference to series from owning chart
     * @param _layer                Rendering layer
     * @param axisX                 Axis X
     * @param axisY                 Axis Y
     * @param axisXAttachHandler    Attach handler for Axis X
     * @param axisYAttachHandler    Attach handler for Axis Y
     * @param _newUILayer           Factory for creating new UI layers for drawing SeriesMarkers
     * @param _theme                Theme from owning Chart.
     * @hidden
     */
    constructor(chart: ChartXY, _removeFromChart: RemoveHandler<ChartComponent>, _restoreFromChart: RestoreHandler<ChartComponent>, _layer: Layer2D, axisX: Axis, axisY: Axis, axisXAttachHandler: AxisAttachHandler, axisYAttachHandler: AxisAttachHandler, _newUILayer: () => Layer2D, _theme: Theme, automaticColorIndex: number);
    /**
     * Add new figure to the series.
     * @param   dimensions  Dimensions that figure must represent
     * @return              Created figure
     */
    add(dimensions: Point[]): PolygonFigure;
}
/**
 * Interface for supplying readonly configurations to a [[PolygonSeries]].
 */
export interface PolygonSeriesOptions extends SeriesOptions {
}
/**
 * RectSeries, implementation of FigureSeries that simply plots individual 'Rect' shapes
 */
/**
 * Interface for defining dimensions of a Rectangle with position and size.
 */
export interface RectanglePositionAndSize {
    /**
     * X coordinate of rectangles bottom-left corner.
     */
    readonly x: number;
    /**
     * Y coordinate of rectangles bottom-left corner.
     */
    readonly y: number;
    /**
     * Width of rectangle
     */
    readonly width: number;
    /**
     * Height of rectangle
     */
    readonly height: number;
}
/**
 * Interface for defining dimensions of a Rectangle with two locations.
 */
export interface RectangleTwoPoints {
    /**
     * X coordinate of rectangles bottom-left corner.
     */
    readonly x1: number;
    /**
     * Y coordinate of rectangles bottom-left corner.
     */
    readonly y1: number;
    /**
     * X coordinate of rectangles top-right corner.
     */
    readonly x2: number;
    /**
     * Y coordinate of rectangles top-right corner.
     */
    readonly y2: number;
}
/**
 * Class for series visual that is a Rectangle.
 */
export declare class RectangleFigure extends CustomizableFigure {
    protected readonly _layer: Layer2D;
    readonly scale: LinearScaleXY | MixedScaleXY;
    protected readonly _figureBoundsChanged: () => void;
    /**
     * @param   _layer                  Rendering layer
     * @param   scale                   Rendering scale
     * @param   _remove                 Callback that is called when Figure.dispose() is called
     * @param   _restore                Callback that is called when Figure.restore() is called
     * @param   _figureBoundsChanged    Callback that is called when Figure boundaries are changed
     * @param _theme                Theme from owning Chart, used for styling
     * @hidden
     */
    constructor(_layer: Layer2D, scale: LinearScaleXY | MixedScaleXY, _remove: RemoveHandler<Figure>, _restore: RestoreHandler<Figure>, _figureBoundsChanged: () => void, _theme: Theme, iSeries: number);
    /**
     * Get boundaries that contain figure.
     * @return  Interval<Point>
     */
    getBoundaries(): Interval<Point>;
    /**
     * Set new dimensions for figure.
     * @param   dimensions  Dimensions as either of supported Rectangle interfaces
     * @return              Object itself
     * @sideEffect          Owning series will be informed of change in size, possible initiating scrolling.
     */
    setDimensions(dimensions: RectanglePositionAndSize | RectangleTwoPoints): this;
    /**
     * Get current dimensions of figure as interface 'RectanglePositionAndSize'.
     * @return  RectanglePositionAndSize
     */
    getDimensionsPositionAndSize(): RectanglePositionAndSize;
    /**
     * Get current dimensions of figure as interface 'RectangleTwoPoints'.
     * @return  RectangleTwoPoints
     */
    getDimensionsTwoPoints(): RectangleTwoPoints;
    /**
     * Set fill style of Rectangle.
     * @param   fillStyle   FillStyle object or mutator to modify existing one
     * @return              Object itself
     */
    setFillStyle(fillStyle: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of Rectangle.
     * @return              FillStyle object
     */
    getFillStyle(): FillStyle;
    /**
     * Set fill style of Rectangle when highlighted.
     * @param   fillStyle   FillStyle object or mutator to modify existing one or undefined for auto assignment
     * @return              Object itself
     */
    setFillStyleHighlight(fillStyle: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * Get fill style of Rectangle when highlighted.
     * @return              FillStyle object or undefined for auto assignment
     */
    getFillStyleHighlight(): FillStyle | undefined;
    /**
     * Set stroke style of Rectangle.
     * @param   value       LineStyle object or mutator to modify existing one
     * @return              Object itself
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stroke style of Rectangle.
     * @return              LineStyle object
     */
    getStrokeStyle(): LineStyle;
    /**
     * Set stroke style of Rectangle when highlighted.
     * @param   value   LineStyle object or mutator to modify existing one or undefined for auto assignment
     * @return              Object itself
     */
    setStrokeStyleHighlight(value: LineStyle | ImmutableMutator<LineStyle> | undefined): this;
    /**
     * Get stroke style of Rectangle when highlighted.
     * @return              LineStyle object or undefined for auto assignment
     */
    getStrokeStyleHighlight(): LineStyle | undefined;
    /**
     * Set highlighted state of the Object
     * @param isHighlighted Highlight state of the object
     * @returns             Object itself for fluent interface
     */
    setHighlighted(isHighlighted: boolean): this;
    /**
     * Return some dominant fill style of the figure
     * @returns     FillStyle object
     */
    getDominantStyle(): FillStyle;
}
/**
 * Series that lets user draw Rectangles with independent figures.
 */
export declare class RectangleSeries extends SimpleFigureSeries<RectangleFigure, FigureSeriesFormatter<RectangleFigure, RectangleSeries>, RectanglePositionAndSize | RectangleTwoPoints, LinearScaleXY | MixedScaleXY> {
    /**
     * @param _chart                Parent Chart
     * @param _removeFromChart      Handler for removing reference to series from owning chart
     * @param _restoreFromChart     Handler for restoring reference to series from owning chart
     * @param _layer                Rendering layer
     * @param axisX                 Axis X
     * @param axisY                 Axis Y
     * @param axisXAttachHandler    Attach handler for Axis X
     * @param axisYAttachHandler    Attach handler for Axis Y
     * @param _newUILayer           Factory for creating new UI layers for drawing SeriesMarkers
     * @param _theme                Theme from owning Chart.
     * @hidden
     */
    constructor(chart: ChartXY, _removeFromChart: RemoveHandler<ChartComponent>, _restoreFromChart: RestoreHandler<ChartComponent>, _layer: Layer2D, axisX: Axis, axisY: Axis, axisXAttachHandler: AxisAttachHandler, axisYAttachHandler: AxisAttachHandler, _newUILayer: () => Layer2D, _theme: Theme, automaticColorIndex: number);
    /**
     * Add new figure to the series.
     * @param   dimensions  Dimensions that figure must represent
     * @return              Created figure
     */
    add(dimensions: RectanglePositionAndSize | RectangleTwoPoints): RectangleFigure;
}
/**
 * Interface for supplying readonly configurations to a [[RectangleSeries]].
 */
export interface RectangleSeriesOptions extends SeriesOptions {
}
/**
 * LineSeries, abstract implementation of FigureSeries that simply plots individual 'Line' shapes
 */
/**
 * Data structure that defines dimensions of a line-segment
 */
export interface SegmentDimensions {
    /**
     * X value of start location
     */
    startX: number;
    /**
     * Y value of start location
     */
    startY: number;
    /**
     * X value of end location
     */
    endX: number;
    /**
     * Y value of end location
     */
    endY: number;
}
/**
 * Class for series visual that is a Segment.
 */
export declare class SegmentFigure extends CustomizableFigure {
    protected readonly _layer: Layer2D;
    readonly scale: LinearScaleXY | MixedScaleXY;
    protected readonly _figureBoundsChanged: () => void;
    /**
     * Dimensions of figure.
     */
    protected dimensions: SegmentDimensions;
    /**
     * @param   _layer                  Rendering layer
     * @param   scale                   Rendering scale
     * @param   _remove                 Callback that is called when Figure.dispose() is called
     * @param   _restore                Callback that is called when Figure.restore() is called
     * @param   _figureBoundsChanged    Callback that is called when Figure boundaries are changed
     * @param   _theme                  Theme from owning Chart, used for styling
     * @hidden
     */
    constructor(_layer: Layer2D, scale: LinearScaleXY | MixedScaleXY, _remove: RemoveHandler<Figure>, _restore: RestoreHandler<Figure>, _figureBoundsChanged: () => void, _theme: Theme, iSeries: number);
    /**
     * Get boundaries that contain figure.
     * @return  Interval<Point>
     */
    getBoundaries(): Interval<Point>;
    /**
     * Set new dimensions for figure.
     * @param   dimensions  Dimensions
     * @return              Object itself
     * @sideEffect          Owning series will be informed of change in size, possible initiating scrolling.
     */
    setDimensions(dimensions: SegmentDimensions): this;
    /**
     * Get current dimensions of figure.
     * @return  Dimensions
     */
    getDimensions(): SegmentDimensions;
    /**
     * Set stroke style of Segment.
     * @param   value       FillStyle object or mutator to modify existing one
     * @return              Object itself
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stroke style of Segment.
     * @return              FillStyle object
     */
    getStrokeStyle(): LineStyle;
    /**
     * Set stroke style of Segment when highlighted.
     * @param   value   FillStyle object or mutator to modify existing one or undefined for auto assignment
     * @return              Object itself
     */
    setStrokeStyleHighlight(value: LineStyle | ImmutableMutator<LineStyle> | undefined): this;
    /**
     * Get stroke style of Segment when highlighted.
     * @return              FillStyle object or undefined for auto assignment
     */
    getStrokeStyleHighlight(): LineStyle | undefined;
    /**
     * Set highlighted state of the Object
     * @param isHighlighted Highlight state of the object
     * @returns             Object itself for fluent interface
     */
    setHighlighted(isHighlighted: boolean): this;
    /**
     * Return some dominant fill style of the figure
     * @returns     FillStyle object
     */
    getDominantStyle(): FillStyle;
}
/**
 * Series for that lets user draw Segments with independent figures.
 */
export declare class SegmentSeries extends SimpleFigureSeries<SegmentFigure, FigureSeriesFormatter<SegmentFigure, SegmentSeries>, SegmentDimensions, LinearScaleXY | MixedScaleXY> {
    /**
     * @param _chart                Parent Chart
     * @param _removeFromChart      Handler for removing reference to series from owning chart
     * @param _restoreFromChart     Handler for restoring reference to series from owning chart
     * @param _layer                Rendering layer
     * @param axisX                 Axis X
     * @param axisY                 Axis Y
     * @param axisXAttachHandler    Attach handler for Axis X
     * @param axisYAttachHandler    Attach handler for Axis Y
     * @param _newUILayer           Factory for creating new UI layers for drawing SeriesMarkers
     * @param _theme                Theme from owning Chart.
     * @hidden
     */
    constructor(chart: ChartXY, _removeFromChart: RemoveHandler<ChartComponent>, _restoreFromChart: RestoreHandler<ChartComponent>, _layer: Layer2D, axisX: Axis, axisY: Axis, axisXAttachHandler: AxisAttachHandler, axisYAttachHandler: AxisAttachHandler, _newUILayer: () => Layer2D, _theme: Theme, automaticColorIndex: number);
    /**
     * Add new figure to the series.
     * @param   dimensions  Dimensions that figure must represent
     * @return              Created figure
     */
    add(dimensions: SegmentDimensions): SegmentFigure;
}
/**
 * Interface for supplying readonly configurations to a [[SegmentSeries]].
 */
export interface SegmentSeriesOptions extends SeriesOptions {
}
/**
 * Interface that describes an intensity heatmap data point.
 */
export interface HeatmapIntensityDataPoint {
    /**
     * Index of column (grid index on X axis).
     */
    readonly column: number;
    /**
     * Index of row (grid index on Y axis).
     */
    readonly row: number;
    /**
     * Intensity value of heatmap cell.
     */
    readonly intensity: number;
    /**
     * X Axis coordinate.
     *
     * If cursor interpolation is disabled, this will be calculated as the center coordinate of the grid cell.
     *
     * If cursor interpolation is enabled, it will snap to closest coordinate of the grid from the solve location (e.g. mouse location).
     */
    readonly x: number;
    /**
     * Y Axis coordinate.
     *
     * If cursor interpolation is disabled, this will be calculated as the center coordinate of the grid cell.
     *
     * If cursor interpolation is enabled, it will snap to closest coordinate of the grid from the solve location (e.g. mouse location).
     */
    readonly y: number;
}
/**
 * Interface for a function which builds ResultTable content when pointing at a HeatmapSeries with numeric *intensity* values.
 * @param   tableContentBuilder     Builder that is used to build contents of ResultTable.
 *                                  Use addRow() method for adding content.
 * @param   series                  Series
 * @param   dataPoint               Information about the pointed data point.
 * @return                          TableContentBuilder that was supplied
 */
export declare type HeatmapSeriesFormatterIntensity<Series = SeriesXY> = <T extends TableContentBuilder>(tableContentBuilder: T, series: Series, dataPoint: HeatmapIntensityDataPoint) => T;
/**
 * @hidden
 */
export declare const _defaultHeatmapSeriesFormatterIntensity: HeatmapSeriesFormatterIntensity<SeriesXY>;
/**
 * Interface describing readonly configurations of a [[HeatmapGridSeries]].
 *
 * **Required properties:**
 * - [[columns]]
 * - [[rows]]
 *
 * **Optional properies:**
 * - [[start]]
 * - [[step]]
 * - [[dataOrder]]
 * - [[heatmapDataType]]
 */
export interface HeatmapGridSeriesOptions<DataType extends 'intensity' = 'intensity'> extends SeriesOptions {
    /**
     * Specify how to interpret grid matrix values supplied by user.
     *
     * `'columns'` -> Supply lists of "columns"
     *
     * ```typescript
     *  const intensityValues = [
     *      [
     *          0, // Intensity value column = 0, row = 0
     *          0, // Intensity value column = 0, row = 1
     *          0, // Intensity value column = 0, row = n
     *      ],
     *      [
     *          0, // Intensity value column = 1, row = 0
     *          0, // Intensity value column = 1, row = 1
     *          0, // Intensity value column = 1, row = n
     *      ],
     *  ]
     * ```
     *
     * `'rows'` -> Supply lists of "rows"
     *
     * ```typescript
     *  const intensityValues = [
     *      [
     *          0, // Intensity value row = 0, column = 0
     *          0, // Intensity value row = 0, column = 1
     *          0, // Intensity value row = 0, column = n
     *      ],
     *      [
     *          0, // Intensity value row = 1, column = 0
     *          0, // Intensity value row = 1, column = 1
     *          0, // Intensity value row = 1, column = n
     *      ],
     *  ]
     * ```
     *
     * Defaults to `'columns'`.
     */
    dataOrder?: 'columns' | 'rows';
    /**
     * Selection of format in which heatmap values are supplied.
     *
     * `'intensity'` | numeric value that can be colored with an associated color look up table.
     *
     * Defaults to `'intensity'.`
     */
    heatmapDataType?: DataType;
    /**
     * Amount of *columns* (values on X Axis).
     */
    columns: number;
    /**
     * Amount of *rows* (values on Y Axis).
     */
    rows: number;
    /**
     * Start coordinate of Heatmap on its X and Y Axes.
     *
     * Defaults to `{ x: 0, y: 0 }`
     */
    start?: Point;
    /**
     * Step between each consecutive heatmap value on the X and Y Axes.
     *
     * X = columns,
     * Y = rows
     *
     * Defaults to `{ x: 1, y: 1 }`
     */
    step?: Point;
    /**
     * End coordinate of Heatmap on its X and Y Axes.
     *
     * If both are defined, `end` has priority over `step`.
     */
    end?: Point;
}
/**
 * Abstract Series class for visualizing a *Heatmap Grid* with static columns and rows count.
 *
 * Implementations:
 * - [[HeatmapGridSeriesIntensityValues]]
 */
export declare abstract class HeatmapGridSeries extends SeriesXY<HeatmapGridStatic, CursorPoint, LinearScaleXY> implements AttachableWithLUT {
    /**
     * Clear all previous data pushed to the series.
     * @return  Object itself for fluent interface.
     */
    clear(): this;
    /**
     * Set style of wireframe.
     *
     * ```js
     *  // Example, disable wireframe.
     *  heatmapSeries.setWireframeStyle(emptyLine)
     * ```
     *
     * ```js
     *  // Example, set wireframe style.
     *  heatmapSeries.setWireframeStyle(new SolidLine({
     *      thickness: 1,
     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0, 255) })
     *  }))
     * ```
     *
     * Wireframe is a line grid that highlights the edges of each cell of the heatmap.
     * @param   value   Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
     * @return          Series itself for fluent interface.
     */
    setWireframeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of wireframe.
     *
     * Wireframe is a line grid that highlights the edges of each cell of the heatmap.
     * @return          LineStyle.
     */
    getWireframeStyle(): LineStyle;
    /**
     * Set cursor interpolation enabled.
     *
     * If enabled, cursors will display bilinearly interpolated *intensity* values from the four closest heatmap cells
     * to the mouse pointer. Otherwise, cursor will display the nearest actual data point supplied by user.
     *
     * @param   state   Boolean flag
     * @returns         Object itself for fluent interface
     */
    setCursorInterpolationEnabled(state: boolean): this;
    /**
     * Get if cursor interpolates solved data-points along series by default.
     * @returns         Boolean flag
     */
    getCursorInterpolationEnabled(): boolean;
    /**
     * Set heatmap intensity interpolation mode.
     *
     * `'disabled'` or `undefined`: Interpolation disabled; draw data exactly as it is.
     *
     * `'bilinear'`: Each PIXEL is colored based on an Bi-linearly interpolated intensity value based on the 4 closest real intensity values.
     *
     * @param   interpolationMode   Heatmap intensity interpolation mode selection.
     * @return                      Object itself for fluent interface.
     */
    setIntensityInterpolation(interpolationMode: IntensityInterpolationMode | undefined): this;
    /**
     * Get heatmap intensity interpolation mode.
     * @return                     Heatmap intensity interpolation mode selection.
     */
    getIntensityInterpolation(): IntensityInterpolationMode;
    /**
     * Set heatmap fill pixel interpolation mode.
     *
     * `'disabled'` or `undefined`: Interpolation disabled; all pixels within a grid cell share the same color.
     *
     * `'bilinear'`: Each pixel is colored individually by *bilinear interpolation*.
     * @param   interpolationMode   Heatmap fill pixel interpolation mode selection.
     * @return                      Object itself for fluent interface.
     * @deprecated                  Will be removed in v.4.0.0 in favour of [[setIntensityInterpolation]]
     */
    setPixelInterpolationMode(interpolationMode: IntensityInterpolationMode | undefined): this;
    /**
     * Get heatmap fill pixel interpolation mode.
     * @return                      Heatmap fill pixel interpolation mode selection.
     * @deprecated                  Will be removed in v.4.0.0 in favour of [[getIntensityInterpolation]]
     */
    getPixelInterpolationMode(): IntensityInterpolationMode;
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Series itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick?: boolean): this;
    solveNearestFromScreen(location: Point, interpolate?: boolean): undefined | CursorPoint;
    solveNearestFromSegment(location: Point, segment: HeatmapGridStatic, interpolate?: boolean): undefined | CursorPoint;
    /**
     * @return Max X value of the series
     */
    getXMax(): number | undefined;
    /**
     * @return Min X value of the series
     */
    getXMin(): number | undefined;
    /**
     * @return Max Y value of the series
     */
    getYMax(): number | undefined;
    /**
     * @return Min Y value of the series
     */
    getYMin(): number | undefined;
}
/**
 * Series for visualizing a *Intensity Heatmap Grid* with a static column and grid count. Has API for fast modification of cell values.
 *
 * `HeatmapGridSeriesIntensityValues` is optimized for *massive* amounts of data - here are some reference specs on average PC to give an idea:
 *
 * - Heatmap Chart with 1 million data points (`1000x1000`) is cold started in ~0.3 seconds.
 * - Heatmap Chart with 1 million data points (`1000x1000`) is re-populated (change data set) in ~0.050 seconds.
 * - Heatmap Chart with 16 million data points (`4000x4000`) is cold started in ~2.0 seconds.
 * - Heatmap Chart with 16 million data points (`4000x4000`) is re-populated (change data set) in ~0.5 seconds.
 *
 * `HeatmapGridSeriesIntensityValues` max data amount is entirely restricted by the client hardware RAM and more specifically amount of RAM usable by the context running LightningChart JS.
 * If by increasing the amount of `columns` and `rows` you encounter suddenly weak performance, it is likely that there is not enough RAM memory available.
 *
 * Created with [[ChartXY.addHeatmapGridSeries]].
 *
 * Frequently used API:
 * - Set intensity data [[invalidateIntensityValues]]
 * - Set fill style [[setFillStyle]]
 * - Set wireframe style [[setWireframeStyle]]
 * - Format auto cursor [[setCursorResultTableFormatter]]
 */
export declare class HeatmapGridSeriesIntensityValues extends HeatmapGridSeries {
    /**
     * Invalidate range of heatmap intensity values starting from first column and row, updating coloring if a Color look up table ([[LUT]]) has been attached to the series (see [[HeatmapGridSeriesIntensityValues.setFillStyle]]).
     *
     * ```js
     *  // Example, 3x3 grid full invalidation.
     *  const heatmapGridSeries = ChartXY.addHeatmapGridSeries({
     *      dataOrder: 'columns',
     *      columns: 3,
     *      rows: 3
     *  })
     *
     *  heatmapGridSeries.invalidateIntensityValues([
     *      // Column 1 intensity values.
     *      [0, 0, 0],
     *      // Column 2 intensity values.
     *      [1, 1, 1],
     *      // Column 3 intensity values.
     *      [0, 2, 0],
     *  ])
     * ```
     *
     * Data interpretation basis is defined by [[HeatmapGridSeriesOptions.dataOrder]] property from when the series was created.
     * Can be either list of *columns*, or list of *rows*.
     *
     * `invalidateIntensityValues` can trigger warnings when used controversially.
     * In production applications, these can be controlled with [[LightningChartOptions.warnings]].
     *
     * @param   value       Matrix containing intensity values for each data slot of the grid.
     * @returns             Object itself for fluent interface.
     */
    invalidateIntensityValues(value: number[][]): this;
    /**
     * Invalidate a partial range of heatmap intensity values, updating coloring if a Color look up table ([[LUT]]) has been attached to the series (see [[HeatmapGridSeriesIntensityValues.setFillStyle]]).
     *
     * ```js
     *  // Example, 100x10 grid invalidate partial section of grid.
     *
     *  const heatmapGridSeries = ChartXY.addHeatmapGridSeries({
     *      dataOrder: 'columns',
     *      columns: 100,
     *      rows: 10
     *  })
     *
     *  heatmapGridSeries.invalidateIntensityValues({
     *      // Index of first invalidated column.
     *      iColumn: 50,
     *      // Index of first invalidated row.
     *      iRow: 2,
     *      // Intensity values matrix. It's dimensions imply the amount of invalidated columns & rows.
     *      values: [
     *          // 1st invalidated column intensity values.
     *          [1, 1, 1, 1, 1],
     *          // 2nd invalidated column intensity values.
     *          [2, 2, 2, 2, 2],
     *          // 3rd invalidated column intensity values.
     *          [1, 0, 0, 0, 1],
     *          // 4th invalidated column intensity values.
     *          [0, 1, 0, 1, 0],
     *          // 5th invalidated column intensity values.
     *          [0, 0, 1, 0, 0],
     *      ],
     *  })
     * ```
     *
     * `invalidateIntensityValues` can trigger warnings when used controversially.
     * In production applications, these can be controlled with [[LightningChartOptions.warnings]].
     *
     * @param   value       Partial invalidation information, where `values` is an intensity value matrix, `iColumn` the first affected column and `iRow` the first affected row.
     * @returns             Object itself for fluent interface.
     */
    invalidateIntensityValues(value: {
        iColumn: number;
        iRow: number;
        values: number[][];
    }): this;
    /**
     * Set fill style of heatmap series.
     *
     * **Supported fill styles:**
     *
     * [[PalettedFill]]:
     *
     * Colors heatmap fill by looking color up from [[LUT]] based on heatmap *intensity values*.
     *
     * ```js
     *  // Example, color look up by intensity values.
     *  heatmapSeries.setFillStyle(
     *      new PalettedFill({
     *          lut: new LUT({
     *              steps: [
     *                  { value: 0, color: ColorCSS('red') },
     *                  { value: 20, color: ColorCSS('blue') },
     *              ],
     *              interpolate: true,
     *          }),
     *      }),
     *  )
     * ```
     *
     * Assign *intensity values* with [[invalidateIntensityValues]].
     *
     * [[SolidFill]]:
     *
     * Solid color for all heatmap cells. Supported for debugging purposes mainly.
     *
     * [[emptyFill]]:
     *
     * Disables heatmap fill.
     *
     * ```js
     *  // Example, hide heatmap fill and show wireframe.
     *  heatmapSeries
     *      .setFillStyle(emptyFill)
     *      .setWireframeStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
     * ```
     *
     * @param value     FillStyle object or function which modifies current value.
     * @return          Object itself for fluent interface.
     */
    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of series.
     * @return  FillStyle.
     */
    getFillStyle(): FillStyle;
    /**
     * Method for customizing contents of ResultTables when pointing at this Series.
     *
     * ```js
     *  HeatmapGridSeries.setCursorResultTableFormatter((builder, series, dataPoint) =>
     *      builder
     *          .addRow('Pointing at')
     *          .addRow(`${dataPoint.x.toFixed(1)}, ${dataPoint.y.toFixed(1)}`)
     *          .addRow(`= ${dataPoint.intensity.toFixed(1)}`),
     *  )
     * ```
     *
     * Default Axis formatting can be referenced by using [[Axis.formatValue]] method.
     *
     * @param   formatter   Function which builds ResultTable content.
     *                      See definition of [[HeatmapSeriesFormatterIntensity]] for supplied formatting information.
     * @return              Object itself
     */
    setCursorResultTableFormatter(formatter: HeatmapSeriesFormatterIntensity): this;
    /**
     * Get ResultTable Formatter.
     * @return  Function which builds ResultTable content for this series type.
     */
    getCursorResultTableFormatter(): HeatmapSeriesFormatterIntensity<this>;
}
/**
 * Interface describing readonly configurations of a [[HeatmapScrollingGridSeries]].
 *
 * **Required properties:**
 * - [[resolution]]
 *
 * **Optional properies:**
 * - [[start]]
 * - [[step]]
 * - [[scrollDimension]]
 * - [[heatmapDataType]]
 */
export interface HeatmapScrollingGridSeriesOptions<DataType extends 'intensity' = 'intensity'> extends SeriesOptions {
    /**
     * Select scrolling dimension, as well as how to interpret grid matrix values supplied by user.
     *
     * If `columns` is selected, then there will be no limit on how many *columns* can be pushed to the series, but *rows* amount will be static.
     *
     * If `rows` is selected, then there will be no limit on how many *rows* can be pushed to the series, but *columns* amount will be static.
     *
     * Data order:
     *
     * `'columns'` -> Supply lists of "columns"
     *
     * ```typescript
     *  const intensityValues = [
     *      [
     *          0, // Intensity value column = 0, row = 0
     *          0, // Intensity value column = 0, row = 1
     *          0, // Intensity value column = 0, row = n
     *      ],
     *      [
     *          0, // Intensity value column = 1, row = 0
     *          0, // Intensity value column = 1, row = 1
     *          0, // Intensity value column = 1, row = n
     *      ],
     *  ]
     * ```
     *
     * `'rows'` -> Supply lists of "rows"
     *
     * ```typescript
     *  const intensityValues = [
     *      [
     *          0, // Intensity value row = 0, column = 0
     *          0, // Intensity value row = 0, column = 1
     *          0, // Intensity value row = 0, column = n
     *      ],
     *      [
     *          0, // Intensity value row = 1, column = 0
     *          0, // Intensity value row = 1, column = 1
     *          0, // Intensity value row = 1, column = n
     *      ],
     *  ]
     * ```
     *
     * Defaults to `'columns'`.
     */
    scrollDimension?: 'columns' | 'rows';
    /**
     * Static amount of *columns* (cells on X Axis) OR *rows* (cells on Y Axis).
     *
     * This depends on value of `scrollDimension`:
     *
     * `scrollDimension: 'columns'` -> amount of rows.
     *
     * `scrollDimension: 'rows'` -> amount of columns.
     */
    resolution: number;
    /**
     * Selection of format in which heatmap values are supplied.
     *
     * `'intensity'` | numeric value that can be colored with an associated color look up table.
     *
     * Defaults to `'intensity'.`
     */
    heatmapDataType?: DataType;
    /**
     * Start coordinate of Heatmap on its X and Y Axes.
     *
     * Defaults to `{ x: 0, y: 0 }`
     */
    start?: Point;
    /**
     * Step between each consecutive heatmap value on the X and Y Axes.
     *
     * X = columns,
     * Y = rows
     *
     * Defaults to `{ x: 1, y: 1 }`
     */
    step?: Point;
}
/**
 * Abstract Series class for visualizing a *Heatmap Grid*, with API for pushing data in a scrolling manner (append new data on top of existing data).
 *
 * Implementations:
 * - [[HeatmapScrollingGridSeriesIntensityValues]]
 */
export declare abstract class HeatmapScrollingGridSeries extends SeriesXY<HeatmapGridScrolling, CursorPoint, LinearScaleXY> implements SeriesWithDataCleaning, AttachableWithLUT {
    /**
     * Clear all previous data pushed to the series.
     * @return  Object itself for fluent interface.
     */
    clear(): this;
    /**
     * Set style of wireframe.
     *
     * Wireframe is a line grid that highlights the edges of each cell of the heatmap.
     *
     * ```js
     *  // Example, disable wireframe.
     *  heatmapSeries.setWireframeStyle(emptyLine)
     * ```
     *
     * ```js
     *  // Example, set wireframe style.
     *  heatmapSeries.setWireframeStyle(new SolidLine({
     *      thickness: 1,
     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0, 255) })
     *  }))
     * ```
     * @param   value   Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
     * @return          Series itself for fluent interface.
     */
    setWireframeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of wireframe.
     *
     * Wireframe is a line grid that highlights the edges of each cell of the heatmap.
     * @return          LineStyle.
     */
    getWireframeStyle(): LineStyle;
    /**
     * Set heatmap fill pixel interpolation mode.
     *
     * `'disabled'` or `undefined`: Interpolation disabled; all pixels within a grid cell share the same color.
     *
     * `'bilinear'`: Each pixel is colored individually by *bilinear interpolation*.
     * @param   interpolationMode   Heatmap fill pixel interpolation mode selection.
     * @return                      Object itself for fluent interface.
     */
    setPixelInterpolationMode(interpolationMode: IntensityInterpolationMode | undefined): this;
    /**
     * Get heatmap fill pixel interpolation mode.
     * @return                      Heatmap fill pixel interpolation mode selection.
     */
    getPixelInterpolationMode(): IntensityInterpolationMode;
    /**
     * Set cursor interpolation enabled.
     *
     * If enabled, cursors will display bilinearly interpolated *intensity* values from the four closest heatmap cells
     * to the mouse pointer. Otherwise, cursor will display the nearest actual data point supplied by user.
     *
     * @param   state   Boolean flag
     * @returns         Object itself for fluent interface
     */
    setCursorInterpolationEnabled(state: boolean): this;
    /**
     * Get if cursor interpolates solved data-points along series by default.
     * @returns         Boolean flag
     */
    getCursorInterpolationEnabled(): boolean;
    /**
     * Disable automatic data cleaning.
     *
     * ```js
     *  // Example syntax, disable data cleaning.
     *  series.setDataCleaning(undefined)
     * ```
     *
     * @param   arg             Data cleaning configuration.
     * @return                  Object itself for fluent interface.
     */
    setDataCleaning(arg: undefined): this;
    /**
     * Enable automatic data cleaning by `minDataPointCount` configuration.
     *
     * Specifying `minDataPointCount` enables _lazy_ cleaning of data that is **outside view** as long as the remaining data amount doesn't go below the configured threshold.
     *
     * ```js
     *  // Example syntax for specifying minDataPointCount
     *  series.setDataCleaning({ minDataPointCount: 10000 })
     * ```
     *
     * Usage of `minDataPointCount` is recommended in most common applications that require automatic data cleaning.
     * The actual value is often not very particular, just setting it above `0` to enable it is usually enough (lazy data cleaning of out of view data).
     *
     * ```js
     *  // Example, enable lazy data cleaning of out of view data.
     *  series.setDataCleaning({ minDataPointCount: 1 })
     * ```
     *
     * @param   arg             Data cleaning configuration.
     * @return                  Object itself for fluent interface.
     */
    setDataCleaning(arg: {
        minDataPointCount: number | undefined;
    }): this;
    /**
     * Enable automatic data cleaning by `maxDataPointCount` configuration.
     *
     *Specifying `maxDataPointCount` results in data cleaning always happening **exactly** when total data amount exceeds the supplied threshold.
     *
     * ```js
     *  // Example syntax for specifying maxDataPointCount
     *  series.setDataCleaning({ maxDataPointCount: 10000 })
     * ```
     *
     * `maxDataPointCount` is usually used in memory limited applications to prevent running out of memory.
     *
     * **`maxDataPointCount` is currently only supported by only select series:**
     * - [[HeatmapScrollingGridSeries]].
     * - [[OHLCSeries]].
     *
     * If the feature receives good support and usage from the user base, it might be expanded to all series types in a future release.
     *
     * @param   arg             Data cleaning configuration.
     * @return                  Object itself for fluent interface.
     */
    setDataCleaning(arg: {
        maxDataPointCount: number | undefined;
    }): this;
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Series itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick: boolean): this;
    solveNearestFromScreen(location: Point, interpolate?: boolean): undefined | CursorPoint;
    solveNearestFromSegment(location: Point, segment: HeatmapGridStatic, interpolate?: boolean): undefined | CursorPoint;
    /**
     * @return Max X value of the series
     */
    getXMax(): number;
    /**
     * @return Min X value of the series
     */
    getXMin(): number;
    /**
     * @return Max Y value of the series
     */
    getYMax(): number | undefined;
    /**
     * @return Min Y value of the series
     */
    getYMin(): number | undefined;
}
/**
 * Series class for visualizing a *Heatmap Grid*, with API for pushing data in a scrolling manner (append new data on top of existing data).
 *
 * `HeatmapScrollingGridSeriesIntensityValues` is optimized for *massive* amounts of data - here are some reference specs on average PC to give an idea:
 *
 * - Scrolling Heatmap Chart with 2 million incoming data points **per second** (`rows: 2048`, 1000 columns/s) runs consistently and smoothly with 60 FPS and no stuttering. CPU usage stays easily below 40%.
 * - Scrolling Heatmap Chart with 8 million incoming data points **per second** (`rows: 4096`, 2000 columns/s) runs consistently and smoothly with 60 FPS and minor stuttering.
 *
 * `HeatmapScrollingGridSeriesIntensityValues` max data amount is entirely restricted by the client hardware RAM and more specifically amount of RAM usable by the context running LightningChart JS.
 * If performance suddenly plummets at some approximate data threshold, then it is likely that there is not enough RAM available.
 * Use data cleaning configuration and suitable Axis intervals to adjust to your hardware limitations.
 *
 * Each cell of the heatmap grid is associated with a *numeric intensity value*, which can be used in conjuction with a Color look up table ([[LUT]]).
 *
 * Created with [[ChartXY.addHeatmapScrollingGridSeries]].
 *
 * Frequently used API:
 * - Add intensity data [[addIntensityValues]]
 * - Set fill style [[setFillStyle]]
 * - Set wireframe style [[setWireframeStyle]]
 * - Format auto cursor [[setCursorResultTableFormatter]]
 * - Configure automatic data cleaning [[setDataCleaning]]
 */
export declare class HeatmapScrollingGridSeriesIntensityValues extends HeatmapScrollingGridSeries {
    /**
     * Push a Matrix of *intensity values* into the Heatmap grid.
     * Each value describes one cell in the grid.
     *
     * Order of data is selected when creating the series;
     *
     * `scrollDimension: 'columns'` ->
     *
     * ```typescript
     *  [
     *      [
     *          0, // Intensity value column = 0, row = 0
     *          0, // Intensity value column = 0, row = 1
     *          0, // Intensity value column = 0, row = n
     *      ],
     *      [
     *          0, // Intensity value column = 1, row = 0
     *          0, // Intensity value column = 1, row = 1
     *          0, // Intensity value column = 1, row = n
     *      ],
     *  ]
     * ```
     *
     * `scrollDimension: 'rows'` ->
     *
     * ```typescript
     *  [
     *      [
     *          0, // Intensity value row = 0, column = 0
     *          0, // Intensity value row = 0, column = 1
     *          0, // Intensity value row = 0, column = n
     *      ],
     *      [
     *          0, // Intensity value row = 1, column = 0
     *          0, // Intensity value row = 1, column = 1
     *          0, // Intensity value row = 1, column = n
     *      ],
     *  ]
     * ```
     *
     * Example usage:
     *
     * ```typescript
     *  // Create x-scrolling intensity heatmap.
     *  const series = ChartXY.addHeatmapScrollingGridSeries({
     *      heatmapDataType: 'intensity',
     *      scrollDimension: 'columns',
     *      resolution: 5,
     *      start: { x: 0, y: 0 },
     *      step: { x: 1, y: 1 },
     *  })
     *
     *  // Push a column into heatmap.
     *  series.addIntensityValues([
     *      [0, 10, 0, 20, 0]
     *  ])
     * ```
     *
     * `invalidateIntensityValues` can trigger warnings when used controversially.
     * In production applications, these can be controlled with [[LightningChartOptions.warnings]].
     *
     * @param   intensityValues     Matrix of *intensity values* - Each array represents a column or row, and each number represents a cell in the grid.
     * @return                      Object itself for fluent interface.
     */
    addIntensityValues(intensityValues: number[][]): this;
    /**
     * Set fill style of heatmap series.
     *
     * **Supported fill styles:**
     *
     * `PalettedFill`:
     *
     * Colors heatmap fill by looking color up from [[LUT]] based on heatmap *intensity values*.
     *
     * ```js
     *  // Example, color look up by intensity values.
     *  heatmapSeries.setFillStyle(
     *      new PalettedFill({
     *          lut: new LUT({
     *              steps: [
     *                  { value: 0, color: ColorCSS('red') },
     *                  { value: 20, color: ColorCSS('blue') },
     *              ],
     *              interpolate: true,
     *          }),
     *      }),
     *  )
     * ```
     *
     * Intensity values are defined when data is pushed in with [[addIntensityValues]] method.
     *
     * - `SolidFill`:
     *
     * Solid color for all heatmap cells. Supported for debugging purposes mainly.
     *
     * `emptyFill`:
     *
     * Disables heatmap fill.
     *
     * ```js
     *  // Example, hide heatmap fill and show wireframe.
     *  heatmapSeries
     *      .setFillStyle(emptyFill)
     *      .setWireframeStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
     * ```
     *
     * @param value     FillStyle object or function which modifies current value.
     * @return          Object itself for fluent interface.
     */
    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of series.
     * @return  FillStyle.
     */
    getFillStyle(): FillStyle;
    /**
     * Method for customizing contents of ResultTables when pointing at this Series.
     *
     * ```js
     *  HeatmapScrollingGridSeries.setCursorResultTableFormatter((builder, series, dataPoint) =>
     *      builder
     *          .addRow('Pointing at')
     *          .addRow(`${dataPoint.x.toFixed(1)}, ${dataPoint.y.toFixed(1)}`)
     *          .addRow(`= ${dataPoint.intensity.toFixed(1)}`),
     *  )
     * ```
     *
     * Default Axis formatting can be referenced by using [[Axis.formatValue]] method.
     *
     * @param   formatter   Function which builds ResultTable content.
     *                      See definition of [[HeatmapSeriesFormatterIntensity]] for supplied formatting information.
     * @return              Object itself
     */
    setCursorResultTableFormatter(formatter: HeatmapSeriesFormatterIntensity): this;
    /**
     * Get ResultTable Formatter.
     * @return  Function which builds ResultTable content for this series type.
     */
    getCursorResultTableFormatter(): HeatmapSeriesFormatterIntensity<this>;
}
/**
 * IntensityGridSeries for visualization of magnitude in two dimensions.
 *
 * IntensityGridSeries are created with [[ChartXY.addHeatmapSeries]] with IntensitySeriesType of [[IntensitySeriesTypes.Grid]]
 *
 * @deprecated Will be removed in v4.0 in favor of new optimized `Heatmap Series`.
 */
export declare class IntensityGridSeries extends IntensitySeries {
}
/**
 * IntensityMeshSeries for visualization of magnitude in two dimensions.
 *
 * Mesh allows to edit the geometry of the displayed intensity series.
 *
 * IntensityMeshSeries are created with [[ChartXY.addHeatmapSeries]] with IntensitySeriesType of [[IntensitySeriesTypes.Mesh]]
 *
 * @deprecated Will be removed in v4.0 in favor of new optimized `Heatmap Series`.
 */
export declare class IntensityMeshSeries extends IntensitySeries {
    /**
     * Treat the data of the matrix as any of the *Point*-based type of points.
     * *Point*-based data is represented in format { x: number, y: number } to modify the geometry only.
     *
     * Invalidates only the **geometry** coordinates without update the intensity or color data,
     * providing significantly faster rendering of dynamically changed geometry.
     *
     * @param vertices Matrix of new vertices.
     * The resolution of the IntensityMesh should be valid.
     * @param range    Optional configuration object to specify the range of the grid to be invalidated.
     * @returns   Series itself for fluent interface.
     */
    invalidateGeometryOnly(vertices: Matrix<Point>, range?: GridRangeOptions): this;
    /**
     * Treat the data of the matrix as any of the *Point*-based type of points.
     * *Point*-based data is represented in format { x: number, y: number } to modify the geometry only.
     *
     * Invalidates only the **geometry** coordinates without update the intensity or color data,
     * providing significantly faster rendering of dynamically changed geometry.
     *
     * @param callback Callback function to map through the input to modify the matrix geometry.
     * The resolution of the IntensityMesh should be valid.
     * @param range    Optional configuration object to specify the range of the grid to be invalidated.
     * @returns   Series itself for fluent interface.
     */
    invalidateGeometryOnly(vertices: UpdateGeometryCallback<Point>, range?: GridRangeOptions): this;
}
/**
 * Abstract super class for following series types:
 *
 * - [[IntensityGridSeries]]
 * - [[IntensityMeshSeries]]
 *
 * @deprecated Will be removed in v4.0 in favor of new optimized `Heatmap Series`.
 */
export declare abstract class IntensitySeries extends SeriesXY<Intensity, CursorPoint, LinearScaleXY> implements AttachableWithLUT {
    /**
     * @param layer                 Rendering layer for the entire series.
     * @param _chart                Cartesian chart surface.
     * @param _removeFromChart      Injected method to remove the created series from Chart that owns it.
     * @param axisX                 X-axis to which the series has to be attached.
     * @param axisY                 Y-axis to which the series has to be attached.
     * @param axisXAttachHandler    Attach handler for Axis X
     * @param axisYAttachHandler    Attach handler for Axis Y
     * @param _newUILayer           Factory for creating new UI layers for drawing SeriesMarkers
     * @param options               Major mandatory properties of Intensity.
     * @param _dataPattern          Data-Pattern for enabling case-specific optimizations
     * @hidden
     */
    constructor(_chart: ChartXY, _removeFromChart: RemoveHandler<IntensitySeries>, _restoreFromChart: RestoreHandler<IntensitySeries>, layer: Layer2D, axisX: Axis, axisY: Axis, axisXAttachHandler: AxisAttachHandler, axisYAttachHandler: AxisAttachHandler, _newUILayer: () => Layer2D, options: IntensityOptions, _theme: Theme, automaticColorIndex: number);
    /**
     * Reset the existing intensity shape and apply new settings.
     * The following method removes all the existing data.
     * The shape would be reset to the default state:
     * - Old Geometry transformations do not valid. The Intensity is a uniform grid.
     * - Old IntensityValues and/or ColorValues do not valid and exist anymore.
     * @param options   Major mandotary properties of Intensity.
     * @returns   Series itself for fluent interface.
     */
    reset(options: IntensityOptions): this;
    /**
     * Set fill style of Intensity Heatmap Series.
     * * SolidFill: apply single solid color.
     * * IndividualPointFill: apply individual color per data-point.
     * * PalettedFill: apply palette using *LUT* lookup table of colors.
     * * emptyFill: no color, empty rendering.
     * @param   fillstyle  Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns            Series itself for fluent interface.
     */
    setFillStyle(fillstyle: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of Intensity Heatmap Series.
     * * SolidFill: apply single solid color.
     * * IndividualPointFill: apply individual color per data-point.
     * * PalettedFill: apply palette using *LUT* lookup table of colors.
     * * emptyFill: no color, empty rendering.
     *  @return     FillStyle.
     */
    getFillStyle(): FillStyle;
    /**
     * Set style of wireframe.
     *
     * Wireframe is a line grid that highlights the edges of each cell of the heatmap.
     * @param   value   Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @return          Series itself for fluent interface.
     */
    setWireframeStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get style of wireframe.
     *
     * Wireframe is a line grid that highlights the edges of each cell of the heatmap.
     * @return          FillStyle.
     */
    getWireframeStyle(): FillStyle;
    /**
     * Append new rows of data to the end of the Intensity.
     * Update color data of the rows.
     * Example:
     * ```ts
     * // scroll two rows and update colors
     * heatmap.addRow(2, 'color', [
     *  [ColorHEX( '0xFF0000' ), ColorHEX( '0x00FF00' )],
     *  [ColorHEX( '0xFF00FF' ), ColorHEX( '0x00FF00' )]
     * ])
     * ```
     */
    addRow(rows: number, type: 'color', colors: Matrix<Color>): this;
    /**
     * Append new rows of data to the end of the Intensity.
     * Update intensity data of new rows.
     * Example:
     * ```ts
     * // scroll two rows and update values
     * heatmap.addColumn(2, 'value', [
     *  [10, 20],
     *  [50, 68]
     * ])
     * ```
     */
    addRow(rows: number, type: 'value', values: Matrix<number>): this;
    /**
     * Append new columns of data to the end of the Intensity.
     * Update color data of new columns.
     * Example:
     * ```ts
     * // scroll two columns and update colors
     * heatmap.addColumn(2, 'color', [
     *  [ColorHEX( '0xFF0000' ), ColorHEX( '0x00FF00' )],
     *  [ColorHEX( '0xFF00FF' ), ColorHEX( '0x00FF00' )]
     * ])
     * ```
     */
    addColumn(columns: number, type: 'color', colors: Matrix<Color>): this;
    /**
     * Append new columns of data to the end of the Intensity.
     * Update intensity data of new columns.
     * Example:
     * ```ts
     * // scroll two columns and update values
     * heatmap.addColumn(2, 'value', [
     *  [10, 20],
     *  [50, 68]
     * ])
     * ```
     */
    addColumn(columns: number, type: 'value', values: Matrix<number>): this;
    /**
     * Treat the data of the matrix as *ColorValue*-based type of points.
     * *ColorValue*-based data is represented in format { ...color: Color } for *IndividualPointFill* style.
     *
     * Invalidates only the **color** without update the geometry data,
     * providing significantly faster rendering of dynamically changed colors.
     *
     * @param colors Matrix of new colors.
     * The resolution of the IntensityShape should be valid.
     * @param range  Optional configuration object to specify the range of the grid to be invalidated.
     * @returns      Series itself for fluent interface.
     */
    invalidateColorsOnly(colors: Matrix<Color>, range?: GridRangeOptions): this;
    /**
     * Treat the data of the matrix as *ColorValue*-based type of points.
     * *ColorValue*-based date is represented in format { ...color: Color } for *IndividualPointFill* style.
     *
     * Invalidates only the **color** without update the geometry data,
     * providing significantly faster rendering of dynamically changed colors.
     *
     * @param callback Callback function to map through the input to modify the matrix colors.
     * The resolution of the IntensityShape should be valid.
     * @param range    Optional configuration object to specify the range of the grid to be invalidated.
     * @returns        Series itself for fluent interface.
     */
    invalidateColorsOnly(callback: UpdateColorCallback, range?: GridRangeOptions): this;
    /**
     * Treat the data of the matrix as *IntensityValue*-based type of points.
     * *IntensityValue*-based data is represented in format { ...intensity: number } for *PalettedFill* style.
     *
     * Invalidates only the **intensity** values without update the geometry data,
     * providing significantly faster rendering of dynamically changed intensity.
     *
     * @param values Matrix of new intensity values.
     * @param range  Optional configuration object to specify the range of the grid to be invalidated.
     * @returns      Series itself for fluent interface.
     */
    invalidateValuesOnly(values: Matrix<number>, range?: GridRangeOptions): this;
    /**
     * Treat the data of the matrix as *IntensityValue*-based type of points.
     * *IntensityValue*-based data is represented in format { ...intensity: number } for *PalettedFill* style.
     *
     * Invalidates only the **intensity** values without update the geometry data,
     * providing significantly faster rendering of dynamically changed intensity.
     *
     * @param callback Callback function to map through the input to modify the matrix of intensity values.
     * The resolution of the IntensityShape should be valid.
     * @param range  Optional configuration object to specify the range of the grid to be invalidated.
     * @returns      Series itself for fluent interface.
     */
    invalidateValuesOnly(callback: UpdateValueCallback, range?: GridRangeOptions): this;
    solveNearestFromScreen(location: Point, interpolate?: boolean): undefined | CursorPoint;
    solveNearestFromSegment(location: Point, segment: Intensity, interpolate?: boolean): undefined | CursorPoint;
    /**
     * Set if cursor interpolates solved data-points along series by default.
     *
     * ```typescript
     *  // Example, disable default interpolation of intensity grid series.
     *  IntensityGridSeries.setCursorInterpolationEnabled(false)
     * ```
     *
     * **Related API:**
     *
     * - [[setCursorEnabled]] | configure whether *cursors* should pick on this particular *series* or not.
     * - [[setCursorResultTableFormatter]] | configure formatting of *result table* contents, when this series is pointed.
     * - [[ChartXY.setAutoCursorMode]] | configure behavior when auto cursor is visible.
     *
     * @param   state   Boolean flag
     * @returns         Object itself for fluent interface
     */
    setCursorInterpolationEnabled(state: boolean): this;
    /**
     * Get if cursor interpolates solved data-points along series by default.
     * @returns         Boolean flag
     */
    getCursorInterpolationEnabled(): boolean;
    /**
     * Configure formatting of *Cursor ResultTable* when pointing at this *series*.
     *
     * ```typescript
     *  // Example usage
     *  IntensityGridSeries.setCursorResultTableFormatter((tableBuilder, series, x, y, value) => {
     *      return tableBuilder
     *          .addRow(`Pointing at`, '', series.getName())
     *          .addRow(`X:`, '', x.toFixed(0))
     *          .addRow(`Y:`, '', y.toFixed(0))
     *          .addRow(`Value:`, '', value.toFixed(1))
     *  })
     * ```
     *
     * The general syntax of configuring *ResultTable* formatting is shared between all *series* types;
     * You specify a callback function, which receives a [[TableContentBuilder]]. The contents of the table are then set using methods of the *table builder*:
     *
     * ```typescript
     *  // Using TableContentBuilder.
     *  IntensityGridSeries.setCursorResultTableFormatter((tableBuilder, series, x, y, value) => {
     *      // addRow adds a list of strings to a new row in the table. Empty strings ('') will allocate any extra horizontal space within the row.
     *      tableBuilder
     *          .addRow('Item 0:', '', 'Value 0')
     *          .addRow('Item 1:', '', 'Value 1')
     *          .addRow('Long row that highlights the idea of empty strings')
     *
     *      // After configuration, the table builder must be returned!
     *      return tableBuilder
     *  })
     * ````
     *
     * Default Axis formatting can be referenced by using [[Axis.formatValue]] method.
     *
     * The additional values that are supplied to the callback function, **vary per series**,
     * refer to the *series* documentation of `setCursorResultTableFormatter` to learn the exact available information.
     * All `Intensity Series` receive four extra parameters:
     * 1. `series` | reference to the series itself.
     * 2. `x` | pointed data point X coordinate.
     * 3. `y` | pointed data point Y coordinate.
     * 3. `value` | pointed data point *intensity* value.
     *
     * **Related API:**
     *
     * - [[setCursorEnabled]] | configure whether *cursors* should pick on this particular *series* or not.
     * - [[setCursorInterpolationEnabled]] | configure whether cursor interpolates solved data-points.
     * - [[ChartXY.setAutoCursorMode]] | configure behavior when auto cursor is visible.
     *
     * @param   formatter   Function which builds *ResultTable* content.
     * @return              Object itself
     */
    setCursorResultTableFormatter(formatter: IntensitySeriesFormatter): this;
    /**
     * Get ResultTable Formatter.
     * @return  Function which builds ResultTable content for IntensitySeries.
     */
    getCursorResultTableFormatter(): IntensitySeriesFormatter;
    /**
     * @return Max X value of the series
     */
    getXMax(): number | undefined;
    /**
     * @return Min X value of the series
     */
    getXMin(): number | undefined;
    /**
     * @return Max Y value of the series
     */
    getYMax(): number | undefined;
    /**
     * @return Min Y value of the series
     */
    getYMin(): number | undefined;
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Series itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick?: boolean): this;
}
/**
 * Interface can be used to define:
 * - X and Y Axes that a series should be attached to
 * - Resolution (rows & columns)
 * - Start and End points of boundary box
 * - Pixelation mode to draw per cell or per point colouring
 * - Type of intensity series
 *
 * @deprecated Will be removed in v4.0 in favor of new optimized `Heatmap Series`.
 */
export interface IntensitySeriesOptions<IntensityType extends IntensitySeriesTypes> extends IntensityOptions, SeriesOptions {
    /**
     * Defines the type of intensity series. The API can vary for each selected series type.
     *
     * See [[IntensitySeriesTypes]] for a collection of options.
     */
    type?: IntensityType;
}
/**
 * Interface for a function which builds ResultTable content when pointing at a IntensitySeries.
 * @param   tableContentBuilder     Builder that is used to build contents of ResultTable.
 *                                  Use addRow() method for adding content.
 * @param   series                  IntensitySeries
 * @param   value                   Value along axis
 * @param   formatValue             Formating function for values along axis
 * @return                          TableContentBuilder that was supplied
 *
 * @deprecated Will be removed in v4.0 in favor of new optimized `Heatmap Series`.
 */
export declare type IntensitySeriesFormatter = <T extends TableContentBuilder>(tableContentBuilder: T, series: IntensitySeries, x: number, y: number, value: number) => T;
/**
 * @deprecated Will be removed in v4.0 in favor of new optimized `Heatmap Series`.
 */
export declare const IntensitySeriesTypes: {
    /**
     * IntensityGridSeries for visualization of magnitude in two dimensions.
     */
    Grid: typeof IntensityGridSeries;
    /**
     * IntensityMeshSeries for visualization of magnitude in two dimensions.
     *
     * Mesh allows to edit the geometry of the displayed intensity series.
     */
    Mesh: typeof IntensityMeshSeries;
};
/**
 * @deprecated Will be removed in v4.0 in favor of new optimized `Heatmap Series`.
 */
export declare type IntensitySeriesTypes = typeof IntensitySeriesTypes[keyof typeof IntensitySeriesTypes];
/**
 * Implementation of *SeriesXY* for visualizing a collection of progressive *AreaPoints*
 * (which consist of one *X*-value, and two *Y*-values) by filling the area between the points two *Y*-values.
 *
 * Composed of the areas *fill* and *border*, both of which have two possible styles:
 * - **High**
 * - **Low**. This is used for *AreaPoints* whose *high*-value is **lower** than the *low*-value.
 *
 * *AreaRangeSeries* are created with [[ChartXY.addAreaRangeSeries]].
 */
export declare class AreaRangeSeries extends RangeSeries implements ObservableXYData<AreaPoint>, DataInputHighLow {
    /**
     * @param _chart                Parent Chart
     * @param _removeFromChart      Handler for removing reference to series from owning chart
     * @param _restoreFromChart     Handler for restoring reference to series from owning chart
     * @param _layer                Rendering layer
     * @param axisX                 Axis X
     * @param axisY                 Axis Y
     * @param axisXAttachHandler    Attach handler for Axis X
     * @param axisYAttachHandler    Attach handler for Axis Y
     * @param _newUILayer           Factory for creating new UI layers for drawing SeriesMarkers
     * @param _theme                Theme from owning Chart.
     * @hidden
     */
    constructor(chart: ChartXY, _removeFromChart: RemoveHandler<ChartComponent>, _restoreFromChart: RestoreHandler<ChartComponent>, _layer: Layer2D, axisX: Axis, axisY: Axis, axisXAttachHandler: AxisAttachHandler, axisYAttachHandler: AxisAttachHandler, _newUILayer: () => Layer2D, _theme: Theme, automaticColorIndex: number);
    /**
     * Add point or array of points to the dataset.
     *
     * ```ts
     *  // Example syntax
     *  AreaRangeSeries.add({ position: 0, low: 10, high: 100 })
     *
     *  AreaRangeSeries.add([
     *      { position: 0, low: 100, high: 200 },
     *      { position: 10, low: 50, high: 220 },
     *      { position: 20, low: 75, high: 250 },
     *  ])
     * ```
     *
     * **Data gaps**
     *
     * When using [[LineSeries]], [[AreaSeries]], [[AreaRangeSeries]] or other series types which connect data points together,
     * the connections between specific data points can be removed by adding gap data points.
     *
     * A gap data point is specified by using `Number.NaN`.
     *
     * ```ts
     *  // Example, data gap syntax.
     *  AreaRangeSeries.add([
     *      { position: 0, low: 10, high: 30 },
     *      { position: 1, low: 12, high: 32 },
     *      { position: 2, low: Number.NaN, high: Number.NaN },
     *      { position: 10, low: 15, high: 38 },
     *      { position: 11, low: 20, high: 35 },
     *      { position: 12, low: 18, high: 30 }
     *  ])
     * ```
     * @param   points   Single new point or an array of new points.
     * @returns          Series itself for fluent interface.
     */
    add(data: AreaPoint | AreaPoint[]): this;
    /**
     * Add two individual Arrays, one for high values, and another for low values.
     * @param   arrayHigh  Array of High values.
     * @param   arrayLow   Array of Low values. Length should be equal to length of *array1*.
     * @return             Object itself for fluent interface.
     */
    addArraysHighLow(arrayHigh: number[] | TypedArray, arrayLow: number[] | TypedArray, step?: number, start?: number): this;
    /**
     * Set fill style of high area of the Series.
     *
     *Example Usage:
     *```javascript
     * // Specified FillStyle
     * AreaRangeSeries.setHighFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * AreaRangeSeries.setHighFillStyle((solidFill) => solidFill.setA(80))
     * // Hidden (emptyFill is not supported)
     * AreaRangeSeries.setHighFillStyle(transparentFill)
     * ```
     * @param value  Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns      Series itself for fluent interface.
     */
    setHighFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Set fill style of low area of the Series.
     *
     *Example Usage:
     *```javascript
     * // Specified FillStyle
     * AreaRangeSeries.setLowFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * AreaRangeSeries.setLowFillStyle((solidFill) => solidFill.setA(80))
     * // Hidden (emptyFill is not supported)
     * AreaRangeSeries.setLowFillStyle(transparentFill)
     * ```
     * @param value  Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns      Series itself for fluent interface.
     */
    setLowFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Set fill style of high area of the Series when it is highlighted.
     *
     * Example usage:
     *```javascript
     * // Specified FillStyle
     * AreaRangeSeries.setHighFillStyleHighlight(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * AreaRangeSeries.setHighFillStyleHighlight((solidFill) => solidFill.setA(80))
     * // Hidden (emptyFill is not supported)
     * AreaRangeSeries.setHighFillStyleHighlight(transparentFill)
     * // Automatic
     * AreaRangeSeries.setHighFillStyleHighlight(undefined)
     * ```
     * @param value Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value or
     *              undefined for automatic value based on normal style.
     * @returns     Series itself for fluent interface.
     */
    setHighFillStyleHighlight(value: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * Set fill style of low are of the Series when it is highlighted.
     *
     * Example usage:
     *```javascript
     * // Specified FillStyle
     * AreaRangeSeries.setLowFillStyleHighlight(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * AreaRangeSeries.setLowFillStyleHighlight((solidFill) => solidFill.setA(80))
     * // Hidden (emptyFill is not supported)
     * AreaRangeSeries.setLowFillStyleHighlight(transparentFill)
     * // Automatic
     * AreaRangeSeries.setLowFillStyleHighlight(undefined)
     * ```
     * @param value  Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value or
     *              undefined for automatic value based on normal style.
     * @returns      Series itself for fluent interface.
     */
    setLowFillStyleHighlight(value: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * Set style of the Series high stroke.
     *
     * Example usage:
     *```javascript
     * // Specified SolidLine
     * AreaRangeSeries.setHighStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * AreaRangeSeries.setHighStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * AreaRangeSeries.setHighStrokeStyle(transparentLine)
     * ```
     * @param value  Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
     * @returns      Series itself for fluent interface.
     */
    setHighStrokeStyle(value: SolidLine | ImmutableMutator<SolidLine>): this;
    /**
     * Set style of the Series low stroke.
     *
     * Example usage:
     *```javascript
     * // Specified SolidLine
     * AreaRangeSeries.setLowStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * AreaRangeSeries.setLowStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * AreaRangeSeries.setLowStrokeStyle(transparentLine)
     * ```
     * @param value  Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
     * @returns      Series itself for fluent interface.
     */
    setLowStrokeStyle(value: SolidLine | ImmutableMutator<SolidLine>): this;
    /**
     * Set style of the Series high stroke when it is highlighted.
     * Highlighting is activated by placing mouse on top / touching Series (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     *
     * Example usage:
     *```javascript
     * // Specified SolidLine
     * AreaRangeSeries.setHighStrokeStyleHighlight(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * AreaRangeSeries.setHighStrokeStyleHighlight((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * AreaRangeSeries.setHighStrokeStyleHighlight(transparentLine)
     * // Automatic
     * AreaRangeSeries.setHighStrokeStyleHighlight(undefined)
     * ```
     * @param   value   Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value or
     *                  undefined for automatic value based on normal style.
     * @returns         Chart itself
     */
    setHighStrokeStyleHighlight(value: SolidLine | ImmutableMutator<SolidLine> | undefined): this;
    /**
     * Set style of the Series low stroke when it is highlighted.
     * Highlighting is activated by placing mouse on top / touching Series (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     *
     * Example usage:
     *```javascript
     * // Specified SolidLine
     * AreaRangeSeries.setLowStrokeStyleHighlight(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * AreaRangeSeries.setLowStrokeStyleHighlight((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * AreaRangeSeries.setLowStrokeStyleHighlight(transparentLine)
     * // Automatic
     * AreaRangeSeries.setLowStrokeStyleHighlight(undefined)
     * ```
     * @param   value   Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value or
     *                  undefined for automatic value based on normal style.
     * @returns         Chart itself
     */
    setLowStrokeStyleHighlight(value: SolidLine | ImmutableMutator<SolidLine> | undefined): this;
    /**
     * Get a current fill style used for the coloring of the high area in the series.
     * @returns      Current fill style used for the coloring of the high area in the series.
     */
    getHighFillStyle(): FillStyle;
    /**
     * Get a current highlight fill style used for the coloring of the high area by series.
     * @returns     Current highlight fill style used for the coloring of the high area by series.
     */
    getHighFillStyleHighlight(): FillStyle;
    /**
     * Get a current fill style used for the coloring of the low area in the series.
     * @returns      Current fill style used for the coloring of the low area in the series.
     */
    getLowFillStyle(): FillStyle;
    /**
     * Get a current highlight fill style used for the coloring of the low area by series.
     * @returns     Current highlight fill style used for the coloring of the low area by series.
     */
    getLowFillStyleHighlight(): FillStyle;
    /**
     * Get a current line style of a stroke used for the coloring of the high border in the series.
     * @returns     Current line style of a stroke used for the coloring of the high border.
     */
    getHighStrokeStyle(): LineStyle;
    /**
     * Get a current line style of a border used for the coloring of the high border by series.
     * @returns     Current line style of a border used for the coloring of the high border by series.
     */
    getHighStrokeStyleHighlight(): LineStyle;
    /**
     * Get a current line style of a border used for the coloring of the low border in the series.
     * @returns     Current line style of a border used for the coloring of the low border.
     */
    getLowStrokeStyle(): LineStyle;
    /**
     * Get a current line style of a border used for the coloring of of the low border by series.
     * @returns     Current line style of a border used for the coloring of the low border by series.
     */
    getLowStrokeStyleHighlight(): LineStyle;
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Series itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick?: boolean): this;
}
/**
 * Interface for supplying readonly configurations to a [[AreaRangeSeries]].
 */
export interface AreaRangeSeriesOptions extends SeriesOptions {
}
/**
 * The abstact class implements the most part of general logic for mountains.
 * The series contains the following elements:
 * - Junction area with stylable and switchable fill styles for High and Low values.
 * - Line with points for High values border.
 * - Line with points for Low values border.
 * @hidden Internal class
 */
export declare abstract class RangeSeries extends SeriesXY<Junction, CursorPoint, LinearScaleXY | MixedScaleXY> implements SeriesWithDataCleaning {
    /**
     * Disable automatic data cleaning.
     *
     * ```js
     *  // Example syntax, disable data cleaning.
     *  series.setDataCleaning(undefined)
     * ```
     *
     * @param   arg             Data cleaning configuration.
     * @return                  Object itself for fluent interface.
     */
    setDataCleaning(arg: undefined): this;
    /**
     * Enable automatic data cleaning by `minDataPointCount` configuration.
     *
     * Specifying `minDataPointCount` enables _lazy_ cleaning of data that is **outside view** as long as the remaining data amount doesn't go below the configured threshold.
     *
     * ```js
     *  // Example syntax for specifying minDataPointCount
     *  series.setDataCleaning({ minDataPointCount: 10000 })
     * ```
     *
     * Usage of `minDataPointCount` is recommended in most common applications that require automatic data cleaning.
     * The actual value is often not very particular, just setting it above `0` to enable it is usually enough (lazy data cleaning of out of view data).
     *
     * ```js
     *  // Example, enable lazy data cleaning of out of view data.
     *  series.setDataCleaning({ minDataPointCount: 1 })
     * ```
     *
     * @param   arg             Data cleaning configuration.
     * @return                  Object itself for fluent interface.
     */
    setDataCleaning(arg: {
        minDataPointCount: number | undefined;
    }): this;
    /**
     * Clear all previously pushed data points from the *series*.
     *
     * ```ts
     *  // Example usage
     *  LineSeries.clear()
     * ```
     *
     * @return      Object itself for fluent interface.
     */
    clear(): this;
    /**
     * Get amount of points that series currently has.
     * @return  Number of points
     */
    getPointAmount(): number;
    /**
     * Set if cursor interpolates solved data-points along series by default.
     *
     * ```typescript
     *  // Example, disable default interpolation of area series.
     *  const series = ChartXY.addAreaSeries()
     *      .setCursorInterpolationEnabled(false)
     * ```
     *
     * **Related API:**
     *
     * - [[setCursorEnabled]] | configure whether *cursors* should pick on this particular *series* or not.
     * - [[setCursorResultTableFormatter]] | configure formatting of *result table* contents, when this series is pointed.
     * - `setCursorSolveBasis` | configure basis of finding nearest data point for the series (`'nearest-x'`, `'nearest'`, etc.).
     * NOTE: This method is not yet available for *range series*, stay tuned for future updates!.
     * - [[ChartXY.setAutoCursorMode]] | configure behavior when auto cursor is visible.
     *
     * @param   state   Boolean flag
     * @returns         Object itself for fluent interface
     */
    setCursorInterpolationEnabled(state: boolean): this;
    /**
     * Get if cursor interpolates solved data-points along series by default.
     * @returns         Boolean flag
     */
    getCursorInterpolationEnabled(): boolean;
    /**
     * Configure automatic *data cleaning* by `maxPointCount`.
     * This allows the cleaning of all excess data points that are outside view, so that after cleaning at least `maxPointCount`
     * data points are retained.
     * Essentially it configures the *head length* of a series.
     *
     * ```ts
     *  // Example, progressive X line series with automatic data cleaning.
     *  const series = ChartXY.addLineSeries({
     *      dataPattern: {
     *          pattern: 'ProgressiveX'
     *      }
     *  })
     *      // Keep at least 1000 data points in series, otherwise excess out of view data can be cleaned for more memory.
     *      .setMaxPointCount(1000)
     *
     * // Setup automatically scrolling X Axis.
     * chart.getDefaultAxisX().setScrollStrategy(AxisScrollStrategies.progressive).setInterval(0, 1000)
     *
     *  // Continously stream data into series.
     *  let x = 0
     *  setInterval(() => {
     *      const newDataPoints = []
     *      for (let i = 0; i <= 10; i += 1) {
     *          newDataPoints.push({ x: x + i, y: Math.random() * 100 })
     *      }
     *      x += newDataPoints.length
     *      series.add(newDataPoints)
     *  }, 1000 / 60)
     * ```
     *
     * Enabling automatic *data cleaning* is crucial in applications that run for a long time, or even *forever*,
     * because it allows clearing memory for allocating new data points.
     *
     * @param   maxPointCount   Configuration for automatic *data cleaning* by `maxPointCount`.
     *                          If undefined or 0 is passed, automatic *data cleaning* by `maxPointCount` will be disabled.
     * @returns                 Object itself for fluent interface.
     * @deprecated              Will be removed in v4.0 in favour of [[setDataCleaning]].
     */
    setMaxPointCount(maxPointCount?: number): this;
    /**
     * Get amount of points that series should keep around at all times (data-cleaning won't touch them).
     * @return  Number of points, or undefined if data-cleaning is disabled
     */
    getMaxPointCount(): number | undefined;
    /**
     * Configure formatting of *Cursor ResultTable* when pointing at this *series*.
     *
     * ```typescript
     *  // Example usage
     *  AreaSeries.setCursorResultTableFormatter((tableBuilder, series, position, high, low) => {
     *      return tableBuilder
     *          .addRow(`Pointing at`, '', series.getName())
     *          .addRow(`X:`, '', position.toFixed(1))
     *          .addRow(`Y:`, '', high.toFixed(1))
     *  })
     * ```
     *
     * The general syntax of configuring *ResultTable* formatting is shared between all *series* types;
     * You specify a callback function, which receives a [[TableContentBuilder]]. The contents of the table are then set using methods of the *table builder*:
     *
     * ```typescript
     *  // Using TableContentBuilder.
     *  AreaSeries.setCursorResultTableFormatter((tableBuilder, series, position, high, low) => {
     *      // addRow adds a list of strings to a new row in the table. Empty strings ('') will allocate any extra horizontal space within the row.
     *      tableBuilder
     *          .addRow('Item 0:', '', 'Value 0')
     *          .addRow('Item 1:', '', 'Value 1')
     *          .addRow('Long row that highlights the idea of empty strings')
     *
     *      // After configuration, the table builder must be returned!
     *      return tableBuilder
     *  })
     * ````
     *
     * Default Axis formatting can be referenced by using [[Axis.formatValue]] method.
     *
     * The additional values that are supplied to the callback function, **vary per series**,
     * refer to the *series* documentation of `setCursorResultTableFormatter` to learn the exact available information.
     * All `Range Series` (*area* and *area-range*) receive four extra parameters:
     * 1. `series` | reference to the series itself.
     * 2. `position` | pointed data point X coordinate.
     * 3. `high` | pointed data point high Y coordinate.
     * 3. `low` | pointed data point low Y coordinate.
     *
     * **Related API:**
     *
     * - [[setCursorEnabled]] | configure whether *cursors* should pick on this particular *series* or not.
     * - [[setCursorInterpolationEnabled]] | configure whether cursor interpolates solved data-points.
     * - [[ChartXY.setAutoCursorMode]] | configure behavior when auto cursor is visible.
     *
     * @param   formatter   Function which builds *ResultTable* content.
     * @return              Object itself
     */
    setCursorResultTableFormatter(formatter: RangeSeriesFormatter): this;
    /**
     * Get ResultTable Formatter.
     * @return  Function which builds ResultTable content for RangeSeries.
     */
    getCursorResultTableFormatter(): RangeSeriesFormatter;
    /**
     * @return Max X value of the series
     */
    getXMax(): number | undefined;
    /**
     * @return Min X value of the series
     */
    getXMin(): number | undefined;
    /**
     * @return Max Y value of the series
     */
    getYMax(): number | undefined;
    /**
     * @return Min Y value of the series
     */
    getYMin(): number | undefined;
    /**
     * Tell the owning chart to remove this series.
     * @return  Object itself.
     */
    dispose(): this;
    /**
     * Tell the owning chart to restore this series.
     * @return  Object itself.
     */
    restore(): this;
    /**
     * Method that solves the nearest datapoint on mountain to a given coordinate on screen.
     * @param   location    Location on screen
     * @return              Undefined or data-structure for positioning of cursors
     */
    solveNearestFromScreen(location: Point, interpolate?: boolean): undefined | CursorPoint;
    /**
     * Method that solves the nearest datapoint on mountain to a given coordinate on a screen from a specific segment.
     * @param   location    Location on screen
     * @param   segment     Segment to solve from
     * @return              Undefined or data-structure for positioning of cursors
     */
    solveNearestFromSegment(location: Point, segment: Junction, interpolate?: boolean): undefined | CursorPoint;
}
/**
 * Interface for a function which builds ResultTable content when pointing at a RangeSeries.
 * @param   tableContentBuilder     Builder that is used to build contents of ResultTable.
 *                                  Use addRow() method for adding content.
 * @param series                    RangeSeries.
 * @param position                  Position on the axis.
 * @param high                      High value on the axis.
 * @param low                       Low value on the axis.
 * @return                          TableContentBuilder that was supplied
 */
export declare type RangeSeriesFormatter = <T extends TableContentBuilder>(tableContentBuilder: T, series: RangeSeries, position: number, high: number, low: number) => T;
/**
 * Enum for selecting step behavior for [[StepSeries]].
 *
 * This must be specified when the [[StepSeries]] is created, and can't be changed afterwards.
 */
export declare enum StepOptions {
    /**
     * The y-value changes before the x-value.
     */
    before = 0,
    /**
     * The y-value changes at the midpoint of each pair of adjacent x-values.
     */
    middle = 0.5,
    /**
     * The y-value changes after the x-value.
     */
    after = 1
}
/**
 * Class for visualization of polynom function.
 */
export declare class SplineSeries extends PointLineSeries {
    /**
     * Set if cursor interpolates solved data-points along series by default.
     *
     * ```typescript
     *  // Example, disable default interpolation of spline series.
     *  const series = ChartXY.addSplineSeries()
     *      .setCursorInterpolationEnabled(false)
     * ```
     *
     * **Related API:**
     *
     * - [[setCursorEnabled]] | configure whether *cursors* should pick on this particular *series* or not.
     * - [[setCursorResultTableFormatter]] | configure formatting of *result table* contents, when this series is pointed.
     * - [[setCursorSolveBasis]] | configure basis of finding nearest data point for the series (`'nearest-x'`, `'nearest'`, etc.).
     * - [[ChartXY.setAutoCursorMode]] | configure behavior when auto cursor is visible.
     *
     * @param   state   Boolean flag
     * @returns         Object itself for fluent interface
     */
    setCursorInterpolationEnabled(state: boolean): this;
    /**
     * Solves the nearest datapoint of a given coordinate on screen
     * @param   location    Location on screen
     * @param   interpolate Should interpolate? If omitted, defaults to setting of series
     * @return              Undefined or data-structure for positioning of cursors
     */
    solveNearestFromScreen(location: Point, interpolate?: boolean): undefined | CursorPoint;
    /**
     * Solves the nearest datapoint to a given coordinate on a screen from a specific segment.
     * @param   location    Location on screen
     * @param   segment     Segment to solve data-point from
     * @param   interpolate Should interpolate? If omitted, defaults to setting of series
     * @return              Undefined or data-structure for positioning of cursors
     */
    solveNearestFromSegment(location: Point, segment: LineSet | PointSet, interpolate?: boolean): undefined | CursorPoint;
    /**
     * Configure automatic *data cleaning* by `maxPointCount`.
     * This allows the cleaning of all excess data points that are outside view, so that after cleaning at least `maxPointCount`
     * data points are retained.
     * Essentially it configures the *head length* of a series.
     *
     * ```ts
     *  // Example, progressive X line series with automatic data cleaning.
     *  const series = ChartXY.addLineSeries({
     *      dataPattern: {
     *          pattern: 'ProgressiveX'
     *      }
     *  })
     *      // Keep at least 1000 data points in series, otherwise excess out of view data can be cleaned for more memory.
     *      .setMaxPointCount(1000)
     *
     * // Setup automatically scrolling X Axis.
     * chart.getDefaultAxisX().setScrollStrategy(AxisScrollStrategies.progressive).setInterval(0, 1000)
     *
     *  // Continously stream data into series.
     *  let x = 0
     *  setInterval(() => {
     *      const newDataPoints = []
     *      for (let i = 0; i <= 10; i += 1) {
     *          newDataPoints.push({ x: x + i, y: Math.random() * 100 })
     *      }
     *      x += newDataPoints.length
     *      series.add(newDataPoints)
     *  }, 1000 / 60)
     * ```
     *
     * For *progressive* `LineSeries`, there is another way to enable automatic *data cleaning*: [[setDataCleaningThreshold]].
     *
     * Enabling automatic *data cleaning* is crucial in applications that run for a long time, or even *forever*,
     * because it allows clearing memory for allocating new data points.
     *
     * @param   maxPointCount   Configuration for automatic *data cleaning* by `maxPointCount`.
     *                          If undefined or 0 is passed, automatic *data cleaning* by `maxPointCount` will be disabled.
     * @returns                 Object itself for fluent interface.
     * @deprecated              Will be removed in v4.0 in favour of [[setDataCleaning]].
     */
    setMaxPointCount(maxPointCount?: number): this;
}
/**
 * Interface for readonly configuration of [[SplineSeries]].
 *
 * **Commonly used properties:**
 * - [[SplineSeriesOptions.pointShape]]: Specify shape of *point markers*.
 * - [[SplineSeriesOptions.xAxis]]: Attach series on non-default X Axis.
 * - [[SplineSeriesOptions.yAxis]]: Attach series on non-default Y Axis.
 *
 * **Example usage:**
 *
 * ```typescript
 *  // Example 1, create series with default configuration.
 *  const series = ChartXY.addSplineSeries({})
 * ```
 *
 * ```typescript
 *  // Example 2, select shape of point markers.
 *  const series = ChartXY.addSplineSeries({
 *      pointShape: PointShape.Circle
 *  })
 * ```
 */
export interface SplineSeriesOptions extends PointLineSeriesOptions {
}
/**
 * Step Series that plots incoming data-points using Step preprocessing function.
 */
export declare class StepSeries extends PointLineSeries {
    /**
     * @param chart                 Owning Chart
     * @param _removeFromChart      Handler for removing reference to series from owning chart
     * @param _restoreFromChart     Handler for restoring reference to series from owning chart
     * @param _layer                Rendering layer
     * @param axisX                 Axis X
     * @param axisY                 Axis Y
     * @param axisXAttachHandler    Attach handler for Axis X
     * @param axisYAttachHandler    Attach handler for Axis Y
     * @param _newUILayer           Factory for creating new UI layers for drawing SeriesMarkers
     * @param _dataPattern          Data-Pattern for enabling case-specific optimizations
     * @param _pointShape           Shape for points of PointSeries
     * @param _step                 Step function, which defines how series will be visualized.
     * @param _theme                Theme from owning Chart, used for styling
     * @hidden
     */
    constructor(chart: ChartXY, _removeFromChart: RemoveHandler<ChartComponent>, _restoreFromChart: RestoreHandler<ChartComponent>, _layer: Layer2D, axisX: Axis, axisY: Axis, axisXAttachHandler: AxisAttachHandler, axisYAttachHandler: AxisAttachHandler, _newUILayer: () => Layer2D, _pointShape: PointShape, _step: StepOptions, _theme: Theme, _userApplicationFlags: InternalApplicationFlagPlusArgs[], automaticColorIndex: number);
}
/**
 * Interface for readonly configuration of [[StepSeries]].
 *
 * **Commonly used properties:**
 * - [[StepSeries.mode]]: Select stroke edge step behavior.
 * - [[StepSeries.pointShape]]: Specify shape of *point markers*.
 * - [[StepSeries.xAxis]]: Attach series on non-default X Axis.
 * - [[StepSeries.yAxis]]: Attach series on non-default Y Axis.
 *
 * **Example usage:**
 *
 * ```typescript
 *  // Example 1, create series with default configuration.
 *  const series = ChartXY.addStepSeries({})
 * ```
 *
 * ```typescript
 *  // Example 2, select shape of point markers.
 *  const series = ChartXY.addStepSeries({
 *      pointShape: PointShape.Circle
 *  })
 * ```
 *
 * Note, currently `StepSeries` only supports `'ProgressiveX'` data.
 */
export interface StepSeriesOptions extends PointLineSeriesOptions {
    /**
     * Step behavior for [[StepSeries]].
     *
     * Select value from [[StepOptions]].
     *
     * ```typescript
     *  // Example, step Y edge before X.
     *  const series = ChartXY.addPointLineSeries({
     *      mode: StepOptions.before,
     *  })
     * ```
     */
    mode?: StepOptions;
}
/**
 * Different ways the image might be placed on the element.
 *
 * See [[ImageFill]].
 * @see ImageFill
 */
export declare enum ImageFitMode {
    /**
     * Ensures that the image fills the full area of the element it's inside of.
     * Will keep image aspect ratio as is.
     * Image might be clipped on the smaller size axis.
     */
    Fill = 0,
    /**
     * Ensures that the image fits in the full area of the element it's inside of.
     * Will keep image aspect ratio as is.
     * Image might be not fill the element fully on the larger size axis.
     */
    Fit = 1,
    /**
     * Ensures that the image fills the full area of the element it's inside of.
     * Image aspect ratio will be distorted if the element aspect ratio is not same as the image aspect ratio.
     */
    Stretch = 2,
    /**
     * Places the image to the center of the full area of the element it's inside of.
     * Image aspect ratio will be kept as is.
     * Image might be clipped or not fill the element on either top/bottom and/or left/right, if the element is not same size as the image.
     */
    Center = 3
}
/**
 * Types that are accepted as the image source for [[ImageFill]].
 *
 * Can be any of `ImageBitmap | ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement`
 *
 * @see ImageFill
 */
export declare type ImageFillSource = TexImageSource | undefined;
/**
 * Interface for all options of a [[ImageFill]].
 *
 * See [[ImageFill]].
 * @see ImageFill
 */
export interface ImageFillStyleProperties {
    /**
     * The image source element to use.
     *
     * Can be any of [[ImageFillSource]].
     *
     * Most commonly a `HTMLImageElement`.
     *
     * Example:
     * ```javascript
     * const myImage = new Image()
     * myImage.src = 'https://example.com/myImage.png'
     * const imageFill = new ImageFill({
     *      source: myImage
     * })
     * ```
     */
    source: ImageFillSource;
    /**
     * The color filling the area of element not filled by the image.
     */
    surroundingColor: Color;
    /**
     * The color filling element when image is loading or image loading failed.
     */
    sourceMissingColor: Color;
    /**
     * Image fitting mode.
     *
     * Example:
     *
     * ```javascript
     * const imageFill = new ImageFill({
     *      fitMode: ImageFitMode.Stretch
     * })
     * ```
     */
    fitMode: ImageFitMode;
}
/**
 * **Internal feature !**
 *
 * Record contractor for ImageFillFillStyleProperties.
 * @hidden
 */
declare const ImageFillStyleRecord: Record.Factory<ImageFillStyleProperties>;
/**
 * Style class for describing a *image fill style*.
 *
 * Instances of ImageFill, like all LCJS style classes, are *immutable*, meaning that its setters don't modify the actual object,
 * but instead return a completely new modified object.
 *
 * **Properties of ImageFill:**
 * - `surroundingColor`: Fill color for the area surrounding the image. Construct a *LCJS color* using one of the many available *factories*:
 *      * [[ColorRGBA]]
 *      * [[ColorHEX]]
 *      * [[ColorCSS]]
 *      * [[ColorHSV]]
 *
 * - `sourceMissingColor`: Fill color used in place of the image when image is loading or image loading has failed. Construct a *LCJS color* using one of the many available *factories*:
 *      * [[ColorRGBA]]
 *      * [[ColorHEX]]
 *      * [[ColorCSS]]
 *      * [[ColorHSV]]
 *
 * - `fitMode`: [[ImageFitMode]] that specifies how the image is placed inside of the element using the ImageFill.
 * - `source`: Image source object. Can be any of `ImageBitmap | ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement`.
 *
 * **ImageFill Usage:**
 *
 * Use ImageFill with:
 * - `setFillStyle` methods:
 *      * [[RectangleFigure.setFillStyle]]
 *      * [[ChartXY.setSeriesBackgroundFillStyle]]
 *      * [[ChartXY.setBackgroundFillStyle]]
 *      * [[ChartXY.setZoomingRectangleFillStyle]]
 *      * [[ChartXY.setFittingRectangleFillStyle]]
 *      * [[Chart3D.setBackgroundFillStyle]]
 *      * [[Axis.setOverlayStyle]]
 *      * [[UIBackground.setFillStyle]]
 *
 * Example 1:
 * Styling a rectangle figure with an image.
 * ```typescript
 * const myImage = new Image()
 * myImage.src = 'https://example.com/myImage.png'
 * rectangleFigure.setFillStyle(new ImageFill({
 *     source: myImage,
 *     fitMode: ImageFitModes.Stretch
 * }))
 * ```
 *
 * Example 2:
 * Creating a new ImageFill object with a video as the source.
 * ```javascript
 * const myVideo = document.createElement('video')
 * myVideo.autoplay = true
 * myVideo.muted = true
 * myVideo.loop = true
 * myVideo.src = 'https://example.com/myVideo.mp4'
 * myVideo.play()
 * const imageFill = new ImageFill({
 *      source: myVideo,
 *      fitMode: ImageFitModes.Fit
 * })
 * ```
 *
 * **Related information:**
 *
 * For more *fill styles*, see:
 * - [[emptyFill]]
 * - [[IndividualPointFill]]
 * - [[PalettedFill]]
 * - [[RadialGradientFill]]
 * - [[LinearGradientFill]]
 * - [[SolidFill]]
 */
export declare class ImageFill extends ImageFillStyleRecord implements FillStyle {
    readonly type = "fillstyle";
    /**
     * Construct a new ImageFill object, specifying any amount of its properties.
     *
     * Example 1:
     * Creating a new ImageFill object with an image as the source.
     * ```javascript
     * const myImage = new Image()
     * myImage.src = 'https://example.com/myImage.png'
     * const imageFill = new ImageFill({
     *      source: myImage,
     *      fitMode: ImageFitModes.Stretch
     * })
     * ```
     *
     * Example 2:
     * Creating a new ImageFill object with a video as the source.
     * ```javascript
     * const myVideo = document.createElement('video')
     * myVideo.autoplay = true
     * myVideo.muted = true
     * myVideo.loop = true
     * myVideo.src = 'https://example.com/myVideo.mp4'
     * myVideo.play()
     * const imageFill = new ImageFill({
     *      source: myVideo,
     *      fitMode: ImageFitModes.Fit
     * })
     * ```
     *
     * When a HTMLVideoElement is specified as the source the chart will be constantly rendered while the video is playing.
     *
     * @param props Object containing any amount of ImageFill properties.
     */
    constructor(props?: Partial<ImageFillStyleProperties>);
    /**
     * Construct a new ImageFill object based on this one, but with different image source.
     *
     * Example:
     * ```javascript
     * const myImg = new Image()
     * myImg.src = 'https://example.com/myImage.png'
     * imageFill.setSource(myImg)
     * ```
     *
     * @param   value   TextureSource object
     * @return          New ImageFill object
     */
    setSource(value: ImageFillSource): this;
    /**
     * Get image of ImageFill.
     * @return  ImageTexture object
     */
    getSource(): ImageFillSource;
    /**
     * Construct a new ImageFill object based on this one, but with modified surrounding color.
     *
     * Surrounding color is used to fill the remaining element when the image doesn't fill the element completely.
     *
     * Example:
     * ```javascript
     * // specify new color
     * imageFill.setSurroundingColor( ColorHEX('#F00') )
     *
     * // change individual color properties
     * imageFill.setSurroundingColor( color => color.setA(80) )
     * ```
     * @param   value   Either a Color object or a function, which will be used to create a new Color based on current value.
     * @return          New ImageFill object
     */
    setSurroundingColor(value: Color | ImmutableMutator<Color>): this;
    /**
     * Get color of ImageFill.
     * @return  Color object
     */
    getSurroundingColor(): Color;
    /**
     * Construct a new ImageFill object based on this one, but with modified source missing color.
     *
     * Source missing color is used in place of an image when the image has not been loaded yet or loading of the image has failed.
     *
     * Example:
     * ```javascript
     * // specify new color
     * imageFill.setSourceMissingColor( ColorHEX('#F00') )
     *
     * // change individual color properties
     * imageFill.setSourceMissingColor( color => color.setA(80) )
     * ```
     * @param   value   Either a Color object or a function, which will be used to create a new Color based on current value.
     * @return          New ImageFill object
     */
    setSourceMissingColor(value: Color | ImmutableMutator<Color>): this;
    /**
     * Get source missing color of ImageFill.
     * @return  Color object
     */
    getSourceMissingColor(): Color;
    /**
     * Set new image fit mode.
     * @param value Image fit mode
     */
    setFitMode(value: ImageFitMode): this;
    /**
     * Get fit mode of ImageFill.
     * @return  Fit mode
     */
    getFitMode(): ImageFitMode;
    /**
     * @return Newly created default highlight style of this one, with lighter fill color
     */
    protected createDefaultHighlightStyle(): this;
    /**
     * Cache default highlight style to prevent recreation
     */
    private _defaultHighlightStyle?;
    /**
     * Get automatically computed highlight style.
     * @return  FillStyle object
     */
    getDefaultHighlightStyle(): this;
}
export {};

export declare abstract class AbstractBoxGeometry3D extends GlInstanceGeometry implements GlInstanceGeometry3D {
    constructor(_glUtils: GlUtils);
}

export declare class BoxGeometry3D extends AbstractBoxGeometry3D {
    constructor(glUtils: GlUtils);
}

export declare class BoxRoundedEdgesGeometry3D extends AbstractBoxGeometry3D {
    constructor(glUtils: GlUtils, roundness: number);
}

export declare class LineSegmentGeometry2D extends GlInstanceGeometry {
    protected readonly _resolution: number;
    
    constructor(_glUtils: GlUtils, _resolution: number);
}

export declare class LineSegmentGeometry3D extends GlInstanceGeometry implements GlInstanceGeometry3D {
    protected readonly _resolution: number;
    
    constructor(_glUtils: GlUtils, _resolution: number);
}

export declare class PointGeo extends GlInstanceGeometry {
    
    constructor(_glUtils: GlUtils, _data: Point[]);
}

export declare class SphereGeometry3D extends GlInstanceGeometry implements GlInstanceGeometry3D {
    protected readonly _sectors: number;
    protected readonly _stacks: number;
    
    constructor(_glUtils: GlUtils, _sectors: number, _stacks: number);
}

export declare class GlArc extends Arc implements GlEntity {
    protected readonly _glEngine: GlEngine;
    
    constructor(_glEngine: GlEngine, scale: LinearScaleXY | RadialScale, remove: RemoveHandler<GlArc>, restore: RestoreHandler<GlArc>, applicationFlags: InternalApplicationFlagPlusArgs[]);
}

export declare class GlBoxSet3DInstanced extends GlShape3D implements BoxSet3D {
    constructor(_glLayer3D: GlLayer3D, _remove: RemoveHandler<GlShape3D>, _restore: RestoreHandler<GlShape3D>, applicationFlags: InternalApplicationFlagPlusArgs[]);
}

export declare class GlConvexPolygon extends ConvexPolygon implements GlEntity {
    protected readonly _glEngine: GlEngine;
    
    constructor(_glEngine: GlEngine, scale: LinearScaleXY | RadialScale, remove: RemoveHandler<GlConvexPolygon>, restore: RemoveHandler<GlConvexPolygon>, applicationFlags: InternalApplicationFlagPlusArgs[]);
}

export declare class GlIntensity extends Intensity implements GlEntity {
    protected readonly _glEngine: GlEngine;
    
    constructor(_glEngine: GlEngine, scale: LinearScaleXY | RadialScale, remove: RemoveHandler<GlIntensity>, restore: RestoreHandler<GlIntensity>, applicationFlags: InternalApplicationFlagPlusArgs[]);
}

export declare class GlJunction extends Junction implements GlEntity {
    protected readonly _glEngine: GlEngine;
    
    constructor(_glEngine: GlEngine, scale: LinearScaleXY | RadialScale | MixedScaleXY, remove: RemoveHandler<GlJunction>, restore: RestoreHandler<GlJunction>, applicationFlags: InternalApplicationFlagPlusArgs[]);
}

export declare class GlLine extends Line implements GlEntity {
    protected readonly _glEngine: GlEngine;
    
    constructor(_glEngine: GlEngine, scale: LinearScaleXY | RadialScale | MixedScaleXY, remove: RemoveHandler<GlLine>, restore: RestoreHandler<GlLine>, applicationFlags: InternalApplicationFlagPlusArgs[]);
    
    dispose(): this;
}
export declare class GlLineCollection extends LineCollection implements GlEntity {
    protected readonly _glEngine: GlEngine;
    
    constructor(_glEngine: GlEngine, scale: LinearScaleXY | RadialScale | MixedScaleXY, remove: RemoveHandler<GlLineCollection>, restore: RestoreHandler<GlLineCollection>, applicationFlags: InternalApplicationFlagPlusArgs[]);
}

export declare class GlLineCollection3D extends GlShape3D implements LineCollection3D, GlEntity {
    
    constructor(_layer: GlLayer3D, _remove: RemoveHandler<GlLineCollection3D>, _restore: RestoreHandler<GlLineCollection3D>, applicationFlags: InternalApplicationFlagPlusArgs[]);
}

export declare class GlLineSet extends LineSet<LinearScaleXY | RadialScale | MixedScaleXY> implements GlEntity {
    protected readonly _options: LineSetOptions | undefined;
    
    constructor(_glEngine: GlEngine, scale: LinearScaleXY | RadialScale | MixedScaleXY, remove: RemoveHandler<GlLineSet>, restore: RestoreHandler<GlLineSet>, applicationFlags: InternalApplicationFlagPlusArgs[], _options: LineSetOptions | undefined);
    
    dispose(): this;
    
    getPointsBounds(): Interval<Point>;
}

export declare class GlLineSet3D extends GlShape3D implements LineSet3D {
    
    constructor(_layer: GlLayer3D, _remove: RemoveHandler<GlLineSet3D>, _restore: RestoreHandler<GlLineSet3D>, applicationFlags: InternalApplicationFlagPlusArgs[]);
    
    dispose(): this;
}

export declare class GlPointSet3D extends GlShape3D implements PointSet3D, GlEntity {
    protected readonly _options: PointSet3DOptions | undefined;
    
    constructor(_layer: GlLayer3D, _remove: RemoveHandler<GlPointSet3D>, _restore: RestoreHandler<GlPointSet3D>, applicationFlags: InternalApplicationFlagPlusArgs[], _options: PointSet3DOptions | undefined);
    
    dispose(): this;
}

export declare class GlPointSetInstanced extends PointSet implements GlEntity {
    protected readonly _glEngine: GlEngine;
    
    constructor(_glEngine: GlEngine, scale: LinearScaleXY | RadialScale | MixedScaleXY, remove: RemoveHandler<GlPointSetInstanced>, restore: RestoreHandler<GlPointSetInstanced>, applicationFlags: InternalApplicationFlagPlusArgs[]);
}

export declare class GLRect extends Rect implements GlEntity {
    protected readonly _glEngine: GlEngine;
    
    constructor(_glEngine: GlEngine, scale: LinearScaleXY | RadialScale | MixedScaleXY, remove: RemoveHandler<GLRect>, restore: RestoreHandler<GLRect>, applicationFlags: InternalApplicationFlagPlusArgs[]);
}

export declare abstract class GlShape3D extends Shape3D implements GlEntity {
    protected readonly _glLayer3D: GlLayer3D;
    constructor(_glLayer3D: GlLayer3D, _remove: RemoveHandler<GlShape3D>, _restore: RestoreHandler<GlShape3D>, applicationFlags: InternalApplicationFlagPlusArgs[]);
}

export declare class GlSimplePolygon extends SimplePolygon implements GlEntity {
    protected readonly _glEngine: GlEngine;
    
    constructor(_glEngine: GlEngine, scale: LinearScaleXY | RadialScale, remove: RemoveHandler<GlSimplePolygon>, restore: RestoreHandler<GlSimplePolygon>, applicationFlags: InternalApplicationFlagPlusArgs[]);
}

export declare class GlSurface3D extends GlShape3D implements Surface3D, IntensityState<Point3D>, GlEntity {
    
    constructor(_layer: GlLayer3D, _remove: RemoveHandler<GlSurface3D>, _restore: RestoreHandler<GlSurface3D>, applicationFlags: InternalApplicationFlagPlusArgs[]);
}

export declare class ShaderBuilder {
    modifiers: ShaderModifier[];
    constructor(modifiers: ShaderModifier[]);
    
    alter(modifiers: ShaderModifier[]): ShaderBuilder;
    
    build(src: string): string;
}

export declare type ShaderModifier = (src: string) => string;

export declare const ShaderAdd: (...codeLines: (string | false | undefined)[]) => ShaderModifier;

export declare const ShaderAddFunction: (func: string) => ShaderModifier;

export declare const ShaderRemove: (code: string) => ShaderModifier;

export declare const ShaderStart: (...codeLines: string[]) => ShaderModifier;

export declare const ShaderBefore: (match: string, ...codeLines: string[]) => ShaderModifier;

export declare const ShaderAfter: (match: string, ...codeLines: string[]) => ShaderModifier;

export declare const ShaderEnd: (...codeLines: string[]) => ShaderModifier;

export declare const ShaderVertexToFragment: (input: string, out: string) => ShaderModifier;
export declare const ShaderExtension: (...codeLines: string[]) => ShaderModifier;

declare abstract class ShaderStage {
    readonly id: string;
    readonly shader: WebGLShader | null;
    readonly gl: WebGLRenderingContext;
    
    constructor(id: string, source: string | undefined, shader: WebGLShader | null, gl: WebGLRenderingContext);
}

declare class VertexShaderStage extends ShaderStage {
    constructor(id: string, source: string, gl: WebGLRenderingContext);
}

declare class FragmentShaderStage extends ShaderStage {
    constructor(id: string, source: string, gl: WebGLRenderingContext);
}

export declare class Shader {
    readonly _gl: WebGLRenderingContext;
    readonly _shader: WebGLProgram | null;
    
    constructor(_vertex: VertexShaderStage, _fragment: FragmentShaderStage, _gl: WebGLRenderingContext, _shader?: WebGLProgram | null);
}

export declare const Shaders: (glUtils: GlUtils) => {
    _Shaders: (vertType: keyof typeof StaticVertexShaders, fragType: keyof typeof StaticFragmentShaders) => Shader;
    _DynamicShaders: (...featuresIn: (ShaderFeature | false | undefined)[]) => Shader;
};
export {};
export {};
export {};
export {};
export {};

export declare const _precomputed: {
    doubles: {
        step: number;
        points: string[][];
    };
    naf: {
        wnd: number;
        points: string[][];
    };
};
/**
 * File contains interfaces and builder for CheckBox
 */
/**
 * Interface for 'CheckBox'.
 */
export interface UICheckBox<BackgroundType extends UIBackground = UIBackground, PictureOffType extends UIButtonPicture = UIButtonPicture, PictureOnType extends UIButtonPicture = UIButtonPicture> extends UIPartWithBackground<BackgroundType>, CustomizableText, StylableButton, Switchable {
}
/**
 * Interface for 'CheckBox'-builder.
 */
export interface UICheckBoxBuilder<BackgroundType extends UIBackground = UIBackground, PictureOffType extends UIButtonPicture = UIButtonPicture, PictureOnType extends UIButtonPicture = UIButtonPicture> extends UIElementBuilder<UICheckBox<BackgroundType, PictureOffType, PictureOnType>> {
    /**
     * Make new CheckBoxBuilder with different background.
     * @param   newBackground   Constructor for desired Background. See [[UIBackgrounds]] for a collection of options.
     */
    setBackground<NewBackgroundType extends BackgroundType & InternalBackground>(newBackground: BackgroundConstructor<NewBackgroundType>): UICheckBoxBuilder<NewBackgroundType, PictureOffType, PictureOnType>;
    /**
     * Make new CheckBoxBuilder with different Picture OFF.
     * @param   newPictureOff   Constructor for desired Picture OFF. See [[UIButtonPictures]] for a collection of options.
     * @return                  New CheckBoxBuilder with different Picture OFF.
     */
    setPictureOff<NewPictureOffType extends PictureOffType>(newPictureOff: PrimitiveUiConstructor<NewPictureOffType>): UICheckBoxBuilder<BackgroundType, NewPictureOffType, PictureOnType>;
    /**
     * Make new CheckBoxBuilder with different Picture ON.
     * @param   newPictureOff   Constructor for desired Picture ON. See [[UIButtonPictures]] for a collection of options.
     * @return                  New CheckBoxBuilder with different Picture ON.
     */
    setPictureOn<NewPictureOnType extends PictureOnType>(newPictureOn: PrimitiveUiConstructor<NewPictureOnType>): UICheckBoxBuilder<BackgroundType, PictureOffType, NewPictureOnType>;
}
/**
 * Builder for 'CheckBox'.
 * @hidden
 */
export declare const _checkBoxBuilder: UICheckBoxBuilder<UIBackground, UIButtonPicture, UIButtonPicture>;
/**
 * File contains interfaces and builder for LUTCheckBox.
 *
 * Same as CheckBox but has a LUT visualization next to it.
 */
/**
 * Interface for 'LUTCheckBox'.
 */
export interface UILUTCheckBox<BackgroundType extends UIBackground = UIBackground, PictureOffType extends UIButtonPicture = UIButtonPicture, PictureOnType extends UIButtonPicture = UIButtonPicture> extends UICheckBox<BackgroundType, PictureOffType, PictureOnType> {
    /**
     * Set attached LUT (color look up table).
     * @param   lut     LUT (color look up table).
     * @return          Object itself.
     */
    setLUT(lut: LUT): this;
    /**
     * Get attached LUT (color look up table).
     * @return          (color look up table).
     */
    getLUT(): LUT | undefined;
    /**
     * Set length of LUT box as pixels.
     * @param   lengthPixels    Length as pixels.
     */
    setLUTLength(lengthPixels: number): this;
    /**
     * Get length of LUT box as pixels.
     * @return                  Length as pixels.
     */
    getLUTLength(): number;
    /**
     * Set thickness of LUT box as pixels.
     * @param   thicknessPixels Thickness as pixels.
     */
    setLUTThickness(thicknessPixels: number): this;
    /**
     * Get thickness of LUT box as pixels.
     * @return                  Thickness as pixels.
     */
    getLUTThickness(): number;
    /**
     * Set displayed unit of Look Up Values. For example, "mm/h" (millimetres per hour).
     * @param   unit    String to display next to Look Up Values.
     * @return          Object itself.
     */
    setLookUpUnit(unit: string): this;
    /**
     * Get displayed unit of Look Up Values. For example, "mm/h" (millimetres per hour).
     * @return          String to display next to Look Up Values.
     */
    getLookUpUnit(unit: string): this;
    /**
     * Specify step value formatting of LUT Legend.
     *
     * **Example usage:**
     *
     * ```ts
     *  // Display one fraction.
     *  setStepValueFormatter((step, lut) => step.value.toFixed(1))
     * ```
     * @param   formatter   Callback function that receives the [[LUTStep]] object created by user, and maps it into a string that is displayed in the label.
     */
    setLUTStepValueFormatter(formatter: (step: LUTStep, lut: LUT) => string): this;
    /**
     * Set fill style of LUT color steps and unit.
     *
     * Note that this style is overridden by calls to `setTextFillStyle`, which affects all text of the component.
     * @param value Fill style object or function which modifies it
     * @return      Object itself for fluent interface
     */
    setLUTTextFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * @return Current fill style of LUT color steps and unit
     */
    getLUTTextFillStyle(): FillStyle;
    /**
     * Set font of LUT color steps and unit text.
     *
     * Note that this style is overridden by calls to `setTextFont`, which affects all text of the component.
     * @param   value   FontSettings or mutator function for existing settings
     * @return          Object itself
     */
    setLUTTextFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
    /**
     * Get font of LUT color steps and unit text.
     * @return          FontSettings
     */
    getLUTTextFont(): FontSettings;
}
/**
 * Interface for 'LUTCheckBox'-builder.
 */
export interface UILUTCheckBoxBuilder<BackgroundType extends UIBackground = UIBackground, PictureOffType extends UIButtonPicture = UIButtonPicture, PictureOnType extends UIButtonPicture = UIButtonPicture> extends UIElementBuilder<UILUTCheckBox<BackgroundType, PictureOffType, PictureOnType>> {
    /**
     * Make new UILUTCheckBoxBuilder with different background.
     * @param   newBackground   Constructor for desired Background. See [[UIBackgrounds]] for a collection of options.
     */
    setBackground<NewBackgroundType extends BackgroundType & InternalBackground>(newBackground: BackgroundConstructor<NewBackgroundType>): UILUTCheckBoxBuilder<NewBackgroundType, PictureOffType, PictureOnType>;
    /**
     * Make new UILUTCheckBoxBuilder with different Picture OFF.
     * @param   newPictureOff   Constructor for desired Picture OFF. See [[UIButtonPictures]] for a collection of options.
     * @return                  New UILUTCheckBoxBuilder with different Picture OFF.
     */
    setPictureOff<NewPictureOffType extends PictureOffType>(newPictureOff: PrimitiveUiConstructor<NewPictureOffType>): UILUTCheckBoxBuilder<BackgroundType, NewPictureOffType, PictureOnType>;
    /**
     * Make new UILUTCheckBoxBuilder with different Picture ON.
     * @param   newPictureOff   Constructor for desired Picture ON. See [[UIButtonPictures]] for a collection of options.
     * @return                  New UILUTCheckBoxBuilder with different Picture ON.
     */
    setPictureOn<NewPictureOnType extends PictureOnType>(newPictureOn: PrimitiveUiConstructor<NewPictureOnType>): UILUTCheckBoxBuilder<BackgroundType, PictureOffType, NewPictureOnType>;
    /**
     * Make new UILUTCheckBoxBuilder with different alignment.
     * @param   alignment       Alignment for UILUTCheckBox
     * @return                  New UILUTCheckBoxBuilder
     */
    setAlignment(alignment: 'horizontal' | 'vertical'): UILUTCheckBoxBuilder<BackgroundType, PictureOffType, PictureOnType>;
}
/**
 * File contains interfaces and builder for TextBox
 */
/**
 * Interface for 'TextBox'.
 */
export interface UITextBox<BackgroundType extends UIBackground = UIBackground> extends UIPartWithBackground<BackgroundType>, CustomizableText {
}
/**
 * Interface for 'TextBox'-builder.
 */
export interface UITextBoxBuilder<BackgroundType extends UIBackground = UIBackground> extends UIElementBuilder<UITextBox<BackgroundType>> {
    /**
     * Make new TextBoxBuilder with different background
     * @param   newBackground   Constructor for desired Background. See [[UIBackgrounds]] for a collection of options.
     */
    setBackground<NewBackgroundType extends BackgroundType & InternalBackground>(newBackground: BackgroundConstructor<NewBackgroundType>): UITextBoxBuilder<NewBackgroundType>;
}
/**
 * Interface for 'PointableTextBox'.
 */
export interface UIPointableTextBox<BackgroundType extends UIBackground = UIBackground> extends UITextBox<BackgroundType>, Pointable {
}
/**
 * Interface for 'PointableTextBox'-builder.
 */
export interface UIPointableTextBoxBuilder<BackgroundType extends PointableBackground = PointableBackground> extends UIElementBuilder<UIPointableTextBox<BackgroundType>> {
    /**
     * Make new PointableTextBoxBuilder with different background.
     * @param   newBackground   Constructor for desired PointableBackground. Currently only UIBackgrounds.Arrow is available.
     */
    setBackground<NewBackgroundType extends BackgroundType & InternalBackground>(newBackground: PointableBackgroundConstructor<NewBackgroundType>): UIPointableTextBoxBuilder<NewBackgroundType>;
}
/**
 * File contains interfaces and builder for TextBox
 */
/**
 * *UIElement* that looks like an Axis tick (tick line + label) and can be used as an Axis CustomTick Marker,
 * by passing its *builder* as an argument to [[Axis.addCustomTick]]:
 *
 * ```typescript
 *  // Specify builder for CustomTick Marker.
 *  const customTick = Axis.addCustomTick(UIElementBuilders.AxisTick)
 *
 *  // TickMarker can be accessed via mutator method of CustomTick.
 *  customTick.setMarker((marker: UITick) => marker
 *      // ... do stuff
 *  )
 * ```
 */
export interface UITick extends UIPart, CustomizableText, Pointable {
    /**
     * Set tick line style.
     * @param   value   LineStyle or function that modifies current LineStyle value.
     * @return          Object itself for fluent interface.
     */
    setTickStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get tick line style.
     * @return          LineStyle.
     */
    getTickStyle(): LineStyle;
}
/**
 * Interface for builder for [[UITick]].
 */
export declare type UITickBuilder = UIElementBuilder<UITick>;
/**
 * UIElement implementation for UITick. This is the actual object passed to user but it is casted to the
 * interface [[UITick]].
 * @hidden
 */
export declare class UILabelAndTick extends InternalUIElement implements UITick {
    /**
     * Dispose object, ceasing its operation while keeping the object intact until call of 'restore'.
     * @return Object itself for fluent interface
     */
    dispose(): this;
    /**
     * Restore object if it was previously disposed.
     * @returns Object itself itself for fluent interface
     */
    restore(): this;
    /**
     * Set mouse interactions enabled or disabled
     * @param state Specifies state of mouse interactions
     * @return     Object itself for fluent interface
     */
    setMouseInteractions(state: boolean): this;
    /**
     * @return Mouse interactions state
     */
    getMouseInteractions(): boolean;
    /**
     * Get the text of the entire shape.
     * @returns             The entire text string.
     */
    getText(): string;
    /**
     * Set text fill style object
     * @param value Fill style object or function which modifies it
     * @return      Object itself for fluent interface
     */
    setTextFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * @return Current text fill style object
     */
    getTextFillStyle(): FillStyle;
    /**
     * Set font of Label.
     * @param   value   FontSettings or mutator function for existing settings
     * @return          Object itself
     */
    setTextFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
    /**
     * Set rotation of Label.
     * @param value Rotation in degrees
     * @returns Object itself
     */
    setTextRotation(rotation: number): this;
    /**
     * Get rotation of Label.
     * @returns Rotation in degrees
     */
    getTextRotation(): number;
    /**
     * Get font of Label.
     * @return          FontSettings
     */
    getTextFont(): FontSettings;
    /**
     * Specify a text string.
     * @param text          The string to be rendered.
     * @returns             Object itself for fluent interface.
     */
    setText(text: string): this;
    /**
     * Set direction.
     * @param   direction   Enum Direction
     * @returns             Object itself for fluent interface
     */
    setDirection(direction: UIDirections): this;
    /**
     * Get direction.
     * @returns             Enum Direction
     */
    getDirection(): UIDirections;
    /**
     * Set length of Pointable head in pixels.
     * @param   length  Length of head in pixels.
     * @returns         Object itself for fluent interface
     */
    setPointerLength(length: pixel): this;
    /**
     * Get length of Pointable head in pixels.
     * @returns             Pixel length
     */
    getPointerLength(): pixel;
    /**
     * Set pixel padding between tick line and label.
     */
    setTickLabelPadding(padding: pixel): this;
    /**
     * Get pixel padding between tick line and label.
     */
    getTickLabelPadding(): pixel;
    /**
     * Set tick line style.
     * @param   value   LineStyle or function that modifies current LineStyle value.
     * @return          Object itself for fluent interface.
     */
    setTickStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get tick line style.
     * @return          LineStyle.
     */
    getTickStyle(): LineStyle;
}
/**
 * File contains interfaces and classes for primitive UI buttons
 */
/**
 * Indicates object whose size can be fitted into an arbitrary Vec2
 * @hidden
 */
export interface Fittable {
    /**
     * Fit object to bounding box.
     * @param   bounds  Bounds in pixels
     * @return          Object itself
     */
    fitTo(bounds: Point): this;
}
/**
 * Type requirement for Pictures of Buttons.
 */
export interface UIButtonPicture extends BorderedPicture, Fittable {
}
/**
 * Switchable UI element with separate visuals for (ON/OFF) states.
 * @hidden Internal class
 */
export declare class Button<PictureOff extends UIButtonPicture = UIButtonPicture, PictureOn extends UIButtonPicture = UIButtonPicture> extends InternalUIElement implements Highlightable {
    /**
     * @param _layer                 Layer of drawing engine
     * @param scale                 Drawing scale of UiElement
     * @param _picOffConstructor     Constructor for OFF picture
     * @param _picOnConstructor      Constructor for ON picture
     * @param remove                Injected remove method from parent.
     * @hidden
     */
    constructor(_layer: Layer2D, renderingScale: LinearScaleXY, scale: ScaleXY, _picOffConstructor: PrimitiveUiConstructor<PictureOff>, _picOnConstructor: PrimitiveUiConstructor<PictureOn>, remove: RemoveHandler<UIElement>, restore: RestoreHandler<UIElement>, theme: Theme);
    /**
     * Subscribe to highlight object event. This is called whenever an object is highlighted.
     * @param   handler         Function that is called when event is triggered.
     * @param   isHighlighted   The Highlight state.
     * @return                  Token that can be used to unsubscribe from the event.
     */
    onHighlight(handler: (isHighlighted: boolean) => void): Token;
    /**
     * Unsubscribe from Highlight object event. This is called whenever an object is highlighted
     * @param   token       Token that was received when subscribing to the event.
     * @return              True if the unsubscription was successful.
     */
    offHighlight(token: Token): boolean;
    /**
     * Set state of switchable object
     * @param isOn  State as boolean flag
     * @returns     Object itself for fluent interface
     */
    setOn(isOn: boolean): this;
    /**
     * @return State as boolean flag
     */
    getOn: () => boolean;
    /**
     * Set fill style of checkbox when state is OFF
     * @param   value   FillStyle object or function which modifies it
     * @return          Object itself for fluent interface
     */
    setOffFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of checkbox when state is OFF
     * @return          FillStyle object
     */
    getOffFillStyle(): FillStyle;
    /**
     * Set highlighted fill style of checkbox when state is OFF
     * @param   value   FillStyle object or mutator to modify existing one or undefined for auto assignment
     * @return          Object itself for fluent interface
     */
    setOffFillStyleHighlight(value: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * Get highlighted fill style of checkbox when state is OFF
     * @return          FillStyle object or undefined for auto assignment
     */
    getOffFillStyleHighlight(): FillStyle | undefined;
    /**
     * Set style of checkbox when state is OFF
     * @param   value   LineStyle object or function which modifies it
     * @return          Object itself for fluent interface
     */
    setOffStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of checkbox when state is OFF
     * @return           LineStyle object
     */
    getOffStrokeStyle(): LineStyle;
    /**
     * Set size of checkbox when state is OFF.
     * @param   size    Size to fit picture as Point or pixel for squared size
     */
    setOffSize(size: Point | pixel): this;
    /**
     * Get size of checkbox in pixels when state is OFF
     */
    getOffSize(): Point;
    /**
     * Set fill style of checkbox when state is ON
     * @param   value   FillStyle object or function which modifies it
     * @return          Object itself for fluent interface
     */
    setOnFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of checkbox when state is ON
     * @return          FillStyle object
     */
    getOnFillStyle(): FillStyle;
    /**
     * Set highlighted fill style of checkbox when state is ON
     * @param   value   FillStyle object or mutator to modify existing one or undefined for auto assignment
     * @return          Object itself for fluent interface
     */
    setOnFillStyleHighlight(value: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * Get highlighted fill style of checkbox when state is ON
     * @return          FillStyle object or undefined for auto assignment
     */
    getOnFillStyleHighlight(): FillStyle | undefined;
    /**
     * Set style of checkbox when state is ON
     * @param   value   LineStyle object or function which modifies it
     * @return          Object itself for fluent interface
     */
    setOnStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of checkbox when state is ON
     * @return           LineStyle object
     */
    getOnStrokeStyle(): LineStyle;
    /**
     * Set size of checkbox when state is ON.
     * @param   size    Size to fit picture to as Point or pixel for squared size
     */
    setOnSize(size: Point | pixel): this;
    /**
     * Get size of checkbox in pixels when state is ON
     */
    getOnSize(): Point;
    /**
     * Restore object if it was previously disposed.
     * @returns Object itself itself for fluent interface
     */
    restore(): this;
    /**
     * Dispose object, ceasing its operation while keeping the object intact until call of 'restore'.
     * @return Object itself for fluent interface
     */
    dispose(): this;
    /**
     * @return True if all sub elements are disposed, false if not.
     */
    isDisposed(): boolean;
    /**
     * Set mouse interactions enabled or disabled
     * @param state Specifies state of mouse interactions
     * @return     Object itself for fluent interface
     */
    setMouseInteractions(state: boolean): this;
    /**
     * @return Mouse interactions state
     */
    getMouseInteractions(): boolean;
    /**
     * @return Flag is highlighted
     */
    getHighlighted(): boolean;
    /**
     * Set highlighted state
     * @param isHighlighted Highlight state of the object
     * @returns             Object itself for fluent interface
     */
    setHighlighted(isHighlighted: boolean): this;
}
/**
 * Interface for Button-builder.
 * @hidden
 */
export interface ButtonBuilder<PictureOffType extends UIButtonPicture = UIButtonPicture, PictureOnType extends UIButtonPicture = UIButtonPicture> extends UIElementBuilder<Button<PictureOffType, PictureOnType>> {
    /**
     * Make new ButtonBuilder with different Picture OFF
     */
    setPictureOff<NewPictureOffType extends PictureOffType>(newPictureOff: PrimitiveUiConstructor<NewPictureOffType>): ButtonBuilder<NewPictureOffType, PictureOnType>;
    /**
     * Make new ButtonBuilder with different Picture ON
     */
    setPictureOn<NewPictureOnType extends PictureOnType>(newPictureOn: PrimitiveUiConstructor<NewPictureOnType>): ButtonBuilder<PictureOffType, NewPictureOnType>;
}
/**
 * File contains class and builder for LegendBox and relative interfaces.
 */
/**
 * Interface for *legendbox entry*.
 *
 * A legendbox entry is a button that resides inside a [[LegendBox]]. A single *entry* is created for each component attached to a *legendbox*.
 * The entry displays the name of this component, and pressing on the entry will toggle the visibility of that component.
 */
export interface LegendBoxEntry extends UIPart, CustomizableText, StylableBackground, StylableButton, Switchable {
}
/**
 * Object which can be attached to a LegendBox
 * @hidden
 */
export interface Attachable {
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Series itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick: boolean): this;
}
/**
 * Interface for extra type safety with Attachables that have LUT.
 * @hidden
 */
export interface AttachableWithLUT extends Attachable {
}
/**
 * Optional configuration options that can be supplied when adding *entries* to a [[LegendBox]].
 */
export declare type LegendBoxAddOptions = {
    /**
     * Optional flag that determines whether clicking the LegendBoxEntry will dispose the Attached objects
     */
    disposeOnClick?: boolean;
    /**
     * Optional builder for custom entry
     */
    builder?: UIElementBuilder<LegendBoxEntry>;
};
/**
 * *Legend box* is a component that describes collections of chart components, like series, highlighters, etc.
 *
 * It contains a *title*, and buttons for each attached chart component that display the component name and can be clicked to hide/restore that particular component.
 * These buttons are known as *legend box entries*.
 * Additionally, attaching a *series* with an associated *color look-up table* ([[LUT]]) will result in the `LegendBox` automatically visualizing the color look up range.
 *
 * A Legend box can be created with the `addLegendBox` method, which is supported by all *chart* types.
 * For example: [[ChartXY.addLegendBox]].
 *
 * **Adding items to LegendBox**:
 *
 * Use [[LegendBox.add]] to add a *series* into the *LegendBox* (if chart, or dashboard is supplied, then all contained *series* will be attached).
 *
 * ```typescript
 *  // Example, attach a series to LegendBox.
 *  const mySeries = ChartXY.addLineSeries()
 *  LegendBox.add(mySeries)
 * ```
 *
 * **Configuring LegendBox title**:
 *
 * *LegendBox* has a built-in title component, which can be configured with [[LegendBox.setTitle]]:
 *
 * ```typescript
 *  // Example 1, specify LegendBox title.
 *  LegendBox.setTitle('Groups Legend')
 * ```
 *
 * ```typescript
 *  // Example 2, hide LegendBox title.
 *  LegendBox.setTitle('')
 * ```
 *
 * **Configuring LegendBox entries**
 *
 * When a *series* is attached to *LegendBox*, it creates a `LegendBoxEntry` associated with that *series*.
 * This *entry* shows as a button + label inside the *LegendBox*. All *entries* that currently exist inside a *LegendBox* can be styled with the [[LegendBox.setEntries]] method:
 *
 * ```typescript
 *  // Example, style LegendBoxEntries.
 *  // First attach series to create entries.
 *  LegendBox.add(mySeries)
 *  // Then style each entry using a callback function.
 *  LegendBox.setEntries((entry, component) => entry
 *      .setTextFont((font) => font
 *          .setStyle('italic')
 *      )
 *  )
 * ```
 *
 * See [[LegendBoxEntry]] for available configuration API for each *entry*.
 *
 * Styling an automatically created `UILUTCheckBox` requires a type cast (*TypeScript* users):
 *
 * ```typescript
 *  // Example, styling a UILUTCheckBox that is automatically created when a series with associated LUT is attached.
 *  LegendBox.add(myHeatmapSeries)
 *  // Heatmap series is styled with `PalettedFill` -> style the created UILUTCheckBox using a reference check + type cast.
 *  LegendBox.setEntries((entry, component) => {
 *      if (component === myHeatmapSeries) {
 *          const lutCheckBox = entry as UILUTCheckBox
 *          lutCheckBox
 *              .setLUTLength(200)
 *              .setLUTThickness(30)
 *              .setLUTTextFont((font) => font
 *                  .setSize(10)
 *              )
 *      }
 *  })
 * ```
 */
export interface LegendBox {
    /**
     * Add a dynamic value to LegendBox, creating a group and entries for it depending on type of value.
     * Supports series, charts and dashboards.
     * @param value             Series, Chart or Dashboard
     * @param opts              Optional extra configuration arguments.
     * @return                  Object itself.
     */
    add(value: Attachable | Chart | Dashboard, opts?: LegendBoxAddOptions): this;
    /**
     * Set text of LegendBox title.
     * @param   title  LegendBox title as a string.
     * @returns        Object itself for fluent interface.
     */
    setTitle(title: string): this;
    /**
     * Get text of LegendBox title.
     * @returns         LegendBox title as a string.
     */
    getTitle(): string;
    /**
     * Set fill style of LegendBox Title.
     *
     * Example usage:
     *```javascript
     * // Create a new style
     * setTitleFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Change transparency
     * setTitleFillStyle((solidFill) => solidFill.setA(80))
     * // Set hidden
     * setTitleFillStyle(emptyFill)
     * ```
     * @param   value   Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns         LegendBox itself
     */
    setTitleFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of LegendBox Title.
     * @returns FillStyle object
     */
    getTitleFillStyle(): FillStyle;
    /**
     * Set font of LegendBox Title.
     *
     * Example usage:
     *```javascript
     * // Create a new FontSettings
     * setTitleFont(new FontSettings({ size: 24, style: 'italic' }))
     * // Change existing settings
     * setTitleFont((fontSettings) => fontSettings.setWeight('bold'))
     * ```
     *
     * @param   value   Either a FontSettings object or a function, which will be used to create a new FontSettings based on current value.
     * @returns         LegendBox itself
     */
    setTitleFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
    /**
     * Get font of LegendBox title.
     * @return  FontSettings object
     */
    getTitleFont(): FontSettings;
    /**
     * Set rotation of LegendBox title.
     * @param value Rotation in degrees
     * @returns Object itself
     */
    setTitleRotation(value: number): this;
    /**
     * Get rotation of LegendBox title.
     * @returns Rotation in degrees
     */
    getTitleRotation(): number;
    /**
     * Set style of LegendBoxEntries with a callback function.
     *
     * To set style of Entry matching a specific component, use the `component` parameter with a custom check.
     *
     * **Example usage:**
     *
     * - Style specific series entry only
     *
     * ```typescript
     *  setEntries((entry, component) =>
     *      // Only apply for single series.
     *      component === mySeries &&
     *      entry.setTextFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
     *  )
     * ```
     *
     * - Style UILUTCheckBox
     *
     * ```typescript
     *  setEntries((entry, component) =>
     *      // Must check for series with attached LUT
     *      component === myHeatmapSeries &&
     *      // Cast type to UILUTCheckBox
     *      (entry as UILUTCheckBox)
     *          .setLookUpUnit('mm/h')
     *          .setLUTThickness(50)
     *  )
     * ```
     *
     * @param   styler  Function that is called for each LegendBoxEntry.
     * @return          Object itself.
     */
    setEntries(styler: (entry: LegendBoxEntry, component: Attachable) => unknown): this;
}
/**
 * Standalone UI Element that functions as a *legend box*.
 *
 * Interface for *legend box* functionality (e.q. attaching series, styling entries, ...): [[LegendBox]]
 *
 * Interface for *ui element* functionality (e.q. moving legend box, styling background, ...): [[UIElement]]
 */
export declare type UILegendBox<BackgroundType extends InternalBackground = InternalBackground> = UIPartWithBackground<BackgroundType> & LegendBox;
/**
 * Public interface for builder of LegendBox.
 */
export interface UILegendBoxBuilder<BackgroundType extends InternalBackground = InternalBackground> extends UIElementBuilder<UILegendBox<BackgroundType>> {
    /**
     * Make new LegendBoxBuilder with different background
     * @param   newBackground   Constructor for Background
     * @return                  New LegendBoxBuilder
     */
    setBackground<NewBackgroundType extends BackgroundType>(newBackground: BackgroundConstructor<NewBackgroundType>): UILegendBoxBuilder<NewBackgroundType>;
    /**
     * Make new LegendBoxBuilder with different alignment of entries.
     *
     * Eq. "Horizontal" meaning that the LegendBox progresses in the X-direction,
     * and aligns its groups downwards.
     * @param   alignment       Alignment for LegendBox
     * @return                  New LegendBoxBuilder
     */
    setAlignment(alignment: 'horizontal' | 'vertical'): UILegendBoxBuilder<BackgroundType>;
    /**
     * Get alignment of LegendBoxBuilder.
     *
     * Eq. "Horizontal" meaning that the LegendBox progresses in the X-direction,
     * and aligns its groups downwards.
     * @return                  Alignment for LegendBox
     */
    getAlignment(): 'horizontal' | 'vertical';
    /**
     * Make new LegendBoxBuilder with explicitly styled title.
     * @param   value   Styler function for a LegendBox title.
     * @return          New LegendBoxBuilder
     */
    styleTitle(value: Mutator<UITextBox>): UILegendBoxBuilder<BackgroundType>;
    /**
     * Make new LegendBoxBuilder with explicitly styled entries.
     * @param   value   Styler function for a LegendBoxEntry.
     * @return          New LegendBoxBuilder
     */
    styleEntries(value: Mutator<LegendBoxEntry>): UILegendBoxBuilder<BackgroundType>;
}
/**
 * Interface for `UILUTRange`, UI element which displays a color lookup table range with labels.
 */
export interface UILUTRange<BackgroundType extends UIBackground = UIBackground> extends UIPartWithBackground<BackgroundType>, StyleTextAPI {
    /**
     * Set attached LUT (color look up table).
     * @param   lut     LUT (color look up table).
     * @return          Object itself.
     */
    setLUT(lut: LUT): this;
    /**
     * Get attached LUT (color look up table).
     * @return          (color look up table).
     */
    getLUT(): LUT | undefined;
    /**
     * Set length of LUT box as pixels.
     * @param   lengthPixels    Length as pixels.
     */
    setLUTLength(lengthPixels: number): this;
    /**
     * Get length of LUT box as pixels.
     * @return                  Length as pixels.
     */
    getLUTLength(): number;
    /**
     * Set thickness of LUT box as pixels.
     * @param   thicknessPixels Thickness as pixels.
     */
    setLUTThickness(thicknessPixels: number): this;
    /**
     * Get thickness of LUT box as pixels.
     * @return                  Thickness as pixels.
     */
    getLUTThickness(): number;
    /**
     * Set displayed unit of Look Up Values. For example, "mm/h" (millimetres per hour).
     * @param   unit    String to display next to Look Up Values.
     * @return          Object itself.
     */
    setLookUpUnit(unit: string): this;
    /**
     * Get displayed unit of Look Up Values. For example, "mm/h" (millimetres per hour).
     * @return          String to display next to Look Up Values.
     */
    getLookUpUnit(unit: string): string;
    /**
     * Specify step value formatting of LUT Legend.
     *
     * **Example usage:**
     *
     * ```ts
     *  // Display one fraction.
     *  setStepValueFormatter((step, lut) => step.value.toFixed(1))
     * ```
     * @param   formatter   Callback function that receives the [[LUTStep]] object created by user, and maps it into a string that is displayed in the label.
     */
    setLUTStepValueFormatter(formatter: (step: LUTStep, lut: LUT) => string): this;
}
/**
 * UI element which displays a color lookup table range with labels.
 * @hidden
 */
export declare class InternalUILUTRange extends InternalUIElement implements StylableTextComponent {
    protected readonly _layer: Layer2D;
    protected readonly _alignment: 'horizontal' | 'vertical';
    /**
     * @param   _layer                  Layer of drawing engine. Should be kept protected at all times
     * @param   renderingScale          Rendering scale
     * @param   scale                   Positioning scale
     * @param   _remove                 Injected remove method from parent.
     * @param   _restore                Injected restore method from parent.
     * @hidden
     */
    constructor(_layer: Layer2D, renderingScale: LinearScaleXY, scale: ScaleXY, remove: RemoveHandler<UIElement>, restore: RestoreHandler<UIElement>, theme: Theme, _alignment: 'horizontal' | 'vertical');
    /**
     * Set text fill style object
     * @param value Fill style object or function which modifies it
     * @return      Object itself for fluent interface
     */
    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * @return Current text fill style object
     */
    getFillStyle(): FillStyle;
    /**
     * Set text fill style object when highlighted
     * @param value Fill style object or mutator to modify existing one or undefined for auto assignment
     * @return      Object itself for fluent interface
     */
    setFillStyleHighlight(value: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * @return Current text fill style object when highlighted or undefined for auto assignment
     */
    getFillStyleHighlight(): FillStyle | undefined;
    /**
     * Set font of Label.
     * @param   value   FontSettings or mutator function for existing settings
     * @return          Object itself
     */
    setFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
    /**
     * Get font of Label.
     * @return          FontSettings
     */
    getFont(): FontSettings;
    /**
     * Set rotation of Label.
     * @param value Rotation in degrees
     * @returns Object itself
     */
    setTextRotation(value: number): this;
    /**
     * Get rotation of Label.
     * @returns Label rotation in degrees
     */
    getTextRotation(): number;
    /**
     * Restore object if it was previously disposed.
     * @returns Object itself itself for fluent interface
     */
    restore(): this;
    /**
     * Dispose object, ceasing its operation while keeping the object intact until call of 'restore'.
     * @return Object itself for fluent interface
     */
    dispose(): this;
    /**
     * @return True if all sub elements are disposed, false if not.
     */
    isDisposed(): boolean;
    /**
     * Set mouse interactions enabled or disabled
     * @param state Specifies state of mouse interactions
     * @return     Object itself for fluent interface
     */
    setMouseInteractions(state: boolean): this;
    /**
     * @return Mouse interactions state
     */
    getMouseInteractions(): boolean;
}
/**
 * Interface for `UILUTRange` builder.
 */
export interface UILUTRangeBuilder<BackgroundType extends UIBackground = UIBackground> extends UIElementBuilder<UILUTRange> {
    /**
     * Make new UILUTRangeBuilder with different background
     * @param   newBackground   Constructor for desired Background. See [[UIBackgrounds]] for a collection of options.
     */
    setBackground<NewBackgroundType extends BackgroundType & InternalBackground>(newBackground: BackgroundConstructor<NewBackgroundType>): UILUTRangeBuilder<NewBackgroundType>;
    /**
     * Make new UILUTRangeBuilder with different alignment.
     * @param   alignment       Alignment for UILUTRange
     * @return                  New UILUTRangeBuilder
     */
    setAlignment(alignment: 'horizontal' | 'vertical'): UILUTRangeBuilder;
}
/**
 * File contains abstract base-classes for implementation of primitive UI elements
 */
/**
 * Type of constructor for primitive uiElement
 * @param layer Layer of drawing engine
 * @param scale Drawing scale of UiElement
 * @hidden
 */
export declare type PrimitiveUiConstructor<UiElementType extends UIElement = UIElement> = new (layer: Layer2D, renderingScale: LinearScaleXY, scale: ScaleXY, remove: RemoveHandler<UIElement>, restore: RestoreHandler<UIElement>) => UiElementType;
/**
 * Class represents any kind of picture, it might be raster image rendered as texture,
 * just colored rectangle or polygon of another shape,
 * several different geometry shapes and so on.
 * @hidden Internal class
 */
export declare abstract class Picture extends InternalUIElement implements Highlightable, StylableComponent {
    /**
     * Subscribe to highlight object event. This is called whenever an object is highlighted.
     * @param   handler         Function that is called when event is triggered.
     * @param   isHighlighted   The Highlight state.
     * @return                  Token that can be used to unsubscribe from the event.
     */
    onHighlight(handler: (isHighlighted: boolean) => void): Token;
    /**
     * Unsubscribe from Highlight object event. This is called whenever an object is highlighted
     * @param   token       Token that was received when subscribing to the event.
     * @return              True if the unsubscription was successful.
     */
    offHighlight(token: Token): boolean;
    /**
     * Set fill style of Picture
     * @param value Fill style object or function which modifies it
     * @return      Object itself for fluent interface
     */
    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of Picture
     */
    getFillStyle(): FillStyle;
    /**
     * Set highlight fill style of object filling
     * @param highlightStyle FillStyle for highlighted object or mutator to modify existing one or undefined for auto assignment
     * @returns         Object itself for fluent interface
     */
    setFillStyleHighlight(highlightStyle: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * @return Highlight FillStyle of the object or undefined for auto assignment
     */
    getFillStyleHighlight(): FillStyle | undefined;
    /**
     * @return True for highlighted state of object and false for basic
     */
    getHighlighted(): boolean;
    /**
     * Set highlighted state of the Object
     * @param isHighlighted Highlight state of the object
     * @returns             Object itself for fluent interface
     */
    setHighlighted(isHighlighted: boolean): this;
    /**
     * Set mouse interactions enabled or disabled
     * @param state Specifies state of mouse interactions
     * @return     Object itself for fluent interface
     */
    setMouseInteractions(state: boolean): this;
    /**
     * @return Mouse interactions state
     */
    getMouseInteractions(): boolean;
    /**
     * Dispose object, ceasing its operation while keeping the object intact until call of 'restore'.
     * @return Object itself for fluent interface
     */
    dispose(): this;
    /**
     * Restore object if it was previously disposed.
     * @returns Object itself itself for fluent interface
     */
    restore(): this;
    /**
     * @return True if all sub elements are disposed, false if not.
     */
    isDisposed(): boolean;
}
/**
 * Abstract Picture with stylable border.
 * @hidden
 */
export declare abstract class BorderedPicture extends Picture {
    /**
     * Set stoke style of Picture
     * @param value LineStyle object or function which modifies it
     * @return      Object itself for fluent interface
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stroke style of Picture
     */
    getStrokeStyle(): LineStyle;
    /**
     * Set stroke style of object when it is highlighted
     * @param value     LineStyle for highlighted object or mutator to modify existing one or undefined for auto assignment
     * @returns         Object itself for fluent interface
     */
    setStrokeStyleHighlight(value: LineStyle | ImmutableMutator<LineStyle> | undefined): this;
    /**
     * @return Highlight LineStyle of the object or undefined for auto assignment
     */
    getStrokeStyleHighlight(): LineStyle | undefined;
    /**
     * Set highlighted state of the Object
     * @param isHighlighted Highlight state of the object
     * @returns             Object itself for fluent interface
     */
    setHighlighted(isHighlighted: boolean): this;
}
/**
 * Abstract background formed with a polygon shape
 * @hidden
 */
export declare abstract class UIPolygon extends BorderedPicture {
    protected readonly _layer: Layer2D;
    /**
     * Implementations should initialize all of their
     * Shapes and UiElements in the constructor.
     * Sub-classes must call 'updatePolygon' initially !
     * @param _layer         Layer of drawing engine
     * @param scale         Drawing scale of UiElement
     * @param polygonType   Type of polygon used for rendering shape
     * @hidden
     */
    constructor(_layer: Layer2D, renderingScale: LinearScaleXY, scale: ScaleXY, polygonType: PolygonType, remove: RemoveHandler<UIElement>, restore: RestoreHandler<UIElement>, theme: Theme);
}
/**
 * File contains librarys most basic primitive UI elements
 * together in one file because very similar class implementations
 */
/**
 * Class which represents a single line of text
 * @hidden Internal class
 */
export declare class UILabel extends Picture implements StylableTextComponent {
    /**
     * Implementations should initialize all of their
     * Shapes and UiElements in the constructor.
     * @param layer Layer of drawing engine
     * @param scale Drawing scale of UiElement
     * @hidden
     */
    constructor(layer: Layer2D, renderingScale: LinearScaleXY, scale: ScaleXY, _remove: RemoveHandler<UIElement>, _restore: RestoreHandler<UIElement>, theme: Theme);
    /**
     * Specify a text string.
     * @param text          The string to be rendered.
     * @returns             Object itself for fluent interface.
     */
    setText(text: string): this;
    /**
     * Get the text of the entire shape.
     * @returns             The entire text string.
     */
    getText(): string;
    /**
     * Set font of Label.
     * @param   value   FontSettings or mutator function for existing settings
     * @return          Object itself
     */
    setFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
    /**
     * Get font of Label.
     * @return          FontSettings
     */
    getFont(): FontSettings;
    /**
     * Set rotation of Label.
     * @param value Rotation in degrees
     * @returns Object itself
     */
    setTextRotation(value: number): this;
    /**
     * Get rotation of Label.
     * @returns Label rotation in degrees
     */
    getTextRotation(): number;
}
/**
 * Rectangular UI shape that can be used as Background, Button picture or cursor PointMarker.
 */
export declare class UIRectangle extends BorderedPicture implements PointMarker, InternalBackground, UIButtonPicture {
    /**
     * Implementations should initialize all of their
     * Shapes and UiElements in the constructor.
     * @param layer Layer of drawing engine
     * @param scale Drawing scale of UiElement
     * @hidden
     */
    constructor(layer: Layer2D, renderingScale: LinearScaleXY, scale: ScaleXY, _remove: RemoveHandler<UIElement>, _restore: RestoreHandler<UIElement>, theme: Theme);
    /**
     * Fit object to bounding box.
     * @param   bounds  Bounds in pixels
     * @return          Object itself
     */
    fitTo: (size: Point) => this;
    /**
     * Set size of PointMarker
     * @param   size        Size of PointMarker in pixels
     * @returns             Object itself
     */
    setSize: (size: Point) => this;
}
/**
 * Circular UI shape that can be used as Background and as Button picture.
 */
export declare class UICircle extends BorderedPicture implements PointMarker, InternalBackground, UIButtonPicture {
    /**
     * @param layer Layer of drawing engine
     * @param scale Drawing scale of UiElement
     * @hidden
     */
    constructor(layer: Layer2D, renderingScale: LinearScaleXY, scale: ScaleXY, _remove: RemoveHandler<UIElement>, _restore: RestoreHandler<UIElement>, theme: Theme);
    /**
     * Fit object to bounding box.
     * @param   bounds  Bounds in pixels
     * @return          Object itself
     */
    fitTo(bounds: Point): this;
    /**
     * Set size of PointMarker
     * @param   size        Size of PointMarker in pixels
     * @returns             Object itself
     */
    setSize: (bounds: Point) => this;
}
/**
 * 45 degrees rotated Rectangle background.
 */
export declare class UIDiamond extends UIPolygon implements PointMarker, InternalBackground, UIButtonPicture {
    protected readonly _layer: Layer2D;
    /**
     * @param _layer Layer of drawing engine
     * @param scale Drawing scale of UiElement
     * @hidden
     */
    constructor(_layer: Layer2D, renderingScale: LinearScaleXY, scale: ScaleXY, _remove: RemoveHandler<UIElement>, _restore: RestoreHandler<UIElement>, theme: Theme);
    /**
     * Fit object to bounding box.
     * @param   bounds  Bounds in pixels
     * @return          Object itself
     */
    fitTo(bounds: Point): this;
    /**
     * Set size of PointMarker
     * @param   size        Size of PointMarker in pixels
     * @returns             Object itself
     */
    setSize: (bounds: Point) => this;
}
/**
 * Background that has a pointable 'arrow'
 */
export declare class UIPointer extends UIPolygon implements InternalBackground {
    /**
     * @param   _layer   Rendering layer
     * @param   scale   Rendering scale
     * @hidden
     */
    constructor(_layer: Layer2D, renderingScale: LinearScaleXY, scale: ScaleXY, _remove: RemoveHandler<UIElement>, _restore: RestoreHandler<UIElement>, theme: Theme);
    /**
     * Set direction.
     * @param   direction   Enum Direction
     * @returns             Object itself for fluent interface
     */
    setDirection(direction: UIDirections): this;
    /**
     * Get direction.
     * @returns             Enum Direction
     */
    getDirection(): UIDirections;
    /**
     * Set length of Pointable head in pixels.
     * @param   length  Head length in pixels
     * @returns         Object itself for fluent interface
     */
    setPointerLength(length: pixel): this;
    /**
     * Get length of Pointable head in pixels.
     * @returns             Pixel length
     */
    getPointerLength(): pixel;
    /**
     * Set angle of Pointable in degrees.
     * @param   angle   Angle of pointer or undefined to match head & body size
     * @returns         Object itself for fluent interface
     */
    setPointerAngle(angle?: number): this;
    /**
     * Get angle of Pointable in degrees.
     * @returns         Angle in degrees
     */
    getPointerAngle(): pixel;
}
/**
 * Empty UiElement
 * @hidden Internal class
 */
export declare class EmptyUIElement extends InternalUIElement {
    /**
     * Set mouse interactions enabled or disabled
     * @param state Specifies state of mouse interactions
     * @return     Object itself for fluent interface
     */
    setMouseInteractions(state: boolean): this;
    /**
     * @return Mouse interactions state
     */
    getMouseInteractions(): boolean;
}
/**
 * Empty background.
 *
 * Indicates that the *Background* can't and shouldn't be styled as it won't be rendered.
 */
export declare class UIEmptyBackground extends EmptyUIElement implements InternalBackground {
    /**
     * Subscribe to highlight object event. This is called whenever an object is highlighted.
     * @param   handler         Function that is called when event is triggered.
     * @param   isHighlighted   The Highlight state.
     * @return                  Token that can be used to unsubscribe from the event.
     */
    onHighlight(handler: (isHighlighted: boolean) => void): Token;
    /**
     * Unsubscribe from Highlight object event. This is called whenever an object is highlighted
     * @param   token       Token that was received when subscribing to the event.
     * @return              True if the unsubscription was successful.
     */
    offHighlight(token: Token): boolean;
    /**
     * @return True for highlighted state of object and false for basic
     */
    getHighlighted(): boolean;
    /**
     * Set highlighted state of the Object
     * @param isHighlighted Highlight state of the object
     * @returns             Object itself for fluent interface
     */
    setHighlighted(): this;
    /**
     * Set highlight fill style of object filling
     * @param highlightStyle    FillStyle for highlighted object or mutator to modify existing one or undefined for default highlighting style
     * @returns                 Object itself for fluent interface
     */
    setFillStyleHighlight(): this;
    /**
     * @return Highlight FillStyle of the object
     */
    getFillStyleHighlight(): FillStyle;
    /**
     * Set fill style object
     * @param value Fill style object or function which modifies it
     * @return      Object itself for fluent interface
     */
    setFillStyle(): this;
    /**
     * @return Current fill style object
     */
    getFillStyle(): FillStyle;
    /**
     * Set stroke style object
     * @param value     LineStyle object or function which modifies it
     * @return          Object itself for fluent interface
     */
    setStrokeStyle(): this;
    /**
     * @return          Current stroke style object
     */
    getStrokeStyle(): LineStyle;
    /**
     * Set stroke thickness in pixels
     * @param thickness Stroke thickness in pixels
     * @returns         Icon itself for fluent interface
     */
    setStrokeThickness(): this;
    /**
     * @return Object stroke thickness
     */
    getStrokeThickness(): number;
}
/**
 * Empty PointMarker
 * @hidden Internal class
 */
export declare class EmptyPointMarker extends UIEmptyBackground implements PointMarker {
    setSize: (size: Point) => this;
}
/**
 * **NOTE: This is a _theme loader_** (function which creates Theme), not the actual theme.
 *
 * Themes are accessed via `Themes` with some extra management logic for optimizations.
 * @hidden
 */
export declare const _themeLoaderAuroraBorealis: () => any;
/**
 * **NOTE: This is a _theme loader_** (function which creates Theme), not the actual theme.
 *
 * Themes are accessed via `Themes` with some extra management logic for optimizations.
 * @hidden
 */
export declare const _themeLoaderBlueSciFi: () => any;
/**
 * **NOTE: This is a _theme loader_** (function which creates Theme), not the actual theme.
 *
 * Themes are accessed via `Themes` with some extra management logic for optimizations.
 * @hidden
 */
export declare const _themeLoaderCyberSpace: () => any;
/**
 * **NOTE: This is a _theme loader_** (function which creates Theme), not the actual theme.
 *
 * Themes are accessed via `Themes` with some extra management logic for optimizations.
 * @hidden
 */
export declare const _themeLoaderDarkGold: () => any;
/**
 * **NOTE: This is a _theme loader_** (function which creates Theme), not the actual theme.
 *
 * Themes are accessed via `Themes` with some extra management logic for optimizations.
 * @hidden
 */
export declare const _themeLoaderDarkGreen: () => any;
/**
 * **NOTE: This is a _theme loader_** (function which creates Theme), not the actual theme.
 *
 * Themes are accessed via `Themes` with some extra management logic for optimizations.
 * @hidden
 */
export declare const _themeLoaderDarkLime: () => any;
/**
 * **NOTE: This is a _theme loader_** (function which creates Theme), not the actual theme.
 *
 * Themes are accessed via `Themes` with some extra management logic for optimizations.
 * @hidden
 */
export declare const _themeLoaderDarkMagenta: () => any;
/**
 * **NOTE: This is a _theme loader_** (function which creates Theme), not the actual theme.
 *
 * Themes are accessed via `Themes` with some extra management logic for optimizations.
 * @hidden
 */
export declare const _themeLoaderDarkRed: () => any;
/**
 * **NOTE: This is a _theme loader_** (function which creates Theme), not the actual theme.
 *
 * Themes are accessed via `Themes` with some extra management logic for optimizations.
 * @hidden
 */
export declare const _themeLoaderDarkTurquoise: () => any;
/**
 * **NOTE: This is a _theme loader_** (function which creates Theme), not the actual theme.
 *
 * Themes are accessed via `Themes` with some extra management logic for optimizations.
 * @hidden
 */
export declare const _themeLoaderDuskInLapland: () => any;
/**
 * **NOTE: This is a _theme loader_** (function which creates Theme), not the actual theme.
 *
 * Themes are accessed via `Themes` with some extra management logic for optimizations.
 * @hidden
 */
export declare const _themeLoaderGlacier: () => any;
/**
 * **NOTE: This is a _theme loader_** (function which creates Theme), not the actual theme.
 *
 * Themes are accessed via `Themes` with some extra management logic for optimizations.
 * @hidden
 */
export declare const _themeLoaderLight: () => any;
/**
 * **NOTE: This is a _theme loader_** (function which creates Theme), not the actual theme.
 *
 * Themes are accessed via `Themes` with some extra management logic for optimizations.
 * @hidden
 */
export declare const _themeLoaderLightNatureOlive: () => any;
export {};
/**
 * **NOTE: This is a _theme loader_** (function which creates Theme), not the actual theme.
 *
 * Themes are accessed via `Themes` with some extra management logic for optimizations.
 * @hidden
 */
export declare const _themeLoaderRockyMountains: () => any;
/**
 * Aurora Borealis theme
 * @internal
 */
export declare const AuroraBorealisTheme: Theme;
/**
 * Aurora Borealis theme
 * @internal
 */
export declare const BlueSciFiTheme: Theme;
/**
 * Theme with relaxing, earthly colors.
 * @internal
 */
export declare const ClassicTheme: Theme;
/**
 * Dark theme with gradients
 * @internal
 */
export declare const DarkGradientTheme: Theme;
/**
 * A predominantly dark theme.
 * @internal
 */
export declare const DarkTheme: Theme;
/**
 * A predominantly dark theme.
 * @internal
 */
export declare const GreenTheme: Theme;
/**
 * Gradient theme with red, gray and white
 * @hidden
 */
export declare const LavenderGradientTheme: Theme;
/**
 * Theme with red, gray and white.
 * @internal
 */
export declare const LavenderTheme: Theme;
/**
 * Light theme with gradients
 * @internal
 */
export declare const LightGradientTheme: Theme;
/**
 * Theme with light backgrounds.
 * @internal
 */
export declare const LightGreenTheme: Theme;
/**
 * Theme with light backgrounds.
 * @internal
 */
export declare const LightPurpleTheme: Theme;
/**
 * Theme with light backgrounds.
 * @internal
 */
export declare const LightRedTheme: Theme;
/**
 * Theme with light backgrounds.
 * @internal
 */
export declare const LightTheme: Theme;
/**
 * @internal
 */
export declare const LipstickTheme: Theme;
/**
 * Aurora Borealis theme
 * @internal
 */
export declare const MonochromeTheme: Theme;
/**
 * Aurora Borealis theme
 * @internal
 */
export declare const NightTheme: Theme;
/**
 * A predominantly dark theme.
 * @internal
 */
export declare const PurpleTheme: Theme;
/**
 * Theme with light backgrounds.
 * @internal
 */
export declare const Rainbow: Theme;
/**
 * Dark theme with pink
 * @internal
 */
export declare const RaspberryTheme: Theme;
/**
 * A predominantly dark theme.
 * @internal
 */
export declare const RedTheme: Theme;
/**
 * Aurora Borealis theme
 * @internal
 */
export declare const SunsetTheme: Theme;
/**
 * Class that represents a single *polygon* from the collection of a [[PolarPolygonSeries]].
 *
 * The geometry of the *polygon* can be mutated at any time, and it can be *disposed* and *restored* whenever.
 *
 * Note, that the style of *PolarPolygon*s is managed by the owning *PolarPolygonSeries*, to change the style, refer to the API of the Series.
 *
 * **Example usage:**
 *
 * ```ts
 *  const polygonSeries = polarChart.addPolygonSeries()
 *  let ang = 45
 *  let amplitude = 50
 *  const polygon = polygonSeries.addPolygon()
 *      .setGeometry([
 *          { angle: (ang += 10), amplitude: (amplitude += 10) },
 *          { angle: (ang += 10), amplitude: (amplitude += 5) },
 *          { angle: (ang += 10), amplitude: (amplitude += 10) },
 *          { angle: (ang += 10), amplitude: (amplitude -= 5) },
 *          { angle: (ang += 10), amplitude: (amplitude += 5) },
 *          { angle: (ang += 5), amplitude: (amplitude -= 5) },
 *          { angle: (ang += 0), amplitude: (amplitude -= 10) },
 *          { angle: (ang -= 5), amplitude: (amplitude -= 5) },
 *          { angle: (ang -= 10), amplitude: (amplitude -= 10) },
 *          { angle: (ang -= 10), amplitude: (amplitude -= 5) },
 *          { angle: (ang -= 10), amplitude: (amplitude += 5) },
 *          { angle: (ang -= 10), amplitude: (amplitude += 10) },
 *      ])
 * ```
 */
export declare class PolarPolygon implements ChartVisual {
    /**
     * Set *polygon* geometry as a list of [[PolarPoint]]s.
     *
     * **NOTE: points have to be in either clockwise or counter-clockwise order**. The polygon coordinates should also not intersect with themselves.
     *
     * Example usage:
     * ```ts
     *  let ang = 45
     *  let amplitude = 50
     *  polarPolygon.setGeometry([
     *      { angle: (ang += 10), amplitude: (amplitude += 10) },
     *      { angle: (ang += 10), amplitude: (amplitude += 5) },
     *      { angle: (ang += 10), amplitude: (amplitude += 10) },
     *      { angle: (ang += 10), amplitude: (amplitude -= 5) },
     *      { angle: (ang += 10), amplitude: (amplitude += 5) },
     *      { angle: (ang += 5), amplitude: (amplitude -= 5) },
     *      { angle: (ang += 0), amplitude: (amplitude -= 10) },
     *      { angle: (ang -= 5), amplitude: (amplitude -= 5) },
     *      { angle: (ang -= 10), amplitude: (amplitude -= 10) },
     *      { angle: (ang -= 10), amplitude: (amplitude -= 5) },
     *      { angle: (ang -= 10), amplitude: (amplitude += 5) },
     *      { angle: (ang -= 10), amplitude: (amplitude += 10) },
     * ])
     * ```
     * @param   geometry    List of *PolarPoints* that form the contour of the desired polygon. Automatically closed.
     */
    setGeometry(geometry: PolarPoint[]): this;
    /**
     * Get *polygon* geometry as a list of [[PolarPoint]]s.
     *
     * **NOTE: points have to be in either clockwise or counter-clockwise order**
     * @return              List of *PolarPoints* that form the contour of the desired polygon. Automatically closed.
     */
    getGeometry(): PolarPoint[] | undefined;
    /**
     * Set mouse interactions enabled or disabled
     * @param state Specifies state of mouse interactions
     * @return      Object itself for fluent interface
     */
    setMouseInteractions(state: boolean): this;
    /**
     * Remove the component from rendering.
     *
     * If the Component supports it, this can be reverted with **restore()** method.
     * @return  Object itself for fluent interface.
     */
    dispose(): this;
    /**
     * @return  True if the component is currently disposed, and thus not being rendered. If the Component supports it, this can be reverted with **restore()** method.
     */
    isDisposed(): boolean;
    /**
     * After the Components **dispose()** method has been called, removing it from rendering, *restore()* can be used to return it back.
     * @return  Object itself for fluent interface.
     */
    restore(): this;
}
/**
 * Type of *PolarSeries* for visualizing a collection of *polygons* inside the Polar coordinate system. They are especially useful for highlighting parts of the Polar coordinate system.
 *
 * *PolarPolygonSeries* are created with [[PolarChart.addPolygonSeries]].
 *
 * Create a [[PolarPolygon]] with [[PolarPolygonSeries.addPolygon]].
 *
 * **Example usage:**
 *
 * ```ts
 *  const polygonSeries = polarChart.addPolygonSeries()
 *  let ang = 45
 *  let amplitude = 50
 *  const polygon = polygonSeries.addPolygon()
 *      .setGeometry([
 *          { angle: (ang += 10), amplitude: (amplitude += 10) },
 *          { angle: (ang += 10), amplitude: (amplitude += 5) },
 *          { angle: (ang += 10), amplitude: (amplitude += 10) },
 *          { angle: (ang += 10), amplitude: (amplitude -= 5) },
 *          { angle: (ang += 10), amplitude: (amplitude += 5) },
 *          { angle: (ang += 5), amplitude: (amplitude -= 5) },
 *          { angle: (ang += 0), amplitude: (amplitude -= 10) },
 *          { angle: (ang -= 5), amplitude: (amplitude -= 5) },
 *          { angle: (ang -= 10), amplitude: (amplitude -= 10) },
 *          { angle: (ang -= 10), amplitude: (amplitude -= 5) },
 *          { angle: (ang -= 10), amplitude: (amplitude += 5) },
 *          { angle: (ang -= 10), amplitude: (amplitude += 10) },
 *      ])
 * ```
 */
export declare class PolarPolygonSeries extends PolarSeries<SimplePolygon, PolarPolygonSeriesCursorPoint> {
    /**
     * Create new *polygon* to the Series.
     *
     * The style of *polygons* is shared, and can be modified with the Series API: [[PolarPolygonSeries.setFillStyle]] and [[PolarPolygonSeries.setStrokeStyle]].
     *
     * Specify the *polygon* geometry with [[PolarPolygon.setGeometry]]
     *
     * **Example usage:**
     *
     * ```ts
     *  const polygonSeries = polarChart.addPolygonSeries()
     *  let ang = 45
     *  let amplitude = 50
     *  const polygon = polygonSeries.addPolygon()
     *      .setGeometry([
     *          { angle: (ang += 10), amplitude: (amplitude += 10) },
     *          { angle: (ang += 10), amplitude: (amplitude += 5) },
     *          { angle: (ang += 10), amplitude: (amplitude += 10) },
     *          { angle: (ang += 10), amplitude: (amplitude -= 5) },
     *          { angle: (ang += 10), amplitude: (amplitude += 5) },
     *          { angle: (ang += 5), amplitude: (amplitude -= 5) },
     *          { angle: (ang += 0), amplitude: (amplitude -= 10) },
     *          { angle: (ang -= 5), amplitude: (amplitude -= 5) },
     *          { angle: (ang -= 10), amplitude: (amplitude -= 10) },
     *          { angle: (ang -= 10), amplitude: (amplitude -= 5) },
     *          { angle: (ang -= 10), amplitude: (amplitude += 5) },
     *          { angle: (ang -= 10), amplitude: (amplitude += 10) },
     *      ])
     * ```
     * @return  [[PolarPolygon]]
     */
    addPolygon(): PolarPolygon;
    /**
     * Set fill style of Series.
     *
     * Example usage:
     *```javascript
     * // Create a new style
     * PolarPolygonSeries.setFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Change transparency
     * PolarPolygonSeries.setFillStyle((solidFill) => solidFill.setA(80))
     * // Set hidden
     * PolarPolygonSeries.setFillStyle(emptyFill)
     * ```
     * @param   value   Either a FillStyle object or a function, which will be used to create a new SolidLine based on current value.
     * @returns         Chart itself
     */
    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of Series.
     * @return  FillStyle object
     */
    getFillStyle(): FillStyle;
    /**
     * Set fill style of Series when it is highlighted.
     * Highlighting is activated by placing mouse on top / touching Series (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     *
     * Example usage:
     *```javascript
     * // Create a new style
     * PolarPolygonSeries.setFillStyleHighlight(new SolidFill({ color: ColorHEX('#F00') }))
     * // Change transparency
     * PolarPolygonSeries.setFillStyleHighlight((solidFill) => solidFill.setA(80))
     * // Set hidden
     * PolarPolygonSeries.setFillStyleHighlight(emptyFill)
     * // Automatic
     * PolarPolygonSeries.setFillStyleHighlight(undefined)
     * ```
     * ```
     * @param   value   Either a FillStyle object or a function, which will be used to modify current value or
     *                  undefined for automatic value based on normal style.
     * @returns         Chart itself
     */
    setFillStyleHighlight(value: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * Get fill style of Series when it is highlighted.
     * Highlighting is activated by placing mouse on top / touching Series (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     * @return  FillStyle object
     */
    getFillStyleHighlight(): FillStyle;
    /**
     * Set stroke style of Series.
     *
     * Example usage:
     *```javascript
     * // Specified LineStyle
     * PolarPolygonSeries.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * PolarPolygonSeries.setStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden
     * PolarPolygonSeries.setStrokeStyle(emptyLine)
     * ```
     * @param   value   Either a LineStyle object or a function, which will be used to create a new SolidLine based on current value.
     * @returns         Chart itself
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stroke style of Series.
     * @return  LineStyle object
     */
    getStrokeStyle(): LineStyle;
    /**
     * Set stroke style of Series when it is highlighted.
     * Highlighting is activated by placing mouse on top / touching Series (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     *
     * Example usage:
     *```javascript
     * // Specified LineStyle
     * PolarPolygonSeries.setStrokeStyleHighlight(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * PolarPolygonSeries.setStrokeStyleHighlight((solidLine) => solidLine.setThickness(5))
     * // Hidden.
     * PolarPolygonSeries.setStrokeStyleHighlight(emptyLine)
     * // Automatic
     * PolarPolygonSeries.setStrokeStyleHighlight(undefined)
     * ```
     * @param   value   Either a LineStyle object or a function, which will be used to modify current value or
     *                  undefined for automatic value based on normal style.
     * @returns         Chart itself
     */
    setStrokeStyleHighlight(value: LineStyle | ImmutableMutator<LineStyle> | undefined): this;
    /**
     * Get stroke style of Series when it is highlighted.
     * Highlighting is activated by placing mouse on top / touching Series (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     * @return  LineStyle object
     */
    getStrokeStyleHighlight(): LineStyle;
    /**
     * Abstract method that solves the nearest datapoint to a given coordinate on screen.
     * @param   location    Location on screen
     * @return              Undefined or data-structure for positioning of cursors
     */
    solveNearestFromScreen(location: Point): PolarPolygonSeriesCursorPoint | undefined;
    /**
     * Abstract method that solves the nearest datapoint to a given coordinate on a screen from a specific segment.
     * @param   location    Location on screen
     * @param   segment     Segment to solve from
     * @return              Undefined or data-structure for positioning of cursors
     */
    solveNearestFromSegment(location: Point, segment: SimplePolygon): PolarPolygonSeriesCursorPoint | undefined;
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Series itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick?: boolean): this;
}
/**
 * Interface that is used to point a Cursor to a specific data-point of a [[PolarPolygonSeries]].
 */
export interface PolarPolygonSeriesCursorPoint extends CursorPoint<PolarPolygonSeries> {
    /**
     * [[PolarPolygon]] that the data point belongs to.
     */
    polarPolygon: PolarPolygon;
}
/**
 * Angular interval object defines the minimum and maximum interval in degrees.
 */
export declare type AngleInterval = SliceInterval;
/**
 * Event handler for gauge angle interval changed
 * @param   obj             Object
 * @param   previous        Previous angle interval of the Gauge
 * @param   current         Current angle interval of the Gauge
 */
export declare type GaugeAngleIntervalEventHandler<T> = (obj: T, previous: AngleInterval, current: AngleInterval) => void;
/**
 * Class of Radial Gauge represents the type of the gauge of a circular shape.
 */
export declare abstract class RadialGauge<P extends GaugeSlice, I extends P> extends GaugeChart<P, I> {
    /**
     * @param   layerSupplier           LayerSupplier. Must NOT be cached, because it contains reference to actual Engine instance.
     * @param   scaleFactory            Scale factory.
     * @param   removeChart             Injectable Panel/Chart remove method.
     * @param   logoFactory             Logo factory.
     * @param   resizeEventInterface    Injectable event interface for resizing Panel (used for dashboard)
     * @param   theme                   Theme used to style elements in the Chart.
     * @param   _disableAnimations      Disable animations by default
     * @hidden
     */
    constructor(_lcjsOptions: InternalLightningChartOptions, layerSupplier: LayerSupplier, scaleFactory: ScaleFactory, removeChart: (chart: Panel) => void, logoFactory?: LogoFactory, resizeEventInterface?: DashboardResizeEventInterface, theme?: Theme, _disableAnimations?: boolean);
    /**
     * Set angular interval of the gauge in degrees.
     * @param start Start angle of the gauge in degrees.
     * @param end   End angle of the gauge in degrees.
     * @returns Gauge itself for fluent interface.
     */
    setAngleInterval(start: number, end: number): this;
    /**
     * Get the angular interval of the gauge.
     * @returns Angle interval object {min, max} in degrees.
     */
    getAngleInterval(): AngleInterval;
    /**
     * Apply new fill style to slice arc.
     * @param value FillStyle or mutator to modify the existing one.
     * @returns     Gauge itself for fluent interface.
     */
    setGaugeFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Set stroke of gauge background
     * @param value LineStyle or mutator to modify the existing one.
     * @returns     Gauge itself for fluent interface.
     */
    setGaugeStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Subscribe to Gauge Angle Change event.
     * @returns Token of the listener.
     */
    onAngleIntervalChange(clbk: GaugeAngleIntervalEventHandler<this>): Token;
    /**
     * Remove listener with provided token.
     * @param token  Token of the listener.
     * @returns True if the listener is successfully removed and false if it is not found.
     */
    offAngleIntervalChange(token: Token): boolean;
}
/**
 * The Gauge Chart with a single solid colored slice.
 *
 * Solid Gauge extends Radial Gauge.
 * Use [[GaugeChart]].setAngleInterval(start: number, end: number)** to set angular appearance of the Chart.
 *
 * Before setting the data, request the slice using *GaugeChart*.**getDefaultSlice()**
 * Set data range using *GaugeChart*.**setInterval(start: number, end: number)**
 * Set data using *GaugeChart*.**setValue(value: number)**
 */
export declare class SolidGauge extends RadialGauge<SolidGaugeSlice, InternalSolidGaugeSlice> {
    /**
     * @param   layerSupplier           LayerSupplier. Must NOT be cached, because it contains reference to actual Engine instance.
     * @param   scaleFactory            Scale factory.
     * @param   removeChart             Injectable Panel/Chart remove method.
     * @param   logoFactory             Logo factory.
     * @param   resizeEventInterface    Injectable event interface for resizing Panel (used for dashboard)
     * @param   theme                   Theme used to style elements in the Chart.
     * @param   _disableAnimations      Disable animations by default
     * @hidden
     */
    constructor(_lcjsOptions: InternalLightningChartOptions, layerSupplier: LayerSupplier, scaleFactory: ScaleFactory, removeChart: (chart: Panel) => void, logoFactory?: LogoFactory, resizeEventInterface?: DashboardResizeEventInterface, theme?: Theme, _disableAnimations?: boolean);
    /**
     * Get the slice of the gauge.
     * @returns Solid Gauge Slice object for further modification.
     */
    getDefaultSlice(): SolidGaugeSlice;
    /**
     * Set the Auto Scaling mode enabled or disabled.
     * @param state True - autofit is enabled, otherwise - False.
     * @returns Gauge itself for fluent interface.
     */
    setAutoScaling(state: boolean): this;
    /**
     * Get the current state of the Auto Scaling mode.
     * @returns True - autofit is enabled, otherwise - False.
     */
    getAutoScaling(): boolean;
    /**
     * Set a new number formatter for the Data label.
     * @param formatter Number formatter
     * @returns Gauge itself for fluent interface.
     */
    setDataLabelFormatter(formatter: Intl.NumberFormat | FormattingFunction): this;
    /**
     * Get the formatter for the Data label.
     * @returns Number formatter object.
     */
    getDataLabelFormatter(): Intl.NumberFormat | FormattingFunction;
    /**
     * Set a new number formatter for the scale labels.
     * @param formatter Number formatter
     * @returns Gauge itself for fluent interface.
     */
    setIntervalLabelFormatter(formatter: Intl.NumberFormat | FormattingFunction): this;
    /**
     * Get the formatter for the scale labels.
     * @returns Number formatter object.
     */
    getIntervalLabelFormatter(): Intl.NumberFormat | FormattingFunction;
    /**
     * Set padding between Gauge and interval labels in pixels.
     * @param   padding     Number with pixel margin
     * @returns Gauge itself for fluent interface.
     */
    setIntervalLabelPadding(padding: number): this;
    /**
     * Get padding around Chart in pixels.
     * @return  Padding datastructure
     */
    getIntervalLabelPadding(): number;
    /**
     * Set thickness of the gauge.
     * @param thickness
     * @returns Gauge itself for fluent interface.
     */
    setThickness(thickness: number): this;
    /**
     * Set lookup table.
     *
     * Example usage:
     *```javascript
     * // Gauge slice color depending on value
     * SolidGauge.setLUT(new LUT ( { steps: [ { value: 0, color: ColorRGBA( 0, 0, 0 ) },
     *  { value: 500, color: ColorRGBA( 12, 213, 87 ) } ],
     *  interpolate: true })
     * ```
     * @param lut   Lookup table |
     * @returns     Gauge itself for fluent interface
     */
    setLUT(lut?: LUT): this;
    /**
     * Set font of Gauge Data Label.
     *
     * Example usage:
     *```javascript
     * // Specified FontSettings
     * SolidGauge.setDataLabelFont(new FontSettings({ size: 24, style: 'italic' }))
     * // Set to bold
     * SolidGauge.setDataLabelFont((fontSettings) => fontSettings.setWeight('bold'))
     * ```
     *
     * @param   value   Either a FontSettings object or a function, which will be used to create a new FontSettings based on current value.
     * @returns         Gauge itself for fluent interface.
     */
    setDataLabelFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
    /**
     * Get font of Gauge Data Label.
     * @returns         FontSettings object for gauge data label.
     */
    getDataLabelFont(): FontSettings;
    /**
     * Get the minimum size of the chart.
     * @returns Size {x, y} or undefined
     */
    getMinimumSize(): Point | undefined;
    /**
     * Apply new fill style to Gauge Data label.
     * @param value FillStyle or mutator to modify the existing one.
     * @returns     Gauge itself for a fluent interface.
     */
    setDataLabelFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get Fill Style of Gauge Data Label.
     * @return FillStyle object
     */
    getDataLabelFillStyle(): FillStyle;
    /**
     * **Permanently** dispose the component.
     *
     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
     * **to the component and its children** in application code.
     * ```javascript
     * let chart = ...Gauge()
     * let slice = chart.getDefaultSlice()
     * // Dispose Chart, and remove all references so that they can be garbage-collected.
     * chart.dispose()
     * chart = undefined
     * slice = undefined
     * ```
     * @return  Object itself for fluent interface
     */
    dispose(): this;
}
/**
 * Class of Solid colored slice Gauge slice.
 * The slice is represented as a single radial Arc shape.
 */
export declare abstract class SolidGaugeSlice extends GaugeSlice {
    /**
     * Apply new fill style to a slice.
     * @param value FillStyle for normal state.
     * @returns     Slice itself for a fluent interface.
     */
    abstract setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Apply new highlight fill style to a slice.
     * @param  value    FillStyle for highlighted state, if omitted then a highlight color is automatically generated.
     * @returns         Slice itself for a fluent interface.
     */
    abstract setFillStyleHighlight(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Subscribe to value change event.
     * @param listener  Event listener.
     * @returns Token that is used to unsubscribe from the event
     * @hidden
     */
    onValueChange(listener: ValueChangeEventListener<SolidGaugeSlice>): Token;
    /**
     * Subscribe to interval change event.
     * @param listener  Event listener.
     * @returns Token that is used to unsubscribe from the event
     */
    onIntervalChange(listener: IntervalChangeEventListener<SolidGaugeSlice>): Token;
}
/**
 * Class contains internal implementation of the Solid Gauge Slice.
 * @hidden
 */
export declare class InternalSolidGaugeSlice extends SolidGaugeSlice {
    protected readonly _arcLayer: Layer2D;
    protected readonly _labelLayer: Layer2D;
    protected _chart: SolidGauge;
    readonly scale: LinearScaleXY;
    /**
     * Shape of the solid angular slice.
     */
    readonly arc: Arc;
    /**
     * Text shape to show the slice value.
     */
    readonly label: Text;
    /**
     * Text shape to show the minimum interval value.
     */
    readonly minLabel: Text;
    /**
     * Text shape to show the maximum interval value.
     */
    readonly maxLabel: Text;
    constructor(_arcLayer: Layer2D, _labelLayer: Layer2D, _chart: SolidGauge, scale: LinearScaleXY, _removeFromChart: RemoveHandler<ChartComponent>, _restoreFromChart: RestoreHandler<ChartComponent>, _theme: Theme);
    /**
     * Set name for the Slice as string.
     * @param name Slice name as string.
     * @returns Slice itself for fluent interface.
     */
    setName(name: string): this;
    /**
     * Set value of Slice.
     * @param   value   Numeric value
     * @return          Slice itself
     */
    setValue(value: number): this;
    /**
     * Get value of Slice.
     * @return          Numeric value
     */
    getValue(): number;
    /**
     * Tell the owning chart to remove this component.
     * @return  Slice itself.
     */
    dispose(): this;
    /**
     * Tell the owning chart to restore this series.
     * @returns     Slice itself for fluent interface.
     */
    restore(): this;
    /**
     * Set scale interval.
     * @param  start                Start scale value
     * @param  end                  End scale value
     * @returns this for fluent interface
     */
    setInterval(start: number, end: number): this;
    /**
     * Set font of interval labels.
     *
     * Example usage:
     *```javascript
     * // Specified FontSettings
     * InternalSolidGaugeSlice.setIntervalLabelsFont(new FontSettings({ size: 24, style: 'italic' }))
     * // Set to bold
     * InternalSolidGaugeSlice.setIntervalLabelsFont((fontSettings) => fontSettings.setWeight('bold'))
     * ```
     * @param   value   Either a FontSettings object or a function, which will be used to create a new FontSettings based on current value.
     * @returns         Chart itself
     */
    setIntervalLabelsFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
    /**
     * Get font of gauge interval labels.
     * @returns         FontSettings object for gauge interval labels.
     */
    getIntervalLabelsFont(): FontSettings;
    /**
     * Set interval labels visibility enabled or disabled.
     * @param state True - labels are enabled, otherwise - disabled.
     * @returns     Slice itself for fluent interface.
     */
    setIntervalLabelsVisible(state: boolean): this;
    /**
     * Get interval labels visibility state.
     * @returns True - labels are enabled, otherwise - disabled.
     */
    getIntervalLabelsVisible(): boolean;
    /**
     * Set the angle interval of a slice.
     * @param start Start angle in degrees.
     * @param end   End angle in degrees.
     * @returns     Slice itself for fluent interface.
     */
    setAngleInterval(start: number, end: number): this;
    /**
     * Set start angle of the slice.
     * @param angle Min angle in degrees.
     * @returns     Slice itself for fluent interface.
     */
    setMinAngle(angle: number): this;
    /**
     * Set max angle of the slice.
     * @param angle
     * @returns     Slice itself for fluent interface.
     */
    setMaxAngle(angle: number): this;
    /**
     * Set offset margins for the slice in degrees.
     * @param left  Left margin in degrees.
     * @param right Right margin in degrees.
     */
    setMarginInDegrees(left?: number, right?: number): this;
    /**
     * Apply new fill style to slice.
     * @param value FillStyle for normal state.
     * @returns     Slice itself for a fluent interface.
     */
    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Apply new highlight fill style to slice.
     * @param  value    FillStyle for highlighted state.
     * if omitted then a highlight color is automatically generated.
     * @returns         Slice itself for a fluent interface.
     */
    setFillStyleHighlight(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get animated value of Slice.
     * When value of Slice is changed, the animated value will not update immediately, but after an animation.
     * (if animations are not disabled).
     * @return  Animated value
     */
    getAnimatedValue(): number;
}
/**
 * Axis Highlighter that highlights an interval on the Axis.
 */
export declare class Band extends Highlighter<Rect> {
    /**
     * Set start value of Band. This is in values of its owning Axis.
     * @param   valueStart  Value on Axis.
     * @return              Object itself for fluent interface.
     */
    setValueStart(valueStart: number): this;
    /**
     * Get start value of Band. This is in values of its owning Axis.
     * @return              Value on Axis.
     */
    getValueStart(): number;
    /**
     * Set end value of Band. This is in values of its owning Axis.
     * @param   valueEnd    Value on Axis.
     * @return              Object itself for fluent interface.
     */
    setValueEnd(valueEnd: number): this;
    /**
     * Get end value of Band. This is in values of its owning Axis.
     * @return              Value on Axis.
     */
    getValueEnd(): number;
    /**
     * Set fill style of Band.
     *
     *Example Usage:
     *```javascript
     * // Specified FillStyle
     * Band.setFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * Band.setFillStyle((solidFill) => solidFill.setA(80))
     * // Hidden (emptyFill is not supported)
     * Band.setFillStyle(transparentFill)
     * ```
     * @param fillStyle     Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns             Object itself for fluent interface.
     */
    setFillStyle(fillStyle: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of Band.
     * @return  Normal FillStyle
     */
    getFillStyle(): FillStyle;
    /**
     * Set fill style of Band when it is highlighted.
     * Highlighting is activated by placing mouse on top / touching Band (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     *
     *```javascript
     * // Specified FillStyle
     * Band.setFillStyleHighlight(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * Band.setFillStyleHighlight((solidFill) => solidFill.setA(80))
     * // Hidden (emptyFill is not supported)
     * Band.setFillStyleHighlight(transparentFill)
     * // Automatic
     * Band.setFillStyleHighlight(undefined)
     * ```
     * @param value Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value or
     *              undefined for automatic value based on normal style.
     * @returns     Object itself for fluent interface.
     */
    setFillStyleHighlight(value: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * Get highlight fill style of Band.
     * @return  FillStyle.
     */
    getFillStyleHighlight(): FillStyle;
    /**
     * Set stroke style of Band.
     *
     * Example usage:
     *```javascript
     * // Specified SolidLine
     * Band.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * Band.setStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * Band.setStrokeStyle(transparentLine)
     * ```
     * @param   value   Either a LineStyle object or a function, which will be used to create a new SolidLine based on current value.
     * @returns         Chart itself
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stroke style of Band.
     * @return  Normal StrokeStyle
     */
    getStrokeStyle(): LineStyle;
    /**
     * Set stroke style of Band when it is highlighted.
     * Highlighting is activated by placing mouse on top / touching Band (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     *
     * Example usage:
     *```javascript
     * // Specified SolidLine
     * Band.setStrokeStyleHighlight(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * Band.setStrokeStyleHighlight((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * Band.setStrokeStyleHighlight(transparentLine)
     * // Automatic
     * Band.setStrokeStyleHighlight(undefined)
     * ```
     * @param   value   Either a SolidLine object or a function, which will be used to modify current value or
     *                  undefined for automatic value based on normal style.
     * @returns         Chart itself
     */
    setStrokeStyleHighlight(value: SolidLine | ImmutableMutator<SolidLine> | undefined): this;
    /**
     * Get highlight stroke style of Band.
     * @return  StrokeStyle.
     */
    getStrokeStyleHighlight(): LineStyle;
    /**
     * Subscribe to value change event.
     *
     * This event is called whenever the position of the *Band* is changed via either **Band.setValueStart/End** or user interactions.
     * @param   handler     Function that is called when event is triggered.
     * @param   band        Band itself.
     * @param   start       New 'start' position of Band.
     * @param   end         New 'end' position of Band.
     * @return              Token that can be used to unsubscribe from the event.
     */
    onValueChange(handler: (band: this, start: number, end: number) => void): Token;
    /**
     * Unsubscribe from value change event.
     *
     * This event is called whenever the position of the *Band* is changed via either **Band.setValueStart/End** or user interactions.
     * @param   token       Token that was received when the subscription was created.
     * @return              True if unsubscription was successful.
     */
    offValueChange(token: Token): boolean;
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Object itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick?: boolean): this;
}
/**
 * Axis Highlighter that highlights a single position on the Axis.
 */
export declare class ConstantLine extends Highlighter<Rect> {
    /**
     * Set value of ConstantLine. This is in values of its owning Axis.
     * @param   value       Value on Axis.
     * @return              Object itself for fluent interface.
     */
    setValue(value: number): this;
    /**
     * Get value of ConstantLine. This is in values of its owning Axis.
     * @return              Value on Axis.
     */
    getValue(): number;
    /**
     * Set stroke style of ConstantLine.
     *
     * Example usage:
     *```javascript
     * // Specified SolidLine
     * ConstantLine.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * ConstantLine.setStrokeStyle((solidLine) => solidLine.setThickness(5))
     * ```
     * @param   value   Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
     * @returns         Chart itself
     */
    setStrokeStyle(value: SolidLine | ImmutableMutator<SolidLine>): this;
    /**
     * Get stroke style of ConstantLine.
     * @return  Normal StrokeStyle
     */
    getStrokeStyle(): SolidLine;
    /**
     * Set stroke style of ConstantLine when it is highlighted.
     * Highlighting is activated by placing mouse on top / touching ConstantLine (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     *
     * Example usage:
     *```javascript
     * // Specified SolidLine
     * ConstantLine.setStrokeStyleHighlight(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * ConstantLine.setStrokeStyleHighlight((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * ConstantLine.setStrokeStyleHighlight(transparentLine)
     * // Automatic
     * ConstantLine.setStrokeStyleHighlight(undefined)
     * ```
     * @param   value   Either a SolidLine object or a function, which will be used to modify current value or
     *                  undefined for automatic value based on normal style.
     * @returns         Chart itself
     */
    setStrokeStyleHighlight(value: SolidLine | ImmutableMutator<SolidLine> | undefined): this;
    /**
     * Get highlight stroke style of ConstantLine.
     * @return  StrokeStyle.
     */
    getStrokeStyleHighlight(): LineStyle;
    /**
     * Subscribe to value change event.
     *
     * This event is called whenever the position of the *ConstantLine* is changed via either
     * **ConstantLine.setValueStart/End** or user interactions.
     * @param   handler         Function that is called when event is triggered.
     * @param   constantLine    ConstantLine itself.
     * @param   value           New 'value' position of ConstantLine.
     * @return                  Token that can be used to unsubscribe from the event.
     */
    onValueChange(handler: (constantLine: this, value: number) => void): Token;
    /**
     * Unsubscribe from value change event.
     *
     * This event is called whenever the position of the *ConstantLine* is changed via either
     * **ConstantLine.setValueStart/End** or user interactions.
     * @param   token       Token that was received when the subscription was created.
     * @return              True if unsubscription was successful.
     */
    offValueChange(token: Token): boolean;
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Object itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick?: boolean): this;
}
/**
 * Abstract base class for Axis Highlighters.
 *
 * These components are placed along a single Axis to highlight some area of data.
 * @hidden
 */
export declare abstract class Highlighter<VisualType extends ChartVisual = ChartVisual> extends ChartComponent<ChartVisual> {
}
/**
 * Datastructure that defines the dimensions of a Box Figure.
 * Used to feed segment data to Box Series.
 */
export interface BoxFigureDimensions {
    readonly start: number;
    readonly end: number;
    readonly lowerExtreme: number;
    readonly lowerQuartile: number;
    readonly median: number;
    readonly upperQuartile: number;
    readonly upperExtreme: number;
}
/**
 * Type of constructor for BoxFigures.
 * This is the type that is used to set type of Figure in BoxSeries.
 * @param layer             Rendering layer
 * @param scale             Rendering scale
 * @param remove            Callback function when figure.dispose() is called
 * @param dimensionStrategy Strategy that is used to flip Figure depending alignment of its series
 * @param start             The start of X segment
 * @param end               The end of X segment
 * @param lowerExtreme      Smallest value excluding outliers
 * @param lowerQuartile     Twenty-five percent of the data points fall below the lower quartile
 * @param median            Marks the mid-point of data. half of the segments values are greater or equal to this value.
 * @param upperQuartile     Seventy-five percent of the data points fall below the upper quartile
 * @param upperExtreme      Highest value excluding outliers
 * @hidden
 */
export declare type BoxFigureConstructor<Type extends BoxFigure> = new (layer: Layer2D, scale: LinearScaleXY, remove: RemoveHandler<Figure>, restore: RestoreHandler<Figure>, dimensionStrategy: MultidimensionalStrategy, start: number, end: number, lowerExtreme: number, lowerQuartile: number, median: number, upperQuartile: number, upperExtreme: number, theme: Theme) => Type;
/**
 * Abstract base class for figures of BoxSeries
 * @hidden Internal class
 */
export declare abstract class BoxFigure extends CustomizableFigure implements BoxFigureDimensions {
    protected readonly _layer: Layer2D;
    readonly scale: LinearScaleXY;
    readonly dimensionStrategy: MultidimensionalStrategy;
    readonly start: number;
    readonly end: number;
    readonly lowerExtreme: number;
    readonly lowerQuartile: number;
    readonly median: number;
    readonly upperQuartile: number;
    readonly upperExtreme: number;
    readonly _theme: Theme;
    /**
     * Boundaries of BoxFigure.
     * Constant and computed in constructor.
     */
    readonly boundaries: Interval<Point>;
    /**
     * @param _layer            Rendering layer
     * @param scale             Rendering scale
     * @param remove            Callback function when figure.dispose() is called
     * @param dimensionStrategy Strategy that is used to flip Figure depending alignment of its series
     * @param start             The start of X segment
     * @param end               The end of X segment
     * @param lowerExtreme      Smallest value excluding outliers
     * @param lowerQuartile     Twenty-five percent of the data points fall below the lower quartile
     * @param median            Marks the mid-point of data. half of the segments values are greater or equal to this value.
     * @param upperQuartile     Seventy-five percent of the data points fall below the upper quartile
     * @param upperExtreme      Highest value excluding outliers
     * @hidden
     */
    constructor(_layer: Layer2D, scale: LinearScaleXY, remove: RemoveHandler<Figure>, restore: RestoreHandler<Figure>, dimensionStrategy: MultidimensionalStrategy, start: number, end: number, lowerExtreme: number, lowerQuartile: number, median: number, upperQuartile: number, upperExtreme: number, _theme: Theme);
    /**
     * Return some dominant fill style of the segment
     * @returns     FillStyle object
     */
    abstract getDominantStyle(): FillStyle;
    /**
     * Get boundaries that contain figure.
     * @return  Interval<Point>
     */
    getBoundaries(): Interval<Point>;
}
/**
 * Box and whiskers StatisticFigure implementation.
 */
export declare class BoxAndWhiskers extends BoxFigure {
    protected readonly _layer: Layer2D;
    readonly scale: LinearScaleXY;
    readonly dimensionStrategy: MultidimensionalStrategy;
    readonly start: number;
    readonly end: number;
    readonly lowerExtreme: number;
    readonly lowerQuartile: number;
    readonly median: number;
    readonly upperQuartile: number;
    readonly upperExtreme: number;
    /**
     * @hidden
     */
    constructor(_layer: Layer2D, scale: LinearScaleXY, remove: (figure: Figure) => void, restore: (figure: Figure) => void, dimensionStrategy: MultidimensionalStrategy, start: number, end: number, lowerExtreme: number, lowerQuartile: number, median: number, upperQuartile: number, upperExtreme: number, _theme: Theme);
    /**
     * Set width of box body as a % of the width of its interval width.
     * @param   width   Ratio between box body width and the segments interval
     * @return          Object itself
     */
    setBodyWidth(width: number): this;
    /**
     * Get width of box body as a % of the width of its interval width.
     * @return          Ratio between box body width and the segments interval
     */
    getBodyWidth(): number;
    /**
     * Set fill style of Series.
     *
     *Example Usage:
     *```javascript
     * // Specified FillStyle
     * BoxAndWhiskers.setBodyFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * BoxAndWhiskers.setBodyFillStyle((solidFill) => solidFill.setA(80))
     * // Hidden (emptyFill is not supported)
     * BoxAndWhiskers.setBodyFillStyle(transparentFill)
     * ```
     * @param value  FillStyle which has to be used for recoloring or mutator to modify existing one.
     * @returns      Series itself for fluent interface.
     */
    setBodyFillStyle(fillStyle: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of box body when not highlighted.
     * @return              FillStyle object
     */
    getBodyFillStyle(): FillStyle;
    /**
     * Set fill style of Series when it is highlighted.
     *
     *```javascript
     * // Specified FillStyle
     * BoxAndWhiskers.setBodyFillStyleHighlight(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * BoxAndWhiskers.setBodyFillStyleHighlight((solidFill) => solidFill.setA(80))
     * // Hidden (emptyFill is not supported)
     * BoxAndWhiskers.setBodyFillStyleHighlight(transparentFill)
     * // Automatic
     * BoxAndWhiskers.setBodyFillStyleHighlight(undefined)
     * ```
     * @param value FillStyle which has to be used during highlighting or mutator to modify existing one or undefined for auto.
     * @returns     Series itself for fluent interface.
     */
    setBodyFillStyleHighlight(fillStyle: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * Get fill style of box body when highlighted.
     * @return              FillStyle object or undefined if not assigned
     */
    getBodyFillStyleHighlight(): FillStyle | undefined;
    /**
     * Set border style of Series.
     *
     *```javascript
     * // Specified SolidLine
     * BoxAndWhiskers.setBodyStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * BoxAndWhiskers.setBodyStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * BoxAndWhiskers.setBodyStrokeStyle(transparentLine)
     * ```
     * @param value  LineStyle which has to be used for recoloring or mutator to modify existing one.
     * @returns      Series itself for fluent interface.
     */
    setBodyStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of box body when not highlighted.
     * @return                  LineStyle object
     */
    getBodyStrokeStyle(): LineStyle;
    /**
     * Set line style of Series border when it is highlighted.
     * Highlighting is activated by placing mouse on top / touching Series (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     *
     * Example usage:
     *```javascript
     * // Specified SolidLine
     * BoxAndWhiskers.setBodyStrokeStyleHighlight(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * BoxAndWhiskers.setBodyStrokeStyleHighlight((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * BoxAndWhiskers.setBodyStrokeStyleHighlight(transparentLine)
     * // Automatic
     * BoxAndWhiskers.setBodyStrokeStyleHighlight(undefined)
     * ```
     * @param   value   Either a SolidLine object or a function, which will be used to modify current value.
     * @returns         Chart itself
     */
    setBodyStrokeStyleHighlight(lineStyle: LineStyle | ImmutableMutator<LineStyle> | undefined): this;
    /**
     * Get style of box body when highlighted.
     * @return                  LineStyle object or undefined if not assigned
     */
    getBodyStrokeStyleHighlight(): LineStyle | undefined;
    /**
     * Set width of box tails as a % of the width of its interval width.
     * @param   width   Ratio between box tail width and the segments interval
     * @return          Object itself
     */
    setTailWidth(width: number): this;
    /**
     * Get width of box tails as a % of the width of its interval width.
     * @return          Ratio between box tail width and the segments interval
     */
    getTailWidth(): number;
    /**
     * Set stroke style of Series whiskers and tails.
     *
     * Example usage:
     *```javascript
     * // Specified SolidLine
     * BoxAndWhiskers.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * BoxAndWhiskers.setStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * BoxAndWhiskers.setStrokeStyle(transparentLine)
     * ```
     * @param   value   Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
     * @returns         Chart itself
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stroke style of box whiskers and tails when not highlighted.
     * @return              LineStyle object
     */
    getStrokeStyle(): LineStyle;
    /**
     * Set stroke style of Series whiskers and tails when they are highlighted.
     * Highlighting is activated by placing mouse on top / touching Series (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     *
     * Example usage:
     *```javascript
     * // Specified SolidLine
     * BoxAndWhiskers.setStrokeStyleHighlight(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * BoxAndWhiskers.setStrokeStyleHighlight((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * BoxAndWhiskers.setStrokeStyleHighlight(transparentLine)
     * // Automatic
     * BoxAndWhiskers.setStrokeStyleHighlight(undefined)
     * ```
     * @param   value   Either a SolidLine object or a function, which will be used to modify current value.
     * @returns         Chart itself
     */
    setStrokeStyleHighlight(value: LineStyle | ImmutableMutator<LineStyle> | undefined): this;
    /**
     * Get stroke style of box whiskers and tails when highlighted.
     * @return              LineStyle object or undefined if not assigned
     */
    getStrokeStyleHighlight(): LineStyle | undefined;
    /**
     * Set stroke style of Series median line.
     *
     * Example usage:
     *```javascript
     * // Specified SolidLine
     * BoxAndWhiskers.setMedianStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * BoxAndWhiskers.setMedianStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * BoxAndWhiskers.setMedianStrokeStyle(transparentLine)
     * ```
     * @param   value   Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
     * @returns         Chart itself
     */
    setMedianStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stroke style of box median line when not highlighted.
     * @return              LineStyle object
     */
    getMedianStrokeStyle(): LineStyle;
    /**
     * Set stroke style of Series median line when it is highlighted.
     * Highlighting is activated by placing mouse on top / touching Series (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     *
     * Example usage:
     *```javascript
     * // Specified SolidLine
     * BoxAndWhiskers.setMedianStrokeStyleHighlight(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * BoxAndWhiskers.setMedianStrokeStyleHighlight((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * BoxAndWhiskers.setMedianStrokeStyleHighlight(transparentLine)
     * // Automatic
     * BoxAndWhiskers.setMedianStrokeStyleHighlight(undefined)
     * ```
     * @param   value   Either a SolidLine object or a function, which will be used to modify current value.
     * @returns         Chart itself
     */
    setMedianStrokeStyleHighlight(value: LineStyle | ImmutableMutator<LineStyle> | undefined): this;
    /**
     * Get stroke style of box median line when highlighted.
     * @return              LineStyle object or undefined if not assigned
     */
    getMedianStrokeStrokeHighlight(): LineStyle | undefined;
    /**
     * Return some dominant fill style of the segment
     * @returns     FillStyle object
     */
    getDominantStyle(): FillStyle;
    /**
     * Set highlighted state of the Object
     * @param isHighlighted Highlight state of the object
     * @returns             Object itself for fluent interface
     */
    setHighlighted(isHighlighted: boolean): this;
}
/**
 * Type of a BoxSeriesFormatter function.
 * Defines what Cursor ResultTables show.
 * @param   tableContentBuilder     Builder that is used to build contents of ResultTable
 * @param   series                  BoxSeries
 * @param   segment                 StatisticData that is to be displayed with ResultTable
 * @return                          TableContentBuilder that was supplied
 */
export declare type BoxSeriesFormatter = <T extends TableContentBuilder>(tableContentBuilder: T, series: BoxSeries, segment: BoxFigureDimensions) => T;
/**
 * BoxSeries class.
 * Takes in types of 'BoxFigureDimensions' and plots it using 'StatisticFigure'
 *
 * Currently always on X
 */
export declare class BoxSeries<FigureType extends BoxFigure = BoxFigure> extends SimpleFigureSeries<FigureType, BoxSeriesFormatter, BoxFigureDimensions, LinearScaleXY> {
    protected readonly _figureType: BoxFigureConstructor<FigureType>;
    protected readonly _dimensionStrategy: MultidimensionalStrategy;
    /**
     * @param chart                 Owning Chart
     * @param _removeFromChart      Handler for removing reference to series from owning chart
     * @param _restoreFromChart     Handler for restoring reference to series from owning chart
     * @param _layer                Rendering layer
     * @param axisX                 Axis X
     * @param axisY                 Axis Y
     * @param axisXAttachHandler    Attach handler for Axis X
     * @param axisYAttachHandler    Attach handler for Axis Y
     * @param _newUILayer           Factory for creating new UI layers for drawing SeriesMarkers
     * @param _figureType           Figure type
     * @param _dimensionStrategy    Dimension strategy for positioning BoxFigures (horizontal/vertical)
     * @param _theme                Theme from owning Chart, used for styling
     * @hidden
     */
    constructor(chart: ChartXY, _removeFromChart: RemoveHandler<ChartComponent>, _restoreFromChart: RestoreHandler<ChartComponent>, _layer: Layer2D, axisX: Axis, axisY: Axis, axisXAttachHandler: AxisAttachHandler, axisYAttachHandler: AxisAttachHandler, _newUILayer: () => Layer2D, _figureType: BoxFigureConstructor<FigureType>, _dimensionStrategy: MultidimensionalStrategy, _theme: Theme, automaticColorIndex: number);
    /**
     * Add new figure to the series.
     * @param   dimensions  Dimensions that figure must represent
     * @return              Created figure
     */
    add(dimensions: BoxFigureDimensions): FigureType;
}
/**
 * Interface can be used to define the X and Y Axis that a series should be attached to,
 * define type of StatisticFigure and type of dimensionStrategy.
 */
export interface BoxSeriesOptions<FigureType extends BoxFigure> extends SeriesOptions {
    /**
     * Figure type of StatisticFigure used for visualizing segments.
     *
     * Currently only [[BoxAndWhiskers]] is implemented.
     */
    figure?: BoxFigureConstructor<FigureType>;
    /**
     * DimensionStrategy Strategy used for selecting between vertical and horizontal Box Series.
     */
    dimensionStrategy?: MultidimensionalStrategy;
}
/**
 * Type of constructor for OHLCFigures.
 * @param layer     Rendering layer
 * @param scale     Rendering scale
 * @param positive  Does figure represent positive or negative segments
 * @param _theme    Theme of owning Chart, used for styling
 * @hidden
 */
export declare type OHLCFigureConstructor<Type extends OHLCFigure> = new (layer: Layer2D, scale: LinearScaleXY | MixedScaleXY, remove: (figure: Figure) => void, restore: (figure: Figure) => void, positive: boolean, _theme: Theme) => Type;
/**
 * Interface for data values of an OHLC segment.
 */
export interface OHLCSegment {
    /**
     * Get Position of OHLC segment.
     * @return  Position
     */
    getPosition(): number;
    /**
     * Get Open value of OHLC segment.
     * @return  Open value
     */
    getOpen(): number;
    /**
     * Get High value of OHLC segment.
     * @return  High value
     */
    getHigh(): number;
    /**
     * Get Low value of OHLC segment.
     * @return  Low value
     */
    getLow(): number;
    /**
     * Get Close value of OHLC segment.
     * @return  Close value
     */
    getClose(): number;
}
/**
 * Abstract base class for OHLCFigures.
 * OHLCFigures are designed to be recycleable, which means they
 * must be able to be resized at any moment. Because OHLC series can have different classes for
 * positive/negative figures, this state is not changeable! So any figure that was created as 'positive',
 * can not be recycled to be 'negative'!
 */
export declare abstract class OHLCFigure extends Figure implements OHLCSegment {
    protected readonly _layer: Layer2D;
    readonly scale: LinearScaleXY | MixedScaleXY;
    readonly positive: boolean;
    /**
     * @param _layer            Rendering layer
     * @param scale             Rendering scale
     * @param remove            Remove handler
     * @param restore           Restore handler
     * @param positive          Does figure represent positive or negative segments
     * @param _theme            Theme from owning chart, used for styling.
     * @hidden
     */
    constructor(_layer: Layer2D, scale: LinearScaleXY | MixedScaleXY, remove: (figure: Figure) => void, restore: (figure: Figure) => void, positive: boolean, _theme: Theme);
    /**
     * Get Middle X position
     * @return  Middle X position
     */
    getPosition(): number;
    /**
     * Get Open value
     * @return  Open value
     */
    getOpen(): number;
    /**
     * Get High value
     * @return  High value
     */
    getHigh(): number;
    /**
     * Get Low value
     * @return  Low value
     */
    getLow(): number;
    /**
     * Get Close value
     * @return  Close value
     */
    getClose(): number;
    /**
     * Get indices of data that figure represents.
     * @return  Either index array for multiple samples or single index
     */
    getDataIndices(): number | number[];
}
/**
 * Candlestick [[OHLCFigure]].
 */
export declare class OHLCCandleStick extends OHLCFigure {
    /**
     * Set stroke style of candles lines.
     * @param   value      LineStyle object or mutator to modify existing one
     * @return             Object itself
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stoke style of candles.
     * @return              LineStyle object
     */
    getStrokeStyle(): LineStyle;
    /**
     * Set stroke style of candles when highlighted.
     * @param   value       FillStyle object or mutator to modify existing one or undefined for automatic computation
     * @return              Object itself
     */
    setStrokeStyleHighlight(value: LineStyle | ImmutableMutator<LineStyle> | undefined): this;
    /**
     * Get stroke style of candles when highlighted.
     * @return              FillStyle object or undefined if unassigned
     */
    getStrokeStyleHighlight(): LineStyle | undefined;
    /**
     * Set fill style of candles body.
     * @param   value       FillStyle object or mutator to modify existing one
     * @return              Object itself
     */
    setBodyFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of candles body.
     * @return              FillStyle object
     */
    getBodyFillStyle(): FillStyle;
    /**
     * Set fill style of candles body when highlighted.
     * @param   fillStyle   FillStyle object or mutator to modify existing one or undefined for automatic assignment
     * @return              Object itself
     */
    setBodyFillStyleHighlight(fillStyle: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * Get fill style of candles body when highlighted.
     * @return              FillStyle object if unassigned
     */
    getBodyFillStyleHighlight(): FillStyle | undefined;
    /**
     * Set stroke style of candles body.
     * @param   value       LineStyle object or mutator to modify existing one
     * @return              Object itself
     */
    setBodyStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stroke style of candles body.
     * @return              LineStyle object
     */
    getBodyStrokeStyle(): LineStyle;
    /**
     * Set style of candles body when highlighted.
     * @param   value       LineStyle object or mutator to modify existing one or undefined for automatic assignment
     * @return              Object itself
     */
    setBodyStrokeStyleHighlight(value: LineStyle | ImmutableMutator<LineStyle> | undefined): this;
    /**
     * Get style of candles body when highlighted.
     * @return              LineStyle object or undefined if unassigned
     */
    getBodyStrokeStyleHighlight(): LineStyle | undefined;
    /**
     * Return some dominant fill style of the segment
     * @returns     FillStyle object
     */
    getDominantStyle(): FillStyle;
    /**
     * Set highlighted state of the Object
     * @param isHighlighted Highlight state of the object
     * @returns             Object itself for fluent interface
     */
    setHighlighted(isHighlighted: boolean): this;
}
/**
 * Bar [[OHLCFigure]].
 */
export declare class OHLCBar extends OHLCFigure {
    /**
     * Set stroke style of bar lines.
     * @param   value       LineStyle object or mutator to modify existing one
     * @return              Object itself
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stroke style of bar lines.
     * @return              LineStyle object
     */
    getStrokeStyle(): LineStyle;
    /**
     * Set stroke style of bar lines when highlighted.
     * @param   value       LineStyle object or mutator to modify existing one or undefined for default
     * @return              Object itself
     */
    setStrokeStyleHighlight(value: LineStyle | ImmutableMutator<LineStyle> | undefined): this;
    /**
     * Get stroke fill style of bar lines when highlighted.
     * @return              LineStyle object or undefined if unassigned
     */
    getStrokeHighlight(): LineStyle | undefined;
    /**
     * Return some dominant fill style of the segment
     * @returns     FillStyle object
     */
    getDominantStyle(): FillStyle;
    /**
     * Set highlighted state of the Object
     * @param isHighlighted Highlight state of the object
     * @returns             Object itself for fluent interface
     */
    setHighlighted(isHighlighted: boolean): this;
}
/**
 * Collection of [[OHLCFigure]] options.
 *
 * Used for selecting different figure designs for *OHLCSeries*. eq.
 * - Candlestick Chart can be created using [[OHLCFigures.Candlestick]]
 * - OHLC Chart can be created using [[OHLCFigures.Bar]]
 *
 * Example usage:
 *```javascript
 * // Specify OHLCFigure of OHLCSeries
 * ChartXY.addOHLCSeries(undefined, undefined, OHLCFigures.Candlestick)
 * ```
 */
export declare const OHLCFigures: {
    /**
     * Candlestick *OHLCFigure*.
     */
    Candlestick: typeof OHLCCandleStick;
    /**
     * Bar *OHLCFigure*.
     */
    Bar: typeof OHLCBar;
};
/**
 * StockSeries implementation using FigureSeries.
 * Actual types used are in file 'stockInterfaces.ts'
 */
/**
 * Interface for CursorPoints that point to an OHLCSegment.
 * Used to pack information about pointed segment to users.
 */
export interface OHLCCursorPoint extends CursorPoint<OHLCSeries<OHLCFigure, OHLCFigure>> {
    /**
     * Interface that contains information about the pointed OHLCSegment.
     */
    ohlcSegment: OHLCSegment;
}
/**
 * Interface for a function which builds ResultTable content when pointing at an OHLCSeries.
 * @param   tableContentBuilder     Builder that is used to build contents of ResultTable.
 *                                  Use addRow() method for adding content.
 * @param   series                  OHLCSeries
 * @param   ohlcSegment             OHLCSegment that is pointed. Has methods for reading its Open, High, Low, Close and Position values.
 * @return                          TableContentBuilder that was supplied
 */
export declare type OHLCSeriesFormatter = <T extends TableContentBuilder>(tableContentBuilder: T, series: OHLCSeries<OHLCFigure, OHLCFigure>, ohlcSegment: OHLCSegment) => T;
/**
 * Ordered tuple that contains values for:
 * - X
 * - Open
 * - High
 * - Low
 * - Close
 */
export declare type XOHLC = [number, number, number, number, number];
/**
 * Type of styler function for OHLC figures
 */
export declare type OHLCFigureStyler<T extends OHLCFigure> = (figure: T) => void;
/**
 * Type definition for OHLC-series constructor.
 * @param chart                 Owning Chart
 * @param _removeFromChart      Handler for removing reference to series from owning chart
 * @param _restoreFromChart     Handler for restoring reference to series from owning chart
 * @param _layer                Rendering layer
 * @param axisX                 Axis X
 * @param axisY                 Axis Y
 * @param axisXAttachHandler    Attach handler for Axis X
 * @param axisYAttachHandler    Attach handler for Axis Y
 * @param _newUILayer           Factory for creating new UI layers for drawing SeriesMarkers
 * @param _positiveFigure   OHLCFigure constructor for positive figure
 * @param _negativeFigure   OHLCFigure constructor for negative figure
 * @hidden
 */
export declare type OHLCSeriesConstructor<PositiveFigure extends OHLCFigure, NegativeFigure extends OHLCFigure, OHLCSeriesType extends OHLCSeriesTypes<PositiveFigure, NegativeFigure>> = new (chart: ChartXY, _removeFromChart: RemoveHandler<ChartComponent>, _restoreFromChart: RestoreHandler<ChartComponent>, _layer: Layer2D, axisX: Axis, axisY: Axis, axisXAttachHandler: AxisAttachHandler, axisYAttachHandler: AxisAttachHandler, _newUILayer: () => Layer2D, _positiveFigure: OHLCFigureConstructor<PositiveFigure>, _negativeFigure: OHLCFigureConstructor<NegativeFigure>, _theme: Theme, automaticColorIndex: number) => OHLCSeriesType;
/**
 * Super class of [[OHLCSeriesTraditional]] and [[OHLCSeriesWithAutomaticPacking]].
 *
 * Sub classes define method of data input, while styling APIs, etc. are identical.
 */
export declare abstract class OHLCSeries<PositiveFigure extends OHLCFigure = OHLCFigure, NegativeFigure extends OHLCFigure = PositiveFigure> extends FigureSeries<PositiveFigure | NegativeFigure, OHLCCursorPoint, LinearScaleXY | MixedScaleXY> implements ObservableXYData<XOHLC>, SeriesWithDataCleaning {
    protected _positiveFigure: OHLCFigureConstructor<PositiveFigure>;
    protected _negativeFigure: OHLCFigureConstructor<NegativeFigure>;
    /**
     * @param chart                 Owning Chart
     * @param _removeFromChart      Handler for removing reference to series from owning chart
     * @param _restoreFromChart     Handler for restoring reference to series from owning chart
     * @param _layer                Rendering layer
     * @param axisX                 Axis X
     * @param axisY                 Axis Y
     * @param axisXAttachHandler    Attach handler for Axis X
     * @param axisYAttachHandler    Attach handler for Axis Y
     * @param _newUILayer           Factory for creating new UI layers for drawing SeriesMarkers
     * @param _positiveFigure       OHLCFigure constructor for positive figure
     * @param _negativeFigure       OHLCFigure constructor for negative figure
     * @param _theme                Theme from owning Chart, used for styling
     * @hidden
     */
    constructor(chart: ChartXY, _removeFromChart: RemoveHandler<ChartComponent>, _restoreFromChart: RestoreHandler<ChartComponent>, _layer: Layer2D, axisX: Axis, axisY: Axis, axisXAttachHandler: AxisAttachHandler, axisYAttachHandler: AxisAttachHandler, _newUILayer: () => Layer2D, _positiveFigure: OHLCFigureConstructor<PositiveFigure>, _negativeFigure: OHLCFigureConstructor<NegativeFigure>, _theme: Theme, automaticColorIndex: number);
    /**
     * Set common style for both positive and negative figures.
     * NOTE: Because the function is applied for each figure added, it is not advised to create any objects inside the function.
     * Instead they should be previously cached and later referred to.
     *
     * Example usage:
     *```javascript
     * // Explicit style
     * // The type of figure can be equal to type parameter PositiveFigure or NegativeFigure
     * OHLCSeries.setStyle((figure) => ... )
     * ```
     * @param   styler  Styler function that is applied to all existing and newly added segments
     * @return          Object itself
     */
    setStyle(style: OHLCFigureStyler<PositiveFigure | NegativeFigure>): this;
    /**
     * Set style of positive figures.
     * Positive style is applied after common style.
     * NOTE: Because the function is applied for each figure added, it is not advised to create any objects inside the function.
     * Instead they should be previously cached and later referred to.
     *
     * Example usage:
     *```javascript
     * // Explicit style
     * // The type of figure can be equal to type parameter PositiveFigure
     * OHLCSeries.setPositiveStyle((figure) => ... )
     * ```     * @param   styler  Styler function that is applied to all existing and newly added segments
     * @return          Object itself
     */
    setPositiveStyle(style: OHLCFigureStyler<PositiveFigure>): this;
    /**
     * Set style of negative figures.
     * Negative style is applied after common style.
     * NOTE: Because the function is applied for each figure added, it is not advised to create any objects inside the function.
     *
     * Example usage:
     *```javascript
     * // Explicit style
     * // The type of figure can be equal to type parameter NegativeFigure
     * OHLCSeries.setNegativeStyle((figure) => ... )
     * ```
     * @param   styler  Styler function that is applied to all existing and newly added segments
     * @return          Object itself
     */
    setNegativeStyle(style: OHLCFigureStyler<NegativeFigure>): this;
    /**
     * Set width of figures in pixels.
     * @param   width   Width in pixels
     * @return          Object itself
     */
    setFigureWidth(width: pixel): this;
    /**
     * Get width of figures in pixels.
     */
    getFigureWidth(): pixel;
    /**
     * Set whether auto-fitting of Figures is enabled. When enabled, figures are automatically split / fused based on distance
     * from each other.
     * @param   enabled Is auto-fitting enabled.
     * @return          Object itself for fluent interface
     */
    setFigureAutoFitting(enabled: boolean): this;
    /**
     * Get whether auto-fitting of Figures is enabled. When enabled, figures are automatically split / fused based on distance
     * from each other.
     * @return          Is auto-fitting enabled.
     */
    getFigureAutoFitting(): boolean;
    /**
     * Disable automatic data cleaning.
     *
     * ```js
     *  // Example syntax, disable data cleaning.
     *  series.setDataCleaning(undefined)
     * ```
     *
     * @param   arg             Data cleaning configuration.
     * @return                  Object itself for fluent interface.
     */
    setDataCleaning(arg: undefined): this;
    /**
     * Enable automatic data cleaning by `minDataPointCount` configuration.
     *
     * Specifying `minDataPointCount` enables _lazy_ cleaning of data that is **outside view** as long as the remaining data amount doesn't go below the configured threshold.
     *
     * ```js
     *  // Example syntax for specifying minDataPointCount
     *  series.setDataCleaning({ minDataPointCount: 10000 })
     * ```
     *
     * Usage of `minDataPointCount` is recommended in most common applications that require automatic data cleaning.
     * The actual value is often not very particular, just setting it above `0` to enable it is usually enough (lazy data cleaning of out of view data).
     *
     * ```js
     *  // Example, enable lazy data cleaning of out of view data.
     *  series.setDataCleaning({ minDataPointCount: 1 })
     * ```
     *
     * @param   arg             Data cleaning configuration.
     * @return                  Object itself for fluent interface.
     */
    setDataCleaning(arg: {
        minDataPointCount: number | undefined;
    }): this;
    /**
     * Enable automatic data cleaning by `maxDataPointCount` configuration.
     *
     *Specifying `maxDataPointCount` results in data cleaning always happening **exactly** when total data amount exceeds the supplied threshold.
     *
     * ```js
     *  // Example syntax for specifying maxDataPointCount
     *  series.setDataCleaning({ maxDataPointCount: 10000 })
     * ```
     *
     * `maxDataPointCount` is usually used in memory limited applications to prevent running out of memory.
     *
     * **`maxDataPointCount` is currently only supported by only select series:**
     * - [[HeatmapScrollingGridSeries]].
     * - [[OHLCSeries]].
     *
     * If the feature receives good support and usage from the user base, it might be expanded to all series types in a future release.
     *
     * @param   arg             Data cleaning configuration.
     * @return                  Object itself for fluent interface.
     */
    setDataCleaning(arg: {
        maxDataPointCount: number | undefined;
    }): this;
    /**
     * Configure automatic *data cleaning* by `maxPointCount`.
     * This allows the cleaning of all excess data points that are outside view, so that after cleaning at least `maxPointCount`
     * data points are retained.
     * Essentially it configures the *head length* of a series.
     *
     * ```ts
     *  // Example, progressive X line series with automatic data cleaning.
     *  const series = ChartXY.addLineSeries({
     *      dataPattern: {
     *          pattern: 'ProgressiveX'
     *      }
     *  })
     *      // Keep at least 1000 data points in series, otherwise excess out of view data can be cleaned for more memory.
     *      .setMaxPointCount(1000)
     *
     * // Setup automatically scrolling X Axis.
     * chart.getDefaultAxisX().setScrollStrategy(AxisScrollStrategies.progressive).setInterval(0, 1000)
     *
     *  // Continously stream data into series.
     *  let x = 0
     *  setInterval(() => {
     *      const newDataPoints = []
     *      for (let i = 0; i <= 10; i += 1) {
     *          newDataPoints.push({ x: x + i, y: Math.random() * 100 })
     *      }
     *      x += newDataPoints.length
     *      series.add(newDataPoints)
     *  }, 1000 / 60)
     * ```
     *
     * Enabling automatic *data cleaning* is crucial in applications that run for a long time, or even *forever*
     * - because it allows clearing memory for allocating new data points.
     *
     * @param   maxPointCount   Configuration for automatic *data cleaning* by `maxPointCount`.
     *                          If undefined or 0 is passed, automatic *data cleaning* by `maxPointCount` will be disabled.
     * @returns                 Object itself for fluent interface.
     * @deprecated              Will be removed in v4.0 in favour of [[setDataCleaning]].
     */
    setMaxPointCount(maxPointCount?: number): this;
    /**
     * Solves the nearest datapoint to a given coordinate on screen.
     * @param   location    Location on screen
     * @return              Undefined or data-structure for positioning of cursors
     */
    solveNearestFromScreen(location: Point): undefined | OHLCCursorPoint;
    /**
     * Solves the nearest datapoint to a given coordinate on a screen from a specific segment.
     * @param   location    Location on screen
     * @param   segment     Segment to solve from
     * @return              Undefined or data-structure for positioning of cursors
     */
    solveNearestFromSegment(location: Point, segment: OHLCFigure): undefined | OHLCCursorPoint;
    /**
     * Configure formatting of *Cursor ResultTable* when pointing at this *series*.
     *
     * ```typescript
     *  // Example usage
     *  OHLCSeries.setCursorResultTableFormatter((tableBuilder, series, ohlcSegment) => {
     *      return tableBuilder
     *          .addRow(`Pointing at`, '', series.getName())
     *          .addRow(`X:`, '', ohlcSegment.getPosition())
     *          .addRow(`Open:`, '', ohlcSegment.getOpen())
     *          .addRow(`High:`, '', ohlcSegment.getHigh())
     *          .addRow(`Low:`, '', ohlcSegment.getLow())
     *          .addRow(`Close:`, '', ohlcSegment.getClose())
     *  })
     * ```
     *
     * The general syntax of configuring *ResultTable* formatting is shared between all *series* types;
     * You specify a callback function, which receives a [[TableContentBuilder]]. The contents of the table are then set using methods of the *table builder*:
     *
     * ```typescript
     *  // Using TableContentBuilder.
     *  OHLCSeries.setCursorResultTableFormatter((tableBuilder, series, ohlcSegment) => {
     *      // addRow adds a list of strings to a new row in the table. Empty strings ('') will allocate any extra horizontal space within the row.
     *      tableBuilder
     *          .addRow('Item 0:', '', 'Value 0')
     *          .addRow('Item 1:', '', 'Value 1')
     *          .addRow('Long row that highlights the idea of empty strings')
     *
     *      // After configuration, the table builder must be returned!
     *      return tableBuilder
     *  })
     * ````
     *
     * Default Axis formatting can be referenced by using [[Axis.formatValue]] method.
     *
     * The additional values that are supplied to the callback function vary between different *chart* and *series* types,
     * refer to the *series* documentation of `setCursorResultTableFormatter` to learn the exact available information.
     * `OHLC Series` receive two extra parameters:
     * 1. `series` | reference to the series itself.
     * 2. `ohlcSegment` | reference to the pointed [[OHLCSegment]], which contains *position, open, high, low and close* values.
     *
     * **Related API:**
     *
     * - [[setCursorEnabled]] | configure whether *cursors* should pick on this particular *series* or not.
     * - [[ChartXY.setAutoCursorMode]] | configure behavior when auto cursor is visible.
     *
     * @param   formatter   Function which builds *ResultTable* content.
     * @return              Object itself
     */
    setCursorResultTableFormatter(formatter: OHLCSeriesFormatter): this;
    /**
     * Get ResultTable Formatter.
     * @return  Function which builds ResultTable content for OHLCSeries.
     */
    getCursorResultTableFormatter(): OHLCSeriesFormatter;
    /**
     * Clear all previously pushed data points from the *series*.
     *
     * ```ts
     *  // Example usage
     *  LineSeries.clear()
     * ```
     *
     * @return      Object itself for fluent interface.
     */
    clear(): this;
    /**
     * @return Max X value of the series
     */
    getXMax(): number;
    /**
     * @return Min X value of the series
     */
    getXMin(): number;
    /**
     * @return Max Y value of the series
     */
    getYMax(): number;
    /**
     * @return Min Y value of the series
     */
    getYMin(): number;
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Series itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick?: boolean): this;
}
/**
 * OHLCSeries class.
 * Takes data in format of OHLC segment interface and renders it using generic StockFigures.
 * Currently only supports progressive X timeline!
 */
export declare class OHLCSeriesTraditional<PositiveFigure extends OHLCFigure = OHLCFigure, NegativeFigure extends OHLCFigure = PositiveFigure> extends OHLCSeries<PositiveFigure, NegativeFigure> {
    /**
     * Add OHLC segments to series.
     * NOTE: Added segments must always have progressive X values!
     * @param   data    Tuple of X+OHLC values or array of such tuples
     * @return          Object itself
     */
    add(data: XOHLC | XOHLC[]): this;
}
/**
 * Type of OHLCSeries that automatically packages progressive (X) Vec2 data.
 */
export declare class OHLCSeriesWithAutomaticPacking<PositiveFigure extends OHLCFigure = OHLCFigure, NegativeFigure extends OHLCFigure = PositiveFigure> extends OHLCSeries<PositiveFigure, NegativeFigure> implements DataInput, DataInputY {
    /**
     * Append a single `XY` coordinate or list of coordinates into the *series*.
     *
     * ```ts
     *  // Example syntax
     *  LineSeries.add({ x: 0, y: 100 })
     *
     *  LineSeries.add([
     *      { x: 0, y: 100 },
     *      { x: 10, y: 50 },
     *      { x: 20, y: 75 },
     *  ])
     * ```
     *
     * @param    points  Single XY coordinate or list of coordinates.
     * @returns          Object itself for fluent interface.
     */
    add(points: Point | Point[]): this;
    /**
     * Add point to the Series.
     * @param   p       New point
     * @returns         Series itself for fluent interface
     */
    addPoint(p: Point): this;
    /**
     * Add points to the Stock series.
     * @param   points   Array of new points
     * @returns          Series itself for fluent interface
     */
    addPoints(points: Point[]): this;
    /**
     * Each Y-value will be paired with an automatically generated X-value, based on *step*-argument.
     * @param   arrayY  Array of Y-values.
     * @param   step    Optional step between each X coordinate. Defaults to 1.
     * @param   start   Optional value for first generated X-value. If undefined, will continue after last point's X value in series,
     *                  or 0 if there are no points in series.
     * @return          Object itself for fluent interface.
     */
    addArrayY(arrayY: number[], step?: number, start?: number): this;
    /**
     * Set resolution of Stock segment packing.
     * Smaller resolution will let user zoom to greater detail.
     * If no resolution has been defined, series will use pixel width of figures as packing resolution.
     * @param   resolution  Axis value interval for resolution of a single Stock segment
     *                      or undefined to be automatically calculated based on pixelSize.
     * @return              Object itself
     * @sideEffect          Series will consume more memory if resolution value is lowered.
     */
    setPackingResolution(resolution?: number): this;
    /**
     * @return Copy of last point added to the Series or undefined if it doesn't exist.
     */
    getLastPoint(): Point | undefined;
}
/**
 * Available OHLC Series types
 */
export declare type OHLCSeriesTypes<PositiveFigure extends OHLCFigure, NegativeFigure extends OHLCFigure> = OHLCSeriesTraditional<PositiveFigure, NegativeFigure> | OHLCSeriesWithAutomaticPacking<PositiveFigure, NegativeFigure>;
/**
 * Collection of *OHLCSeries* types.
 *
 * By default, *OHLCSeries* will be [[OHLCSeriesTraditional]], but different types can be created with these options.
 * Note, that based on the selection the *Series* can have different *API*!
 *
 * Example usage:
 *```javascript
 * // Create OHLCSeries with automatic packing
 * ChartXY.addOHLCSeries(undefined, undefined, undefined, undefined, OHLCSeriesTypes.AutomaticPacking)
 * ```
 */
export declare const OHLCSeriesTypes: {
    /**
     * *OHLCSeries* type that takes data traditionally in XOHLC-tuples.
     */
    Normal: typeof OHLCSeriesTraditional;
    /**
     * *OHLCSeries* type that takes data as X-progressive Points.
     * The *Series* automatically packs these into OHLC-segments.
     *
     * **If this option is selected, the "add()"-method of the created *Series* will only accept *Points*, rather than *XOHLC*-values**.
     */
    AutomaticPacking: typeof OHLCSeriesWithAutomaticPacking;
};
/**
 * Interface can be used to define the X and Y Axis that a series should be attached to,
 * type of OHLCFigure used for positive segments, negative segments and series.
 */
export interface OHLCSeriesOptions<PositiveFigure extends OHLCFigure, NegativeFigure extends OHLCFigure, OHLCSeriesType extends OHLCSeriesTypes<PositiveFigure, NegativeFigure>> extends SeriesOptions {
    /**
     * Type of OHLCFigure used for positive segments.
     */
    positiveFigure?: OHLCFigureConstructor<PositiveFigure>;
    /**
     * Type of OHLCFigure used for negative segments.
     */
    negativeFigure?: OHLCFigureConstructor<NegativeFigure>;
    /**
     * Type of OHLCSeries created.
     */
    seriesConstructor?: OHLCSeriesConstructor<PositiveFigure, NegativeFigure, OHLCSeriesType>;
}
/**
 * Abstract super class for following series types:
 *
 * - [[AreaSeriesPositive]]
 * - [[AreaSeriesNegative]]
 * - [[AreaSeriesBipolar]]
 */
export declare abstract class AreaSeries extends RangeSeries implements ObservableXYData<Point>, DataInputY {
    protected readonly _baseline: number;
    /**
     * @param chart                 Owning Chart
     * @param _removeFromChart      Handler for removing reference to series from owning chart
     * @param _restoreFromChart     Handler for restoring reference to series from owning chart
     * @param _layer                Rendering layer
     * @param axisX                 Axis X
     * @param axisY                 Axis Y
     * @param axisXAttachHandler    Attach handler for Axis X
     * @param axisYAttachHandler    Attach handler for Axis Y
     * @param _newUILayer           Factory for creating new UI layers for drawing SeriesMarkers
     * @param _baseline             The limit at which series starts.
     * @param _theme                Theme from owning Chart, used for styling
     * @hidden
     */
    constructor(chart: ChartXY, _removeFromChart: RemoveHandler<ChartComponent>, _restoreFromChart: RestoreHandler<ChartComponent>, _layer: Layer2D, axisX: Axis, axisY: Axis, axisXAttachHandler: AxisAttachHandler, axisYAttachHandler: AxisAttachHandler, _newUILayer: () => Layer2D, _baseline: number, _theme: Theme);
    /**
     * Append a single `XY` coordinate or list of `XY` coordinates into the *series*.
     *
     * ```ts
     *  // Example syntax
     *  AreaSeries.add({ x: 0, y: 100 })
     *
     *  AreaSeries.add([
     *      { x: 0, y: 100 },
     *      { x: 10, y: 50 },
     *      { x: 20, y: 75 },
     *  ])
     * ```
     *
     * For more methods of appending data into series, see:
     *
     * - [[addArrayY]] | Append only Y coordinates.
     *
     * **Data gaps**
     *
     * When using [[LineSeries]], [[AreaSeries]] or other series types which connect data points together,
     * the connections between specific data points can be removed by adding gap data points.
     *
     * A gap data point is specified by using `Number.NaN` as either X or Y coordinate.
     *
     * ```ts
     *  // Example, data gap syntax.
     *  AreaSeries.add([
     *      { x: 0, y: 10 },
     *      { x: 1, y: 12 },
     *      { x: 2, y: Number.NaN },
     *      { x: 3, y: 15 },
     *      { x: 4, y: 20 }
     *  ])
     * ```
     *
     * @param    points  Single XY coordinate or list of coordinates.
     * @returns          Object itself for fluent interface.
     */
    add(points: Point | Point[]): this;
    /**
     * Append new data points into the series by only supplying Y coordinates.
     *
     * ```ts
     *  // Example syntax, number array
     *  AreaSeries.addArrayY([ 5, 1, 2, 0 ])
     * ```
     *
     * This method supports binary data input by using *Typed arrays*.
     * If your data comes in any binary format, then using the typed array syntax is recommended for best performance.
     *
     * ```ts
     *  // Example syntax, typed array (Float32)
     *  const float32Array = new Float32Array(4)
     *  float32Array[0] = 5
     *  float32Array[1] = 1
     *  float32Array[2] = 2
     *  float32Array[3] = 0
     *  AreaSeries.addArrayY(float32Array)
     * ```
     *
     * Each Y coordinate will be paired with an automatically generated X coordinate.
     *
     * By default, this continues from the last data point in the series.
     * However, the behavior of assigning X coordinates can be controlled with the optional `step` and `start` parameters.
     *
     * For more methods of appending data into series, see:
     *
     * - [[add]] | Append XY coordinates.
     *
     * **Data gaps**
     *
     * When using [[LineSeries]], [[AreaSeries]] or other series types which connect data points together,
     * the connections between specific data points can be removed by adding gap data points.
     *
     * A gap data point is specified by using `Number.NaN`.
     *
     * ```ts
     *  // Example, data gap syntax.
     *  AreaSeries.addArrayY([ 10, 12, Number.NaN, 15, 20 ])
     * ```
     *
     * @param   arrayY  Array of Y-values.
     * @param   step    Optional step between each X coordinate. Defaults to 1.
     * @param   start   Optional value for first generated X-value. If undefined, will continue after last point's X value in series,
     *                  or 0 if there are no points in series.
     * @return          Object itself for fluent interface.
     */
    addArrayY(arrayY: number[], step?: number, start?: number): this;
}
/**
 * Interface can be used to define the X and Y Axis that a series should be attached to,
 * a reference number used for comparison and type of area series.
 */
export interface AreaSeriesOptions<AreaType extends AreaSeriesTypes> extends SeriesOptions {
    /**
     * A fixed reference number.
     */
    baseline?: number;
    /**
     * Defines the type of area series. Selected option can enable/disable specific APIs!
     *
     * See [[AreaSeriesTypes]] for a collection of options.
     */
    type?: AreaType;
}
/**
 * Implementation of *SeriesXY* for visualizing a collection of progressive *Points* by
 * filling the area between the points *Y*-values and a static *baseline* value.
 *
 * This type of *AreaSeries* shows data on both sides of the *baseline*, and it has individual styles for each side:
 * *positive* and *negative*. Each side is also composed of the areas *fill* and *border*.
 *
 * *AreaSeriesBipolar* are created with [[ChartXY.addAreaSeries]] and selecting *AreaSeriesTypes.Bipolar*.
 */
export declare class AreaSeriesBipolar extends AreaSeries {
    /**
     * @param _chart                Parent Chart
     * @param _removeFromChart      Handler for removing reference to series from owning chart
     * @param _restoreFromChart     Handler for restoring reference to series from owning chart
     * @param _layer                Rendering layer
     * @param axisX                 Axis X
     * @param axisY                 Axis Y
     * @param axisXAttachHandler    Attach handler for Axis X
     * @param axisYAttachHandler    Attach handler for Axis Y
     * @param _newUILayer           Factory for creating new UI layers for drawing SeriesMarkers
     * @param _theme                Theme from owning Chart.
     * @hidden
     */
    constructor(chart: ChartXY, _removeFromChart: RemoveHandler<ChartComponent>, _restoreFromChart: RestoreHandler<ChartComponent>, _layer: Layer2D, axisX: Axis, axisY: Axis, axisXAttachHandler: AxisAttachHandler, axisYAttachHandler: AxisAttachHandler, _newUILayer: () => Layer2D, _baseline: number, _theme: Theme);
    /**
     * Set positive area style of Series.
     *
     *Example Usage:
     *```javascript
     * // Specified FillStyle
     * AreaSeriesBipolar.setPositiveFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * AreaSeriesBipolar.setPositiveFillStyle((solidFill) => solidFill.setA(80))
     * // Hidden (emptyFill is not supported)
     * AreaSeriesBipolar.setPositiveFillStyle(transparentFill)
     * ```
     * @param value Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns     Series itself for fluent interface.
     */
    setPositiveFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Set positive area style of Series when it is highlighted.
     *
     *Example Usage:
     *```javascript
     * // Specified FillStyle
     * AreaSeriesBipolar.setPositiveFillStyleHighlight(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * AreaSeriesBipolar.setPositiveFillStyleHighlight((solidFill) => solidFill.setA(80))
     * // Hidden (emptyFill is not supported)
     * AreaSeriesBipolar.setPositiveFillStyleHighlight(transparentFill)
     * ```
     * @param value Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value or
     *              undefined for automatic value based on normal style.
     * @returns     Series itself for fluent interface.
     */
    setPositiveFillStyleHighlight(value: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * Set negative area style of Series.
     *
     *Example Usage:
     *```javascript
     * // Specified FillStyle
     * AreaSeriesBipolar.setNegativeFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * AreaSeriesBipolar.setNegativeFillStyle((solidFill) => solidFill.setA(80))
     * // Hidden (emptyFill is not supported)
     * AreaSeriesBipolar.setNegativeFillStyle(transparentFill)
     * ```
     * @param value Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns     Series itself for fluent interface.
     */
    setNegativeFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Set negative area style of Series when it is highlighted.
     *
     *Example Usage:
     *```javascript
     * // Specified FillStyle
     * AreaSeriesBipolar.setNegativeFillStyleHighlight(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * AreaSeriesBipolar.setNegativeFillStyleHighlight((solidFill) => solidFill.setA(80))
     * // Hidden (emptyFill is not supported)
     * AreaSeriesBipolar.setNegativeFillStyleHighlight(transparentFill)
     * ```
     * @param value Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value or
     *              undefined for automatic value based on normal style.
     * @returns     Series itself for fluent interface.
     */
    setNegativeFillStyleHighlight(value: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * Set positive stroke style of Series.
     *
     * Example usage:
     *```javascript
     * // Specified SolidLine
     * AreaSeriesBipolar.setPositiveStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * AreaSeriesBipolar.setPositiveStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * AreaSeriesBipolar.setPositiveStrokeStyle(transparentLine)
     * ```
     * @param value  Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
     * @returns      Series itself for fluent interface.
     */
    setPositiveStrokeStyle(value: SolidLine | ImmutableMutator<SolidLine>): this;
    /**
     * Set positive stroke style of Series when it is highlighted.
     * Highlighting is activated by placing mouse on top / touching Series (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     *
     * Example usage:
     *```javascript
     * // Specified SolidLine
     * AreaSeriesBipolar.setPositiveStrokeStyleHighlight(new SolidLine(
     * { thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * AreaSeriesBipolar.setPositiveStrokeStyleHighlight((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * AreaSeriesBipolar.setPositiveStrokeStyleHighlight(transparentLine)
     * // Automatic
     * AreaSeriesBipolar.setPositiveStrokeStyleHighlight(undefined)
     * ```
     * @param   value   Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value or
     *                  undefined for automatic value based on normal style.
     * @returns         Chart itself
     */
    setPositiveStrokeStyleHighlight(value: SolidLine | ImmutableMutator<SolidLine> | undefined): this;
    /**
     * Set negative stroke style of Series.
     *
     * Example usage:
     *```javascript
     * // Specified SolidLine
     * AreaSeriesBipolar.setNegativeStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * AreaSeriesBipolar.setNegativeStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * AreaSeriesBipolar.setNegativeStrokeStyle(transparentLine)
     * ```
     * @param value  Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
     * @returns      Series itself for fluent interface.
     */
    setNegativeStrokeStyle(value: SolidLine | ImmutableMutator<SolidLine>): this;
    /**
     * Set negative stroke style of Series when it is highlighted.
     * Highlighting is activated by placing mouse on top / touching Series (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     *
     * Example usage:
     *```javascript
     * // Specified SolidLine
     * AreaSeriesBipolar.setNegativeStrokeStyleHighlight(new SolidLine(
     * { thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * AreaSeriesBipolar.setNegativeStrokeStyleHighlight((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * AreaSeriesBipolar.setNegativeStrokeStyleHighlight(transparentLine)
     * // Automatic
     * AreaSeriesBipolar.setNegativeStrokeStyleHighlight(undefined)
     * ```
     * @param   value   Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value or
     *                  undefined for automatic value based on normal style.
     * @returns         Chart itself
     */
    setNegativeStrokeStyleHighlight(value: SolidLine | ImmutableMutator<SolidLine> | undefined): this;
    /**
     * Get a current fill style used for the coloring of the positive area in the series.
     * @returns      Current fill style used for the coloring of the positive area in the series.
     */
    getPositiveFillStyle(): FillStyle;
    /**
     * Get a current highlight fill style used for the coloring of the positive area during series highlighting.
     * @returns     Current highlight fill style used for the coloring of the positive area during series highlighting.
     */
    getPositiveFillStyleHighlight(): FillStyle;
    /**
     * Get a current fill style used for the coloring of the negative area in the series.
     * @returns      Current fill style used for the coloring of the negative area in the series.
     */
    getNegativeFillStyle(): FillStyle;
    /**
     * Get a current highlight fill style used for the coloring of the negative area during series highlighting.
     * @returns     Current highlight fill style used for the coloring of the negative area during series highlighting.
     */
    getNegativeFillStyleHighlight(): FillStyle;
    /**
     * Get a current line style of a stroke used for the coloring of the positive stroke in the series.
     * @returns     Current line style of a stroke used for the coloring of the positive stroke.
     */
    getPositiveStrokeStyle(): LineStyle;
    /**
     * Get a current line style of a stroke used for the coloring of the positive border during highlighting.
     * @returns     Current line style of a border used for the coloring of the positive border during highlighting.
     */
    getPositiveStrokeStyleHighlight(): LineStyle;
    /**
     * Get a current line style of a border used for the coloring of the negative border in the series.
     * @returns     Current line style of a border used for the coloring of the negative border.
     */
    getNegativeStrokeStyle(): LineStyle;
    /**
     * Get a current line style of a border used for the coloring of of the negative border during highlighting.
     * @returns     Current line style of a border used for the coloring of the negative border during highlighting.
     */
    getNegativeStrokeStyleHighlight(): LineStyle;
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Series itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick?: boolean): this;
}
/**
 * The abstract class implements the most part of general logic for specific area series types.
 * These series use only one fill style and only one border.
 * All the derivative series implements their own logic for processing incoming data.
 * @hidden Internal class
 */
export declare abstract class AreaSeriesMonopolar extends AreaSeries {
    /**
     * Set fill style of Series.
     *
     *Example Usage:
     *```javascript
     * // Specified FillStyle
     * AreaSeriesMonopolar.setFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * AreaSeriesMonopolar.setFillStyle((solidFill) => solidFill.setA(80))
     * // Hidden (emptyFill is not supported)
     * AreaSeriesMonopolar.setFillStyle(transparentFill)
     * ```
     * @param value  Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns      Series itself for fluent interface.
     */
    abstract setFillStyle(fill: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Set fill style of Series when it is highlighted.
     *
     * Example usage:
     *```javascript
     * // Specified FillStyle
     * AreaSeriesMonopolar.setFillStyleHighlight(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * AreaSeriesMonopolar.setFillStyleHighlight((solidFill) => solidFill.setA(80))
     * // Hidden (emptyFill is not supported)
     * AreaSeriesMonopolar.setFillStyleHighlight(transparentFill)
     * // Automatic
     * AreaSeriesMonopolar.setFillStyleHighlight(undefined)
     * ```
     * @param value Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value or
     *              undefined for automatic value based on normal style.
     * @returns     Series itself for fluent interface.
     */
    abstract setFillStyleHighlight(fill: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * Set stroke style of Series.
     *
     * Example usage:
     *```javascript
     * // Specified SolidLine
     * AreaSeriesMonopolar.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * AreaSeriesMonopolar.setStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * AreaSeriesMonopolar.setStrokeStyle(transparentLine)
     * ```
     * @param value  Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
     * @returns      Series itself for fluent interface.
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Set stroke style of Series border when it is highlighted.
     * Highlighting is activated by placing mouse on top / touching Series (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     *
     * Example usage:
     *```javascript
     * // Specified SolidLine
     * AreaSeriesMonopolar.setStrokeStyleHighlight(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * AreaSeriesMonopolar.setStrokeStyleHighlight((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * AreaSeriesMonopolar.setStrokeStyleHighlight(transparentLine)
     * // Automatic
     * AreaSeriesMonopolar.setStrokeStyleHighlight(undefined)
     * ```
     * @param   value   Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value or
     *                  undefined for automatic value based on normal style.
     * @returns         Chart itself
     */
    setStrokeStyleHighlight(value: SolidLine | ImmutableMutator<SolidLine> | undefined): this;
    /**
     * Get a current fill style used for the coloring of an area in the series.
     * @returns      Current fill style used for the coloring of an area in the series.
     */
    abstract getFillStyle(): FillStyle;
    /**
     * Get a current highlight fill style used for the coloring of an area during series highlighting.
     * @returns     Current highlight fill style used for the coloring of an area during series highlighting.
     */
    abstract getFillStyleHighlight(): FillStyle;
    /**
     * Get a current style of a stroke used for the coloring of a series border.
     * @returns     Current style of a stroke used for the coloring of a border.
     */
    getStrokeStyle(): LineStyle;
    /**
     * Get a current style of a stroke used for the coloring of a series border by series.
     * @returns     Current style of a stroke used for the coloring of a series border by series.
     */
    getStrokeStyleHighlight(): LineStyle;
}
/**
 * Implementation of *SeriesXY* for visualizing a collection of progressive *Points* by
 * filling the area between the points *Y*-values and a static *baseline* value.
 * This type of *AreaSeries* only shows data that is **below the baseline**.
 *
 * Composed of the areas *fill* and *border*.
 *
 * *AreaSeriesNegative* are created with [[ChartXY.addAreaSeries]] and selecting *AreaSeriesTypes.Negative*.
 */
export declare class AreaSeriesNegative extends AreaSeriesMonopolar {
    /**
     * @param _chart                Parent Chart
     * @param _removeFromChart      Handler for removing reference to series from owning chart
     * @param _restoreFromChart     Handler for restoring reference to series from owning chart
     * @param _layer                Rendering layer
     * @param axisX                 Axis X
     * @param axisY                 Axis Y
     * @param axisXAttachHandler    Attach handler for Axis X
     * @param axisYAttachHandler    Attach handler for Axis Y
     * @param _newUILayer           Factory for creating new UI layers for drawing SeriesMarkers
     * @param _theme                Theme from owning Chart.
     * @hidden
     */
    constructor(chart: ChartXY, _removeFromChart: RemoveHandler<ChartComponent>, _restoreFromChart: RestoreHandler<ChartComponent>, _layer: Layer2D, axisX: Axis, axisY: Axis, axisXAttachHandler: AxisAttachHandler, axisYAttachHandler: AxisAttachHandler, _newUILayer: () => Layer2D, _baseline: number, _theme: Theme);
    /**
     * Set fill style of Series.
     *
     *Example Usage:
     *```javascript
     * // Specified FillStyle
     * AreaSeriesNegative.setFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * AreaSeriesNegative.setFillStyle((solidFill) => solidFill.setA(80))
     * // Hidden (emptyFill is not supported)
     * AreaSeriesNegative.setFillStyle(transparentFill)
     * ```
     * @param value  Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns      Series itself for fluent interface.
     */
    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Set fill style of Series when it is highlighted.
     *
     * Example usage:
     *```javascript
     * // Specified FillStyle
     * AreaSeriesNegative.setFillStyleHighlight(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * AreaSeriesNegative.setFillStyleHighlight((solidFill) => solidFill.setA(80))
     * // Hidden (emptyFill is not supported)
     * AreaSeriesNegative.setFillStyleHighlight(transparentFill)
     * // Automatic
     * AreaSeriesNegative.setFillStyleHighlight(undefined)
     * ```
     * @param value Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value or
     *              undefined for automatic value based on normal style.
     * @returns     Series itself for fluent interface.
     */
    setFillStyleHighlight(value: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * Get a current fill style used for the coloring of an area in the series.
     * @returns      Current fill style used for the coloring of an area in the series.
     */
    getFillStyle(): FillStyle;
    /**
     * Get a current highlight fill style used for the coloring of an area during series highlighting.
     * @returns     Current highlight fill style used for the coloring of an area during series highlighting.
     */
    getFillStyleHighlight(): FillStyle;
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Series itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick?: boolean): this;
}
/**
 * Implementation of *SeriesXY* for visualizing a collection of progressive *Points* by
 * filling the area between the points *Y*-values and a static *baseline* value.
 * This type of *AreaSeries* only shows data that is **above the baseline**.
 *
 * Composed of the areas *fill* and *border*.
 *
 * *AreaSeriesPositive* are created with [[ChartXY.addAreaSeries]] and selecting *AreaSeriesTypes.Positive*.
 */
export declare class AreaSeriesPositive extends AreaSeriesMonopolar {
    /**
     * @param _chart                Parent Chart
     * @param _removeFromChart      Handler for removing reference to series from owning chart
     * @param _restoreFromChart     Handler for restoring reference to series from owning chart
     * @param _layer                Rendering layer
     * @param axisX                 Axis X
     * @param axisY                 Axis Y
     * @param axisXAttachHandler    Attach handler for Axis X
     * @param axisYAttachHandler    Attach handler for Axis Y
     * @param _newUILayer           Factory for creating new UI layers for drawing SeriesMarkers
     * @param _theme                Theme from owning Chart.
     * @hidden
     */
    constructor(chart: ChartXY, _removeFromChart: RemoveHandler<ChartComponent>, _restoreFromChart: RestoreHandler<ChartComponent>, _layer: Layer2D, axisX: Axis, axisY: Axis, axisXAttachHandler: AxisAttachHandler, axisYAttachHandler: AxisAttachHandler, _newUILayer: () => Layer2D, _baseline: number, _theme: Theme, automaticColorIndex: number);
    /**
     * Set fill style of Series.
     *
     *Example Usage:
     *```javascript
     * // Specified FillStyle
     * AreaSeriesPositive.setFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * AreaSeriesPositive.setFillStyle((solidFill) => solidFill.setA(80))
     * // Hidden (emptyFill is not supported)
     * AreaSeriesPositive.setFillStyle(transparentFill)
     * ```
     * @param value  Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns      Series itself for fluent interface.
     */
    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Set fill style of Series when it is highlighted.
     *
     * Example usage:
     *```javascript
     * // Specified FillStyle
     * AreaSeriesPositive.setFillStyleHighlight(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * AreaSeriesPositive.setFillStyleHighlight((solidFill) => solidFill.setA(80))
     * // Hidden (emptyFill is not supported)
     * AreaSeriesPositive.setFillStyleHighlight(transparentFill)
     * // Automatic
     * AreaSeriesPositive.setFillStyleHighlight(undefined)
     * ```
     * @param value Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value or
     *              undefined for automatic value based on normal style.
     * @returns     Series itself for fluent interface.
     */
    setFillStyleHighlight(value: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * Get a current fill style used for the coloring of an area in the series.
     * @returns      Current fill style used for the coloring of an area in the series.
     */
    getFillStyle(): FillStyle;
    /**
     * Get a current highlight fill style used for the coloring of an area during series highlighting.
     * @returns     Current highlight fill style used for the coloring of an area during series highlighting.
     */
    getFillStyleHighlight(): FillStyle;
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Series itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick?: boolean): this;
}
/**
 * Collection of *AreaSeries* implementations.
 *
 * Used when creating an *AreaSeries* with [[ChartXY.addAreaSeries]].
 * Selected option tells what the returned *Series* type will be - different *Series* types can have different *API*s !
 *
 * - Select AreaSeriesTypes.Positive to show only area above the baseline.
 * - Select AreaSeriesTypes.Negative to show only area below the baseline.
 * - Select AreaSeriesTypes.Both to show both areas from both sides of the baseline.
 */
export declare const AreaSeriesTypes: {
    /**
     * Type of *AreaSeries* that only shows data that is **above the baseline**.
     */
    Positive: typeof AreaSeriesPositive;
    /**
     * Type of *AreaSeries* that only shows data that is **below the baseline**.
     */
    Negative: typeof AreaSeriesNegative;
    /**
     * Type of *AreaSeries* that shows data on both sides of baseline.
     *
     * Has individual styles for positive/negative areas.
     */
    Bipolar: typeof AreaSeriesBipolar;
};
/**
 * Available Area Series types
 */
export declare type AreaSeriesTypes = typeof AreaSeriesTypes[keyof typeof AreaSeriesTypes];

export declare class GlHeatmapGridScrollingIntensity extends HeatmapGridScrolling implements GlEntity {
    protected readonly _glEngine: GlEngine;
    
    constructor(_glEngine: GlEngine, scale: LinearScaleXY | RadialScale, remove: RemoveHandler<GlIntensity>, restore: RestoreHandler<GlIntensity>, applicationFlags: InternalApplicationFlagPlusArgs[], _options: HeatmapGridScrollingOptions);
    
    dispose(): this;
    
    restore(): this;
}

export declare class GlHeatmapGridStaticIntensity extends HeatmapGridStatic implements GlEntity {
    protected readonly _glEngine: GlEngine;
    
    constructor(_glEngine: GlEngine, scale: LinearScaleXY | RadialScale, remove: RemoveHandler<GlIntensity>, restore: RestoreHandler<GlIntensity>, applicationFlags: InternalApplicationFlagPlusArgs[], _options: HeatmapGridStaticOptions);
    
    dispose(): this;
}

export declare class GlSurfaceGridScrolling extends GlShape3D implements SurfaceGridScrolling {
    
    constructor(_layer: GlLayer3D, _remove: RemoveHandler<GlSurfaceGridScrolling>, _restore: RestoreHandler<GlSurfaceGridScrolling>, applicationFlags: InternalApplicationFlagPlusArgs[], _options: SurfaceGridScrollingOptions);
    
    dispose(): this;
    
    restore(): this;
}

export declare class GlSurfaceGridStatic extends GlShape3D implements SurfaceGridStatic {
    
    constructor(_layer: GlLayer3D, _remove: RemoveHandler<GlSurfaceGridStatic>, _restore: RestoreHandler<GlSurfaceGridStatic>, applicationFlags: InternalApplicationFlagPlusArgs[], _options: SurfaceGridStaticOptions);
    debugBufferNormals: WebGLBuffer;
    
    dispose(): this;
    
    restore(): this;
}

export interface HeatmapGridInfo<ExtraTileInfo extends {} = {}, ExtraTileSizeInfo extends {} = {}> {
    
    gridTiles: (HeatmapGridTileInfo & ExtraTileInfo)[];
    
    gridTileSizes: ({
        
        sizeHeatmapData: {
            primary: number;
            secondary: number;
        };
        
        tiles: (HeatmapGridTileInfo & ExtraTileInfo)[];
    } & ExtraTileSizeInfo)[];
}

export interface HeatmapGridTileInfo {
    
    iFirstVector: {
        primary: number;
        secondary: number;
    };
    
    iFirstUniqueVector: {
        primary: number;
        secondary: number;
    };
    
    sizeHeatmapDataVectors: {
        primary: number;
        secondary: number;
    };
    
    sizeUniqueHeatmapDataVectors: {
        primary: number;
        secondary: number;
    };
}

export declare type TextBase = 'top' | 'hanging' | 'middle' | 'alphabetic' | 'ideographic' | 'bottom';

export declare type TextAlign = 'left' | 'right' | 'center' | 'start' | 'end';

export interface GlFontRenderInfo {
    
    texture: WebGLTexture;
    
    vertices: Float32Array;
    
    texCoords: Float32Array;
}

export declare const pointsToPixels: (points: number) => number;

export declare const GlyphFactory: () => (char: string, fontProperties: FontProperties, devicePixelRatio: number) => [Uint8ClampedArray, GlyphInfo] | undefined;

export declare class GlFont {
    constructor(glHelper: GlUtils);
}

export declare class GlText extends Text implements GlEntity {
    protected readonly _glEngine: GlEngine;
    
    constructor(_glEngine: GlEngine, scale: LinearScaleXY | RadialScale | MixedScaleXY, remove: RemoveHandler<GlText>, restore: RestoreHandler<GlText>, applicationFlags: InternalApplicationFlagPlusArgs[]);
}

export declare enum GlyphAddState {
    
    Fail = 0,
    
    Success = 1,
    
    Resize = 2
}

export declare class GlyphAtlasTextureCollection {
    constructor(glUtils: GlUtils);
}

export declare const ShaderFeatures: {
    
    DebugConsole: (debugLabel?: string | undefined) => ShaderFeature;
    
    '2D': ShaderFeature;
    
    '3D': ShaderFeature;
    
    PointSize: (dataType: 'uniform' | 'attribute') => ShaderFeature;
    
    Color: (args: {
        dataType: 'uniform' | 'attribute' | ['lookup', 'x' | 'y' | 'z' | 'value'] | ['gradient', LinearGradientFill | RadialGradientFill] | 'texture';
        maskTexture?: boolean | undefined;
    }) => ShaderFeature;
    
    ColorShaded3D: (args: {
        dataType: 'uniform' | 'attribute' | ['lookup', 'x' | 'y' | 'z' | 'value'];
        shadingStyle: 'simple' | 'phong';
        wireframe?: boolean;
    }) => ShaderFeature;
    
    VertexLocation: (args: VertexLocationProperties) => ShaderFeature;
    
    LineInstanced2D: (args: VertexLocationProperties) => ShaderFeature;
    
    LineInstanced3D: (args: {
        axisWorldTranslation: AxisWorldTranslationDefinition;
    }) => ShaderFeature;
    
    RoundedEdges3D: ShaderFeature;
    
    ColorGrid2D: (args: {
        heatmapType: 'intensity';
        interpolation: false | 'bilinear';
        flipXY: boolean;
        intensityTextureType: 'float' | 'ubyte';
        littleEndian: boolean;
    }) => ShaderFeature;
    
    DrawToNormalTexture: (args: {
        flipXZ: boolean;
        vertexIdSource: undefined | 'attribute';
        normalTextureType: 'uint' | 'ubyte';
        heightmapTextureType: 'float' | 'ubyte';
        littleEndian: boolean;
    }) => ShaderFeature;
    
    SurfaceGrid: (args: {
        axisWorldTranslation: AxisWorldTranslationDefinition;
        fillColor: undefined | 'uniform' | ['lookup', 'x' | 'y' | 'z' | 'value'];
        interpolation: false | 'bilinear';
        flipXZ: boolean;
        shadingStyle: 'simple' | 'phong';
        wireframe: boolean;
        instanceIdSource: undefined | 'attribute';
        normalTextureType: 'uint' | 'ubyte';
        heightmapTextureType: 'float' | 'ubyte';
        intensityTextureType: 'float' | 'ubyte';
        littleEndian: boolean;
    }) => ShaderFeature;
    
    DebugSurfaceGridNormals: (args: {
        axisWorldTranslation: AxisWorldTranslationDefinition;
        flipXZ: boolean;
        instanceIdSource: undefined | 'attribute';
        normalTextureType: 'uint' | 'ubyte';
        heightmapTextureType: 'float' | 'ubyte';
        littleEndian: boolean;
    }) => ShaderFeature;
    
    OffsetTowardsCamera: () => ShaderFeature;
    
    AliasedEdge: () => ShaderFeature;
};

export declare type AxisWorldTranslationDefinition = 'linear' | 'linear-highPrecision' | 'matrix' | ['logarithmic', Partial<Vec3<{
    base: LogarithmicBaseInternal;
}>>];

export interface VertexLocationProperties {
    
    axisWorldTranslation: AxisWorldTranslationDefinition;
    
    flipXY?: boolean;
    
    flipXZ?: boolean;
    
    splitPosAttribute?: boolean;
    
    scaling?: false | {
        
        dataType: 'uniform' | 'attribute';
    };
    
    translation?: false | {
        
        dataType: 'uniform' | 'attribute';
        
        sizeUnit: 'axis';
    };
    
    offset?: {
        
        dataType: 'uniform' | 'attribute';
        
        sizeUnit: 'axis' | 'wu' | 'nwu' | 'px';
        
        halved?: boolean;
        
        symmetric?: boolean;
        
        rotation?: false | {
            
            dataType: 'uniform' | 'attribute';
        };
    };
    
    normalSource: VertexNormalSource;
}

export declare type VertexNormalSource = 'gpu-calculate' | 'attribute' | 'custom' | undefined;
declare type VertexShaderTemplate = keyof typeof VertexShaderTemplates;
declare type StaticFragmentShader = keyof typeof StaticFragmentShaders;
declare type FragmentShaderTemplate = keyof typeof FragmentShaderTemplates | StaticFragmentShader;

export interface ShaderFeature {
    
    idFeature: string;
    
    idVertex: string | undefined;
    
    idFragment: string | undefined;
    
    apply: ShaderFeatureApplier;
}
declare type ShaderHintFragmentShaderOutput = {
    
    type: 'fragOutput';
    
    fragOutput: string;
};

export declare type ShaderHint = ShaderHintFragmentShaderOutput;

export declare type ShaderFeatureApplier = (allFeatures: ShaderFeature[], webglVersion: 'webgl2' | 'webgl1') => {
    
    defaultVertexShader?: VertexShaderTemplate;
    
    vertexShader?: VertexShaderTemplate;
    
    vertexShaderModifiers?: ShaderModifierList;
    
    defaultFragmentShader?: FragmentShaderTemplate;
    
    fragmentShader?: FragmentShaderTemplate;
    
    fragmentShaderModifiers?: ShaderModifierList;
    
    hints?: (undefined | false | ShaderHint)[];
};

interface ShaderDescription<Template> {
    
    id: string;
    
    template: Template;
    
    modifiers: ShaderModifier[];
}

export interface ShaderProgramDescription {
    
    id: string;
    
    vertexShader: ShaderDescription<VertexShaderTemplate>;
    
    fragmentShader: StaticFragmentShader | ShaderDescription<FragmentShaderTemplate>;
    
    hints: ShaderHint[];
}

export declare type ShaderModifierList = (ShaderModifier | undefined | false)[];
export {};

export declare const VertexShaderTemplates: {
    '2D': string;
    '3D': string;
};

export declare const FragmentShaderTemplates: {
    EmptyFragmentShader: string;
};
export {};

export declare const StaticFragmentShaders: {
    Basic: string;
    BasicTextureMask: string;
    PointColor: string;
    PointColorTextureMask: string;
    Paletted: string;
    PalettedTextureMask: string;
    Phong3D: string;
    Simple3D: string;
    Paletted3D: string;
    SimplePaletted3D: string;
    PointColor3D: string;
    SimplePointColor3D: string;
    Textured2D: string;
};

export declare const StaticVertexShaders: {
    Basic: string;
    BasicOffsetted: string;
    BasicInstanced: string;
    PointSize: string;
    Texture: string;
    PointSizePointColor: string;
    PointColor: string;
    PointColorOffsetted: string;
    PointColorInstanced: string;
    Paletted: string;
    PalettedOffsetted: string;
};
/**
 * Abstract super class for Polar Area Series.
 * @hidden For minimal typedocs. Users can refer to implementations (only PolarAreaSeriesInterior atm)
 */
export declare abstract class PolarAreaSeries extends PolarSeries<SimplePolygon, CursorPoint<PolarAreaSeries>> {
    /**
     * Set data for PolarSeries to render as a list of [[PolarPoint]]s.
     * @param   points  List of [[PolarPoint]]s.
     * @return          Object itself for fluent interface.
     */
    setData(points: PolarPoint[]): this;
    /**
     * Set fill style of Series.
     *
     * Example usage:
     *```javascript
     * // Create a new style
     * PolarAreaSeries.setFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Change transparency
     * PolarAreaSeries.setFillStyle((solidFill) => solidFill.setA(80))
     * // Set hidden
     * PolarAreaSeries.setFillStyle(emptyFill)
     * ```
     * @param   value   Either a FillStyle object or a function, which will be used to create a new SolidLine based on current value.
     * @returns         Chart itself
     */
    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of Series.
     * @return  FillStyle object
     */
    getFillStyle(): FillStyle;
    /**
     * Set fill style of Series when it is highlighted.
     * Highlighting is activated by placing mouse on top / touching Series (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     *
     * Example usage:
     *```javascript
     * // Create a new style
     * PolarAreaSeries.setFillStyleHighlight(new SolidFill({ color: ColorHEX('#F00') }))
     * // Change transparency
     * PolarAreaSeries.setFillStyleHighlight((solidFill) => solidFill.setA(80))
     * // Set hidden
     * PolarAreaSeries.setFillStyleHighlight(emptyFill)
     * // Automatic
     * PolarAreaSeries.setFillStyleHighlight(undefined)
     * ```
     * ```
     * @param   value   Either a FillStyle object or a function, which will be used to modify current value or
     *                  undefined for automatic value based on normal style.
     * @returns         Chart itself
     */
    setFillStyleHighlight(value: FillStyle | ImmutableMutator<FillStyle> | undefined): this;
    /**
     * Get fill style of Series when it is highlighted.
     * Highlighting is activated by placing mouse on top / touching Series (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     * @return  FillStyle object
     */
    getFillStyleHighlight(): FillStyle;
    /**
     * Set stroke style of Series.
     *
     * Example usage:
     *```javascript
     * // Specified LineStyle
     * PolarAreaSeries.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * PolarAreaSeries.setStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden
     * PolarAreaSeries.setStrokeStyle(emptyLine)
     * ```
     * @param   value   Either a LineStyle object or a function, which will be used to create a new SolidLine based on current value.
     * @returns         Chart itself
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stroke style of Series.
     * @return  LineStyle object
     */
    getStrokeStyle(): LineStyle;
    /**
     * Set stroke style of Series when it is highlighted.
     * Highlighting is activated by placing mouse on top / touching Series (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     *
     * Example usage:
     *```javascript
     * // Specified LineStyle
     * PolarAreaSeries.setStrokeStyleHighlight(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * PolarAreaSeries.setStrokeStyleHighlight((solidLine) => solidLine.setThickness(5))
     * // Hidden.
     * PolarAreaSeries.setStrokeStyleHighlight(emptyLine)
     * // Automatic
     * PolarAreaSeries.setStrokeStyleHighlight(undefined)
     * ```
     * @param   value   Either a LineStyle object or a function, which will be used to modify current value or
     *                  undefined for automatic value based on normal style.
     * @returns         Chart itself
     */
    setStrokeStyleHighlight(value: LineStyle | ImmutableMutator<LineStyle> | undefined): this;
    /**
     * Get stroke style of Series when it is highlighted.
     * Highlighting is activated by placing mouse on top / touching Series (if mouse-interactions are not disabled),
     * or by using setHighlighted() method.
     * @return  LineStyle object
     */
    getStrokeStyleHighlight(): LineStyle;
    /**
     * Set automatic connection of first and last data points enabled or not.
     *
     * **Disabled by default.**
     * @param   enabled     Boolean.
     * @return              Object itself for fluent interface.
     */
    setConnectDataAutomaticallyEnabled(enabled: boolean): this;
    /**
     * Get automatic connection of first and last data points enabled or not.
     * @return              Boolean.
     */
    getConnectDataAutomaticallyEnabled(): boolean;
    /**
     * Attach object to an legendBox entry
     * @param entry             Object which has to be attached
     * @param disposeOnClick    Flag that indicates whether the Attachable should be disposed/restored,
     *                          when its respective Entry is clicked.
     * @return                  Series itself for fluent interface
     */
    attach(entry: LegendBoxEntry, disposeOnClick?: boolean): this;
}
/**
 * Type of *PolarAreaSeries* that fills the Polar area between data points and center of Polar Chart.
 *
 * **Example usage:**
 *
 * - *Plot sub section (< 360 degrees) of the Polar Chart*
 * ```ts
 *  const areaSeries = polarChart.addAreaSeries()
 *      .setData(
 *          new Array( 90 ).fill( 0 ).map(( _, i ) => ({
 *              angle: i,
 *              amplitude: 60 + 25 * Math.cos( 5 * i * Math.PI / 180 )
 *          }))
 *      )
 * ```
 *
 * - *Plot a fully connected (360 degrees) section of the Polar Chart*
 * ```ts
 *  const areaSeries = polarChart.addAreaSeries()
 *      .setConnectDataAutomaticallyEnabled(true)
 *      .setData(
 *          new Array(360).fill(0).map((_, i) => ({
 *              angle: i,
 *              amplitude: 60 + 25 * Math.cos((5 * i * Math.PI) / 180),
 *          })),
 *      )
 * ```
 */
export declare class PolarAreaSeriesInterior extends PolarAreaSeries {
    /**
     * Abstract method that solves the nearest data point to a given coordinate on screen.
     * @param   location    Location on screen
     * @return              Undefined or data-structure for positioning of cursors
     */
    solveNearestFromScreen(location: Point): CursorPoint<this> | undefined;
    /**
     * Abstract method that solves the nearest data point to a given coordinate on a screen from a specific segment.
     * @param   location    Location on screen
     * @param   segment     Segment to solve from
     * @return              Undefined or data-structure for positioning of cursors
     */
    solveNearestFromSegment(location: Point, segment: SimplePolygon): CursorPoint<this> | undefined;
}
